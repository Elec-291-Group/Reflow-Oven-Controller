0000              1   ; Project 1
0000              2   ; CV-8052 microcontroller in DE10-Lite board
0000              3   ;-------------------------------------------------------------------------------
0000              4   ; Reset vector
0000              5   org 0x0000
0000 020D46       6       ljmp main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9       reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 02046E      12       ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15       reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18       reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 32          21       reti
0024             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
002B 0206B3      24       ljmp Timer2_ISR
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 32   $LIST
0320             34   ; ----------------------------------------------------------------------------------------------;
0320             35   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             36   dseg at 0x30
0030             37   current_time_sec:     ds 1
0031             38   current_time_minute:  ds 1
0032             39   ; math32 buffer variables
0032             40   x:      ds  4
0036             41   y:      ds  4
003A             42   bcd:    ds  5
003F             43   
003F             44   ; -------- UART RX state (polling) --------
003F             45   rx_idx:    ds 1
0040             46   rx_ready:  ds 1
0041             47   
0041             48   
0041             49   current_temp: ds 4 ;
0045             50   soak_temp:    ds 4 ;
0049             51   reflow_temp:  ds 4 ;
004D             52   
004D             53   wait25_btn_cnt:    ds 1
004E             54   wait25_keypad_cnt: ds 1
004F             55   wait25_adc_cnt:    ds 1
0050             56   wait25_lcd_cnt:    ds 1
0051             57   wait25_count: ds 1  
0052             58   
0052             59   current_time: ds 4 ;
0056             60   soak_time:    ds 4 ;
005A             61   reflow_time:  ds 4 ;
005E             62   
005E             63   power_output:  ds 4 ;
0062             64   pwm_counter: ds 4 ; counter for pwm (0-1500)
0066             65   
0066             66   KEY1_DEB_timer: ds 1
0067             67   SEC_FSM_timer:  ds 1
0068             68   KEY1_DEB_state:    ds 1
0069             69   SEC_FSM_state:     ds 1
006A             70   Control_FSM_state: ds 1 
006B             71   
006B             72   Current_State:     ds 1
006C             73   soak_temp_diff: ds 4 ; temperature difference between target soak temp and current oven temp 
0070             74   proportional_gain_var: ds 4 ; power gain calculated from the proportional block
0074             75   ;-- UI buffers I added (ayaan)
0074             76   Cursor_Idx: ds 1
0075             77   
0075             78   ; These hold the TEXT (ASCII) safely
0075             79   ; Digits Only + Null Terminator, got rid of C,:, and s 
0075             80   
0075             81   ; Buzzer state
0075             82   beep_count:  ds 1      ; remaining beeps
0076             83   beep_state:  ds 1      ; 0=idle, 1=ON, 2=OFF
0077             84   beep_tmr:    ds 2      ; 16-bit ms timer (needs to reach 500)
0079             85   
0079             86   servo_pwm_counter: ds 1 ; counter for the servo pwm signal
007A             87   
0080             88   iseg at 0x80
0080             89   Buf_Soak_Temp: ds 4   
0084             90   Buf_Soak_Time: ds 5   
0089             91   Buf_Refl_Temp: ds 4   
008D             92   Buf_Refl_Time: ds 5
0092             93   ; UART RX line buffer (polling) in upper RAM
0092             94   rx_buf:    ds 40    ; null-terminated command line
00BA             95   
00BA             96   
00BA             97   
00BA             98   ; 46d bytes used
00BA             99   
00BA            100   ;-------------------------------------------------------------------------------
00BA            101   ; bit operation setb, clr, jb, and jnb
0000            102   bseg
0000            103   remote_config_mode: dbit 1
0001            104   mf:     dbit 1 ; math32 sign
0002            105   one_second_flag: dbit 1
0003            106   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0004            107   
0004            108   soak_temp_reached: dbit 1
0005            109   reflow_temp_reached: dbit 1
0006            110   cooling_temp_reached: dbit 1
0007            111   
0007            112   soak_time_reached: dbit 1
0008            113   reflow_time_reached: dbit 1
0009            114   
0009            115   reset_signal: dbit 1
000A            116   stop_signal: dbit 1
000B            117   start_signal: dbit 1
000C            118   config_finish_signal: dbit 1
000D            119   
000D            120   state_change_signal: dbit 1
000E            121   
000E            122   Key1_flag: dbit 1
000F            123   
000F            124   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
0010            125   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0011            126   PB0_flag: dbit 1 ; start entire program
0012            127   PB1_flag: dbit 1 ; start soak
0013            128   PB2_flag: dbit 1 ; pause process
0014            129   
0014            130   ;buzzer beep
0014            131   one_ms_beep_flag: dbit 1
0015            132   
0015            133   ; BSEG (Bit Segment)
0015            134   wait25_active: dbit 1 ; 1 = We are currently waiting
0016            135   wait25_done:   dbit 1 ; 1 = The 25ms has finished
0017            136   wait25_btn_active:    dbit 1
0018            137   wait25_btn_done:      dbit 1
0019            138   wait25_keypad_active: dbit 1
001A            139   wait25_keypad_done:   dbit 1
001B            140   wait25_adc_active:    dbit 1
001C            141   wait25_adc_done:      dbit 1
001D            142   wait25_lcd_active:    dbit 1
001E            143   wait25_lcd_done:      dbit 1
001F            144   
001F            145   one_millisecond_flag_servo: dbit 1 ; set the one millsiecond flag for servo pwm signal generation
0020            146   servo_angle_zero: dbit 1 ; flag for indicating whether the servo angle should be at 0 or not: 1 -> 0; 0 -> 180
0021            147   soak_temp_greater: dbit 1 ; target soak_temp greater than current_temp
0022            148   ; 11 bits used
0022            149   
0022            150   ;-------------------------------------------------------------------------------
0320            151   cseg
0320            152   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            153   BAUD           EQU 57600
0320            154   
0320            155   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            156   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            157   ; is always 12 unlike the N76E003 where is selectable.
0320            158   
0320            159   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            160   
0320            161   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            162   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            163   
0320            164   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            165   
0320            166   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            167   
0320            168   PWM_OUT        EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            169   
0320            170   ; These 'equ' must match the wiring between the DE10Lite board and the LCD!
0320            171   ; P0 is in connector JPIO.
0320            172   
0320            173   ;Added correct I/O definitions
0320            174   ;-- LCD Pins ---
0320            175   ELCD_RS equ P1.7
0320            176   ELCD_E  equ P1.1
0320            177   ELCD_D4 equ P0.7
0320            178   ELCD_D5 equ P0.5
0320            179   ELCD_D6 equ P0.3
0320            180   ELCD_D7 equ P0.1
0320            181   
0320            182   ; -- Buttons --
0320            183   BTN_SOAK_TEMP equ P0.0
0320            184   BTN_SOAK_TIME equ P0.2
0320            185   BTN_REFL_TEMP equ P0.4
0320            186   BTN_REFL_TIME equ P0.6
0320            187   
0320            188   ; --- KEYPAD ---
0320            189   ROW1 equ P1.2
0320            190   ROW2 equ P1.4
0320            191   ROW3 equ P1.6
0320            192   ROW4 equ P2.0
0320            193   COL1 equ P2.2
0320            194   COL2 equ P2.4
0320            195   COL3 equ P2.6
0320            196   COL4 equ P3.0
0320            197   
0320            198   SERVO_OUT      EQU p3.6 ; servo pin
0320            199   
0320            200   SERVO_PERIOD   EQU 20 ; pwm signal period for the servo motor (20 ms)
0320            201   SERVO_0        EQU 1 ; pwm high time for the servo motor to stay at 0 degree
0320            202   SERVO_180      EQU 2 ; pwm high time for the servo motor to stay at 180 degrees
0320            203   
0320            204   COLD_JUNCTION_TEMP equ 20
0320            205   MAX_POWER           EQU 1500 ; max oven power
0320            206   NO_POWER            EQU 0    ; no power
0320            207   BASE_POWER     EQU (MAX_POWER/5) ; 20% base power for state 2, 4
0320            208   KP                          EQU 5 ; proportional gain
0320            209   
0320            210   ;                     1234567890123456 <-- 16 characters per line LCD
0320 696E6974   211   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   212   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   213   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            214   
0350            215   ; --- UI STRINGS (REQUIRED FOR KEYPAD LOGIC), <- I can fix if duplicates
0350 53656C65   216   Txt_Home:     db 'Select Mode:    ', 0
     6374204D
     6F64653A
     20202020
     00
0361 53657420   217   Txt_SoakT:    db 'Set Soak Temp   ', 0
     536F616B
     2054656D
     70202020
     00
0372 53657420   218   Txt_SoakTime: db 'Set Soak Time   ', 0
     536F616B
     2054696D
     65202020
     00
0383 53657420   219   Txt_ReflT:    db 'Set Reflow Temp ', 0
     5265666C
     6F772054
     656D7020
     00
0394 53657420   220   Txt_ReflTime: db 'Set Reflow Time ', 0
     5265666C
     6F772054
     696D6520
     00
03A5            221   
03A5            222   ;                       1234567890123456
03A5 53657420   223   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
03B5 536F616B   224   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
03C0 5265666C   225   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
03CD 536F616B   226   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
03D8 5265666C   227   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03E5            228   
03E5 54656D70   229   String_temp_line:  db 'Temp: ', 0
     3A2000
03EC            230   
03EC            231   ;                     1234567890123456
03EC 52616D70   232   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03FC 536F616B   233   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
040C 52616D70   234   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
041C 5265666C   235   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
042C 436F6F6C   236   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
043C 50726F63   237   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
044C            238   
044C 20202020   239   String_Blank:    db '                ', 0
     20202020
     20202020
     20202020
     00
045D            240   
045D            241   ;-------------------------------------------------------------------------------
045D            242   ; Timers Setting:
045D            243   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
045D            244   ;   Timer 1: Serial port baud rate 57600 generator
045D            245   ;   Timer 2: 1ms interrupt for BCD counter increment/decrement
045D            246   ;-------------------------------------------------------------------------------
045D            247   ; Routine to initialize the ISR for Timer 0 ;
045D            248   Timer0_Init:
045D E589       249       mov a, TMOD
045F 54F0       250       anl a, #0xf0 ; Clear the bits for timer 0
0461 4401       251       orl a, #0x01 ; Configure timer 0 as 16-timer
0463 F589       252       mov TMOD, a
0465 758CFD     253       mov TH0, #high(TIMER0_RELOAD)
0468 758A5A     254       mov TL0, #low(TIMER0_RELOAD)
046B            255       ; Enable the timer and interrupts
046B D2A9       256       setb ET0  ; Enable timer 0 interrupt
046D            257       ; setb TR0  (no need to open at first)
046D 22         258       ret
046E            259   ; ISR for timer 0.  Set to execute every 1/4096Hz 
046E            260   ; to generate a 2048 Hz square wave at pin P1.5 
046E            261   Timer0_ISR:
046E            262       ;clr TF0  ; According to the data sheet this is done for us already.
046E 758CFD     263       mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
0471 758A5A     264       mov TL0, #low(TIMER0_RELOAD)
0474 B295       265       cpl SOUND_OUT ; Connect speaker to P1.5
0476 32         266       reti
0477            267   ; -----------------------------------------------------------------------------------------------;
0477            268   
0477            269   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
0477            270   Initialize_Serial_Port:
0477            271       ; Configure serial port and baud rate
0477 C28E       272       clr TR1 ; Disable timer 1
0479 53890F     273       anl TMOD, #0x0f ; Mask the bits for timer 1
047C 438920     274       orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
047F 438780     275       orl PCON, #80H ; Set SMOD to 1
0482 758DFD     276       mov TH1, #low(TIMER_1_RELOAD)
0485 758BFD     277       mov TL1, #low(TIMER_1_RELOAD) 
0488 D28E       278       setb TR1 ; Enable timer 1
048A 759852     279       mov SCON, #52H
048D 22         280       ret
048E            281   
048E            282   ; uart sending functions
048E            283   putchar:
048E 109902     284       jbc TI, putchar_L1
0491 80FB       285       sjmp putchar
0493            286   putchar_L1:
0493 F599       287       mov SBUF,a
0495 22         288       ret
0496            289   
0496            290   SendString:
0496 E4         291       clr a
0497 93         292       movc a, @a+dptr
0498 6006       293       jz SendString_L1
049A 12048E     294       lcall putchar
049D A3         295       inc dptr
049E 80F6       296       sjmp SendString  
04A0            297   SendString_L1:
04A0 22         298       ret
04A1            299   
04A1            300   ;------------------------------------------------------------
04A1            301   ; getchar_nb (non-blocking)
04A1            302   ; OUT: C=1 if got byte, A=byte
04A1            303   ;      C=0 if none
04A1            304   ;------------------------------------------------------------
04A1            305   getchar_nb:
04A1 309806     306       jnb RI, rx_none
04A4 E599       307       mov A, SBUF
04A6 C298       308       clr RI
04A8 D3         309       setb C
04A9 22         310       ret
04AA            311   rx_none:
04AA C3         312       clr C
04AB 22         313       ret
04AC            314   ;------------------------------------------------------------
04AC            315   ; Serial_RX_Pump
04AC            316   ; Builds a null-terminated line in rx_buf.
04AC            317   ; Sets rx_ready=1 when a full line received.
04AC            318   ;------------------------------------------------------------
04AC            319   Serial_RX_Pump:
04AC E540       320       mov A, rx_ready
04AE 7034       321       jnz rxp_done          ; don't overwrite unprocessed line
04B0            322   
04B0            323   rxp_more:
04B0 1204A1     324       lcall getchar_nb
04B3 502F       325       jnc rxp_done          ; no new byte
04B5 F5F0       326       mov B, A              ; save received byte
04B7            327   
04B7            328       ; ignore CR
04B7 B40D02     329       cjne A, #0DH, rxp_not_cr
04BA 80F4       330       sjmp rxp_more
04BC            331   
04BC            332   rxp_not_cr:
04BC            333       ; if LF -> finish line
04BC B40A0F     334       cjne A, #0AH, rxp_store
04BF            335   
04BF            336       ; terminate string
04BF E53F       337       mov A, rx_idx
04C1 2492       338       add A, #rx_buf
04C3 F8         339       mov R0, A
04C4 7600       340       mov @R0, #0
04C6 754001     341       mov rx_ready, #1
04C9 753F00     342       mov rx_idx, #0
04CC 8016       343       sjmp rxp_done
04CE            344   
04CE            345   rxp_store:
04CE            346       ; store char if room (max 39 chars)
04CE E53F       347       mov A, rx_idx
04D0 B42705     348       cjne A, #39, rxp_ok
04D3 753F00     349       mov rx_idx, #0        ; overflow: reset
04D6 800C       350       sjmp rxp_done
04D8            351   
04D8            352   rxp_ok:
04D8 E53F       353       mov A, rx_idx
04DA 2492       354       add A, #rx_buf
04DC F8         355       mov R0, A
04DD E5F0       356       mov A, B
04DF F6         357       mov @R0, A
04E0 053F       358       inc rx_idx
04E2 80CC       359       sjmp rxp_more
04E4            360   
04E4            361   rxp_done:
04E4 22         362       ret
04E5            363   ; copies 3 ASCII digits to buffer at R1, null terminates
04E5            364   ; R0 = src (first digit), R1 = dst
04E5            365   Copy3DigitsToBuf:
04E5 E6         366       mov A, @R0
04E6 F7         367       mov @R1, A
04E7 08         368       inc R0
04E8 09         369       inc R1
04E9 E6         370       mov A, @R0
04EA F7         371       mov @R1, A
04EB 08         372       inc R0
04EC 09         373       inc R1
04ED E6         374       mov A, @R0
04EE F7         375       mov @R1, A
04EF 09         376       inc R1
04F0 7700       377       mov @R1, #0
04F2 22         378       ret
04F3            379   
04F3            380   ; copies 4 ASCII digits to buffer at R1, null terminates
04F3            381   Copy4DigitsToBuf:
04F3 E6         382       mov A, @R0
04F4 F7         383       mov @R1, A
04F5 08         384       inc R0
04F6 09         385       inc R1
04F7 E6         386       mov A, @R0
04F8 F7         387       mov @R1, A
04F9 08         388       inc R0
04FA 09         389       inc R1
04FB E6         390       mov A, @R0
04FC F7         391       mov @R1, A
04FD 08         392       inc R0
04FE 09         393       inc R1
04FF E6         394       mov A, @R0
0500 F7         395       mov @R1, A
0501 09         396       inc R1
0502 7700       397       mov @R1, #0
0504 22         398       ret
0505            399   
0505            400   ;------------------------------------------------------------
0505            401   ; Serial_Process_Line
0505            402   ; Handles: S:TTT, K:MMSS, R:TTT, L:MMSS, CFG:APPLY, RUN:0/1
0505            403   ;------------------------------------------------------------
0505            404   Serial_Process_Line:
0505 E540       405       mov A, rx_ready
0507 7003       406       jnz SPL_HAVE
0509 020625     407       ljmp spl_done
050C            408   SPL_HAVE:
050C 754000     409       mov rx_ready, #0
050F            410   
050F 7892       411       mov R0, #rx_buf
0511            412   
0511            413   ; ---------------- S:TTT ----------------
0511 E6         414       mov A, @R0
0512 B45302     415       cjne A, #'S', S_NOT
0515 8003       416       sjmp S_MATCH
0517            417   S_NOT:
0517 02052D     418       ljmp chk_K
051A            419   
051A            420   S_MATCH:
051A 08         421       inc R0
051B E6         422       mov A, @R0
051C B43A02     423       cjne A, #':', S_BAD
051F 8003       424       sjmp S_GO
0521            425   S_BAD:
0521 020625     426       ljmp spl_done
0524            427   S_GO:
0524 08         428       inc R0
0525 7980       429       mov R1, #Buf_Soak_Temp
0527 1204E5     430       lcall Copy3DigitsToBuf
052A 020625     431       ljmp spl_done
052D            432   
052D            433   ; ---------------- K:MMSS ----------------
052D            434   chk_K:
052D 7892       435       mov R0, #rx_buf
052F E6         436       mov A, @R0
0530 B44B02     437       cjne A, #'K', K_NOT
0533 8003       438       sjmp K_MATCH
0535            439   K_NOT:
0535 02054B     440       ljmp chk_R
0538            441   
0538            442   K_MATCH:
0538 08         443       inc R0
0539 E6         444       mov A, @R0
053A B43A02     445       cjne A, #':', K_BAD
053D 8003       446       sjmp K_GO
053F            447   K_BAD:
053F 020625     448       ljmp spl_done
0542            449   K_GO:
0542 08         450       inc R0
0543 7984       451       mov R1, #Buf_Soak_Time
0545 1204F3     452       lcall Copy4DigitsToBuf
0548 020625     453       ljmp spl_done
054B            454   
054B            455   ; ---------------- R:TTT ----------------
054B            456   chk_R:
054B 7892       457       mov R0, #rx_buf
054D E6         458       mov A, @R0
054E B45202     459       cjne A, #'R', R_NOT
0551 8003       460       sjmp R_MATCH
0553            461   R_NOT:
0553 020569     462       ljmp chk_L
0556            463   
0556            464   R_MATCH:
0556 08         465       inc R0
0557 E6         466       mov A, @R0
0558 B43A02     467       cjne A, #':', R_BAD
055B 8003       468       sjmp R_GO
055D            469   R_BAD:
055D 020625     470       ljmp spl_done
0560            471   R_GO:
0560 08         472       inc R0
0561 7989       473       mov R1, #Buf_Refl_Temp
0563 1204E5     474       lcall Copy3DigitsToBuf
0566 020625     475       ljmp spl_done
0569            476   
0569            477   ; ---------------- L:MMSS ----------------
0569            478   chk_L:
0569 7892       479       mov R0, #rx_buf
056B E6         480       mov A, @R0
056C B44C02     481       cjne A, #'L', L_NOT
056F 8003       482       sjmp L_MATCH
0571            483   L_NOT:
0571 020587     484       ljmp chk_CFG
0574            485   
0574            486   L_MATCH:
0574 08         487       inc R0
0575 E6         488       mov A, @R0
0576 B43A02     489       cjne A, #':', L_BAD
0579 8003       490       sjmp L_GO
057B            491   L_BAD:
057B 020625     492       ljmp spl_done
057E            493   L_GO:
057E 08         494       inc R0
057F 798D       495       mov R1, #Buf_Refl_Time
0581 1204F3     496       lcall Copy4DigitsToBuf
0584 020625     497       ljmp spl_done
0587            498   
0587            499   ; ---------------- CFG:APPLY (loose) ----------------
0587            500   chk_CFG:
0587 7892       501       mov R0, #rx_buf
0589 E6         502       mov A, @R0
058A B44302     503       cjne A, #'C', CFG_NOT
058D 8003       504       sjmp CFG_C
058F            505   CFG_NOT:
058F 0205C4     506       ljmp chk_RUN
0592            507   
0592            508   CFG_C:
0592 08         509       inc R0
0593 E6         510       mov A, @R0
0594 B44602     511       cjne A, #'F', CFG_BAD
0597 8003       512       sjmp CFG_F
0599            513   CFG_BAD:
0599 0205C4     514       ljmp chk_RUN
059C            515   
059C            516   CFG_F:
059C 08         517       inc R0
059D E6         518       mov A, @R0
059E B44702     519       cjne A, #'G', CFG_BAD2
05A1 8003       520       sjmp CFG_G
05A3            521   CFG_BAD2:
05A3 0205C4     522       ljmp chk_RUN
05A6            523   
05A6            524   CFG_G:
05A6 08         525       inc R0
05A7 E6         526       mov A, @R0
05A8 B43A02     527       cjne A, #':', CFG_BAD3
05AB 8003       528       sjmp CFG_COLON
05AD            529   CFG_BAD3:
05AD 0205C4     530       ljmp chk_RUN
05B0            531   
05B0            532   CFG_COLON:
05B0 08         533       inc R0
05B1 E6         534       mov A, @R0
05B2 B44102     535       cjne A, #'A', CFG_BAD4
05B5 8003       536       sjmp CFG_APPLY
05B7            537   CFG_BAD4:
05B7 0205C4     538       ljmp chk_RUN
05BA            539   
05BA            540   CFG_APPLY:
05BA 120E68     541       lcall Update_FSM_Variables
05BD C200       542       clr  remote_config_mode
05BF D20D       543       setb state_change_signal   ; force LCD redraw
05C1            544       ; optional: lcall Update_Screen_Full  ; if you want parameter page redraw instantly
05C1 020625     545       ljmp spl_done
05C4            546   
05C4            547   
05C4            548   ; ---------------- RUN:0 / RUN:1 ----------------
05C4            549   chk_RUN:
05C4 7892       550       mov R0, #rx_buf
05C6 E6         551       mov A, @R0
05C7 B45202     552       cjne A, #'R', RUN_BAD
05CA 8003       553       sjmp RUN_R
05CC            554   RUN_BAD:
05CC 020625     555       ljmp spl_done
05CF            556   
05CF            557   RUN_R:
05CF 08         558       inc R0
05D0 E6         559       mov A, @R0
05D1 B45502     560       cjne A, #'U', RUN_BAD2
05D4 8003       561       sjmp RUN_U
05D6            562   RUN_BAD2:
05D6 020625     563       ljmp spl_done
05D9            564   
05D9            565   RUN_U:
05D9 08         566       inc R0
05DA E6         567       mov A, @R0
05DB B44E02     568       cjne A, #'N', RUN_BAD3
05DE 8003       569       sjmp RUN_N
05E0            570   RUN_BAD3:
05E0 020625     571       ljmp spl_done
05E3            572   
05E3            573   RUN_N:
05E3 08         574       inc R0
05E4 E6         575       mov A, @R0
05E5 B43A02     576       cjne A, #':', RUN_BAD4
05E8 8003       577       sjmp RUN_COLON
05EA            578   RUN_BAD4:
05EA 020625     579       ljmp spl_done
05ED            580   
05ED            581   RUN_COLON:
05ED 08         582       inc R0
05EE E6         583       mov A, @R0
05EF B43102     584       cjne A, #'1', RUN_NOT1
05F2 8003       585       sjmp RUN_1
05F4            586   RUN_NOT1:
05F4 02060E     587       ljmp run_zero
05F7            588   
05F7            589   RUN_1:
05F7 C200       590       clr  remote_config_mode
05F9 756A00     591       mov Control_FSM_state, #0
05FC 756B00     592       mov Current_State, #0
05FF 753000     593       mov current_time_sec, #0
0602 753100     594       mov current_time_minute, #0
0605 D20D       595       setb state_change_signal
0607 D210       596       setb tc_startup_window
0609 C20F       597       clr  tc_missing_abort
060B 020625     598       ljmp spl_done
060E            599   
060E            600   
060E            601   run_zero:
060E B43002     602       cjne A, #'0', RUN_BAD5
0611 8003       603       sjmp RUN_0
0613            604   RUN_BAD5:
0613 020625     605       ljmp spl_done
0616            606   
0616            607   RUN_0:
0616 C293       608       clr PWM_OUT
0618 D20A       609       setb stop_signal
061A 756A00     610       mov Control_FSM_state, #0
061D 756B00     611       mov Current_State, #0
0620 D20D       612       setb state_change_signal
0622 020625     613       ljmp spl_done
0625            614   
0625            615   spl_done:
0625 22         616       ret
0626            617   
0626            618   
0626            619   ;-------------------------------------------------------------------------------
0626            620   ; serial debugging
0626            621   ; send a four byte number via serial to laptop
0626            622   ; need to be used with python script
0626            623   ; content needed to be sent should be stored in the varaible x
0626            624   ;-------------------------------------------------------------------------------
0626            625   Send32:
0626            626       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
0626 74AA       627       mov A, #0AAH
0628 12048E     628       lcall putchar
062B 7455       629       mov A, #055H
062D 12048E     630       lcall putchar
0630            631   
0630 E535       632       mov A, x+3
0632 12048E     633       lcall putchar
0635 E534       634       mov A, x+2
0637 12048E     635       lcall putchar
063A E533       636       mov A, x+1
063C 12048E     637       lcall putchar
063F E532       638       mov A, x+0
0641 12048E     639       lcall putchar
0644            640   
0644 740A       641       mov A, #0AH
0646 12048E     642       lcall putchar
0649 22         643       ret
064A            644   ; -----------------------------------------------------------------------------------------------;
064A            645   
064A            646   ;-------------------------------------------------------------------------------
064A            647   ; Serial temperature line for PuTTY/screen
064A            648   ; Outputs: "Temp: XXXC\r\n"
064A            649   ;-------------------------------------------------------------------------------
064A            650   Serial_Send_Temp_Line:
064A 9003E5     651       mov dptr, #String_temp_line
064D 120496     652       lcall SendString
0650            653   
0650            654       ; Convert current_temp to BCD (same as LCD)
0650 854132     655       mov x, current_temp
0653 854233     656       mov x+1, current_temp+1
0656 854334     657       mov x+2, current_temp+2
0659 854435     658       mov x+3, current_temp+3
065C 12002E     659       lcall hex2bcd
065F            660   
065F 7F00       661       mov R7, #0          ; printed_flag = 0
0661            662   
0661            663       ; Print Hundreds (if non-zero)
0661 E53B       664       mov a, bcd+1
0663 540F       665       anl a, #0x0F
0665 6007       666       jz Serial_Skip_Hundreds
0667 2430       667       add a, #0x30
0669 12048E     668       lcall putchar
066C 7F01       669       mov R7, #1
066E            670   Serial_Skip_Hundreds:
066E            671   
066E            672       ; Print Tens (if non-zero or if hundreds already printed)
066E E53A       673       mov a, bcd+0
0670 C4         674       swap a
0671 540F       675       anl a, #0x0F
0673 7003       676       jnz Serial_Print_Tens
0675 EF         677       mov a, R7
0676 600C       678       jz Serial_Skip_Tens
0678            679   Serial_Print_Tens:
0678 E53A       680       mov a, bcd+0
067A C4         681       swap a
067B 540F       682       anl a, #0x0F
067D 2430       683       add a, #0x30
067F 12048E     684       lcall putchar
0682 7F01       685       mov R7, #1
0684            686   Serial_Skip_Tens:
0684            687   
0684            688       ; Print Ones (always)
0684 E53A       689       mov a, bcd+0
0686 540F       690       anl a, #0x0F
0688 2430       691       add a, #0x30
068A 12048E     692       lcall putchar
068D            693   
068D            694       ; Print 'C' and newline
068D 7443       695       mov a, #'C'
068F 12048E     696       lcall putchar
0692 740D       697       mov a, #0DH     ; CR
0694 12048E     698       lcall putchar
0697 740A       699       mov a, #0AH     ; LF
0699 12048E     700       lcall putchar
069C 22         701       ret
069D            702   
069D            703   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
069D              1   ;-------------------------------------------------------------------------------
069D              2   ; Timer2_ISR.inc
069D              3   ; Contains Initialization and ISR for the 1ms System Timer
069D              4   ;-------------------------------------------------------------------------------
069D              5   
069D              6   ;-------------------------------------------------------------------------------
069D              7   ; Routine to initialize the ISR for timer 2
069D              8   ;-------------------------------------------------------------------------------
069D              9   Timer2_Init:
069D 75C800      10       mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
06A0 75CDF5      11       mov TH2, #high(TIMER2_RELOAD)
06A3 75CC27      12       mov TL2, #low(TIMER2_RELOAD)
06A6             13       ; Set the reload value
06A6 75CBF5      14       mov RCAP2H, #high(TIMER2_RELOAD)
06A9 75CA27      15       mov RCAP2L, #low(TIMER2_RELOAD)
06AC             16       
06AC C2CF        17       clr TF2       ; Clear flag just in case
06AE             18       ; Enable the timer and interrupts
06AE D2AD        19       setb ET2      ; Enable timer 2 interrupt
06B0 D2CA        20       setb TR2      ; Enable timer 2
06B2 22          21       ret
06B3             22   
06B3             23   ;-------------------------------------------------------------------------------
06B3             24   ; ISR for timer 2.  Runs every 1 ms
06B3             25   ;-------------------------------------------------------------------------------
06B3             26   Timer2_ISR:
06B3 C0E0        27       push acc
06B5 C0D0        28       push psw
06B7             29       
06B7 C2CF        30       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
06B9             31   
06B9             32       ; --- 1. Existing FSM Timers ---
06B9 0566        33       inc KEY1_DEB_timer
06BB 0567        34       inc SEC_FSM_timer
06BD D203        35       setb one_ms_pwm_flag 
06BF D214        36       setb one_ms_beep_flag
06C1 D21F        37       setb one_millisecond_flag_servo
06C3             38   
06C3             39       ; --- 2. NEW: Non-Blocking Delay Counters ---
06C3             40       
06C3             41       ; A. BUTTON DELAY
06C3 30170B      42       jnb wait25_btn_active, T2_Check_Keypad
06C6 054D        43       inc wait25_btn_cnt
06C8 E54D        44       mov a, wait25_btn_cnt
06CA B41904      45       cjne a, #25, T2_Check_Keypad
06CD D218        46       setb wait25_btn_done
06CF C217        47       clr wait25_btn_active
06D1             48       
06D1             49       ; B. KEYPAD DELAY
06D1             50   T2_Check_Keypad:
06D1 30190B      51       jnb wait25_keypad_active, T2_Check_ADC
06D4 054E        52       inc wait25_keypad_cnt
06D6 E54E        53       mov a, wait25_keypad_cnt
06D8 B41904      54       cjne a, #25, T2_Check_ADC
06DB D21A        55       setb wait25_keypad_done
06DD C219        56       clr wait25_keypad_active
06DF             57   
06DF             58       ; C. ADC DELAY (Thermocouple)
06DF             59   T2_Check_ADC:
06DF 301B0B      60       jnb wait25_adc_active, T2_Check_LCD
06E2 054F        61       inc wait25_adc_cnt
06E4 E54F        62       mov a, wait25_adc_cnt
06E6 B41904      63       cjne a, #25, T2_Check_LCD
06E9 D21C        64       setb wait25_adc_done
06EB C21B        65       clr wait25_adc_active
06ED             66   
06ED             67       ; D. LCD DELAY
06ED             68   T2_Check_LCD:
06ED 301D0B      69       jnb wait25_lcd_active, T2_Check_Generic
06F0 0550        70       inc wait25_lcd_cnt
06F2 E550        71       mov a, wait25_lcd_cnt
06F4 B41904      72       cjne a, #25, T2_Check_Generic
06F7 D21E        73       setb wait25_lcd_done
06F9 C21D        74       clr wait25_lcd_active
06FB             75   
06FB             76       ; E. GENERIC DELAY (Used by Wait_25ms in Main)
06FB             77   T2_Check_Generic:
06FB 30150B      78       jnb wait25_active, Timer2_ISR_done
06FE 0551        79       inc wait25_count
0700 E551        80       mov a, wait25_count
0702 B41904      81       cjne a, #25, Timer2_ISR_done
0705 D216        82       setb wait25_done      ; Tells Wait_25ms that we are finished
0707 C215        83       clr wait25_active     ; Stop counting
0709             84   
0709             85   Timer2_ISR_done:
0709 D0D0        86       pop psw
070B D0E0        87       pop acc
070D 32          88       reti
070E             89            
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
070E              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
070E              2   cseg
070E              3   
070E              4   ; When using a 33.333333MHz crystal clock
070E              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
070E              6   
070E              7   ;---------------------------------;
070E              8   ; Wait 40 microseconds            ;
070E              9   ;---------------------------------;
070E             10   Wait40uSec:
070E C000        11            push AR0
0710 78BE        12            mov R0, #190
0712             13   L0: 
0712 00          14            nop
0713 00          15            nop
0714 00          16            nop
0715 00          17            nop
0716 D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
0718 D000        19            pop AR0
071A 22          20       ret
071B             21   
071B             22   ;---------------------------------;
071B             23   ; Wait 'R2' milliseconds          ;
071B             24   ;---------------------------------;
                 25   Wait_Milli_Seconds mac
                 26   	push AR2
                 27   	mov R2, %0
                 28   	lcall ?Wait_Milli_Seconds
                 29   	pop AR2
                 30   endmac
071B             31   
071B             32   ?Wait_Milli_Seconds:
071B C000        33            push AR0
071D C001        34            push AR1
071F 7932        35   L3: mov R1, #50
0721 78DF        36   L2: mov R0, #223
0723 D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
0725 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
0727 DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
0729 D001        40       pop AR1
072B D000        41       pop AR0
072D 22          42       ret
072E             43            
072E             44   ;---------------------------------;
072E             45   ; Toggles the 'E' pin in the LCD  ;
072E             46   ;---------------------------------;
072E             47   ELCD_pulse:
072E D291        48            setb ELCD_E
0730 12070E      49            lcall Wait40uSec
0733 C291        50            clr ELCD_E
0735 12070E      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
0738 22          52       ret
0739             53   
0739             54   ;---------------------------------;
0739             55   ; Writes acc to LCD in 4-bit mode ;
0739             56   ;---------------------------------;
0739             57   ELCD_byte:
0739             58            ; Write high 4 bits first
0739 A2E7        59            mov c, ACC.7
073B 9281        60            mov ELCD_D7, c
073D A2E6        61            mov c, ACC.6
073F 9283        62            mov ELCD_D6, c
0741 A2E5        63            mov c, ACC.5
0743 9285        64            mov ELCD_D5, c
0745 A2E4        65            mov c, ACC.4
0747 9287        66            mov ELCD_D4, c
0749 12072E      67       lcall ELCD_pulse
074C             68            ; Write low 4 bits next
074C A2E3        69            mov c, ACC.3
074E 9281        70            mov ELCD_D7, c
0750 A2E2        71            mov c, ACC.2
0752 9283        72            mov ELCD_D6, c
0754 A2E1        73            mov c, ACC.1
0756 9285        74            mov ELCD_D5, c
0758 A2E0        75            mov c, ACC.0
075A 9287        76            mov ELCD_D4, c
075C 12072E      77       lcall ELCD_pulse
075F 22          78            ret
0760             79   
0760             80   ;---------------------------------;
0760             81   ; Write data to LCD               ;
0760             82   ;---------------------------------;
                 83   WriteData mac
                 84   	mov a, %0
                 85   	lcall ?WriteData
                 86   endmac
0760             87            
0760             88   ?WriteData:
0760 D297        89            setb ELCD_RS
0762 020739      90            ljmp ELCD_byte
0765             91   
0765             92   ;---------------------------------;
0765             93   ; Write command to LCD            ;
0765             94   ;---------------------------------;
                 95   WriteCommand mac
                 96   	mov a, %0
                 97   	lcall ?WriteCommand
                 98   endmac
0765             99   
0765            100   ?WriteCommand:
0765 C297       101            clr ELCD_RS
0767 020739     102            ljmp ELCD_byte
076A            103   
076A            104   ;---------------------------------;
076A            105   ; Configure LCD in 4-bit mode     ;
076A            106   ;---------------------------------;
076A            107   ELCD_4BIT:
076A C291       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
076C            109            ;clr ELCD_RW  ; RW forced to zero
076C            110            
076C            111            ; After power on, let the LCD start up before initializing
076C C002       112            push AR2
076E 7A28       112            mov R2, #40
0770 12071B     112            lcall ?Wait_Milli_Seconds
0773 D002       112            pop AR2
0775            113            
0775            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
0775 7433       115            mov a, #0x33
0777 120765     115            lcall ?WriteCommand
077A 7433       116            mov a, #0x33
077C 120765     116            lcall ?WriteCommand
077F 7432       117            mov a, #0x32
0781 120765     117            lcall ?WriteCommand ; change to 4-bit mode
0784            118   
0784            119            ; Configure the LCD
0784 7428       120            mov a, #0x28
0786 120765     120            lcall ?WriteCommand
0789 740C       121            mov a, #0x0c
078B 120765     121            lcall ?WriteCommand
078E 7401       122            mov a, #0x01
0790 120765     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
0793            123   
0793            124       ;Wait for the clear screen command to finish.
0793 C002       125            push AR2
0795 7A02       125            mov R2, #2
0797 12071B     125            lcall ?Wait_Milli_Seconds
079A D002       125            pop AR2
079C 22         126       ret
079D            127   
079D            128   ;---------------------------------;
079D            129   ; Send a constant string to LCD   ;
079D            130   ;---------------------------------;
                131   Send_Constant_String mac
                132   	push dph
                133   	push dpl
                134   	push acc
                135   	mov dptr, %0
                136   	lcall ?Send_Constant_String
                137   	pop acc
                138   	pop dpl
                139   	pop dph
                140   endmac
079D            141   
079D            142   ?Send_Constant_String:
079D E4         143       clr a
079E 93         144       movc a, @a+dptr
079F 6006       145       jz ?Send_Constant_String_Done
07A1 120760     146       lcall ?WriteData
07A4 A3         147       inc dptr
07A5 80F6       148       sjmp ?Send_Constant_String
07A7            149   ?Send_Constant_String_Done:
07A7 22         150       ret  
07A8            151   
07A8            152   ;---------------------------------;
07A8            153   ; Set LCD cursor at row, column   ;
07A8            154   ;---------------------------------;
                155   Set_Cursor mac
                156   	push acc
                157   	mov a, #%1
                158   	dec a
                159   	lcall ?Set_Cursor_%0 ; Select column and row
                160   	pop acc
                161   endmac
07A8            162   
07A8            163   ?Set_Cursor_2:
07A8 4440       164            orl a, #01000000B
07AA            165   ?Set_Cursor_1:
07AA 4480       166            orl a, #10000000B
07AC 020765     167            ljmp ?WriteCommand ; Select column and row
07AF            168   
07AF            169   ;---------------------------------;
07AF            170   ; Display a BCD number in the LCD ;
07AF            171   ;---------------------------------;
                172   Display_BCD mac
                173   	push ar0
                174   	mov r0, %0
                175   	lcall ?Display_BCD
                176   	pop ar0
                177   endmac
07AF            178   
07AF            179   ?Display_BCD:
07AF C0E0       180            push acc
07B1            181            ; Write most significant digit
07B1 E8         182            mov a, r0
07B2 C4         183            swap a
07B3 540F       184            anl a, #0fh
07B5 4430       185            orl a, #30h
07B7 120760     186            lcall ?WriteData
07BA            187            ; write least significant digit
07BA E8         188            mov a, r0
07BB 540F       189            anl a, #0fh
07BD 4430       190            orl a, #30h
07BF 120760     191            lcall ?WriteData
07C2 D0E0       192            pop acc
07C4 22         193            ret
07C5            194   
07C5            195   ;------------------------------------;
07C5            196   ; Display a char in the LCD          ;
07C5            197   ;------------------------------------;
                198   Display_char mac
                199   	push acc
                200   	mov a, %0
                201   	lcall ?WriteData
                202   	pop acc
                203   endmac
07C5            204   
07C5            706            ;-----------------------------------------------------------------------------------------------;
07C5            707   
07C5            708   ;-------------------------------------------------------------------------------
07C5            709   ; Display Function for 7-segment displays       
07C5            710   ;-------------------------------------------------------------------------------
07C5            711   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
07C5            712   T_7seg:
07C5 C0F9A4B0   713       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
07CA 9282F880   714       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
07CF 8883C6A1   715       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
07D5            716   
07D5            717   ; Displays a BCD number pased in R0 in HEX5-HEX0
07D5            718   Display_BCD_7_Seg_HEX10:
07D5 9007C5     719       mov dptr, #T_7seg
07D8 E8         720       mov a, R0
07D9 C4         721       swap a
07DA 540F       722       anl a, #0FH
07DC 93         723       movc a, @a+dptr
07DD F592       724       mov HEX1, a
07DF E8         725       mov a, R0
07E0 540F       726       anl a, #0FH
07E2 93         727       movc a, @a+dptr
07E3 F591       728       mov HEX0, a
07E5 22         729       ret
07E6            730   
07E6            731   Display_BCD_7_Seg_HEX32:
07E6 9007C5     732       mov dptr, #T_7seg
07E9 E8         733       mov a, R0
07EA C4         734       swap a
07EB 540F       735       anl a, #0FH
07ED 93         736       movc a, @a+dptr
07EE F594       737       mov HEX3, a
07F0 E8         738       mov a, R0
07F1 540F       739       anl a, #0FH
07F3 93         740       movc a, @a+dptr
07F4 F593       741       mov HEX2, a
07F6 22         742       ret
07F7            743   
07F7            744   Display_BCD_7_Seg_HEX54:
07F7 9007C5     745       mov dptr, #T_7seg
07FA E8         746       mov a, R0
07FB C4         747       swap a
07FC 540F       748       anl a, #0FH
07FE 93         749       movc a, @a+dptr
07FF F58F       750       mov HEX5, a
0801 E8         751       mov a, R0
0802 540F       752       anl a, #0FH
0804 93         753       movc a, @a+dptr
0805 F58E       754       mov HEX4, a
0807 22         755       ret
0808            756   
0808            757   ; The 8-bit hex number passed in the accumulator is converted to
0808            758   ; BCD and stored in [R1, R0]
0808            759   Hex_to_bcd_8bit:
0808 75F064     760       mov b, #100
080B 84         761       div ab
080C F9         762       mov R1, a   ; After dividing, a has the 100s
080D E5F0       763       mov a, b    ; Remainder is in register b
080F 75F00A     764       mov b, #10
0812 84         765       div ab ; The tens are stored in a, the units are stored in b 
0813 C4         766       swap a
0814 54F0       767       anl a, #0xf0
0816 45F0       768       orl a, b
0818 F8         769       mov R0, a
0819 22         770       ret
081A            771   ;-------------------------------------------------------------------------------
081A            772   ; Display Function for LCD                      
081A            773   ;-------------------------------------------------------------------------------
081A            774   LCD_Print_2Digits:
081A 120808     775       lcall Hex_to_bcd_8bit
081D E8         776       mov a, R0
081E C4         777       swap a
081F 540F       778       anl a, #0x0F
0821 2430       779       add a, #0x30
0823 120760     780       lcall ?WriteData
0826 E8         781       mov a, R0
0827 540F       782       anl a, #0x0F
0829 2430       783       add a, #0x30
082B 120760     784       lcall ?WriteData
082E 22         785       ret
082F            786   
082F            787   LCD_Display_Update_func:
082F C0E0       788       push acc
0831            789       
0831            790       ; ==========================================
0831            791       ; PART 1: STATIC TEXT (Title)
0831            792       ; Runs ONLY when the state changes
0831            793       ; ==========================================
0831            794       
0831            795       ; [FIX] "Trampoline" logic for long distance jump
0831            796       ; If signal is SET (1), we stay here and update.
0831            797       ; If signal is CLEAR (0), we Long Jump to the Live Update section.
0831 200D03     798       jb state_change_signal, Do_Static_Update
0834 02096D     799       ljmp Check_Live_Update
0837            800   
0837            801   Do_Static_Update:
0837 C20D       802       clr state_change_signal
0839            803       
0839            804       ; State Changed: Clear Screen and Write Title
0839 1211A4     805       lcall Clear_Screen_Func
083C E56A       806       mov a, Control_FSM_state
083E            807       
083E            808       ; State 0: Welcome
083E B4003B     809       cjne a, #0, LCD_Check_1
0841 C0E0       810            push acc
0843 7401       810            mov a, #1
0845 14         810            dec a
0846 1207AA     810            lcall ?Set_Cursor_1 ; Select column and row
0849 D0E0       810            pop acc
084B C083       811            push dph
084D C082       811            push dpl
084F C0E0       811            push acc
0851 900330     811            mov dptr, #String_state0_1
0854 12079D     811            lcall ?Send_Constant_String
0857 D0E0       811            pop acc
0859 D082       811            pop dpl
085B D083       811            pop dph
085D C0E0       812            push acc
085F 7401       812            mov a, #1
0861 14         812            dec a
0862 1207A8     812            lcall ?Set_Cursor_2 ; Select column and row
0865 D0E0       812            pop acc
0867 C083       813            push dph
0869 C082       813            push dpl
086B C0E0       813            push acc
086D 900340     813            mov dptr, #String_state0_2
0870 12079D     813            lcall ?Send_Constant_String
0873 D0E0       813            pop acc
0875 D082       813            pop dpl
0877 D083       813            pop dph
0879 02096A     814       ljmp LCD_Done_Bridge ; Exit
087C            815   
087C            816   LCD_Check_1: ; Setup
087C B4011F     817       cjne a, #1, LCD_Check_2
087F C0E0       818            push acc
0881 7401       818            mov a, #1
0883 14         818            dec a
0884 1207AA     818            lcall ?Set_Cursor_1 ; Select column and row
0887 D0E0       818            pop acc
0889 C083       819            push dph
088B C082       819            push dpl
088D C0E0       819            push acc
088F 9003A5     819            mov dptr, #String_state1
0892 12079D     819            lcall ?Send_Constant_String
0895 D0E0       819            pop acc
0897 D082       819            pop dpl
0899 D083       819            pop dph
089B 02096A     820       ljmp LCD_Done_Bridge
089E            821   
089E            822   LCD_Check_2: ; Ramp to Soak
089E B4021F     823       cjne a, #2, LCD_Check_3
08A1 C0E0       824            push acc
08A3 7401       824            mov a, #1
08A5 14         824            dec a
08A6 1207AA     824            lcall ?Set_Cursor_1 ; Select column and row
08A9 D0E0       824            pop acc
08AB C083       825            push dph
08AD C082       825            push dpl
08AF C0E0       825            push acc
08B1 9003EC     825            mov dptr, #String_state2
08B4 12079D     825            lcall ?Send_Constant_String
08B7 D0E0       825            pop acc
08B9 D082       825            pop dpl
08BB D083       825            pop dph
08BD 02098D     826       ljmp LCD_Update_Temp_Value ; Draw Temp immediately!
08C0            827   
08C0            828   LCD_Check_3: ; Soak
08C0 B4031F     829       cjne a, #3, LCD_Check_4
08C3 C0E0       830            push acc
08C5 7401       830            mov a, #1
08C7 14         830            dec a
08C8 1207AA     830            lcall ?Set_Cursor_1 ; Select column and row
08CB D0E0       830            pop acc
08CD C083       831            push dph
08CF C082       831            push dpl
08D1 C0E0       831            push acc
08D3 9003FC     831            mov dptr, #String_state3
08D6 12079D     831            lcall ?Send_Constant_String
08D9 D0E0       831            pop acc
08DB D082       831            pop dpl
08DD D083       831            pop dph
08DF 02098D     832       ljmp LCD_Update_Temp_Value
08E2            833   
08E2            834   LCD_Check_4: ; Ramp to Peak
08E2 B4041F     835       cjne a, #4, LCD_Check_5
08E5 C0E0       836            push acc
08E7 7401       836            mov a, #1
08E9 14         836            dec a
08EA 1207AA     836            lcall ?Set_Cursor_1 ; Select column and row
08ED D0E0       836            pop acc
08EF C083       837            push dph
08F1 C082       837            push dpl
08F3 C0E0       837            push acc
08F5 90040C     837            mov dptr, #String_state4
08F8 12079D     837            lcall ?Send_Constant_String
08FB D0E0       837            pop acc
08FD D082       837            pop dpl
08FF D083       837            pop dph
0901 02098D     838       ljmp LCD_Update_Temp_Value
0904            839   
0904            840   LCD_Check_5: ; Reflow
0904 B4051F     841       cjne a, #5, LCD_Check_6
0907 C0E0       842            push acc
0909 7401       842            mov a, #1
090B 14         842            dec a
090C 1207AA     842            lcall ?Set_Cursor_1 ; Select column and row
090F D0E0       842            pop acc
0911 C083       843            push dph
0913 C082       843            push dpl
0915 C0E0       843            push acc
0917 90041C     843            mov dptr, #String_state5
091A 12079D     843            lcall ?Send_Constant_String
091D D0E0       843            pop acc
091F D082       843            pop dpl
0921 D083       843            pop dph
0923 02098D     844       ljmp LCD_Update_Temp_Value
0926            845   
0926            846   LCD_Check_6: ; Cooling
0926 B4061F     847       cjne a, #6, LCD_Check_7
0929 C0E0       848            push acc
092B 7401       848            mov a, #1
092D 14         848            dec a
092E 1207AA     848            lcall ?Set_Cursor_1 ; Select column and row
0931 D0E0       848            pop acc
0933 C083       849            push dph
0935 C082       849            push dpl
0937 C0E0       849            push acc
0939 90042C     849            mov dptr, #String_state6
093C 12079D     849            lcall ?Send_Constant_String
093F D0E0       849            pop acc
0941 D082       849            pop dpl
0943 D083       849            pop dph
0945 02098D     850       ljmp LCD_Update_Temp_Value
0948            851   
0948            852   LCD_Check_7: ; Done
0948            853       ; [FIX] Check distance safe logic for State 7
0948 B4071F     854       cjne a, #7, LCD_Done_Bridge ; If not 7, we are done
094B C0E0       855            push acc
094D 7401       855            mov a, #1
094F 14         855            dec a
0950 1207AA     855            lcall ?Set_Cursor_1 ; Select column and row
0953 D0E0       855            pop acc
0955 C083       856            push dph
0957 C082       856            push dpl
0959 C0E0       856            push acc
095B 90043C     856            mov dptr, #String_state7
095E 12079D     856            lcall ?Send_Constant_String
0961 D0E0       856            pop acc
0963 D082       856            pop dpl
0965 D083       856            pop dph
0967 02096A     857       ljmp LCD_Done_Bridge
096A            858   
096A            859   ; Local bridge to reach the far-away LCD_Done
096A            860   LCD_Done_Bridge:
096A 0209EE     861       ljmp LCD_Done
096D            862   
096D            863   ; ==========================================
096D            864   ; PART 2: DYNAMIC VALUES (Temperature)
096D            865   ; Runs every time 'one_second_flag' is set
096D            866   ; ==========================================
096D            867   Check_Live_Update:
096D 3002FA     868       jnb one_second_flag, LCD_Done_Bridge
0970 C202       869       clr one_second_flag
0972            870       
0972            871       ; Only update temp for States 2, 3, 4, 5, 6
0972 E56A       872       mov a, Control_FSM_state
0974 B40202     873       cjne a, #2, Check_St3
0977 8014       874       sjmp LCD_Update_Temp_Value
0979            875   Check_St3:
0979 B40302     876       cjne a, #3, Check_St4
097C 800F       877       sjmp LCD_Update_Temp_Value
097E            878   Check_St4:
097E B40402     879       cjne a, #4, Check_St5
0981 800A       880       sjmp LCD_Update_Temp_Value
0983            881   Check_St5:
0983 B40502     882       cjne a, #5, Check_St6
0986 8005       883       sjmp LCD_Update_Temp_Value
0988            884   Check_St6:
0988 B40663     885       cjne a, #6, LCD_Done
098B 8000       886       sjmp LCD_Update_Temp_Value
098D            887   
098D            888   ; --- HELPER: Prints "XXX C" on Line 2 ---
098D            889   LCD_Update_Temp_Value:
098D C0E0       890            push acc
098F 7401       890            mov a, #1
0991 14         890            dec a
0992 1207A8     890            lcall ?Set_Cursor_2 ; Select column and row
0995 D0E0       890            pop acc
0997            891       
0997            892       ; Convert current_temp to BCD
0997 854132     893       mov x, current_temp
099A 854233     894       mov x+1, current_temp+1
099D 854334     895       mov x+2, current_temp+2
09A0 854435     896       mov x+3, current_temp+3
09A3 12002E     897       lcall hex2bcd
09A6            898   
09A6            899       ; Update HEX2-HEX0 with temperature
09A6 1209F1     900       lcall Update_HEX_Temp
09A9            901       
09A9            902       ; Print Hundreds
09A9 E53B       903       mov a, bcd+1
09AB 540F       904       anl a, #0x0F
09AD 2430       905       add a, #0x30
09AF 120760     906       lcall ?WriteData
09B2            907       
09B2            908       ; Print Tens
09B2 E53A       909       mov a, bcd+0
09B4 C4         910       swap a
09B5 540F       911       anl a, #0x0F
09B7 2430       912       add a, #0x30
09B9 120760     913       lcall ?WriteData
09BC            914       
09BC            915       ; Print Ones
09BC E53A       916       mov a, bcd+0
09BE 540F       917       anl a, #0x0F
09C0 2430       918       add a, #0x30
09C2 120760     919       lcall ?WriteData
09C5            920       
09C5            921       ; Print 'C'
09C5 7443       922       mov a, #'C'
09C7 120760     923       lcall ?WriteData
09CA            924       
09CA            925       ; Clear remaining line space (prevents garbage)
09CA 7420       926       mov a, #' '
09CC 120760     927       lcall ?WriteData
09CF 120760     928       lcall ?WriteData
09D2            929   
09D2            930       ; Print time MM:SS at bottom right
09D2 C0E0       931            push acc
09D4 740C       931            mov a, #12
09D6 14         931            dec a
09D7 1207A8     931            lcall ?Set_Cursor_2 ; Select column and row
09DA D0E0       931            pop acc
09DC E531       932       mov a, current_time_minute
09DE 12081A     933       lcall LCD_Print_2Digits
09E1 743A       934       mov a, #':'
09E3 120760     935       lcall ?WriteData
09E6 E530       936       mov a, current_time_sec
09E8 12081A     937       lcall LCD_Print_2Digits
09EB            938   
09EB            939       ; Mirror temp to serial (PuTTY/screen)
09EB 12064A     940       lcall Serial_Send_Temp_Line
09EE            941   
09EE            942   LCD_Done:
09EE D0E0       943       pop acc
09F0 22         944       ret
09F1            945   ;---------------------------------------------------------
09F1            946   
09F1            947   ;-------------------------------------------------------------------------------
09F1            948   ; Update HEX2-HEX0 with temperature (3 digits)
09F1            949   ;-------------------------------------------------------------------------------
09F1            950   Update_HEX_Temp:
09F1 9007C5     951       mov dptr, #T_7seg
09F4            952       ; Hundreds -> HEX2
09F4 E53B       953       mov a, bcd+1
09F6 540F       954       anl a, #0x0F
09F8 93         955       movc a, @a+dptr
09F9 F593       956       mov HEX2, a
09FB            957       ; Tens -> HEX1
09FB E53A       958       mov a, bcd+0
09FD C4         959       swap a
09FE 540F       960       anl a, #0x0F
0A00 93         961       movc a, @a+dptr
0A01 F592       962       mov HEX1, a
0A03            963       ; Ones -> HEX0
0A03 E53A       964       mov a, bcd+0
0A05 540F       965       anl a, #0x0F
0A07 93         966       movc a, @a+dptr
0A08 F591       967       mov HEX0, a
0A0A 22         968       ret
0A0B            969   
0A0B            970   KEY1_DEB:
0A0B            971   ;non-blocking state machine for KEY1 debounce
0A0B E568       972       mov a, KEY1_DEB_state
0A0D            973   KEY1_DEB_state0:
0A0D B4000A     974       cjne a, #0, KEY1_DEB_state1
0A10 20F92D     975       jb KEY.1, KEY1_DEB_done
0A13 756600     976       mov KEY1_DEB_timer, #0
0A16 0568       977       inc KEY1_DEB_state
0A18 8026       978       sjmp KEY1_DEB_done
0A1A            979   KEY1_DEB_state1:
0A1A B40109     980       cjne a, #1, KEY1_DEB_state2
0A1D            981       ; this is the debounce state
0A1D E566       982       mov a, KEY1_DEB_timer
0A1F B4321E     983       cjne a, #50, KEY1_DEB_done ; 50 ms passed?
0A22 0568       984       inc KEY1_DEB_state
0A24 801A       985       sjmp KEY1_DEB_done  
0A26            986   KEY1_DEB_state2:
0A26 B4020C     987       cjne a, #2, KEY1_DEB_state3
0A29 20F904     988       jb KEY.1, KEY1_DEB_state2b
0A2C 0568       989       inc KEY1_DEB_state
0A2E 8010       990       sjmp KEY1_DEB_done  
0A30            991   KEY1_DEB_state2b:
0A30 756800     992       mov KEY1_DEB_state, #0
0A33 800B       993       sjmp KEY1_DEB_done
0A35            994   KEY1_DEB_state3:
0A35 B40308     995       cjne a, #3, KEY1_DEB_done
0A38 30F905     996       jnb KEY.1, KEY1_DEB_done
0A3B D20E       997       setb Key1_flag ; Suscesfully detected a valid KEY1 press/release
0A3D 756800     998       mov KEY1_DEB_state, #0  
0A40            999   KEY1_DEB_done:
0A40 22        1000       ret
0A41           1001   ; ------------------------------------------------------------------------------
0A41           1002   ; Non-blocking FSM for the one second counter
0A41           1003   ;-------------------------------------------------------------------------------
0A41           1004   SEC_FSM:
0A41 E569      1005       mov a, SEC_FSM_state
0A43           1006   SEC_FSM_state0:
0A43 B4000C    1007       cjne a, #0, SEC_FSM_state1
0A46 E567      1008       mov a, SEC_FSM_timer
0A48 B4FA4B    1009       cjne a, #250, SEC_FSM_done ; 250 ms passed?
0A4B 756700    1010       mov SEC_FSM_timer, #0
0A4E 0569      1011       inc SEC_FSM_state
0A50 8044      1012       sjmp SEC_FSM_done
0A52           1013   SEC_FSM_state1: 
0A52 B4010E    1014       cjne a, #1, SEC_FSM_state2
0A55 D2E9      1015       setb LEDRA.1
0A57 E567      1016       mov a, SEC_FSM_timer
0A59 B4FA3A    1017       cjne a, #250, SEC_FSM_done ; 250 ms passed?
0A5C 756700    1018       mov SEC_FSM_timer, #0
0A5F 0569      1019       inc SEC_FSM_state
0A61 8033      1020       sjmp SEC_FSM_done
0A63           1021   SEC_FSM_state2: 
0A63 B4020E    1022       cjne a, #2, SEC_FSM_state3
0A66 D2EA      1023       setb LEDRA.2
0A68 E567      1024       mov a, SEC_FSM_timer
0A6A B4FA29    1025       cjne a, #250, SEC_FSM_done ; 250 ms passed?
0A6D 756700    1026       mov SEC_FSM_timer, #0
0A70 0569      1027       inc SEC_FSM_state
0A72 8022      1028       sjmp SEC_FSM_done
0A74           1029   SEC_FSM_state3: 
0A74 B4031F    1030       cjne a, #3, SEC_FSM_done
0A77 D2EB      1031       setb LEDRA.3
0A79 E567      1032       mov a, SEC_FSM_timer
0A7B B4FA18    1033       cjne a, #250, SEC_FSM_done ; 250 ms passed?
0A7E 756700    1034       mov SEC_FSM_timer, #0
0A81 756900    1035       mov SEC_FSM_state, #0
0A84           1036       
0A84           1037       ; --- 1 Second has passed! ---
0A84 D202      1038       setb one_second_flag
0A86           1039       
0A86 E530      1040       mov a, current_time_sec
0A88 B43B07    1041       cjne a, #59, IncCurrentTimeSec 
0A8B           1042       
0A8B           1043       ; --- FIX: 59s -> 0s AND Increment Minute ---
0A8B 753000    1044       mov current_time_sec, #0
0A8E 0531      1045       inc current_time_minute    ; <--- YOU WERE MISSING THIS!
0A90           1046       ; -------------------------------------------
0A90           1047       
0A90 8004      1048       sjmp SEC_FSM_done
0A92           1049   
0A92           1050   IncCurrentTimeSec:
0A92 0530      1051       inc current_time_sec
0A94 B2E8      1052       cpl LEDRA.0 
0A96           1053   SEC_FSM_done:
0A96 22        1054       ret
0A97           1055   ;-------------------------------------------------------------------------------
0A97           1056   ; PWM
0A97           1057   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0A97           1058   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0A97           1059   ; ------------------------------------------------------------------------------
0A97           1060   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0A97 100302    1061       jbc one_ms_pwm_flag, pwm_wave_generator
0A9A 8071      1062       sjmp end_pwm_generator
0A9C           1063   
0A9C           1064   pwm_wave_generator:
0A9C C201      1065       clr mf
0A9E           1066       ; move pwm counter value into x for comparison purpose
0A9E 856232    1067       mov x, pwm_counter
0AA1 856333    1068       mov x+1, pwm_counter+1
0AA4 856434    1069       mov x+2, pwm_counter+2
0AA7 856535    1070       mov x+3, pwm_counter+3
0AAA           1071   
0AAA 7536DB    1072            mov y+0, #low (PWM_PERIOD % 0x10000) 
0AAD 753705    1072            mov y+1, #high(PWM_PERIOD % 0x10000) 
0AB0 753800    1072            mov y+2, #low (PWM_PERIOD / 0x10000) 
0AB3 753900    1072            mov y+3, #high(PWM_PERIOD / 0x10000) 
0AB6           1073   
0AB6           1074       ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
0AB6           1075       ; increase x by 1
0AB6 120152    1076       lcall x_eq_y 
0AB9 20011D    1077       jb mf, wrap_pwm_counter
0ABC           1078       ; x not equal 1499, increment by 1
0ABC 753601    1079            mov y+0, #low (1 % 0x10000) 
0ABF 753700    1079            mov y+1, #high(1 % 0x10000) 
0AC2 753800    1079            mov y+2, #low (1 / 0x10000) 
0AC5 753900    1079            mov y+3, #high(1 / 0x10000) 
0AC8 1200D3    1080       lcall add32
0ACB           1081       ; update pwm_counter
0ACB 853262    1082       mov pwm_counter, x
0ACE 853363    1083       mov pwm_counter+1, x+1
0AD1 853464    1084       mov pwm_counter+2, x+2
0AD4 853565    1085       mov pwm_counter+3, x+3
0AD7 8018      1086       sjmp set_pwm
0AD9           1087   
0AD9           1088   wrap_pwm_counter:
0AD9           1089       ; x equal 1499, wrap to 0
0AD9 753200    1090            mov x+0, #low (0 % 0x10000) 
0ADC 753300    1090            mov x+1, #high(0 % 0x10000) 
0ADF 753400    1090            mov x+2, #low (0 / 0x10000) 
0AE2 753500    1090            mov x+3, #high(0 / 0x10000) 
0AE5 853262    1091       mov pwm_counter, x
0AE8 853363    1092       mov pwm_counter+1, x+1
0AEB 853464    1093       mov pwm_counter+2, x+2
0AEE 853565    1094       mov pwm_counter+3, x+3
0AF1           1095   
0AF1           1096   set_pwm:
0AF1           1097       ; compare with power_output, if pwm counter smaller than power_output, 
0AF1           1098       ; set pwm pin high; else set pwm pin low load y with power output value
0AF1 855E36    1099       mov y, power_output
0AF4 855F37    1100       mov y+1, power_output+1
0AF7 856038    1101       mov y+2, power_output+2
0AFA 856139    1102       mov y+3, power_output+3
0AFD           1103   
0AFD           1104       ; compare x(pwm counter) with y(power output)
0AFD 12011A    1105       lcall x_lt_y
0B00 200106    1106       jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
0B03           1107       ;output set pwm pin low if pwm counter greater than power output
0B03 C293      1108       clr PWM_OUT
0B05 C2EC      1109       clr LEDRA.4
0B07 8004      1110       sjmp end_pwm_generator
0B09           1111   
0B09           1112   set_pwm_high:
0B09 D293      1113       setb PWM_OUT
0B0B D2EC      1114       setb LEDRA.4
0B0D           1115   
0B0D           1116   end_pwm_generator:
0B0D 22        1117       ret
0B0E           1118   
0B0E           1119   ;-------------------------------------------------------------------------------;
0B0E           1120   ; Temp_Compare
0B0E           1121   ; Checks if we have reached the user's target temperatures.
0B0E           1122   ; Sets 'soak_temp_reached' if current_temp >= soak_temp
0B0E           1123   ; Sets 'reflow_temp_reached' if current_temp >= reflow_temp
0B0E           1124   ;-------------------------------------------------------------------------------;
0B0E           1125   Temp_Compare:
0B0E           1126       ; Reset flags initially
0B0E C204      1127       clr soak_temp_reached
0B10 C205      1128       clr reflow_temp_reached
0B12           1129   
0B12 C0E0      1130       push acc
0B14 C0D0      1131       push psw
0B16 C000      1132       push AR0
0B18 C001      1133       push AR1
0B1A C002      1134       push AR2
0B1C           1135       
0B1C           1136       ; --- 1. CHECK SOAK TEMP ---
0B1C           1137       ; Copy current_temp to X
0B1C 7841      1138       mov R0, #current_temp
0B1E 7932      1139       mov R1, #x
0B20 120B94    1140       lcall Copy4_Bytes_R0_to_R1
0B23           1141   
0B23           1142       ; Copy soak_temp to Y
0B23 7845      1143       mov R0, #soak_temp
0B25 7936      1144       mov R1, #y
0B27 120B94    1145       lcall Copy4_Bytes_R0_to_R1
0B2A           1146   
0B2A           1147       ; Compare: Is X (Current) < Y (Target)?
0B2A 12011A    1148       lcall x_lt_y
0B2D 200102    1149       jb mf, Check_Reflow_Threshold ; If Current < Target, jump (Flag stays 0)
0B30           1150       
0B30           1151       ; If we are here, Current >= Target
0B30 D204      1152       setb soak_temp_reached
0B32           1153   
0B32           1154   Check_Reflow_Threshold:
0B32           1155       ; --- 2. CHECK REFLOW TEMP ---
0B32           1156       ; Copy current_temp to X (Need to reload X because math32 destroys it)
0B32 7841      1157       mov R0, #current_temp
0B34 7932      1158       mov R1, #x
0B36 120B94    1159       lcall Copy4_Bytes_R0_to_R1
0B39           1160   
0B39           1161       ; Copy reflow_temp to Y
0B39 7849      1162       mov R0, #reflow_temp
0B3B 7936      1163       mov R1, #y
0B3D 120B94    1164       lcall Copy4_Bytes_R0_to_R1
0B40           1165   
0B40           1166       ; Compare
0B40 12011A    1167       lcall x_lt_y
0B43 200102    1168       jb mf, Temp_Compare_Done
0B46           1169       
0B46           1170       ; If Current >= Target
0B46 D205      1171       setb reflow_temp_reached
0B48           1172   
0B48           1173   Temp_Compare_Done:
0B48 D002      1174       pop AR2
0B4A D001      1175       pop AR1
0B4C D000      1176       pop AR0
0B4E D0D0      1177       pop psw
0B50 D0E0      1178       pop acc
0B52 22        1179       ret
0B53           1180   ;-------------------------------------------------------------------------------;
0B53           1181   ; Time_Compare
0B53           1182   ;
0B53           1183   ; PURPOSE:
0B53           1184   ;   Compare the elapsed time against soak and reflow
0B53           1185   ;   time limits.
0B53           1186   ;
0B53           1187   ; BEHAVIOR:
0B53           1188   ;   - If current_time >= soak_time   if soak_time_reached    = 1
0B53           1189   ;   - If current_time >= reflow_time if reflow_time_reached = 1
0B53           1190   ;
0B53           1191   ; NOTES:
0B53           1192   ;   - Time values are treated as 32-bit UNSIGNED numbers
0B53           1193   ;     (e.g., milliseconds or seconds).
0B53           1194   ;   - Uses the SAME compare logic as Temp_Compare.
0B53           1195   ;   - This routine ONLY SETS flags.
0B53           1196   ;
0B53           1197   ; EXPECTED VARIABLES:
0B53           1198   ;   current_time[4], soak_time[4], reflow_time[4]
0B53           1199   ;   x[4], y[4]
0B53           1200   ;   mf, soak_time_reached, reflow_time_reached
0B53           1201   ;-------------------------------------------------------------------------------;
0B53           1202   Time_Compare:
0B53 C0E0      1203       push acc
0B55 C0D0      1204       push psw
0B57 C000      1205       push AR0
0B59 C001      1206       push AR1
0B5B C002      1207       push AR2
0B5D           1208   
0B5D           1209   ; Check: current_time >= soak_time ?
0B5D           1210       ; Copy current_time of x
0B5D 7852      1211       mov  R0, #current_time
0B5F 7932      1212       mov  R1, #x
0B61 120B94    1213       lcall Copy4_Bytes_R0_to_R1
0B64           1214   
0B64           1215       ; Copy soak_time of y
0B64 7856      1216       mov  R0, #soak_time
0B66 7936      1217       mov  R1, #y
0B68 120B94    1218       lcall Copy4_Bytes_R0_to_R1
0B6B           1219   
0B6B           1220       ; Compare elapsed time vs soak time
0B6B 12011A    1221       lcall x_lt_y
0B6E 200102    1222       jb   mf, Time_Soak_NotReached
0B71 D207      1223       setb soak_time_reached
0B73           1224   
0B73           1225   ; Check: current_time >= reflow_time ?
0B73           1226   Time_Soak_NotReached:
0B73           1227       ; Copy current_time of x
0B73 7852      1228       mov  R0, #current_time
0B75 7932      1229       mov  R1, #x
0B77 120B94    1230       lcall Copy4_Bytes_R0_to_R1
0B7A           1231   
0B7A           1232       ; Copy reflow_time of y
0B7A 785A      1233       mov  R0, #reflow_time
0B7C 7936      1234       mov  R1, #y
0B7E 120B94    1235       lcall Copy4_Bytes_R0_to_R1
0B81           1236   
0B81           1237       ; Compare elapsed time vs reflow time
0B81 12011A    1238       lcall x_lt_y
0B84 200102    1239       jb   mf, Time_Reflow_NotReached
0B87 D208      1240       setb reflow_time_reached
0B89           1241   
0B89           1242   Time_Reflow_NotReached:
0B89 D002      1243       pop  AR2
0B8B D001      1244       pop  AR1
0B8D D000      1245       pop  AR0
0B8F D0D0      1246       pop  psw
0B91 D0E0      1247       pop  acc
0B93 22        1248       ret
0B94           1249   
0B94           1250   ;-------------------------------------------------------------------------------;
0B94           1251   ; Copy4_Bytes_R0_to_R1
0B94           1252   ;
0B94           1253   ; PURPOSE:
0B94           1254   ;   Utility routine to copy a 32-bit value (4 bytes)
0B94           1255   ;   from one memory location to another.
0B94           1256   ;
0B94           1257   ; INPUTS:
0B94           1258   ;   R0 st source address
0B94           1259   ;   R1 at destination address
0B94           1260   ;
0B94           1261   ; USES:
0B94           1262   ;   R2 as loop counter
0B94           1263   ;
0B94           1264   ; EXAMPLE:
0B94           1265   ;   mov R0, #current_temp
0B94           1266   ;   mov R1, #x
0B94           1267   ;   lcall Copy4_Bytes_R0_to_R1
0B94           1268   ;-------------------------------------------------------------------------------;
0B94           1269   Copy4_Bytes_R0_to_R1:
0B94 7A04      1270       mov  R2, #4
0B96           1271   Copy4_Loop:
0B96 E6        1272       mov  a, @R0
0B97 F7        1273       mov  @R1, a
0B98 08        1274       inc  R0
0B99 09        1275       inc  R1
0B9A DAFA      1276       djnz R2, Copy4_Loop
0B9C 22        1277       ret
0B9D           1278   
0B9D           1279   ;-------------------------------------------------------------------------------;
0B9D           1280   ; Abort condition safety check Temperature time
0B9D           1281   ;
0B9D           1282   ; PURPOSE:
0B9D           1283   ;   Automatic cycle termination on error:
0B9D           1284   ;   Abort if oven fails to reach at least 50C in first 60s.
0B9D           1285   ;
0B9D           1286   ; TRIP CONDITION:
0B9D           1287   ;   if (current_time >= 60s) AND (current_temp < 50C)
0B9D           1288   ;       -> set tc_missing_abort
0B9D           1289   ;       -> set stop_signal
0B9D           1290   ;
0B9D           1291   ; ASSUMPTIONS:
0B9D           1292   ;   - current_time is in SECONDS (32-bit, little-endian)
0B9D           1293   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
0B9D           1294   ;
0B9D           1295   ;   the Load_Y constants accordingly.
0B9D           1296   ;-------------------------------------------------------------------------------;
0B9D           1297   Safety_Check_TC:
0B9D C0E0      1298       push acc
0B9F C0D0      1299       push psw
0BA1 C000      1300       push AR0
0BA3 C001      1301       push AR1
0BA5 C002      1302       push AR2
0BA7           1303   
0BA7           1304       ; ---------------------------------------------------------
0BA7           1305       ; [FIX] GATEKEEPER: IGNORE UNLESS IN STATE 2 (RAMP TO SOAK)
0BA7           1306       ; ---------------------------------------------------------
0BA7 E56A      1307       mov a, Control_FSM_state
0BA9 B40202    1308       cjne a, #2, Safety_TC_Exit_Bridge ; If State != 2, skip everything
0BAC 8003      1309       sjmp Safety_Logic_Proceed         ; If State == 2, do the check
0BAE           1310   
0BAE           1311       Safety_TC_Exit_Bridge:
0BAE 020BFC    1312           ljmp Safety_TC_Done               ; Jump to the end
0BB1           1313   
0BB1           1314       Safety_Logic_Proceed:
0BB1           1315           ; If already aborted or startup window closed, do nothing
0BB1 200F48    1316           jb   tc_missing_abort, Safety_TC_Done
0BB4 301045    1317           jnb  tc_startup_window, Safety_TC_Done
0BB7           1318   
0BB7           1319       ; Check: current_time >= 60 ?
0BB7 7852      1320       mov  R0, #current_time
0BB9 7932      1321       mov  R1, #x
0BBB 120B94    1322       lcall Copy4_Bytes_R0_to_R1
0BBE           1323   
0BBE 75363C    1324            mov y+0, #low (60 % 0x10000) 
0BC1 753700    1324            mov y+1, #high(60 % 0x10000) 
0BC4 753800    1324            mov y+2, #low (60 / 0x10000) 
0BC7 753900    1324            mov y+3, #high(60 / 0x10000) 
0BCA 12011A    1325       lcall x_lt_y
0BCD 2001DE    1326       jb   mf, Safety_TC_Exit_Bridge        ; still < 60s ? keep waiting
0BD0           1327   
0BD0           1328       ; We reached 60s: close the startup window so it won't re-check later
0BD0 C210      1329       clr  tc_startup_window
0BD2           1330   
0BD2           1331       ; Now check: current_temp < 50 ?
0BD2 7841      1332       mov  R0, #current_temp
0BD4 7932      1333       mov  R1, #x
0BD6 120B94    1334       lcall Copy4_Bytes_R0_to_R1
0BD9           1335   
0BD9 753632    1336            mov y+0, #low (50 % 0x10000) 
0BDC 753700    1336            mov y+1, #high(50 % 0x10000) 
0BDF 753800    1336            mov y+2, #low (50 / 0x10000) 
0BE2 753900    1336            mov y+3, #high(50 / 0x10000) 
0BE5 12011A    1337       lcall x_lt_y
0BE8 3001C3    1338       jnb  mf, Safety_TC_Exit_Bridge        ; temp >= 50 ? pass
0BEB           1339   
0BEB           1340       ; FAIL: at 60s, still below 50C ? abort
0BEB C293      1341       clr  PWM_OUT
0BED D20F      1342       setb tc_missing_abort
0BEF D20A      1343       setb stop_signal
0BF1 120C11    1344            lcall Beep_Ten
0BF4           1345       ; 3. Force FSM to State 0 (Welcome)
0BF4 756A00    1346       mov Control_FSM_state, #0
0BF7           1347       
0BF7           1348       ; 4. Force UI to State 0 (Home Screen)
0BF7 756B00    1349       mov Current_State, #0
0BFA           1350       
0BFA           1351       ; 5. Trigger Screen Refresh
0BFA D20D      1352       setb state_change_signal ; Tell loop to redraw "Welcome"
0BFC           1353   
0BFC           1354   Safety_TC_Done:
0BFC D002      1355       pop  AR2
0BFE D001      1356       pop  AR1
0C00 D000      1357       pop  AR0
0C02 D0D0      1358       pop  psw
0C04 D0E0      1359       pop  acc
0C06 22        1360       ret
0C07           1361   
0C07           1362   ; ============================================================
0C07           1363   ; BUZZER STARTUP FUNCTIONS
0C07           1364   ; ============================================================
0C07           1365   
0C07           1366   Beep_Once:
0C07 757501    1367       mov beep_count, #1
0C0A 800A      1368       sjmp Beep_Start
0C0C           1369   
0C0C           1370   Beep_Five:
0C0C 757505    1371       mov beep_count, #5
0C0F 8005      1372       sjmp Beep_Start
0C11           1373   
0C11           1374   Beep_Ten:
0C11 75750A    1375       mov beep_count, #10
0C14 8000      1376       sjmp Beep_Start      ; [FIX] Added explicit jump for safety
0C16           1377   
0C16           1378   Beep_Start:
0C16 C28C      1379       clr TR0              ; [FIX] Stop timer briefly to reset cleanly
0C18 757601    1380       mov beep_state, #1   ; Set State to ON
0C1B 757700    1381       mov beep_tmr, #0     ; Reset Timer High Byte
0C1E 757800    1382       mov beep_tmr+1, #0   ; Reset Timer Low Byte
0C21 D2A9      1383       setb ET0             ; [FIX] Ensure Interrupt is enabled
0C23 D28C      1384       setb TR0             ; START the 2kHz tone
0C25 22        1385       ret
0C26           1386   ;============================================================
0C26           1387   
0C26           1388   ;============================================================
0C26           1389   ; Buzzer beep Task 
0C26           1390   ; Purpose: beeps, holds, stop
0C26           1391   ; Buzzer task:
0C26           1392   ; Beep once when state changes
0C26           1393   ; Beep five times if finished
0C26           1394   ; Beep ten times if meets error
0C26           1395   ;============================================================
0C26           1396   
0C26           1397   Beep_Task:
0C26 301435    1398       jnb one_ms_beep_flag, Beep_Done
0C29 C214      1399       clr one_ms_beep_flag
0C2B           1400   
0C2B E576      1401       mov a, beep_state
0C2D 602F      1402       jz Beep_Done
0C2F           1403   
0C2F           1404   ; ---- increment 16-bit timer ----
0C2F 0577      1405       inc beep_tmr
0C31 E577      1406       mov a, beep_tmr
0C33 7002      1407       jnz Beep_Check
0C35 0578      1408       inc beep_tmr+1
0C37           1409   
0C37           1410   Beep_Check:
0C37           1411       ; [FIX] FUZZY TIMER CHECK
0C37           1412       ; Check if High Byte is non-zero (Time >= 256ms)
0C37 E578      1413       mov a, beep_tmr+1
0C39 6023      1414       jz Beep_Done        ; If 0, keep beeping
0C3B           1415   
0C3B           1416       ; --- Time Limit Reached ---
0C3B 757700    1417       mov beep_tmr, #0    ; Reset timer
0C3E 757800    1418       mov beep_tmr+1, #0
0C41           1419   
0C41 E576      1420       mov a, beep_state
0C43 B40106    1421       cjne a, #1, Beep_Off_State
0C46           1422   
0C46           1423       ; State was 1 (ON) -> Turn OFF
0C46 C28C      1424       clr TR0             ; Hardware Silence
0C48 757602    1425       mov beep_state, #2  ; Set State to OFF (Pause)
0C4B 22        1426       ret
0C4C           1427   
0C4C           1428   Beep_Off_State:
0C4C           1429   ; ---- OFF finished -> decrement count / next ON ----
0C4C 1575      1430       dec beep_count
0C4E E575      1431       mov a, beep_count
0C50 6006      1432       jz  Beep_Stop
0C52           1433   
0C52 757601    1434       mov beep_state, #1
0C55 D28C      1435       setb TR0
0C57 22        1436       ret
0C58           1437   
0C58           1438   Beep_Stop:
0C58 C28C      1439       clr TR0
0C5A 757600    1440       mov beep_state, #0
0C5D 22        1441       ret
0C5E           1442   
0C5E           1443   Beep_Done:
0C5E 22        1444       ret
0C5F           1445   ;==================================================================
0C5F           1446   
0C5F           1447   ;-------------------------------------------------------------------------------;
0C5F           1448   ; Main Control FSM for the entire process
0C5F           1449   ;-------------------------------------------------------------------------------;
0C5F           1450   ;-------------------------------------------------------------------------------;
0C5F           1451   ; FSM LOGIC (Button Logic Fixed)
0C5F           1452   ;-------------------------------------------------------------------------------;
0C5F           1453   Control_FSM:
0C5F E56A      1454       mov a, Control_FSM_state
0C61 8005      1455       sjmp Control_FSM_state0
0C63           1456   
0C63           1457   Control_FSM_state0_a:
0C63 756A00    1458       mov Control_FSM_state, #0
0C66 D20D      1459       setb state_change_signal
0C68           1460            
0C68           1461   Control_FSM_state0:
0C68 B40015    1462       cjne a, #0, Control_FSM_state1
0C6B 209005    1463       jb P1.0, Control_FSM_done_bridge ; If Button High (Not Pressed), Exit
0C6E 1211CE    1464       lcall Wait_For_P1_0_Release      ; If Low (Pressed), Wait & Proceed
0C71 8001      1465       sjmp Control_FSM_state1_a  
0C73           1466       
0C73           1467   Control_FSM_done_bridge:
0C73 22        1468       ret
0C74           1469   
0C74           1470   Control_FSM_state1_a:
0C74 056A      1471       inc Control_FSM_state
0C76 756B00    1472       mov Current_State, #0
0C79 1210AC    1473       lcall Update_Screen_Full 
0C7C D20D      1474       setb state_change_signal
0C7E E56A      1475       mov a, Control_FSM_state
0C80           1476       
0C80           1477   Control_FSM_state1:
0C80 B40127    1478       cjne a, #1, Control_FSM_state2
0C83 120EE4    1479       lcall Check_Buttons 
0C86 120F30    1480       lcall Check_Keypad
0C89           1481       
0C89           1482       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
0C89 209008    1483       jb P1.0, Control_FSM_state1_ret
0C8C           1484       
0C8C           1485       ; If we get here, Button is LOW (Pressed)
0C8C 1211CE    1486       lcall Wait_For_P1_0_Release
0C8F 120E68    1487       lcall Update_FSM_Variables
0C92 8001      1488       sjmp Control_FSM_state2_a
0C94           1489   Control_FSM_state1_ret:
0C94 22        1490       ret
0C95           1491   
0C95           1492   ; --- STATE 2: RAMP TO SOAK ---
0C95           1493   Control_FSM_state2_a:
0C95 056A      1494       inc Control_FSM_state
0C97 E56A      1495       mov a, Control_FSM_state   ; [FIX] RELOAD 'A' so it matches the new state!
0C99 D20D      1496       setb state_change_signal
0C9B 120C07    1497       lcall Beep_Once
0C9E           1498   
0C9E D210      1499       setb tc_startup_window    ; OPEN the safety window
0CA0 C20F      1500       clr tc_missing_abort      ; Clear any previous aborts
0CA2 753000    1501       mov current_time_sec, #0  ; Reset Seconds to 0
0CA5 753100    1502       mov current_time_minute, #0 ; Reset Minutes to 0
0CA8           1503       
0CA8           1504       ; [FIX] CLEAR FLAG ON ENTRY
0CA8           1505       ; Force the system to wait for at least one fresh temp reading
0CA8           1506       ; before deciding we are done.
0CA8 C204      1507       clr soak_temp_reached      
0CAA           1508   
0CAA           1509   Control_FSM_state2:
0CAA B4021F    1510       cjne a, #2, Control_FSM_state3
0CAD 301305    1511       jnb PB2_flag, State2_Check
0CB0 C213      1512       clr PB2_flag
0CB2 020D1D    1513       ljmp Control_FSM_state6_a ; Pause
0CB5           1514   
0CB5           1515   State2_Check:
0CB5 300413    1516       jnb soak_temp_reached, State2_Ret
0CB8           1517       
0CB8           1518       ; --- We reached Temp! Move to State 3 ---
0CB8 C204      1519       clr soak_temp_reached
0CBA 056A      1520       inc Control_FSM_state
0CBC           1521       
0CBC           1522       ; [FIX] RELOAD 'A' (Good practice)
0CBC E56A      1523       mov a, Control_FSM_state   
0CBE           1524       
0CBE D20D      1525       setb state_change_signal
0CC0 120C07    1526       lcall Beep_Once
0CC3           1527       
0CC3 753000    1528       mov current_time_sec, #0
0CC6 753100    1529       mov current_time_minute, #0
0CC9           1530       
0CC9           1531       ; Ensure we start State 3 fresh
0CC9 C207      1532       clr soak_time_reached 
0CCB           1533   
0CCB           1534   State2_Ret:
0CCB 22        1535       ret
0CCC           1536   
0CCC           1537   ; --- STATE 3: SOAK PHASE ---
0CCC           1538   Control_FSM_state3:
0CCC B40315    1539       cjne a, #3, Control_FSM_state4
0CCF 301305    1540       jnb PB2_flag, State3_Check
0CD2 C213      1541       clr PB2_flag
0CD4 020D1D    1542       ljmp Control_FSM_state6_a
0CD7           1543   State3_Check:
0CD7 300709    1544       jnb soak_time_reached, State3_Ret
0CDA C207      1545       clr soak_time_reached
0CDC 056A      1546       inc Control_FSM_state      
0CDE D20D      1547       setb state_change_signal 
0CE0 120C07    1548            lcall Beep_Once
0CE3           1549   State3_Ret:
0CE3 22        1550       ret
0CE4           1551   
0CE4           1552   ; --- STATE 4: RAMP TO PEAK ---
0CE4           1553   Control_FSM_state4:
0CE4 B4041D    1554       cjne a, #4, Control_FSM_state5
0CE7 301305    1555       jnb PB2_flag, State4_Check
0CEA C213      1556       clr PB2_flag
0CEC 020D1D    1557       ljmp Control_FSM_state6_a
0CEF           1558   State4_Check:
0CEF 300511    1559       jnb reflow_temp_reached, State4_Ret
0CF2 C205      1560       clr reflow_temp_reached
0CF4 056A      1561       inc Control_FSM_state
0CF6 D20D      1562       setb state_change_signal
0CF8 120C07    1563            lcall Beep_Once
0CFB 753000    1564       mov current_time_sec, #0
0CFE 753100    1565       mov current_time_minute, #0
0D01           1566       ; --- ADD THIS LINE ---
0D01 C208      1567       clr reflow_time_reached ; Kill the ghost flag
0D03           1568       ; ---------------------
0D03           1569   State4_Ret:
0D03 22        1570       ret
0D04           1571   
0D04           1572   ; --- STATE 5: REFLOW PHASE ---
0D04           1573   Control_FSM_state5:
0D04 B40502    1574       cjne a, #5, Control_FSM_state6_trampoline
0D07 8003      1575       sjmp State5_Logic
0D09           1576   Control_FSM_state6_trampoline:
0D09 020D24    1577       ljmp Control_FSM_state6
0D0C           1578   
0D0C           1579   State5_Logic:
0D0C 301305    1580       jnb PB2_flag, State5_Check
0D0F C213      1581       clr PB2_flag
0D11 020D1D    1582       ljmp Control_FSM_state6_a
0D14           1583   State5_Check:
0D14 300805    1584       jnb reflow_time_reached, State5_Ret
0D17 C208      1585       clr reflow_time_reached
0D19 020D1D    1586       ljmp Control_FSM_state6_a
0D1C           1587   State5_Ret:
0D1C 22        1588       ret
0D1D           1589   
0D1D           1590   ; --- STATE 6: COOLING ---
0D1D           1591   Control_FSM_state6_a:
0D1D 056A      1592       inc Control_FSM_state
0D1F D20D      1593       setb state_change_signal
0D21 120C0C    1594            lcall Beep_Five
0D24           1595   Control_FSM_state6:
0D24 B4060A    1596       cjne a, #6, Control_FSM_state7
0D27           1597       ; Wait for Cooling Temp Reached
0D27 300606    1598       jnb cooling_temp_reached, State6_Ret
0D2A C206      1599       clr cooling_temp_reached
0D2C 056A      1600       inc Control_FSM_state
0D2E D20D      1601       setb state_change_signal
0D30           1602   State6_Ret:
0D30 22        1603       ret
0D31           1604   
0D31           1605   ; --- STATE 7: DONE ---
0D31           1606   Control_FSM_state7:
0D31 B40711    1607       cjne a, #7, Control_FSM_done
0D34           1608       
0D34           1609       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
0D34 201109    1610       jb PB0_flag, Control_FSM_Reset_Logic ; Wait, PB0_flag is software flag?
0D37           1611       
0D37           1612       ; Let's assume you meant the physical button P1.0 like State 0
0D37 20900B    1613       jb P1.0, Control_FSM_done
0D3A           1614       
0D3A 1211CE    1615       lcall Wait_For_P1_0_Release
0D3D 020C63    1616       ljmp Control_FSM_state0_a
0D40           1617   
0D40           1618   Control_FSM_Reset_Logic:
0D40           1619       ; If using PB0_flag from ISR, handle here
0D40 C211      1620       clr PB0_flag
0D42 020C63    1621       ljmp Control_FSM_state0_a
0D45           1622   
0D45           1623   Control_FSM_done:
0D45 22        1624       ret
0D46           1625   ;-------------------------------------------------------------------------------;
0D46           1626   ;         Main program.          
0D46           1627   ;-------------------------------------------------------------------------------;
0D46           1628   main:
0D46           1629   
0D46           1630       ; --------------------------------------------------------
0D46           1631       ; 1. SAFETY SHUTDOWN
0D46           1632       ; --------------------------------------------------------
0D46 C2AF      1633       clr EA              ; FORCE Interrupts OFF immediately
0D48 7581C0    1634       mov SP, #0xC0       ; Reset Stack Pointer to safe location
0D4B           1635       
0D4B           1636       ; --------------------------------------------------------
0D4B           1637       ; 2. THE "DIRTY DELAY" (Fixes Reset Garbage)
0D4B           1638       ; We burn ~100ms here using a raw loop. 
0D4B           1639       ; We cannot use timers yet because they aren't initialized.
0D4B           1640       ; --------------------------------------------------------
0D4B 78FA      1641       mov R0, #250
0D4D           1642   Reset_Delay_Outer:
0D4D 79FF      1643       mov R1, #255
0D4F           1644   Reset_Delay_Inner:
0D4F D9FE      1645       djnz R1, Reset_Delay_Inner
0D51 D8FA      1646       djnz R0, Reset_Delay_Outer
0D53           1647       ; --------------------------------------------------------
0D53           1648   
0D53           1649       ; ... NOW continue with your normal Port Configuration ...
0D53           1650       
0D53           1651       ; --- PORT CONFIGURATION ---
0D53 759AAA    1652       mov P0MOD, #0xAA
0D56           1653   
0D56           1654       ; P1: Mixed usage 
0D56           1655       ; P1.7(LCD_RS), P1.6(Row3), P1.5(Sound), P1.4(Row2)
0D56           1656       ; P1.3(PWM), P1.2(Row1), P1.1(LCD_E) -> All Outputs
0D56           1657       ; P1.0 (Unused/RX) -> Input
0D56           1658       ; Binary: 11111110 -> Hex: 0xFE
0D56 759BFE    1659       mov P1MOD, #0xFE
0D59           1660   
0D59           1661       ; P2: Row4(Out), Cols(In)
0D59           1662       ; P2.0 (Row4) is Out (1). P2.2, P2.4, P2.6 (Cols) are In (0).
0D59           1663       ; Binary: 00000001 -> Hex: 0x01
0D59 759C01    1664       mov P2MOD, #0x01
0D5C           1665   
0D5C           1666       ; P3: Col4(In)
0D5C           1667       ; P3.0 (Col4) is In (0).
0D5C 759D40    1668       mov P3MOD, #01000000B
0D5F           1669       ; Turn off all the LEDs
0D5F 75E800    1670       mov LEDRA, #0 ; LEDRA is bit addressable
0D62 759500    1671       mov LEDRB, #0 ; LEDRB is NOT bit addresable
0D65           1672   
0D65           1673       ; Enable Global interrupts
0D65 D2AF      1674       setb EA  
0D67           1675   
0D67           1676       ; FSM initial states
0D67 756800    1677       mov KEY1_DEB_state, #0
0D6A 756900    1678       mov SEC_FSM_state, #0
0D6D 756A00    1679       mov Control_FSM_state, #0
0D70 756B00    1680       mov Current_State, #0
0D73           1681       
0D73           1682       ; FSM timers initialization
0D73 756600    1683       mov KEY1_DEB_timer, #0
0D76 756700    1684       mov SEC_FSM_timer, #0
0D79           1685       ; time counters initialization
0D79 753000    1686       mov current_time_sec, #0
0D7C 753100    1687       mov current_time_minute, #0
0D7F           1688       ; Initialize counter to zero
0D7F 756200    1689       mov pwm_counter, #0
0D82 756300    1690       mov pwm_counter+1, #0
0D85 756400    1691       mov pwm_counter+2, #0
0D88 756500    1692       mov pwm_counter+3, #0
0D8B           1693       ; Initialize power output
0D8B 756100    1694       mov power_output+3, #0
0D8E 756000    1695       mov power_output+2, #0
0D91 755F02    1696       mov power_output+1, #02H
0D94 755EEE    1697       mov power_output, #0EEH ; (initilize to 750 for testing)
0D97           1698   
0D97           1699       ; Clear all the flags
0D97 C20F      1700       clr  tc_missing_abort
0D99 C20A      1701       clr  stop_signal
0D9B C211      1702       clr PB0_flag
0D9D C212      1703       clr PB1_flag
0D9F C213      1704       clr PB2_flag
0DA1 C202      1705       clr one_second_flag
0DA3 C20C      1706       clr config_finish_signal
0DA5 C204      1707       clr soak_temp_reached
0DA7 C207      1708       clr soak_time_reached
0DA9 C205      1709       clr reflow_temp_reached
0DAB C208      1710       clr reflow_time_reached
0DAD C206      1711       clr cooling_temp_reached
0DAF C20D      1712       clr state_change_signal
0DB1 C21F      1713       clr one_millisecond_flag_servo
0DB3 C200      1714       clr remote_config_mode
0DB5           1715       
0DB5 D20D      1716       setb state_change_signal
0DB7           1717   
0DB7           1718       ; Set bit
0DB7 D210      1719       setb tc_startup_window
0DB9           1720   
0DB9           1721       ; --------------------------------------
0DB9           1722       ; [FIX] ADD THIS BLOCK TO STOP STARTUP BEEP
0DB9           1723       ; --------------------------------------
0DB9 757600    1724       mov beep_state, #0
0DBC 757500    1725       mov beep_count, #0
0DBF 757700    1726       mov beep_tmr, #0
0DC2 757800    1727       mov beep_tmr+1, #0
0DC5 C214      1728       clr one_ms_beep_flag
0DC7 C28C      1729       clr TR0              ; Force buzzer hardware OFF
0DC9           1730       ; --------------------------------------
0DC9           1731   
0DC9           1732   
0DC9 12045D    1733       lcall Timer0_Init
0DCC 12069D    1734       lcall Timer2_Init
0DCF 12076A    1735       lcall ELCD_4BIT
0DD2           1736       ;----- Two new lines I added to initialize the UI
0DD2 121059    1737       lcall Init_All_Buffers
0DD5 1210AC    1738       lcall Update_Screen_Full
0DD8           1739       ;-----
0DD8 120477    1740       lcall Initialize_Serial_Port
0DDB 753F00    1741       mov rx_idx, #0
0DDE 754000    1742       mov rx_ready, #0
0DE1           1743   
0DE1           1744   ;-------------------------------------------------------------------------------;
0DE1           1745   ; while(1) loop
0DE1           1746   ;-------------------------------------------------------------------------------;
0DE1           1747   loop:
0DE1           1748       ; ALWAYS: keep serial alive so PC can send config
0DE1 1204AC    1749       lcall Serial_RX_Pump
0DE4 120505    1750       lcall Serial_Process_Line
0DE7           1751   
0DE7           1752       ; Full reset button on P3.7 (active-low to GND)
0DE7 30B702    1753        jnb P3_7, Full_Reset_Trig
0DEA 8003      1754       sjmp Full_Reset_Check_Done
0DEC           1755   
0DEC           1756   Full_Reset_Trig:
0DEC 0211D6    1757       ljmp Full_Reset
0DEF           1758   
0DEF           1759   Full_Reset_Check_Done:
0DEF           1760   
0DEF           1761       ; =========================================================
0DEF           1762       ; FREEZE CONTROL LOGIC DURING REMOTE CONFIG
0DEF           1763       ; (prevents speaker, FSM jumps, timers, etc.)
0DEF           1764       ; =========================================================
0DEF           1765       ; jb remote_config_mode, Remote_Config_Loop
0DEF           1766   
0DEF           1767       ; ---------------------------------------------------------
0DEF           1768       ; NORMAL RUN LOGIC
0DEF           1769       ; ---------------------------------------------------------
0DEF           1770   
0DEF           1771       ; Check the FSM for KEY1 debounce
0DEF 120A0B    1772       lcall KEY1_DEB
0DF2           1773   
0DF2           1774       ; Take temp readings
0DF2 1211DC    1775       lcall Read_Thermocouple
0DF5           1776   
0DF5           1777       ; 1. Check if we reached temp (Observer)
0DF5 120B0E    1778       lcall Temp_Compare
0DF8           1779   
0DF8           1780       ; 2. Decide heater power based on flags (Driver)
0DF8 12131E    1781       lcall proportional_power_control
0DFB           1782   
0DFB           1783       ; 3. Calculate Total Seconds (Minutes * 60 + Seconds)
0DFB 853132    1784       mov x+0, current_time_minute
0DFE 753300    1785       mov x+1, #0
0E01 753400    1786       mov x+2, #0
0E04 753500    1787       mov x+3, #0
0E07           1788   
0E07 75363C    1789            mov y+0, #low (60 % 0x10000) 
0E0A 753700    1789            mov y+1, #high(60 % 0x10000) 
0E0D 753800    1789            mov y+2, #low (60 / 0x10000) 
0E10 753900    1789            mov y+3, #high(60 / 0x10000) 
0E13 12018C    1790       lcall mul32
0E16           1791   
0E16 853036    1792       mov y+0, current_time_sec
0E19 753700    1793       mov y+1, #0
0E1C 753800    1794       mov y+2, #0
0E1F 753900    1795       mov y+3, #0
0E22           1796   
0E22 1200D3    1797       lcall add32
0E25           1798   
0E25 853252    1799       mov current_time+0, x+0
0E28 853353    1800       mov current_time+1, x+1
0E2B 853454    1801       mov current_time+2, x+2
0E2E 853555    1802       mov current_time+3, x+3
0E31           1803   
0E31 120B53    1804       lcall Time_Compare
0E34 120B9D    1805       lcall Safety_Check_TC
0E37           1806   
0E37           1807       ; one-second counter
0E37 120A41    1808       lcall SEC_FSM
0E3A           1809   
0E3A           1810       ; overall FSM
0E3A 120C5F    1811       lcall Control_FSM
0E3D           1812   
0E3D           1813       ; LCD update (normal)
0E3D 12082F    1814       lcall LCD_Display_Update_func
0E40           1815   
0E40           1816       ; buzzer tick sync
0E40 300302    1817       jnb one_ms_pwm_flag, Skip_Beep_Sync
0E43 D214      1818       setb one_ms_beep_flag
0E45           1819   
0E45           1820   Skip_Beep_Sync:
0E45           1821       ; heater PWM
0E45 120A97    1822       lcall PWM_Wave
0E48           1823   
0E48           1824       ; buzzer
0E48 120C26    1825       lcall Beep_Task
0E4B           1826   
0E4B           1827       ; servo
0E4B 1212B1    1828       lcall call_servo_control
0E4E           1829   
0E4E 020DE1    1830       ljmp loop
0E51           1831   
0E51           1832   
0E51           1833   Remote_Config_Loop:
0E51           1834       ; silence outputs
0E51 C28C      1835       clr TR0
0E53 C293      1836       clr PWM_OUT
0E55           1837   
0E55           1838       ; still allow UI navigation / redraw
0E55 120EE4    1839       lcall Check_Buttons
0E58 120F30    1840       lcall Check_Keypad
0E5B           1841       ; Only redraw when something changed (optional but recommended)
0E5B 200D02    1842       jb state_change_signal, RC_REDRAW
0E5E 8005      1843       sjmp RC_DONE
0E60           1844   RC_REDRAW:
0E60 C20D      1845       clr state_change_signal
0E62 1210AC    1846       lcall Update_Screen_Full
0E65           1847   RC_DONE:
0E65 020DE1    1848       ljmp loop
0E68           1849   
0E68           1850   ;-------------------------------------------------------------------------------;
0E68           1851   
0E68           1852   ; ================================================================
0E68           1853   ; UI & HELPER SUBROUTINES
0E68           1854   ; ================================================================
0E68           1855   
0E68           1856   ; ----------------------------------------------------------------
0E68           1857   ; MODULE: BRIDGE (Text to Integer Conversion)
0E68           1858   ; ----------------------------------------------------------------
0E68           1859   Update_FSM_Variables:
0E68           1860       ; --- 1. SOAK TEMP ---
0E68 7880      1861       mov R0, #Buf_Soak_Temp
0E6A 120EA7    1862       lcall Parse_Temp_String
0E6D 8F45      1863       mov soak_temp+0, R7
0E6F 754600    1864       mov soak_temp+1, #0
0E72 754700    1865       mov soak_temp+2, #0
0E75 754800    1866       mov soak_temp+3, #0
0E78           1867   
0E78           1868       ; --- 2. REFLOW TEMP ---
0E78 7889      1869       mov R0, #Buf_Refl_Temp
0E7A 120EA7    1870       lcall Parse_Temp_String
0E7D 8F49      1871       mov reflow_temp+0, R7
0E7F 754A00    1872       mov reflow_temp+1, #0
0E82 754B00    1873       mov reflow_temp+2, #0
0E85 754C00    1874       mov reflow_temp+3, #0
0E88           1875   
0E88           1876       ; --- 3. SOAK TIME ---
0E88 7884      1877       mov R0, #Buf_Soak_Time
0E8A 120EBB    1878       lcall Parse_Time_String
0E8D 8F56      1879       mov soak_time+0, R7
0E8F 8E57      1880       mov soak_time+1, R6
0E91 755800    1881       mov soak_time+2, #0
0E94 755900    1882       mov soak_time+3, #0
0E97           1883   
0E97           1884       ; --- 4. REFLOW TIME ---
0E97 788D      1885       mov R0, #Buf_Refl_Time
0E99 120EBB    1886       lcall Parse_Time_String
0E9C 8F5A      1887       mov reflow_time+0, R7
0E9E 8E5B      1888       mov reflow_time+1, R6
0EA0 755C00    1889       mov reflow_time+2, #0
0EA3 755D00    1890       mov reflow_time+3, #0
0EA6 22        1891       ret
0EA7           1892   
0EA7           1893   ; --- Helper: Parse "123" to Integer ---
0EA7           1894   Parse_Temp_String:
0EA7 7F00      1895       mov R7, #0              ; Clear Result
0EA9           1896   Parse_Temp_Loop:
0EA9 E6        1897       mov A, @R0
0EAA 600E      1898       jz Parse_Temp_Done      ; If Null, we are done
0EAC           1899       
0EAC           1900       ; Convert ASCII to Digit
0EAC C3        1901       clr C
0EAD 9430      1902       subb A, #0x30
0EAF FD        1903       mov R5, A               ; R5 = New Digit
0EB0           1904       
0EB0           1905       ; Result = (Result * 10) + New Digit
0EB0 EF        1906       mov A, R7
0EB1 75F00A    1907       mov B, #10
0EB4 A4        1908       mul AB
0EB5 2D        1909       add A, R5
0EB6 FF        1910       mov R7, A
0EB7           1911       
0EB7 08        1912       inc R0
0EB8 80EF      1913       sjmp Parse_Temp_Loop
0EBA           1914   Parse_Temp_Done:
0EBA 22        1915       ret
0EBB           1916   
0EBB           1917   ; --- Helper: Parse "MMSS" to Seconds ---
0EBB           1918   Parse_Time_String:
0EBB           1919       ; 1. Minutes Tens
0EBB E6        1920       mov A, @R0
0EBC 9430      1921       subb A, #0x30
0EBE 75F00A    1922       mov B, #10
0EC1 A4        1923       mul AB
0EC2 FD        1924       mov R5, A
0EC3 08        1925       inc R0
0EC4           1926       
0EC4           1927       ; 2. Minutes Ones
0EC4 E6        1928       mov A, @R0
0EC5 9430      1929       subb A, #0x30
0EC7 2D        1930       add A, R5
0EC8 FD        1931       mov R5, A               ; R5 = Total Minutes
0EC9 08        1932       inc R0
0ECA           1933       
0ECA           1934       ; 3. Seconds Tens
0ECA E6        1935       mov A, @R0
0ECB 9430      1936       subb A, #0x30
0ECD 75F00A    1937       mov B, #10
0ED0 A4        1938       mul AB
0ED1 FC        1939       mov R4, A
0ED2 08        1940       inc R0
0ED3           1941       
0ED3           1942       ; 4. Seconds Ones
0ED3 E6        1943       mov A, @R0
0ED4 9430      1944       subb A, #0x30
0ED6 2C        1945       add A, R4               ; R4 = Total Seconds
0ED7           1946       
0ED7           1947       ; 5. Calculate Total Seconds = (Mins * 60) + Secs
0ED7 ED        1948       mov A, R5
0ED8 75F03C    1949       mov B, #60
0EDB A4        1950       mul AB
0EDC 2C        1951       add A, R4
0EDD FF        1952       mov R7, A               ; Low Byte
0EDE E5F0      1953       mov A, B
0EE0 3400      1954       addc A, #0
0EE2 FE        1955       mov R6, A               ; High Byte
0EE3 22        1956       ret
0EE4           1957   
0EE4           1958   ; ----------------------------------------------------------------
0EE4           1959   ; MODULE: BUTTON HANDLER (Mode Selection)
0EE4           1960   ; ----------------------------------------------------------------
0EE4           1961   Check_Buttons:
0EE4           1962       ; --- FORCE INPUT MODE ---
0EE4           1963       ; This clears any '0' the LCD library might have written to our buttons
0EE4 438055    1964       orl P0, #055H   ; Sets P0.0, P0.2, P0.4, and P0.6 to '1' (Input Mode)
0EE7           1965       ; ------------------------
0EE7           1966   
0EE7 30800A    1967       jnb BTN_SOAK_TEMP, Btn_Soak_Temp_Press
0EEA 308212    1968       jnb BTN_SOAK_TIME, Btn_Soak_Time_Press
0EED 30841A    1969       jnb BTN_REFL_TEMP, Btn_Refl_Temp_Press
0EF0 308622    1970       jnb BTN_REFL_TIME, Btn_Refl_Time_Press
0EF3 22        1971       ret
0EF4           1972   
0EF4           1973   Btn_Soak_Temp_Press:
0EF4 12119E    1974       lcall Wait_25ms_BLOCKING
0EF7 756B01    1975       mov Current_State, #1
0EFA 757400    1976       mov Cursor_Idx, #0
0EFD 8021      1977       sjmp Redraw_Screen
0EFF           1978   
0EFF           1979   Btn_Soak_Time_Press:
0EFF 12119E    1980       lcall Wait_25ms_BLOCKING
0F02 756B02    1981       mov Current_State, #2
0F05 757400    1982       mov Cursor_Idx, #0
0F08 8016      1983       sjmp Redraw_Screen
0F0A           1984   
0F0A           1985   Btn_Refl_Temp_Press:
0F0A 12119E    1986       lcall Wait_25ms_BLOCKING
0F0D 756B03    1987       mov Current_State, #3
0F10 757400    1988       mov Cursor_Idx, #0
0F13 800B      1989       sjmp Redraw_Screen
0F15           1990   
0F15           1991   Btn_Refl_Time_Press:
0F15 12119E    1992       lcall Wait_25ms_BLOCKING 
0F18 756B04    1993       mov Current_State, #4
0F1B 757400    1994       mov Cursor_Idx, #0
0F1E 8000      1995       sjmp Redraw_Screen
0F20           1996   
0F20           1997   Redraw_Screen:
0F20           1998       ; Wait for button release
0F20 3080FD    1999       jnb BTN_SOAK_TEMP, $
0F23 3082FD    2000       jnb BTN_SOAK_TIME, $
0F26 3084FD    2001       jnb BTN_REFL_TEMP, $
0F29 3086FD    2002       jnb BTN_REFL_TIME, $
0F2C           2003   
0F2C 1210AC    2004       lcall Update_Screen_Full
0F2F 22        2005       ret
0F30           2006   
0F30           2007   ; ----------------------------------------------------------------
0F30           2008   ; MODULE: KEYPAD HANDLER (Input Logic)
0F30           2009   ; ----------------------------------------------------------------
0F30           2010   Check_Keypad:
0F30           2011       ; If State is 0 (Home), ignore keypad
0F30 E56B      2012       mov A, Current_State
0F32 6050      2013       jz Keypad_Exit
0F34           2014       
0F34 120F85    2015       lcall Keypad_Scan
0F37 504B      2016       jnc Keypad_Exit         ; Carry = 0 means no key pressed
0F39           2017   
0F39           2018       ; --- Check Special Keys ---
0F39 EF        2019       mov A, R7
0F3A B40E0A    2020       cjne A, #14, Check_Hash ; 14 is Star (*)
0F3D           2021       
0F3D           2022       ; Star Key Pressed: Reset Buffer
0F3D 121089    2023       lcall Reset_Current_Buffer
0F40 1210AC    2024       lcall Update_Screen_Full
0F43 757400    2025       mov Cursor_Idx, #0
0F46 22        2026       ret
0F47           2027   
0F47           2028   Check_Hash:
0F47 EF        2029       mov A, R7
0F48 B40C01    2030       cjne A, #12, Check_Numeric ; 12 is Hash (#)
0F4B 22        2031       ret                     ; Ignore Hash key
0F4C           2032   
0F4C           2033   Check_Numeric:
0F4C           2034       ; Ensure key is 0-9
0F4C EF        2035       mov A, R7
0F4D C3        2036       clr C
0F4E 940A      2037       subb A, #10
0F50 5031      2038       jnc Symbol_Key_Ignored
0F52           2039       
0F52           2040       ; Convert to ASCII
0F52 EF        2041       mov A, R7
0F53 2430      2042       add A, #0x30
0F55 FD        2043       mov R5, A
0F56           2044   
0F56           2045       ; Save to Buffer
0F56 1211B7    2046       lcall Get_Current_Buffer_Addr
0F59 E574      2047       mov A, Cursor_Idx
0F5B 28        2048       add A, R0
0F5C F8        2049       mov R0, A
0F5D ED        2050       mov A, R5
0F5E F6        2051       mov @R0, A
0F5F 0574      2052       inc Cursor_Idx
0F61           2053   
0F61           2054       ; --- Check Cursor Limits ---
0F61 E56B      2055       mov A, Current_State
0F63 B40102    2056       cjne A, #1, Check_Limit_Time_1
0F66 8005      2057       sjmp Limit_Temp_3
0F68           2058   
0F68           2059   Check_Limit_Time_1:
0F68 B4030B    2060       cjne A, #3, Limit_Time_4
0F6B 8000      2061       sjmp Limit_Temp_3
0F6D           2062   
0F6D           2063   Limit_Temp_3:
0F6D E574      2064       mov A, Cursor_Idx
0F6F B4030D    2065       cjne A, #3, Do_Refresh
0F72 1574      2066       dec Cursor_Idx          ; Stay at last digit
0F74 8009      2067       sjmp Do_Refresh
0F76           2068   
0F76           2069   Limit_Time_4:
0F76 E574      2070       mov A, Cursor_Idx
0F78 B40404    2071       cjne A, #4, Do_Refresh
0F7B 1574      2072       dec Cursor_Idx          ; Stay at last digit
0F7D 8000      2073       sjmp Do_Refresh
0F7F           2074   
0F7F           2075   Do_Refresh:
0F7F 1210AC    2076       lcall Update_Screen_Full
0F82 22        2077       ret
0F83           2078   
0F83           2079   Symbol_Key_Ignored:
0F83 22        2080       ret
0F84           2081   Keypad_Exit:
0F84 22        2082       ret
0F85           2083   
0F85           2084   ; ----------------------------------------------------------------
0F85           2085   ; MODULE: HARDWARE SCANNER (Matrix Logic)
0F85           2086   ; ----------------------------------------------------------------
0F85           2087   Keypad_Scan:
0F85           2088       ; Step 1: Check if ANY key is pressed (All Rows Low)
0F85 C292      2089       clr ROW1
0F87 C294      2090       clr ROW2
0F89 C296      2091       clr ROW3
0F8B C2A0      2092       clr ROW4
0F8D A2A2      2093       mov C, COL1
0F8F 82A4      2094       anl C, COL2
0F91 82A6      2095       anl C, COL3
0F93 82B0      2096       anl C, COL4
0F95 5002      2097       jnc Keypad_Debounce
0F97 C3        2098       clr C
0F98 22        2099       ret
0F99           2100   
0F99           2101   Keypad_Debounce:
0F99 12119E    2102       lcall Wait_25ms_BLOCKING
0F9C A2A2      2103       mov C, COL1
0F9E 82A4      2104       anl C, COL2
0FA0 82A6      2105       anl C, COL3
0FA2 82B0      2106       anl C, COL4
0FA4 5002      2107       jnc Keypad_Find_Row
0FA6 C3        2108       clr C
0FA7 22        2109       ret
0FA8           2110   
0FA8           2111   Keypad_Find_Row:
0FA8 D292      2112       setb ROW1
0FAA D294      2113       setb ROW2
0FAC D296      2114       setb ROW3
0FAE D2A0      2115       setb ROW4
0FB0           2116   
0FB0           2117       ; Row 1
0FB0 C292      2118       clr ROW1
0FB2 30A23D    2119       jnb COL1, Keypad_Key_1
0FB5 30A43E    2120       jnb COL2, Keypad_Key_2
0FB8 30A63F    2121       jnb COL3, Keypad_Key_3
0FBB 30B040    2122       jnb COL4, Keypad_Key_A
0FBE D292      2123       setb ROW1
0FC0           2124   
0FC0           2125       ; Row 2
0FC0 C294      2126       clr ROW2
0FC2 30A23D    2127       jnb COL1, Keypad_Key_4
0FC5 30A43E    2128       jnb COL2, Keypad_Key_5
0FC8 30A63F    2129       jnb COL3, Keypad_Key_6
0FCB 30B040    2130       jnb COL4, Keypad_Key_B
0FCE D294      2131       setb ROW2
0FD0           2132   
0FD0           2133       ; Row 3
0FD0 C296      2134       clr ROW3
0FD2 30A23D    2135       jnb COL1, Keypad_Key_7
0FD5 30A43E    2136       jnb COL2, Keypad_Key_8
0FD8 30A63F    2137       jnb COL3, Keypad_Key_9
0FDB 30B040    2138       jnb COL4, Keypad_Key_C
0FDE D296      2139       setb ROW3
0FE0           2140   
0FE0           2141       ; Row 4
0FE0 C2A0      2142       clr ROW4
0FE2 30A23D    2143       jnb COL1, Keypad_Key_Star
0FE5 30A43E    2144       jnb COL2, Keypad_Key_0
0FE8 30A63F    2145       jnb COL3, Keypad_Key_Hash
0FEB 30B040    2146       jnb COL4, Keypad_Key_D
0FEE D2A0      2147       setb ROW4
0FF0 C3        2148       clr C
0FF1 22        2149       ret
0FF2           2150   
0FF2           2151   ; Key Mapping (Renamed to avoid conflicts)
0FF2 7F01      2152   Keypad_Key_1: mov R7, #1
0FF4 803C      2153          sjmp Wait_Release
0FF6 7F02      2154   Keypad_Key_2: mov R7, #2
0FF8 8038      2155          sjmp Wait_Release
0FFA 7F03      2156   Keypad_Key_3: mov R7, #3
0FFC 8034      2157          sjmp Wait_Release
0FFE 7F0A      2158   Keypad_Key_A: mov R7, #10
1000 8030      2159          sjmp Wait_Release
1002 7F04      2160   Keypad_Key_4: mov R7, #4
1004 802C      2161          sjmp Wait_Release
1006 7F05      2162   Keypad_Key_5: mov R7, #5
1008 8028      2163          sjmp Wait_Release
100A 7F06      2164   Keypad_Key_6: mov R7, #6
100C 8024      2165          sjmp Wait_Release
100E 7F0B      2166   Keypad_Key_B: mov R7, #11
1010 8020      2167          sjmp Wait_Release
1012 7F07      2168   Keypad_Key_7: mov R7, #7
1014 801C      2169          sjmp Wait_Release
1016 7F08      2170   Keypad_Key_8: mov R7, #8
1018 8018      2171          sjmp Wait_Release
101A 7F09      2172   Keypad_Key_9: mov R7, #9
101C 8014      2173          sjmp Wait_Release
101E 7F0D      2174   Keypad_Key_C: mov R7, #13
1020 8010      2175          sjmp Wait_Release
1022 7F0E      2176   Keypad_Key_Star: mov R7, #14
1024 800C      2177          sjmp Wait_Release
1026 7F00      2178   Keypad_Key_0: mov R7, #0
1028 8008      2179          sjmp Wait_Release
102A 7F0C      2180   Keypad_Key_Hash: mov R7, #12
102C 8004      2181          sjmp Wait_Release
102E 7F0F      2182   Keypad_Key_D: mov R7, #15
1030 8000      2183          sjmp Wait_Release
1032           2184   
1032           2185   Wait_Release:
1032 A2A2      2186       mov C, COL1
1034 82A4      2187       anl C, COL2
1036 82A6      2188       anl C, COL3
1038 82B0      2189       anl C, COL4
103A 50F6      2190       jnc Wait_Release
103C D3        2191       setb C
103D D292      2192       setb ROW1
103F D294      2193       setb ROW2
1041 D296      2194       setb ROW3
1043 D2A0      2195       setb ROW4
1045 22        2196       ret
1046           2197   
1046           2198   Wait_25ms:
1046           2199       ; 1. Check if we are already waiting
1046 20150E    2200       jb wait25_active, Check_Timer_Status
1049           2201       
1049           2202       ; 2. Check if we just finished
1049 301604    2203       jnb wait25_done, Start_New_Timer
104C           2204       
104C           2205       ; 3. Timer is DONE! Reset flags and return True
104C C216      2206       clr wait25_done
104E D3        2207       setb C          ; Carry = 1 means "Done"
104F 22        2208       ret
1050           2209   
1050           2210   Start_New_Timer:
1050           2211       ; 4. Start a new 25ms wait
1050 755100    2212       mov wait25_count, #0
1053 D215      2213       setb wait25_active
1055 C3        2214       clr C           ; Carry = 0 means "Not Done Yet"
1056 22        2215       ret
1057           2216   
1057           2217   Check_Timer_Status:
1057           2218       ; 5. Still waiting... return False immediately
1057 C3        2219       clr C           ; Carry = 0 means "Not Done Yet"
1058 22        2220       ret
1059           2221   
1059           2222   ; ----------------------------------------------------------------
1059           2223   ; MODULE: BUFFER INIT (Reset Logic)
1059           2224   ; ----------------------------------------------------------------
1059           2225   Init_All_Buffers:
1059 7880      2226       mov R0, #Buf_Soak_Temp
105B 12106E    2227       lcall Init_Temp_Template
105E 7889      2228       mov R0, #Buf_Refl_Temp
1060 12106E    2229       lcall Init_Temp_Template
1063 7884      2230       mov R0, #Buf_Soak_Time
1065 12107A    2231       lcall Init_Time_Template
1068 788D      2232       mov R0, #Buf_Refl_Time
106A 12107A    2233       lcall Init_Time_Template
106D 22        2234       ret
106E           2235   
106E           2236   Init_Temp_Template:
106E 7630      2237       mov @R0, #'0'
1070 08        2238       inc R0
1071 7630      2239       mov @R0, #'0'
1073 08        2240       inc R0
1074 7630      2241       mov @R0, #'0'
1076 08        2242       inc R0
1077 7600      2243       mov @R0, #0
1079 22        2244       ret
107A           2245   
107A           2246   Init_Time_Template:
107A 7630      2247       mov @R0, #'0'
107C 08        2248       inc R0
107D 7630      2249       mov @R0, #'0'
107F 08        2250       inc R0
1080 7630      2251       mov @R0, #'0'
1082 08        2252       inc R0
1083 7630      2253       mov @R0, #'0'
1085 08        2254       inc R0
1086 7600      2255       mov @R0, #0
1088 22        2256       ret
1089           2257   
1089           2258   Reset_Current_Buffer:
1089 E56B      2259       mov A, Current_State
108B B40106    2260       cjne A, #1, Reset_Chk_2
108E 7880      2261       mov R0, #Buf_Soak_Temp
1090 12106E    2262       lcall Init_Temp_Template
1093 22        2263       ret
1094           2264   Reset_Chk_2:
1094 B40206    2265       cjne A, #2, Reset_Chk_3
1097 7884      2266       mov R0, #Buf_Soak_Time
1099 12107A    2267       lcall Init_Time_Template
109C 22        2268       ret
109D           2269   Reset_Chk_3:
109D B40306    2270       cjne A, #3, Reset_Chk_4
10A0 7889      2271       mov R0, #Buf_Refl_Temp
10A2 12106E    2272       lcall Init_Temp_Template
10A5 22        2273       ret
10A6           2274   Reset_Chk_4:
10A6 788D      2275       mov R0, #Buf_Refl_Time
10A8 12107A    2276       lcall Init_Time_Template
10AB 22        2277       ret
10AC           2278   
10AC           2279   ; ----------------------------------------------------------------
10AC           2280   ; MODULE: SCREEN UPDATE (Visual Logic)
10AC           2281   ; ----------------------------------------------------------------
10AC           2282   Update_Screen_Full:
10AC 1211A4    2283       lcall Clear_Screen_Func
10AF C0E0      2284            push acc
10B1 7401      2284            mov a, #1
10B3 14        2284            dec a
10B4 1207AA    2284            lcall ?Set_Cursor_1 ; Select column and row
10B7 D0E0      2284            pop acc
10B9           2285   
10B9           2286       ; --- Draw Line 1 (Titles) ---
10B9 E56B      2287       mov A, Current_State
10BB B40013    2288       cjne A, #0, Update_State_1
10BE C083      2289            push dph
10C0 C082      2289            push dpl
10C2 C0E0      2289            push acc
10C4 900350    2289            mov dptr, #Txt_Home
10C7 12079D    2289            lcall ?Send_Constant_String
10CA D0E0      2289            pop acc
10CC D082      2289            pop dpl
10CE D083      2289            pop dph
10D0 22        2290       ret 
10D1           2291   Update_State_1:
10D1 B40114    2292       cjne A, #1, Update_State_2
10D4 C083      2293            push dph
10D6 C082      2293            push dpl
10D8 C0E0      2293            push acc
10DA 900361    2293            mov dptr, #Txt_SoakT
10DD 12079D    2293            lcall ?Send_Constant_String
10E0 D0E0      2293            pop acc
10E2 D082      2293            pop dpl
10E4 D083      2293            pop dph
10E6 8042      2294       sjmp Draw_Temp_Format
10E8           2295   Update_State_2:
10E8 B40214    2296       cjne A, #2, Update_State_3
10EB C083      2297            push dph
10ED C082      2297            push dpl
10EF C0E0      2297            push acc
10F1 900372    2297            mov dptr, #Txt_SoakTime
10F4 12079D    2297            lcall ?Send_Constant_String
10F7 D0E0      2297            pop acc
10F9 D082      2297            pop dpl
10FB D083      2297            pop dph
10FD 8042      2298       sjmp Draw_Time_Format
10FF           2299   Update_State_3:
10FF B40314    2300       cjne A, #3, Update_State_4
1102 C083      2301            push dph
1104 C082      2301            push dpl
1106 C0E0      2301            push acc
1108 900383    2301            mov dptr, #Txt_ReflT
110B 12079D    2301            lcall ?Send_Constant_String
110E D0E0      2301            pop acc
1110 D082      2301            pop dpl
1112 D083      2301            pop dph
1114 8014      2302       sjmp Draw_Temp_Format
1116           2303   Update_State_4:
1116 C083      2304            push dph
1118 C082      2304            push dpl
111A C0E0      2304            push acc
111C 900394    2304            mov dptr, #Txt_ReflTime
111F 12079D    2304            lcall ?Send_Constant_String
1122 D0E0      2304            pop acc
1124 D082      2304            pop dpl
1126 D083      2304            pop dph
1128 8017      2305       sjmp Draw_Time_Format
112A           2306   
112A           2307   ; --- Draw Line 2 (Values) ---
112A           2308   Draw_Temp_Format:
112A C0E0      2309            push acc
112C 7401      2309            mov a, #1
112E 14        2309            dec a
112F 1207A8    2309            lcall ?Set_Cursor_2 ; Select column and row
1132 D0E0      2309            pop acc
1134 1211B7    2310       lcall Get_Current_Buffer_Addr
1137 121194    2311       lcall Print_String_RAM
113A 7443      2312       mov A, #'C'
113C 120760    2313       lcall ?WriteData
113F 8027      2314       sjmp Restore_Cursor
1141           2315   
1141           2316   Draw_Time_Format:
1141 C0E0      2317            push acc
1143 7401      2317            mov a, #1
1145 14        2317            dec a
1146 1207A8    2317            lcall ?Set_Cursor_2 ; Select column and row
1149 D0E0      2317            pop acc
114B 1211B7    2318       lcall Get_Current_Buffer_Addr
114E           2319       ; MM
114E E6        2320       mov A, @R0
114F 120760    2321       lcall ?WriteData
1152 08        2322       inc R0
1153 E6        2323       mov A, @R0
1154 120760    2324       lcall ?WriteData
1157 08        2325       inc R0
1158           2326       ; Colon
1158 743A      2327       mov A, #':'
115A 120760    2328       lcall ?WriteData
115D           2329       ; SS
115D E6        2330       mov A, @R0
115E 120760    2331       lcall ?WriteData
1161 08        2332       inc R0
1162 E6        2333       mov A, @R0
1163 120760    2334       lcall ?WriteData
1166           2335       ; Unit
1166           2336       ;got rid of the "s"
1166           2337       ;mov A, #'s'
1166           2338       ;lcall ?WriteData
1166 8000      2339       sjmp Restore_Cursor
1168           2340   
1168           2341   ; --- Restore Cursor Position ---
1168           2342   Restore_Cursor:
1168 E56B      2343       mov A, Current_State
116A B40202    2344       cjne A, #2, RC_Check_State_4  
116D 800D      2345       sjmp Adjust_Cursor_Time
116F           2346   RC_Check_State_4:             
116F B40402    2347       cjne A, #4, Normal_Cursor
1172 8008      2348       sjmp Adjust_Cursor_Time
1174           2349   
1174           2350   Normal_Cursor:
1174 E574      2351       mov A, Cursor_Idx
1176 24C0      2352       add A, #0xC0
1178 120765    2353       lcall ?WriteCommand
117B 22        2354       ret
117C           2355   
117C           2356   Adjust_Cursor_Time:
117C           2357       ; Skip the colon index (2)
117C E574      2358       mov A, Cursor_Idx
117E B40201    2359       cjne A, #2, No_Skip
1181 04        2360       inc A 
1182           2361   No_Skip:
1182           2362       ; Add 1 if past the colon
1182 C3        2363       clr C
1183 9402      2364       subb A, #2
1185 4005      2365       jc No_Add
1187 E574      2366       mov A, Cursor_Idx
1189 04        2367       inc A
118A 8002      2368       sjmp Final_Cursor_Set
118C           2369   No_Add:
118C E574      2370       mov A, Cursor_Idx
118E           2371   Final_Cursor_Set:
118E 24C0      2372       add A, #0xC0
1190 120765    2373       lcall ?WriteCommand
1193 22        2374       ret
1194           2375   
1194           2376   Print_String_RAM:
1194 E6        2377       mov A, @R0
1195 6006      2378       jz Print_String_Done
1197 120760    2379       lcall ?WriteData
119A 08        2380       inc R0
119B 80F7      2381       sjmp Print_String_RAM
119D           2382   Print_String_Done:
119D 22        2383       ret
119E           2384   
119E           2385   ; Blocking wrapper for LCD clear (keeps old behavior just for this)
119E           2386   Wait_25ms_BLOCKING:
119E 121046    2387       lcall Wait_25ms
11A1 50FB      2388       jnc Wait_25ms_BLOCKING ; Keep jumping back until Done (C=1)
11A3 22        2389       ret
11A4           2390   
11A4           2391   Clear_Screen_Func:
11A4 7401      2392       mov A, #0x01
11A6 120765    2393       lcall ?WriteCommand
11A9           2394       
11A9           2395       ; --- FIX: HARDWARE DELAY LOOP (MAX STRENGTH) ---
11A9           2396       ; The LCD needs ~2ms to clear. 
11A9           2397       ; We use R0=255 to guarantee ~5ms+ delay.
11A9           2398       ; This ensures the LCD is 100% ready before we send "Ramp to Soak".
11A9 78FF      2399       mov R0, #255
11AB           2400   Clear_Delay_Loop_Outer:
11AB 79FF      2401       mov R1, #255
11AD           2402   Clear_Delay_Loop_Inner:
11AD D9FE      2403       djnz R1, Clear_Delay_Loop_Inner
11AF D8FA      2404       djnz R0, Clear_Delay_Loop_Outer
11B1           2405       ; -----------------------------------------------
11B1           2406   
11B1 740C      2407       mov A, #0x0C  ; Display ON, Cursor OFF
11B3 120765    2408       lcall ?WriteCommand
11B6 22        2409       ret
11B7           2410   
11B7           2411   Get_Current_Buffer_Addr:
11B7 E56B      2412       mov A, Current_State
11B9 B40103    2413       cjne A, #1, Get_Buf_2
11BC 7880      2414       mov R0, #Buf_Soak_Temp
11BE 22        2415       ret
11BF           2416   Get_Buf_2:
11BF B40203    2417       cjne A, #2, Get_Buf_3
11C2 7884      2418       mov R0, #Buf_Soak_Time
11C4 22        2419       ret
11C5           2420   Get_Buf_3:
11C5 B40303    2421       cjne A, #3, Get_Buf_4
11C8 7889      2422       mov R0, #Buf_Refl_Temp
11CA 22        2423       ret
11CB           2424   Get_Buf_4:
11CB 788D      2425       mov R0, #Buf_Refl_Time
11CD 22        2426       ret
11CE           2427       
11CE           2428   ; --- Helper to prevent "Machine Gun" button presses ---
11CE           2429   Wait_For_P1_0_Release:
11CE 3090FD    2430       jnb P1.0, $    ; Wait here while the button is still pressed (0)
11D1 22        2431       ret
11D2           2432   
11D2           2433   ; --- Full reset helper for P3.7 (active-low) ---
11D2           2434   Wait_For_P3_7_Release:
11D2 30B7FD    2435       jnb P3_7, $    ; Wait here while the button is still pressed (0)
11D5 22        2436       ret
11D6           2437   
11D6           2438   Full_Reset:
11D6 1211D2    2439       lcall Wait_For_P3_7_Release
11D9 020D46    2440       ljmp main
11DC           2441   
11DC           2442   ; ================================================================
11DC           2443   ; MODULE: THERMOCOUPLE ADC DRIVER (WITH NOISE SUPPRESSION & JUMP FIX)
11DC           2444   ; ================================================================
11DC           2445   Read_Thermocouple:
11DC           2446       ; 1. Check Non-Blocking Timer
11DC 121046    2447       lcall Wait_25ms
11DF           2448       
11DF           2449       ; [FIX] TRAMPOLINE JUMP
11DF           2450       ; "jnc" cannot jump to the end because the code is too long.
11DF           2451       ; We invert logic: If Carry=1 (Time is up), Jump NEARBY.
11DF 4001      2452       jc Proceed_Reading
11E1 22        2453       ret  ; If Carry=0, Return immediately.
11E2           2454   
11E2           2455   Proceed_Reading:
11E2           2456       ; --- 25ms Passed! Time to Read ---
11E2           2457   
11E2           2458       ; [FIX] SILENCE THE BUZZER (Noise Suppression)
11E2           2459       ; Save buzzer state and force it OFF during the sensitive read
11E2 E588      2460       mov A, TCON      
11E4 5410      2461       anl A, #0x10     ; Isolate TR0 bit
11E6 C0E0      2462       push acc         ; Save it
11E8 C28C      2463       clr TR0          ; STOP NOISE
11EA           2464   
11EA           2465       ; 2. Initialize / Trigger ADC
11EA 75A180    2466       mov ADC_C, #0x80    ; Reset
11ED 00        2467       nop
11EE 00        2468       nop
11EF 75A101    2469       mov ADC_C, #0x01    ; Start Channel 0
11F2           2470       
11F2           2471       ; 3. Settle Delay
11F2 7DFA      2472       mov R5, #250
11F4           2473   ADC_Settle_Loop:
11F4 00        2474       nop
11F5 00        2475       nop
11F6 DDFC      2476       djnz R5, ADC_Settle_Loop
11F8           2477       
11F8           2478       ; 4. Read Raw Data
11F8 85A232    2479       mov x+0, ADC_L
11FB 85A333    2480       mov x+1, ADC_H
11FE 753400    2481       mov x+2, #0
1201 753500    2482       mov x+3, #0
1204           2483       
1204           2484       ; 5. Mask Data
1204 E533      2485       mov a, x+1
1206 540F      2486       anl a, #0x0F
1208 F533      2487       mov x+1, a
120A           2488       
120A           2489       ; [FIX] RESTORE THE BUZZER
120A D0E0      2490       pop acc          ; Get previous state
120C 6002      2491       jz Skip_Restore  ; If it was OFF, keep it OFF
120E D28C      2492       setb TR0         ; If it was ON, turn it back ON
1210           2493   Skip_Restore:
1210           2494   
1210           2495       ; 6. Math Conversions
1210 753616    2496            mov y+0, #low (4118 % 0x10000) 
1213 753710    2496            mov y+1, #high(4118 % 0x10000) 
1216 753800    2496            mov y+2, #low (4118 / 0x10000) 
1219 753900    2496            mov y+3, #high(4118 / 0x10000) 
121C 12018C    2497       lcall mul32       
121F           2498   
121F 75A104    2499       mov ADC_C, #0x04    ; Read LM4040
1222 85A236    2500       mov y+0, ADC_L      
1225 85A337    2501       mov y+1, ADC_H      
1228 753800    2502       mov y+2, #0
122B 753900    2503       mov y+3, #0
122E 75A100    2504       mov ADC_C, #0x00    ; Reset
1231           2505       
1231 120280    2506       lcall div32         
1234 753664    2507            mov y+0, #low (100 % 0x10000) 
1237 753700    2507            mov y+1, #high(100 % 0x10000) 
123A 753800    2507            mov y+2, #low (100 / 0x10000) 
123D 753900    2507            mov y+3, #high(100 / 0x10000) 
1240 12018C    2508       lcall mul32
1243 75362B    2509            mov y+0, #low (1323 % 0x10000) 
1246 753705    2509            mov y+1, #high(1323 % 0x10000) 
1249 753800    2509            mov y+2, #low (1323 / 0x10000) 
124C 753900    2509            mov y+3, #high(1323 / 0x10000)         
124F 120280    2510       lcall div32    
1252 753614    2511            mov y+0, #low (COLD_JUNCTION_TEMP % 0x10000) 
1255 753700    2511            mov y+1, #high(COLD_JUNCTION_TEMP % 0x10000) 
1258 753800    2511            mov y+2, #low (COLD_JUNCTION_TEMP / 0x10000) 
125B 753900    2511            mov y+3, #high(COLD_JUNCTION_TEMP / 0x10000) 
125E 1200D3    2512       lcall add32     
1261           2513       
1261           2514       ; 8. Store Result
1261 853241    2515       mov current_temp+0, x+0
1264 853342    2516       mov current_temp+1, x+1
1267 853443    2517       mov current_temp+2, x+2
126A 853544    2518       mov current_temp+3, x+3
126D           2519   
126D 22        2520       ret
126E           2521       
126E           2522   ; ================================================================
126E           2523   ; MODULE: POWER CONTROLLER (The Brain)
126E           2524   ; ================================================================
126E           2525   Power_Control:
126E           2526       ; Default: Turn Heat OFF (Safety)
126E 755E00    2527       mov power_output+0, #0
1271 755F00    2528       mov power_output+1, #0
1274 756000    2529       mov power_output+2, #0
1277 756100    2530       mov power_output+3, #0
127A           2531   
127A E56A      2532       mov a, Control_FSM_state
127C           2533   
127C           2534       ; --- State 2: RAMP TO SOAK ---
127C B40202    2535       cjne a, #2, PC_Check_Soak
127F           2536       ; Mode: Full Speed Ahead
127F 8016      2537       sjmp Set_Max_Power
1281           2538   
1281           2539   PC_Check_Soak:
1281           2540       ; --- State 3: SOAK PHASE ---
1281 B40305    2541       cjne a, #3, PC_Check_Ramp_Reflow
1284           2542       ; Mode: Maintenance (Low Power)
1284           2543       ; If Temp > Target, OFF. If Temp < Target, 20% Power.
1284 20040F    2544       jb soak_temp_reached, PC_Done ; If hot enough, stay OFF
1287 801B      2545       sjmp Set_20_Percent_Power     ; If cold, use 20%
1289           2546   
1289           2547   PC_Check_Ramp_Reflow:
1289           2548       ; --- State 4: RAMP TO REFLOW ---
1289 B40402    2549       cjne a, #4, PC_Check_Reflow
128C           2550       ; Mode: Full Speed Ahead
128C 8009      2551       sjmp Set_Max_Power
128E           2552   
128E           2553   PC_Check_Reflow:
128E           2554       ; --- State 5: REFLOW PHASE ---
128E B40505    2555       cjne a, #5, PC_Done
1291           2556       ; Mode: Maintenance (Low Power)
1291 200502    2557       jb reflow_temp_reached, PC_Done
1294 800E      2558       sjmp Set_20_Percent_Power
1296           2559   
1296           2560   PC_Done:
1296 22        2561       ret
1297           2562   
1297           2563   ; --- Power Helpers ---
1297           2564   
1297           2565   Set_Max_Power:
1297           2566       ; Load 1500 (0x05DC) = 100% Duty Cycle
1297 755EDC    2567       mov power_output+0, #0xDC
129A 755F05    2568       mov power_output+1, #0x05
129D 756000    2569       mov power_output+2, #0
12A0 756100    2570       mov power_output+3, #0
12A3 22        2571       ret
12A4           2572   
12A4           2573   Set_20_Percent_Power:
12A4           2574       ; Load 300 (0x012C) = 20% Duty Cycle
12A4 755E2C    2575       mov power_output+0, #0x2C
12A7 755F01    2576       mov power_output+1, #0x01
12AA 756000    2577       mov power_output+2, #0
12AD 756100    2578       mov power_output+3, #0
12B0 22        2579       ret
12B1           2580   
12B1           2581   
12B1           2582   ;--------------------------------------------------------------
12B1           2583   ; set servo angle according to the state
12B1           2584   ; call servo control function every 1ms
12B1           2585   ;--------------------------------------------------------------
12B1           2586   call_servo_control:
12B1           2587            ; check current state and change servo angle
12B1 E56A      2588            mov a, Control_FSM_state
12B3           2589            
12B3           2590            ; handle state 0
12B3 B40004    2591            cjne a, #0, servo_state1
12B6 C220      2592            clr servo_angle_zero ; close door at state 0
12B8 802C      2593            sjmp check_servo_flag
12BA           2594   
12BA           2595            ; handle state 1
12BA           2596            servo_state1:
12BA B40104    2597            cjne a, #1, servo_state2
12BD D220      2598            setb servo_angle_zero ; open door at state 1
12BF 8025      2599            sjmp check_servo_flag
12C1           2600   
12C1           2601            ; handle state 2
12C1           2602            servo_state2:
12C1 B40204    2603            cjne a, #2, servo_state3
12C4 C220      2604            clr servo_angle_zero ; close door at state 2
12C6 801E      2605            sjmp check_servo_flag
12C8           2606   
12C8           2607            ; handle state 3
12C8           2608            servo_state3:
12C8 B40304    2609            cjne a, #3, servo_state4
12CB C220      2610            clr servo_angle_zero ; close door at state 3
12CD 8017      2611            sjmp check_servo_flag
12CF           2612   
12CF           2613            ; handle state 4
12CF           2614            servo_state4:
12CF B40404    2615            cjne a, #4, servo_state5
12D2 C220      2616            clr servo_angle_zero ; close door at state 4
12D4 8010      2617            sjmp check_servo_flag
12D6           2618   
12D6           2619            ; handle state 5
12D6           2620            servo_state5:
12D6 B40504    2621            cjne a, #5, servo_state6
12D9 C220      2622            clr servo_angle_zero ; close door at state 5
12DB 8009      2623            sjmp check_servo_flag
12DD           2624   
12DD           2625            ; handle state 6
12DD           2626            servo_state6:
12DD B40604    2627            cjne a, #6, servo_state7
12E0 C220      2628            clr servo_angle_zero ; close door at state 6
12E2 8002      2629            sjmp check_servo_flag
12E4           2630   
12E4           2631            ; handle state 7
12E4           2632            servo_state7:
12E4 D220      2633            setb servo_angle_zero ; open door at state 7
12E6           2634   
12E6           2635   check_servo_flag:
12E6           2636            ; check 1 ms flag
12E6 101F01    2637            jbc one_millisecond_flag_servo, run_servo_control
12E9 22        2638            ret
12EA           2639   
12EA           2640   run_servo_control:
12EA 1212EE    2641            lcall servo_control
12ED 22        2642            ret
12EE           2643   
12EE           2644   
12EE           2645   ;---------------------------------------------------------------
12EE           2646   ; servo control
12EE           2647   ; generate a 20 ms period pwm signal to control the servo motor
12EE           2648   ; able to make the servo motor stay at 0 degree and 180 degree
12EE           2649   ;---------------------------------------------------------------
12EE           2650   servo_control:
12EE D2ED      2651       setb LEDRA.5
12F0 C0E0      2652            push acc
12F2 C0D0      2653            push psw
12F4 E579      2654            mov a, servo_pwm_counter ; move servo counter to accumulator
12F6 04        2655            inc A ; a += 1
12F7 B41402    2656            cjne a, #SERVO_PERIOD, servo_pwm_angle_compare ; jump if wrapup not needed
12FA 7400      2657            mov a, #0
12FC           2658   
12FC           2659   servo_pwm_angle_compare: ; read target angle
12FC F579      2660            mov servo_pwm_counter, A
12FE 202009    2661            jb servo_angle_zero, set_zero_degree ; set servo motor to 0 degree
1301           2662            ; set servo motor to 180 degrees
1301 E579      2663            mov a, servo_pwm_counter
1303 C3        2664            clr c
1304 9402      2665            subb a, #SERVO_180
1306 400B      2666            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 180 degrees duty cycle
1308 800D      2667            sjmp servo_pwm_set_low ; set low if greater
130A           2668   
130A           2669   set_zero_degree:
130A           2670            ; set servo motor to 0 degree
130A E579      2671            mov a, servo_pwm_counter
130C C3        2672            clr c
130D 9401      2673            subb a, #SERVO_0
130F 4002      2674            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 0 degrees duty cycle
1311 8004      2675            sjmp servo_pwm_set_low ; set low if greater
1313           2676   
1313           2677   servo_pwm_set_high:
1313           2678            ; set pwm pin high
1313 D2B6      2679            setb SERVO_OUT
1315 8002      2680            sjmp servo_control_done
1317           2681   
1317           2682   servo_pwm_set_low:
1317           2683            ; set pwm pin low
1317 C2B6      2684            clr SERVO_OUT
1319           2685   
1319           2686   servo_control_done:
1319 D0D0      2687            pop psw
131B D0E0      2688            pop acc
131D 22        2689            ret
131E           2690   
131E           2691   ;-------------------------------------------------------------------------------
131E           2692   ; power_control
131E           2693   ;-------------------------------------------------------------------------------
131E           2694   ; Determine the power output based on current state and current temperature 
131E           2695   ; input parameter: Control_FSM_state
131E           2696   ;-------------------------------------------------------------------------------
131E           2697   
131E           2698   proportional_power_control:
131E E56A      2699            mov a, Control_FSM_state
1320           2700   
1320           2701   state0_power_control:
1320           2702            ; idle
1320           2703            ; 0% power
1320 B4000F    2704            cjne a, #0, state1_power_control
1323 755E00    2705            mov power_output, #low(NO_POWER)
1326 755F00    2706            mov power_output+1, #low(NO_POWER)
1329 756000    2707            mov power_output+2, #0
132C 756100    2708            mov power_output+3, #0
132F 0214CA    2709            ljmp power_control_done
1332           2710   
1332           2711   state1_power_control:
1332           2712            ; idle
1332           2713            ; 0% power
1332 B4010F    2714            cjne a, #1, state2_power_control
1335 755E00    2715            mov power_output, #low(NO_POWER)
1338 755F00    2716            mov power_output+1, #low(NO_POWER)
133B 756000    2717            mov power_output+2, #0
133E 756100    2718            mov power_output+3, #0
1341 0214CA    2719            ljmp power_control_done
1344           2720            
1344           2721   state2_power_control:
1344           2722            ; ramp to soak, ramp to ~150C
1344           2723            ; 100% power
1344 B4020F    2724            cjne a, #2, state3_power_control
1347 755EDC    2725            mov power_output, #low(MAX_POWER)
134A 755F05    2726            mov power_output+1, #high(MAX_POWER)
134D 756000    2727            mov power_output+2, #0
1350 756100    2728            mov power_output+3, #0
1353 0214CA    2729            ljmp power_control_done
1356           2730   
1356           2731   state3_power_control:
1356           2732            ; soak period, hold at 150C
1356           2733            ; 20% base power + proportional calculated power
1356 B40302    2734            cjne a, #3, jump_state4_power_control
1359 8003      2735            sjmp state3_power_control_calculation
135B           2736   
135B           2737   jump_state4_power_control:
135B 021488    2738            ljmp state4_power_control
135E           2739   
135E           2740   state3_power_control_calculation:
135E           2741            ; move soak_temp to x
135E 854532    2742            mov x, soak_temp
1361 854633    2743            mov x+1, soak_temp+1
1364 854734    2744            mov x+2, soak_temp+2
1367 854835    2745            mov x+3, soak_temp+3
136A           2746            ; move current_temp to y
136A 854136    2747            mov y, current_temp
136D 854237    2748            mov y+1, current_temp+1
1370 854338    2749            mov y+2, current_temp+2
1373 854439    2750            mov y+3, current_temp+3
1376           2751   
1376           2752            ; compare between soak_temp and current_temp
1376 C201      2753            clr mf
1378 120178    2754            lcall x_gteq_y
137B 10012B    2755            jbc mf, st_sub_ct
137E           2756            ; current_temp - soak_temp if st < ct
137E C221      2757            clr soak_temp_greater
1380           2758            ; move current_temp to y
1380 854536    2759            mov y, soak_temp
1383 854637    2760            mov y+1, soak_temp+1
1386 854738    2761            mov y+2, soak_temp+2
1389 854839    2762            mov y+3, soak_temp+3
138C           2763            ; move current_temp to x
138C 854132    2764            mov x, current_temp
138F 854233    2765            mov x+1, current_temp+1
1392 854334    2766            mov x+2, current_temp+2
1395 854435    2767            mov x+3, current_temp+3
1398 1200F6    2768            lcall sub32
139B 85326C    2769            mov soak_temp_diff, x
139E 85336D    2770            mov soak_temp_diff+1, x+1
13A1 85346E    2771            mov soak_temp_diff+2, x+2
13A4 85356F    2772            mov soak_temp_diff+3, x+3
13A7 8011      2773            sjmp proportional_input_soak
13A9           2774   
13A9           2775   st_sub_ct:
13A9           2776            ; soak_temp - current_temp
13A9 D221      2777            setb soak_temp_greater
13AB 1200F6    2778            lcall sub32
13AE 85326C    2779            mov soak_temp_diff, x
13B1 85336D    2780            mov soak_temp_diff+1, x+1
13B4 85346E    2781            mov soak_temp_diff+2, x+2
13B7 85356F    2782            mov soak_temp_diff+3, x+3
13BA           2783   
13BA           2784   proportional_input_soak:
13BA           2785            ; proportaional block calculation       
13BA           2786            ; move soak_temp_diff to x
13BA 856C32    2787            mov x, soak_temp_diff
13BD 856D33    2788            mov x+1, soak_temp_diff+1
13C0 856E34    2789            mov x+2, soak_temp_diff+2
13C3 856F35    2790            mov x+3, soak_temp_diff+3
13C6           2791            ; move proportional gain to y
13C6 753605    2792            mov y+0, #low (KP % 0x10000) 
13C9 753700    2792            mov y+1, #high(KP % 0x10000) 
13CC 753800    2792            mov y+2, #low (KP / 0x10000) 
13CF 753900    2792            mov y+3, #high(KP / 0x10000) 
13D2 12018C    2793            lcall mul32 ; proportional_output = proportional_gain * difference
13D5           2794            
13D5 853270    2795            mov proportional_gain_var, x
13D8 853371    2796            mov proportional_gain_var+1, x+1
13DB 853472    2797            mov proportional_gain_var+2, x+2
13DE 853573    2798            mov proportional_gain_var+3, x+3
13E1           2799   
13E1           2800            ; base_power + soak_power when soak_temp > current_temp
13E1 302129    2801            jnb soak_temp_greater, sub_proportional_soak
13E4 857032    2802            mov x, proportional_gain_var
13E7 857133    2803            mov x+1, proportional_gain_var+1
13EA 857234    2804            mov x+2, proportional_gain_var+2
13ED 857335    2805            mov x+3, proportional_gain_var+3
13F0 75362C    2806            mov y+0, #low (BASE_POWER % 0x10000) 
13F3 753701    2806            mov y+1, #high(BASE_POWER % 0x10000) 
13F6 753800    2806            mov y+2, #low (BASE_POWER / 0x10000) 
13F9 753900    2806            mov y+3, #high(BASE_POWER / 0x10000) 
13FC 1200D3    2807            lcall add32
13FF           2808            ; x now holds the power output before the saturator
13FF 853270    2809            mov proportional_gain_var, x
1402 853371    2810            mov proportional_gain_var+1, x+1
1405 853472    2811            mov proportional_gain_var+2, x+2
1408 853573    2812            mov proportional_gain_var+3, x+3
140B 803D      2813            sjmp saturator_soak
140D           2814   
140D           2815   sub_proportional_soak:
140D           2816            ; base_power - soak_power when soak_temp <= current_temp
140D 75322C    2817            mov x+0, #low (BASE_POWER % 0x10000) 
1410 753301    2817            mov x+1, #high(BASE_POWER % 0x10000) 
1413 753400    2817            mov x+2, #low (BASE_POWER / 0x10000) 
1416 753500    2817            mov x+3, #high(BASE_POWER / 0x10000) 
1419 857036    2818            mov y, proportional_gain_var
141C 857137    2819            mov y+1, proportional_gain_var+1
141F 857238    2820            mov y+2, proportional_gain_var+2
1422 857339    2821            mov y+3, proportional_gain_var+3
1425           2822   
1425           2823            ; compare whether base_power < proportional_gain_var
1425 C201      2824            clr mf
1427 12011A    2825            lcall x_lt_y ; set mf to 1 if base_power < proportional_gain_var, clamp output to 0
142A 30010E    2826            jnb mf, bp_gteq_pgv
142D 757000    2827            mov proportional_gain_var, #low(NO_POWER)
1430 757100    2828            mov proportional_gain_var+1, #high(NO_POWER)
1433 757200    2829            mov proportional_gain_var+2, #0
1436 757300    2830            mov proportional_gain_var+3, #0
1439 800F      2831            sjmp saturator_soak
143B           2832   
143B           2833   bp_gteq_pgv:
143B           2834            ; calculate subtracted gain
143B 1200F6    2835            lcall sub32
143E           2836            ; x now holds the power output before the saturator
143E 853270    2837            mov proportional_gain_var, x
1441 853371    2838            mov proportional_gain_var+1, x+1
1444 853472    2839            mov proportional_gain_var+2, x+2
1447 853573    2840            mov proportional_gain_var+3, x+3
144A           2841   
144A           2842   saturator_soak:
144A           2843            ; proportional_gain_var now holds the power output before the saturator
144A           2844            ; saturate power output to max power
144A 857032    2845            mov x, proportional_gain_var
144D 857133    2846            mov x+1, proportional_gain_var+1
1450 857234    2847            mov x+2, proportional_gain_var+2
1453 857335    2848            mov x+3, proportional_gain_var+3
1456           2849   
1456 7536DC    2850            mov y+0, #low (MAX_POWER % 0x10000) 
1459 753705    2850            mov y+1, #high(MAX_POWER % 0x10000) 
145C 753800    2850            mov y+2, #low (MAX_POWER / 0x10000) 
145F 753900    2850            mov y+3, #high(MAX_POWER / 0x10000) 
1462           2851   
1462 C201      2852            clr mf
1464 120136    2853            lcall x_gt_y ; set mf to 1 if calculated power output greater than max power
1467 20010F    2854            jb mf, saturated_soak
146A           2855            ; set power_output to calculated power if not saturated
146A 85705E    2856            mov power_output, proportional_gain_var
146D 85715F    2857            mov power_output+1, proportional_gain_var+1
1470 857260    2858            mov power_output+2, proportional_gain_var+2
1473 857361    2859            mov power_output+3, proportional_gain_var+3
1476 0214CA    2860            ljmp power_control_done
1479           2861   
1479           2862   saturated_soak:
1479 755EDC    2863            mov power_output, #low(MAX_POWER)
147C 755F05    2864            mov power_output+1, #high(MAX_POWER)
147F 756000    2865            mov power_output+2, #0
1482 756100    2866            mov power_output+3, #0
1485 0214CA    2867            ljmp power_control_done
1488           2868   
1488           2869   
1488           2870   state4_power_control:
1488           2871            ; ramp to reflow, max power
1488 B4040F    2872            cjne a, #4, state5_power_control
148B 755EDC    2873            mov power_output, #low(MAX_POWER)
148E 755F05    2874            mov power_output+1, #high(MAX_POWER)
1491 756000    2875            mov power_output+2, #0
1494 756100    2876            mov power_output+3, #0
1497 0214CA    2877            ljmp power_control_done
149A           2878   
149A           2879   state5_power_control:
149A           2880            ; reflow 20% base power
149A B4050F    2881            cjne a, #5, state6_power_control
149D 755E2C    2882            mov power_output, #low(BASE_POWER)  
14A0 755F01    2883            mov power_output+1, #high(BASE_POWER)
14A3 756000    2884            mov power_output+2, #0
14A6 756100    2885            mov power_output+3, #0
14A9 0214CA    2886            ljmp power_control_done
14AC           2887   
14AC           2888   state6_power_control:
14AC           2889            ; cooling 0% power
14AC B4060F    2890            cjne a, #6, state_7_power_control
14AF 755E00    2891            mov power_output, #low(NO_POWER)
14B2 755F00    2892            mov power_output+1, #high(NO_POWER)
14B5 756000    2893            mov power_output+2, #0
14B8 756100    2894            mov power_output+3, #0
14BB 0214CA    2895            ljmp power_control_done
14BE           2896   
14BE           2897   state_7_power_control:
14BE           2898            ; idle 0% power
14BE 755E00    2899            mov power_output, #low(NO_POWER)
14C1 755F00    2900            mov power_output+1, #high(NO_POWER)
14C4 756000    2901            mov power_output+2, #0
14C7 756100    2902            mov power_output+3, #0
14CA           2903   
14CA           2904   power_control_done:
14CA 22        2905            ret
14CB           2906   
14CB           2907   END
