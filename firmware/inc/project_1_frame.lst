0000              1   ; Project 1
0000              2   ; CV-8052 microcontroller in DE10-Lite board
0000              3   ;-------------------------------------------------------------------------------
0000              4   ; Reset vector
0000              5   org 0x0000
0000 020D52       6       ljmp main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9       reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 02046E      12       ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15       reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18       reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 32          21       reti
0024             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
002B 0206B5      24       ljmp Timer2_ISR
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 32   $LIST
0320             34   ; ----------------------------------------------------------------------------------------------;
0320             35   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             36   dseg at 0x30
0030             37   current_time_sec:     ds 1
0031             38   current_time_minute:  ds 1
0032             39   ; math32 buffer variables
0032             40   x:      ds  4
0036             41   y:      ds  4
003A             42   bcd:    ds  5
003F             43   
003F             44   ; -------- UART RX state (polling) --------
003F             45   rx_idx:    ds 1
0040             46   rx_ready:  ds 1
0041             47   
0041             48   
0041             49   current_temp: ds 4 ;
0045             50   soak_temp:    ds 4 ;
0049             51   reflow_temp:  ds 4 ;
004D             52   
004D             53   wait25_btn_cnt:    ds 1
004E             54   wait25_keypad_cnt: ds 1
004F             55   wait25_adc_cnt:    ds 1
0050             56   wait25_lcd_cnt:    ds 1
0051             57   wait25_count: ds 1  
0052             58   
0052             59   current_time: ds 4 ;
0056             60   soak_time:    ds 4 ;
005A             61   reflow_time:  ds 4 ;
005E             62   
005E             63   power_output:  ds 4 ;
0062             64   pwm_counter: ds 4 ; counter for pwm (0-1500)
0066             65   
0066             66   KEY1_DEB_timer: ds 1
0067             67   SEC_FSM_timer:  ds 1
0068             68   KEY1_DEB_state:    ds 1
0069             69   SEC_FSM_state:     ds 1
006A             70   Control_FSM_state: ds 1 
006B             71   
006B             72   Current_State:     ds 1
006C             73   soak_temp_diff: ds 4 ; temperature difference between target soak temp and current oven temp 
0070             74   proportional_gain_var: ds 4 ; power gain calculated from the proportional block
0074             75   ;-- UI buffers I added (ayaan)
0074             76   Cursor_Idx: ds 1
0075             77   
0075             78   ; These hold the TEXT (ASCII) safely
0075             79   ; Digits Only + Null Terminator, got rid of C,:, and s 
0075             80   
0075             81   ; Buzzer state
0075             82   beep_count:  ds 1      ; remaining beeps
0076             83   beep_state:  ds 1      ; 0=idle, 1=ON, 2=OFF
0077             84   beep_tmr:    ds 2      ; 16-bit ms timer (needs to reach 500)
0079             85   
0079             86   servo_pwm_counter: ds 1 ; counter for the servo pwm signal
007A             87   
0080             88   iseg at 0x80
0080             89   Buf_Soak_Temp: ds 4   
0084             90   Buf_Soak_Time: ds 5   
0089             91   Buf_Refl_Temp: ds 4   
008D             92   Buf_Refl_Time: ds 5
0092             93   ; UART RX line buffer (polling) in upper RAM
0092             94   rx_buf:    ds 40    ; null-terminated command line
00BA             95   
00BA             96   
00BA             97   
00BA             98   ; 46d bytes used
00BA             99   
00BA            100   ;-------------------------------------------------------------------------------
00BA            101   ; bit operation setb, clr, jb, and jnb
0000            102   bseg
0000            103   remote_config_mode: dbit 1
0001            104   mf:     dbit 1 ; math32 sign
0002            105   one_second_flag: dbit 1
0003            106   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0004            107   
0004            108   soak_temp_reached: dbit 1
0005            109   reflow_temp_reached: dbit 1
0006            110   cooling_temp_reached: dbit 1
0007            111   
0007            112   soak_time_reached: dbit 1
0008            113   reflow_time_reached: dbit 1
0009            114   
0009            115   reset_signal: dbit 1
000A            116   stop_signal: dbit 1
000B            117   start_signal: dbit 1
000C            118   config_finish_signal: dbit 1
000D            119   
000D            120   state_change_signal: dbit 1
000E            121   
000E            122   Key1_flag: dbit 1
000F            123   
000F            124   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
0010            125   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0011            126   PB0_flag: dbit 1 ; start entire program
0012            127   PB1_flag: dbit 1 ; start soak
0013            128   PB2_flag: dbit 1 ; pause process
0014            129   
0014            130   ;buzzer beep
0014            131   one_ms_beep_flag: dbit 1
0015            132   
0015            133   ; BSEG (Bit Segment)
0015            134   wait25_active: dbit 1 ; 1 = We are currently waiting
0016            135   wait25_done:   dbit 1 ; 1 = The 25ms has finished
0017            136   wait25_btn_active:    dbit 1
0018            137   wait25_btn_done:      dbit 1
0019            138   wait25_keypad_active: dbit 1
001A            139   wait25_keypad_done:   dbit 1
001B            140   wait25_adc_active:    dbit 1
001C            141   wait25_adc_done:      dbit 1
001D            142   wait25_lcd_active:    dbit 1
001E            143   wait25_lcd_done:      dbit 1
001F            144   
001F            145   one_millisecond_flag_servo: dbit 1 ; set the one millsiecond flag for servo pwm signal generation
0020            146   servo_angle_zero: dbit 1 ; flag for indicating whether the servo angle should be at 0 or not: 1 -> 0; 0 -> 180
0021            147   soak_temp_greater: dbit 1 ; target soak_temp greater than current_temp
0022            148   ; 11 bits used
0022            149   
0022            150   ;-------------------------------------------------------------------------------
0320            151   cseg
0320            152   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            153   BAUD           EQU 57600
0320            154   
0320            155   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            156   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            157   ; is always 12 unlike the N76E003 where is selectable.
0320            158   
0320            159   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            160   
0320            161   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            162   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            163   
0320            164   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            165   
0320            166   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            167   
0320            168   PWM_OUT        EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            169   
0320            170   ; These 'equ' must match the wiring between the DE10Lite board and the LCD!
0320            171   ; P0 is in connector JPIO.
0320            172   
0320            173   ;Added correct I/O definitions
0320            174   ;-- LCD Pins ---
0320            175   ELCD_RS equ P1.7
0320            176   ELCD_E  equ P1.1
0320            177   ELCD_D4 equ P0.7
0320            178   ELCD_D5 equ P0.5
0320            179   ELCD_D6 equ P0.3
0320            180   ELCD_D7 equ P0.1
0320            181   
0320            182   ; -- Buttons --
0320            183   BTN_SOAK_TEMP equ P0.0
0320            184   BTN_SOAK_TIME equ P0.2
0320            185   BTN_REFL_TEMP equ P0.4
0320            186   BTN_REFL_TIME equ P0.6
0320            187   
0320            188   ; --- KEYPAD ---
0320            189   ROW1 equ P1.2
0320            190   ROW2 equ P1.4
0320            191   ROW3 equ P1.6
0320            192   ROW4 equ P2.0
0320            193   COL1 equ P2.2
0320            194   COL2 equ P2.4
0320            195   COL3 equ P2.6
0320            196   COL4 equ P3.0
0320            197   
0320            198   SERVO_OUT      EQU p3.6 ; servo pin
0320            199   
0320            200   SERVO_PERIOD   EQU 20 ; pwm signal period for the servo motor (20 ms)
0320            201   SERVO_0        EQU 1 ; pwm high time for the servo motor to stay at 0 degree
0320            202   SERVO_180      EQU 2 ; pwm high time for the servo motor to stay at 180 degrees
0320            203   
0320            204   COLD_JUNCTION_TEMP equ 20
0320            205   MAX_POWER           EQU 1500 ; max oven power
0320            206   NO_POWER            EQU 0    ; no power
0320            207   BASE_POWER     EQU (MAX_POWER/5) ; 20% base power for state 2, 4
0320            208   KP                          EQU 5 ; proportional gain
0320            209   
0320            210   ;                     1234567890123456 <-- 16 characters per line LCD
0320 696E6974   211   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   212   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   213   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            214   
0350            215   ; --- UI STRINGS (REQUIRED FOR KEYPAD LOGIC), <- I can fix if duplicates
0350 53656C65   216   Txt_Home:     db 'Select Mode:    ', 0
     6374204D
     6F64653A
     20202020
     00
0361 53657420   217   Txt_SoakT:    db 'Set Soak Temp   ', 0
     536F616B
     2054656D
     70202020
     00
0372 53657420   218   Txt_SoakTime: db 'Set Soak Time   ', 0
     536F616B
     2054696D
     65202020
     00
0383 53657420   219   Txt_ReflT:    db 'Set Reflow Temp ', 0
     5265666C
     6F772054
     656D7020
     00
0394 53657420   220   Txt_ReflTime: db 'Set Reflow Time ', 0
     5265666C
     6F772054
     696D6520
     00
03A5            221   
03A5            222   ;                       1234567890123456
03A5 53657420   223   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
03B5 536F616B   224   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
03C0 5265666C   225   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
03CD 536F616B   226   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
03D8 5265666C   227   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03E5            228   
03E5 54656D70   229   String_temp_line:  db 'Temp: ', 0
     3A2000
03EC            230   
03EC            231   ;                     1234567890123456
03EC 52616D70   232   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03FC 536F616B   233   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
040C 52616D70   234   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
041C 5265666C   235   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
042C 436F6F6C   236   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
043C 50726F63   237   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
044C            238   
044C 20202020   239   String_Blank:    db '                ', 0
     20202020
     20202020
     20202020
     00
045D            240   
045D            241   ;-------------------------------------------------------------------------------
045D            242   ; Timers Setting:
045D            243   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
045D            244   ;   Timer 1: Serial port baud rate 57600 generator
045D            245   ;   Timer 2: 1ms interrupt for BCD counter increment/decrement
045D            246   ;-------------------------------------------------------------------------------
045D            247   ; Routine to initialize the ISR for Timer 0 ;
045D            248   Timer0_Init:
045D E589       249       mov a, TMOD
045F 54F0       250       anl a, #0xf0 ; Clear the bits for timer 0
0461 4401       251       orl a, #0x01 ; Configure timer 0 as 16-timer
0463 F589       252       mov TMOD, a
0465 758CFD     253       mov TH0, #high(TIMER0_RELOAD)
0468 758A5A     254       mov TL0, #low(TIMER0_RELOAD)
046B            255       ; Enable the timer and interrupts
046B D2A9       256       setb ET0  ; Enable timer 0 interrupt
046D            257       ; setb TR0  (no need to open at first)
046D 22         258       ret
046E            259   ; ISR for timer 0.  Set to execute every 1/4096Hz 
046E            260   ; to generate a 2048 Hz square wave at pin P1.5 
046E            261   Timer0_ISR:
046E            262       ;clr TF0  ; According to the data sheet this is done for us already.
046E 758CFD     263       mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
0471 758A5A     264       mov TL0, #low(TIMER0_RELOAD)
0474 B295       265       cpl SOUND_OUT ; Connect speaker to P1.5
0476 32         266       reti
0477            267   ; -----------------------------------------------------------------------------------------------;
0477            268   
0477            269   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
0477            270   Initialize_Serial_Port:
0477            271       ; Configure serial port and baud rate
0477 C28E       272       clr TR1 ; Disable timer 1
0479 53890F     273       anl TMOD, #0x0f ; Mask the bits for timer 1
047C 438920     274       orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
047F 438780     275       orl PCON, #80H ; Set SMOD to 1
0482 758DFD     276       mov TH1, #low(TIMER_1_RELOAD)
0485 758BFD     277       mov TL1, #low(TIMER_1_RELOAD) 
0488 D28E       278       setb TR1 ; Enable timer 1
048A 759852     279       mov SCON, #52H
048D 22         280       ret
048E            281   
048E            282   ; uart sending functions
048E            283   putchar:
048E 109902     284       jbc TI, putchar_L1
0491 80FB       285       sjmp putchar
0493            286   putchar_L1:
0493 F599       287       mov SBUF,a
0495 22         288       ret
0496            289   
0496            290   SendString:
0496 E4         291       clr a
0497 93         292       movc a, @a+dptr
0498 6006       293       jz SendString_L1
049A 12048E     294       lcall putchar
049D A3         295       inc dptr
049E 80F6       296       sjmp SendString  
04A0            297   SendString_L1:
04A0 22         298       ret
04A1            299   
04A1            300   ;------------------------------------------------------------
04A1            301   ; getchar_nb (non-blocking)
04A1            302   ; OUT: C=1 if got byte, A=byte
04A1            303   ;      C=0 if none
04A1            304   ;------------------------------------------------------------
04A1            305   getchar_nb:
04A1 309806     306       jnb RI, rx_none
04A4 E599       307       mov A, SBUF
04A6 C298       308       clr RI
04A8 D3         309       setb C
04A9 22         310       ret
04AA            311   rx_none:
04AA C3         312       clr C
04AB 22         313       ret
04AC            314   ;------------------------------------------------------------
04AC            315   ; Serial_RX_Pump
04AC            316   ; Builds a null-terminated line in rx_buf.
04AC            317   ; Sets rx_ready=1 when a full line received.
04AC            318   ;------------------------------------------------------------
04AC            319   Serial_RX_Pump:
04AC E540       320       mov A, rx_ready
04AE 7034       321       jnz rxp_done          ; don't overwrite unprocessed line
04B0            322   
04B0            323   rxp_more:
04B0 1204A1     324       lcall getchar_nb
04B3 502F       325       jnc rxp_done          ; no new byte
04B5 F5F0       326       mov B, A              ; save received byte
04B7            327   
04B7            328       ; ignore CR
04B7 B40D02     329       cjne A, #0DH, rxp_not_cr
04BA 80F4       330       sjmp rxp_more
04BC            331   
04BC            332   rxp_not_cr:
04BC            333       ; if LF -> finish line
04BC B40A0F     334       cjne A, #0AH, rxp_store
04BF            335   
04BF            336       ; terminate string
04BF E53F       337       mov A, rx_idx
04C1 2492       338       add A, #rx_buf
04C3 F8         339       mov R0, A
04C4 7600       340       mov @R0, #0
04C6 754001     341       mov rx_ready, #1
04C9 753F00     342       mov rx_idx, #0
04CC 8016       343       sjmp rxp_done
04CE            344   
04CE            345   rxp_store:
04CE            346       ; store char if room (max 39 chars)
04CE E53F       347       mov A, rx_idx
04D0 B42705     348       cjne A, #39, rxp_ok
04D3 753F00     349       mov rx_idx, #0        ; overflow: reset
04D6 800C       350       sjmp rxp_done
04D8            351   
04D8            352   rxp_ok:
04D8 E53F       353       mov A, rx_idx
04DA 2492       354       add A, #rx_buf
04DC F8         355       mov R0, A
04DD E5F0       356       mov A, B
04DF F6         357       mov @R0, A
04E0 053F       358       inc rx_idx
04E2 80CC       359       sjmp rxp_more
04E4            360   
04E4            361   rxp_done:
04E4 22         362       ret
04E5            363   ; copies 3 ASCII digits to buffer at R1, null terminates
04E5            364   ; R0 = src (first digit), R1 = dst
04E5            365   Copy3DigitsToBuf:
04E5 E6         366       mov A, @R0
04E6 F7         367       mov @R1, A
04E7 08         368       inc R0
04E8 09         369       inc R1
04E9 E6         370       mov A, @R0
04EA F7         371       mov @R1, A
04EB 08         372       inc R0
04EC 09         373       inc R1
04ED E6         374       mov A, @R0
04EE F7         375       mov @R1, A
04EF 09         376       inc R1
04F0 7700       377       mov @R1, #0
04F2 22         378       ret
04F3            379   
04F3            380   ; copies 4 ASCII digits to buffer at R1, null terminates
04F3            381   Copy4DigitsToBuf:
04F3 E6         382       mov A, @R0
04F4 F7         383       mov @R1, A
04F5 08         384       inc R0
04F6 09         385       inc R1
04F7 E6         386       mov A, @R0
04F8 F7         387       mov @R1, A
04F9 08         388       inc R0
04FA 09         389       inc R1
04FB E6         390       mov A, @R0
04FC F7         391       mov @R1, A
04FD 08         392       inc R0
04FE 09         393       inc R1
04FF E6         394       mov A, @R0
0500 F7         395       mov @R1, A
0501 09         396       inc R1
0502 7700       397       mov @R1, #0
0504 22         398       ret
0505            399   
0505            400   ;------------------------------------------------------------
0505            401   ; Serial_Process_Line
0505            402   ; Handles: S:TTT, K:MMSS, R:TTT, L:MMSS, CFG:APPLY, RUN:0/1
0505            403   ;------------------------------------------------------------
0505            404   Serial_Process_Line:
0505 E540       405       mov A, rx_ready
0507 7003       406       jnz SPL_HAVE
0509 020627     407       ljmp spl_done
050C            408   SPL_HAVE:
050C 754000     409       mov rx_ready, #0
050F            410   
050F 7892       411       mov R0, #rx_buf
0511            412   
0511            413   ; ---------------- S:TTT ----------------
0511 E6         414       mov A, @R0
0512 B45302     415       cjne A, #'S', S_NOT
0515 8003       416       sjmp S_MATCH
0517            417   S_NOT:
0517 02052D     418       ljmp chk_K
051A            419   
051A            420   S_MATCH:
051A 08         421       inc R0
051B E6         422       mov A, @R0
051C B43A02     423       cjne A, #':', S_BAD
051F 8003       424       sjmp S_GO
0521            425   S_BAD:
0521 020627     426       ljmp spl_done
0524            427   S_GO:
0524 08         428       inc R0
0525 7980       429       mov R1, #Buf_Soak_Temp
0527 1204E5     430       lcall Copy3DigitsToBuf
052A 020627     431       ljmp spl_done
052D            432   
052D            433   ; ---------------- K:MMSS ----------------
052D            434   chk_K:
052D 7892       435       mov R0, #rx_buf
052F E6         436       mov A, @R0
0530 B44B02     437       cjne A, #'K', K_NOT
0533 8003       438       sjmp K_MATCH
0535            439   K_NOT:
0535 02054B     440       ljmp chk_R
0538            441   
0538            442   K_MATCH:
0538 08         443       inc R0
0539 E6         444       mov A, @R0
053A B43A02     445       cjne A, #':', K_BAD
053D 8003       446       sjmp K_GO
053F            447   K_BAD:
053F 020627     448       ljmp spl_done
0542            449   K_GO:
0542 08         450       inc R0
0543 7984       451       mov R1, #Buf_Soak_Time
0545 1204F3     452       lcall Copy4DigitsToBuf
0548 020627     453       ljmp spl_done
054B            454   
054B            455   ; ---------------- R:TTT ----------------
054B            456   chk_R:
054B 7892       457       mov R0, #rx_buf
054D E6         458       mov A, @R0
054E B45202     459       cjne A, #'R', R_NOT
0551 8003       460       sjmp R_MATCH
0553            461   R_NOT:
0553 020569     462       ljmp chk_L
0556            463   
0556            464   R_MATCH:
0556 08         465       inc R0
0557 E6         466       mov A, @R0
0558 B43A02     467       cjne A, #':', R_BAD
055B 8003       468       sjmp R_GO
055D            469   R_BAD:
055D 020627     470       ljmp spl_done
0560            471   R_GO:
0560 08         472       inc R0
0561 7989       473       mov R1, #Buf_Refl_Temp
0563 1204E5     474       lcall Copy3DigitsToBuf
0566 020627     475       ljmp spl_done
0569            476   
0569            477   ; ---------------- L:MMSS ----------------
0569            478   chk_L:
0569 7892       479       mov R0, #rx_buf
056B E6         480       mov A, @R0
056C B44C02     481       cjne A, #'L', L_NOT
056F 8003       482       sjmp L_MATCH
0571            483   L_NOT:
0571 020587     484       ljmp chk_CFG
0574            485   
0574            486   L_MATCH:
0574 08         487       inc R0
0575 E6         488       mov A, @R0
0576 B43A02     489       cjne A, #':', L_BAD
0579 8003       490       sjmp L_GO
057B            491   L_BAD:
057B 020627     492       ljmp spl_done
057E            493   L_GO:
057E 08         494       inc R0
057F 798D       495       mov R1, #Buf_Refl_Time
0581 1204F3     496       lcall Copy4DigitsToBuf
0584 020627     497       ljmp spl_done
0587            498   
0587            499   ; ---------------- CFG:APPLY (loose) ----------------
0587            500   chk_CFG:
0587 7892       501       mov R0, #rx_buf
0589 E6         502       mov A, @R0
058A B44302     503       cjne A, #'C', CFG_NOT
058D 8003       504       sjmp CFG_C
058F            505   CFG_NOT:
058F 0205C4     506       ljmp chk_RUN
0592            507   
0592            508   CFG_C:
0592 08         509       inc R0
0593 E6         510       mov A, @R0
0594 B44602     511       cjne A, #'F', CFG_BAD
0597 8003       512       sjmp CFG_F
0599            513   CFG_BAD:
0599 0205C4     514       ljmp chk_RUN
059C            515   
059C            516   CFG_F:
059C 08         517       inc R0
059D E6         518       mov A, @R0
059E B44702     519       cjne A, #'G', CFG_BAD2
05A1 8003       520       sjmp CFG_G
05A3            521   CFG_BAD2:
05A3 0205C4     522       ljmp chk_RUN
05A6            523   
05A6            524   CFG_G:
05A6 08         525       inc R0
05A7 E6         526       mov A, @R0
05A8 B43A02     527       cjne A, #':', CFG_BAD3
05AB 8003       528       sjmp CFG_COLON
05AD            529   CFG_BAD3:
05AD 0205C4     530       ljmp chk_RUN
05B0            531   
05B0            532   CFG_COLON:
05B0 08         533       inc R0
05B1 E6         534       mov A, @R0
05B2 B44102     535       cjne A, #'A', CFG_BAD4
05B5 8003       536       sjmp CFG_APPLY
05B7            537   CFG_BAD4:
05B7 0205C4     538       ljmp chk_RUN
05BA            539   
05BA            540   CFG_APPLY:
05BA 120E74     541       lcall Update_FSM_Variables
05BD C200       542       clr  remote_config_mode
05BF D20D       543       setb state_change_signal   ; force LCD redraw
05C1            544       ; optional: lcall Update_Screen_Full  ; if you want parameter page redraw instantly
05C1 020627     545       ljmp spl_done
05C4            546   
05C4            547   
05C4            548   ; ---------------- RUN:0 / RUN:1 ----------------
05C4            549   chk_RUN:
05C4 7892       550       mov R0, #rx_buf
05C6 E6         551       mov A, @R0
05C7 B45202     552       cjne A, #'R', RUN_BAD
05CA 8003       553       sjmp RUN_R
05CC            554   RUN_BAD:
05CC 020627     555       ljmp spl_done
05CF            556   
05CF            557   RUN_R:
05CF 08         558       inc R0
05D0 E6         559       mov A, @R0
05D1 B45502     560       cjne A, #'U', RUN_BAD2
05D4 8003       561       sjmp RUN_U
05D6            562   RUN_BAD2:
05D6 020627     563       ljmp spl_done
05D9            564   
05D9            565   RUN_U:
05D9 08         566       inc R0
05DA E6         567       mov A, @R0
05DB B44E02     568       cjne A, #'N', RUN_BAD3
05DE 8003       569       sjmp RUN_N
05E0            570   RUN_BAD3:
05E0 020627     571       ljmp spl_done
05E3            572   
05E3            573   RUN_N:
05E3 08         574       inc R0
05E4 E6         575       mov A, @R0
05E5 B43A02     576       cjne A, #':', RUN_BAD4
05E8 8003       577       sjmp RUN_COLON
05EA            578   RUN_BAD4:
05EA 020627     579       ljmp spl_done
05ED            580   
05ED            581   RUN_COLON:
05ED 08         582       inc R0
05EE E6         583       mov A, @R0
05EF B43102     584       cjne A, #'1', RUN_NOT1
05F2 8003       585       sjmp RUN_1
05F4            586   RUN_NOT1:
05F4 020610     587       ljmp run_zero
05F7            588   
05F7            589   RUN_1:
05F7 C200       590       clr  remote_config_mode
05F9 756A00     591       mov Control_FSM_state, #0
05FC 756B00     592       mov Current_State, #0
05FF 753000     593       mov current_time_sec, #0
0602 753100     594       mov current_time_minute, #0
0605 D20D       595       setb state_change_signal
0607 D210       596       setb tc_startup_window
0609 C20F       597       clr  tc_missing_abort
060B D211       598       setb PB0_flag
060D 020627     599       ljmp spl_done
0610            600   
0610            601   
0610            602   run_zero:
0610 B43002     603       cjne A, #'0', RUN_BAD5
0613 8003       604       sjmp RUN_0
0615            605   RUN_BAD5:
0615 020627     606       ljmp spl_done
0618            607   
0618            608   RUN_0:
0618 C293       609       clr PWM_OUT
061A D20A       610       setb stop_signal
061C 756A00     611       mov Control_FSM_state, #0
061F 756B00     612       mov Current_State, #0
0622 D20D       613       setb state_change_signal
0624 020627     614       ljmp spl_done
0627            615   
0627            616   spl_done:
0627 22         617       ret
0628            618   
0628            619   
0628            620   ;-------------------------------------------------------------------------------
0628            621   ; serial debugging
0628            622   ; send a four byte number via serial to laptop
0628            623   ; need to be used with python script
0628            624   ; content needed to be sent should be stored in the varaible x
0628            625   ;-------------------------------------------------------------------------------
0628            626   Send32:
0628            627       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
0628 74AA       628       mov A, #0AAH
062A 12048E     629       lcall putchar
062D 7455       630       mov A, #055H
062F 12048E     631       lcall putchar
0632            632   
0632 E535       633       mov A, x+3
0634 12048E     634       lcall putchar
0637 E534       635       mov A, x+2
0639 12048E     636       lcall putchar
063C E533       637       mov A, x+1
063E 12048E     638       lcall putchar
0641 E532       639       mov A, x+0
0643 12048E     640       lcall putchar
0646            641   
0646 740A       642       mov A, #0AH
0648 12048E     643       lcall putchar
064B 22         644       ret
064C            645   ; -----------------------------------------------------------------------------------------------;
064C            646   
064C            647   ;-------------------------------------------------------------------------------
064C            648   ; Serial temperature line for PuTTY/screen
064C            649   ; Outputs: "Temp: XXXC\r\n"
064C            650   ;-------------------------------------------------------------------------------
064C            651   Serial_Send_Temp_Line:
064C 9003E5     652       mov dptr, #String_temp_line
064F 120496     653       lcall SendString
0652            654   
0652            655       ; Convert current_temp to BCD (same as LCD)
0652 854132     656       mov x, current_temp
0655 854233     657       mov x+1, current_temp+1
0658 854334     658       mov x+2, current_temp+2
065B 854435     659       mov x+3, current_temp+3
065E 12002E     660       lcall hex2bcd
0661            661   
0661 7F00       662       mov R7, #0          ; printed_flag = 0
0663            663   
0663            664       ; Print Hundreds (if non-zero)
0663 E53B       665       mov a, bcd+1
0665 540F       666       anl a, #0x0F
0667 6007       667       jz Serial_Skip_Hundreds
0669 2430       668       add a, #0x30
066B 12048E     669       lcall putchar
066E 7F01       670       mov R7, #1
0670            671   Serial_Skip_Hundreds:
0670            672   
0670            673       ; Print Tens (if non-zero or if hundreds already printed)
0670 E53A       674       mov a, bcd+0
0672 C4         675       swap a
0673 540F       676       anl a, #0x0F
0675 7003       677       jnz Serial_Print_Tens
0677 EF         678       mov a, R7
0678 600C       679       jz Serial_Skip_Tens
067A            680   Serial_Print_Tens:
067A E53A       681       mov a, bcd+0
067C C4         682       swap a
067D 540F       683       anl a, #0x0F
067F 2430       684       add a, #0x30
0681 12048E     685       lcall putchar
0684 7F01       686       mov R7, #1
0686            687   Serial_Skip_Tens:
0686            688   
0686            689       ; Print Ones (always)
0686 E53A       690       mov a, bcd+0
0688 540F       691       anl a, #0x0F
068A 2430       692       add a, #0x30
068C 12048E     693       lcall putchar
068F            694   
068F            695       ; Print 'C' and newline
068F 7443       696       mov a, #'C'
0691 12048E     697       lcall putchar
0694 740D       698       mov a, #0DH     ; CR
0696 12048E     699       lcall putchar
0699 740A       700       mov a, #0AH     ; LF
069B 12048E     701       lcall putchar
069E 22         702       ret
069F            703   
069F            704   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
069F              1   ;-------------------------------------------------------------------------------
069F              2   ; Timer2_ISR.inc
069F              3   ; Contains Initialization and ISR for the 1ms System Timer
069F              4   ;-------------------------------------------------------------------------------
069F              5   
069F              6   ;-------------------------------------------------------------------------------
069F              7   ; Routine to initialize the ISR for timer 2
069F              8   ;-------------------------------------------------------------------------------
069F              9   Timer2_Init:
069F 75C800      10       mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
06A2 75CDF5      11       mov TH2, #high(TIMER2_RELOAD)
06A5 75CC27      12       mov TL2, #low(TIMER2_RELOAD)
06A8             13       ; Set the reload value
06A8 75CBF5      14       mov RCAP2H, #high(TIMER2_RELOAD)
06AB 75CA27      15       mov RCAP2L, #low(TIMER2_RELOAD)
06AE             16       
06AE C2CF        17       clr TF2       ; Clear flag just in case
06B0             18       ; Enable the timer and interrupts
06B0 D2AD        19       setb ET2      ; Enable timer 2 interrupt
06B2 D2CA        20       setb TR2      ; Enable timer 2
06B4 22          21       ret
06B5             22   
06B5             23   ;-------------------------------------------------------------------------------
06B5             24   ; ISR for timer 2.  Runs every 1 ms
06B5             25   ;-------------------------------------------------------------------------------
06B5             26   Timer2_ISR:
06B5 C0E0        27       push acc
06B7 C0D0        28       push psw
06B9             29       
06B9 C2CF        30       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
06BB             31   
06BB             32       ; --- 1. Existing FSM Timers ---
06BB 0566        33       inc KEY1_DEB_timer
06BD 0567        34       inc SEC_FSM_timer
06BF D203        35       setb one_ms_pwm_flag 
06C1 D214        36       setb one_ms_beep_flag
06C3 D21F        37       setb one_millisecond_flag_servo
06C5             38   
06C5             39       ; --- 2. NEW: Non-Blocking Delay Counters ---
06C5             40       
06C5             41       ; A. BUTTON DELAY
06C5 30170B      42       jnb wait25_btn_active, T2_Check_Keypad
06C8 054D        43       inc wait25_btn_cnt
06CA E54D        44       mov a, wait25_btn_cnt
06CC B41904      45       cjne a, #25, T2_Check_Keypad
06CF D218        46       setb wait25_btn_done
06D1 C217        47       clr wait25_btn_active
06D3             48       
06D3             49       ; B. KEYPAD DELAY
06D3             50   T2_Check_Keypad:
06D3 30190B      51       jnb wait25_keypad_active, T2_Check_ADC
06D6 054E        52       inc wait25_keypad_cnt
06D8 E54E        53       mov a, wait25_keypad_cnt
06DA B41904      54       cjne a, #25, T2_Check_ADC
06DD D21A        55       setb wait25_keypad_done
06DF C219        56       clr wait25_keypad_active
06E1             57   
06E1             58       ; C. ADC DELAY (Thermocouple)
06E1             59   T2_Check_ADC:
06E1 301B0B      60       jnb wait25_adc_active, T2_Check_LCD
06E4 054F        61       inc wait25_adc_cnt
06E6 E54F        62       mov a, wait25_adc_cnt
06E8 B41904      63       cjne a, #25, T2_Check_LCD
06EB D21C        64       setb wait25_adc_done
06ED C21B        65       clr wait25_adc_active
06EF             66   
06EF             67       ; D. LCD DELAY
06EF             68   T2_Check_LCD:
06EF 301D0B      69       jnb wait25_lcd_active, T2_Check_Generic
06F2 0550        70       inc wait25_lcd_cnt
06F4 E550        71       mov a, wait25_lcd_cnt
06F6 B41904      72       cjne a, #25, T2_Check_Generic
06F9 D21E        73       setb wait25_lcd_done
06FB C21D        74       clr wait25_lcd_active
06FD             75   
06FD             76       ; E. GENERIC DELAY (Used by Wait_25ms in Main)
06FD             77   T2_Check_Generic:
06FD 30150B      78       jnb wait25_active, Timer2_ISR_done
0700 0551        79       inc wait25_count
0702 E551        80       mov a, wait25_count
0704 B41904      81       cjne a, #25, Timer2_ISR_done
0707 D216        82       setb wait25_done      ; Tells Wait_25ms that we are finished
0709 C215        83       clr wait25_active     ; Stop counting
070B             84   
070B             85   Timer2_ISR_done:
070B D0D0        86       pop psw
070D D0E0        87       pop acc
070F 32          88       reti
0710             89            
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
0710              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
0710              2   cseg
0710              3   
0710              4   ; When using a 33.333333MHz crystal clock
0710              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
0710              6   
0710              7   ;---------------------------------;
0710              8   ; Wait 40 microseconds            ;
0710              9   ;---------------------------------;
0710             10   Wait40uSec:
0710 C000        11            push AR0
0712 78BE        12            mov R0, #190
0714             13   L0: 
0714 00          14            nop
0715 00          15            nop
0716 00          16            nop
0717 00          17            nop
0718 D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
071A D000        19            pop AR0
071C 22          20       ret
071D             21   
071D             22   ;---------------------------------;
071D             23   ; Wait 'R2' milliseconds          ;
071D             24   ;---------------------------------;
                 25   Wait_Milli_Seconds mac
                 26   	push AR2
                 27   	mov R2, %0
                 28   	lcall ?Wait_Milli_Seconds
                 29   	pop AR2
                 30   endmac
071D             31   
071D             32   ?Wait_Milli_Seconds:
071D C000        33            push AR0
071F C001        34            push AR1
0721 7932        35   L3: mov R1, #50
0723 78DF        36   L2: mov R0, #223
0725 D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
0727 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
0729 DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
072B D001        40       pop AR1
072D D000        41       pop AR0
072F 22          42       ret
0730             43            
0730             44   ;---------------------------------;
0730             45   ; Toggles the 'E' pin in the LCD  ;
0730             46   ;---------------------------------;
0730             47   ELCD_pulse:
0730 D291        48            setb ELCD_E
0732 120710      49            lcall Wait40uSec
0735 C291        50            clr ELCD_E
0737 120710      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
073A 22          52       ret
073B             53   
073B             54   ;---------------------------------;
073B             55   ; Writes acc to LCD in 4-bit mode ;
073B             56   ;---------------------------------;
073B             57   ELCD_byte:
073B             58            ; Write high 4 bits first
073B A2E7        59            mov c, ACC.7
073D 9281        60            mov ELCD_D7, c
073F A2E6        61            mov c, ACC.6
0741 9283        62            mov ELCD_D6, c
0743 A2E5        63            mov c, ACC.5
0745 9285        64            mov ELCD_D5, c
0747 A2E4        65            mov c, ACC.4
0749 9287        66            mov ELCD_D4, c
074B 120730      67       lcall ELCD_pulse
074E             68            ; Write low 4 bits next
074E A2E3        69            mov c, ACC.3
0750 9281        70            mov ELCD_D7, c
0752 A2E2        71            mov c, ACC.2
0754 9283        72            mov ELCD_D6, c
0756 A2E1        73            mov c, ACC.1
0758 9285        74            mov ELCD_D5, c
075A A2E0        75            mov c, ACC.0
075C 9287        76            mov ELCD_D4, c
075E 120730      77       lcall ELCD_pulse
0761 22          78            ret
0762             79   
0762             80   ;---------------------------------;
0762             81   ; Write data to LCD               ;
0762             82   ;---------------------------------;
                 83   WriteData mac
                 84   	mov a, %0
                 85   	lcall ?WriteData
                 86   endmac
0762             87            
0762             88   ?WriteData:
0762 D297        89            setb ELCD_RS
0764 02073B      90            ljmp ELCD_byte
0767             91   
0767             92   ;---------------------------------;
0767             93   ; Write command to LCD            ;
0767             94   ;---------------------------------;
                 95   WriteCommand mac
                 96   	mov a, %0
                 97   	lcall ?WriteCommand
                 98   endmac
0767             99   
0767            100   ?WriteCommand:
0767 C297       101            clr ELCD_RS
0769 02073B     102            ljmp ELCD_byte
076C            103   
076C            104   ;---------------------------------;
076C            105   ; Configure LCD in 4-bit mode     ;
076C            106   ;---------------------------------;
076C            107   ELCD_4BIT:
076C C291       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
076E            109            ;clr ELCD_RW  ; RW forced to zero
076E            110            
076E            111            ; After power on, let the LCD start up before initializing
076E C002       112            push AR2
0770 7A28       112            mov R2, #40
0772 12071D     112            lcall ?Wait_Milli_Seconds
0775 D002       112            pop AR2
0777            113            
0777            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
0777 7433       115            mov a, #0x33
0779 120767     115            lcall ?WriteCommand
077C 7433       116            mov a, #0x33
077E 120767     116            lcall ?WriteCommand
0781 7432       117            mov a, #0x32
0783 120767     117            lcall ?WriteCommand ; change to 4-bit mode
0786            118   
0786            119            ; Configure the LCD
0786 7428       120            mov a, #0x28
0788 120767     120            lcall ?WriteCommand
078B 740C       121            mov a, #0x0c
078D 120767     121            lcall ?WriteCommand
0790 7401       122            mov a, #0x01
0792 120767     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
0795            123   
0795            124       ;Wait for the clear screen command to finish.
0795 C002       125            push AR2
0797 7A02       125            mov R2, #2
0799 12071D     125            lcall ?Wait_Milli_Seconds
079C D002       125            pop AR2
079E 22         126       ret
079F            127   
079F            128   ;---------------------------------;
079F            129   ; Send a constant string to LCD   ;
079F            130   ;---------------------------------;
                131   Send_Constant_String mac
                132   	push dph
                133   	push dpl
                134   	push acc
                135   	mov dptr, %0
                136   	lcall ?Send_Constant_String
                137   	pop acc
                138   	pop dpl
                139   	pop dph
                140   endmac
079F            141   
079F            142   ?Send_Constant_String:
079F E4         143       clr a
07A0 93         144       movc a, @a+dptr
07A1 6006       145       jz ?Send_Constant_String_Done
07A3 120762     146       lcall ?WriteData
07A6 A3         147       inc dptr
07A7 80F6       148       sjmp ?Send_Constant_String
07A9            149   ?Send_Constant_String_Done:
07A9 22         150       ret  
07AA            151   
07AA            152   ;---------------------------------;
07AA            153   ; Set LCD cursor at row, column   ;
07AA            154   ;---------------------------------;
                155   Set_Cursor mac
                156   	push acc
                157   	mov a, #%1
                158   	dec a
                159   	lcall ?Set_Cursor_%0 ; Select column and row
                160   	pop acc
                161   endmac
07AA            162   
07AA            163   ?Set_Cursor_2:
07AA 4440       164            orl a, #01000000B
07AC            165   ?Set_Cursor_1:
07AC 4480       166            orl a, #10000000B
07AE 020767     167            ljmp ?WriteCommand ; Select column and row
07B1            168   
07B1            169   ;---------------------------------;
07B1            170   ; Display a BCD number in the LCD ;
07B1            171   ;---------------------------------;
                172   Display_BCD mac
                173   	push ar0
                174   	mov r0, %0
                175   	lcall ?Display_BCD
                176   	pop ar0
                177   endmac
07B1            178   
07B1            179   ?Display_BCD:
07B1 C0E0       180            push acc
07B3            181            ; Write most significant digit
07B3 E8         182            mov a, r0
07B4 C4         183            swap a
07B5 540F       184            anl a, #0fh
07B7 4430       185            orl a, #30h
07B9 120762     186            lcall ?WriteData
07BC            187            ; write least significant digit
07BC E8         188            mov a, r0
07BD 540F       189            anl a, #0fh
07BF 4430       190            orl a, #30h
07C1 120762     191            lcall ?WriteData
07C4 D0E0       192            pop acc
07C6 22         193            ret
07C7            194   
07C7            195   ;------------------------------------;
07C7            196   ; Display a char in the LCD          ;
07C7            197   ;------------------------------------;
                198   Display_char mac
                199   	push acc
                200   	mov a, %0
                201   	lcall ?WriteData
                202   	pop acc
                203   endmac
07C7            204   
07C7            707            ;-----------------------------------------------------------------------------------------------;
07C7            708   
07C7            709   ;-------------------------------------------------------------------------------
07C7            710   ; Display Function for 7-segment displays       
07C7            711   ;-------------------------------------------------------------------------------
07C7            712   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
07C7            713   T_7seg:
07C7 C0F9A4B0   714       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
07CC 9282F880   715       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
07D1 8883C6A1   716       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
07D7            717   
07D7            718   ; Displays a BCD number pased in R0 in HEX5-HEX0
07D7            719   Display_BCD_7_Seg_HEX10:
07D7 9007C7     720       mov dptr, #T_7seg
07DA E8         721       mov a, R0
07DB C4         722       swap a
07DC 540F       723       anl a, #0FH
07DE 93         724       movc a, @a+dptr
07DF F592       725       mov HEX1, a
07E1 E8         726       mov a, R0
07E2 540F       727       anl a, #0FH
07E4 93         728       movc a, @a+dptr
07E5 F591       729       mov HEX0, a
07E7 22         730       ret
07E8            731   
07E8            732   Display_BCD_7_Seg_HEX32:
07E8 9007C7     733       mov dptr, #T_7seg
07EB E8         734       mov a, R0
07EC C4         735       swap a
07ED 540F       736       anl a, #0FH
07EF 93         737       movc a, @a+dptr
07F0 F594       738       mov HEX3, a
07F2 E8         739       mov a, R0
07F3 540F       740       anl a, #0FH
07F5 93         741       movc a, @a+dptr
07F6 F593       742       mov HEX2, a
07F8 22         743       ret
07F9            744   
07F9            745   Display_BCD_7_Seg_HEX54:
07F9 9007C7     746       mov dptr, #T_7seg
07FC E8         747       mov a, R0
07FD C4         748       swap a
07FE 540F       749       anl a, #0FH
0800 93         750       movc a, @a+dptr
0801 F58F       751       mov HEX5, a
0803 E8         752       mov a, R0
0804 540F       753       anl a, #0FH
0806 93         754       movc a, @a+dptr
0807 F58E       755       mov HEX4, a
0809 22         756       ret
080A            757   
080A            758   ; The 8-bit hex number passed in the accumulator is converted to
080A            759   ; BCD and stored in [R1, R0]
080A            760   Hex_to_bcd_8bit:
080A 75F064     761       mov b, #100
080D 84         762       div ab
080E F9         763       mov R1, a   ; After dividing, a has the 100s
080F E5F0       764       mov a, b    ; Remainder is in register b
0811 75F00A     765       mov b, #10
0814 84         766       div ab ; The tens are stored in a, the units are stored in b 
0815 C4         767       swap a
0816 54F0       768       anl a, #0xf0
0818 45F0       769       orl a, b
081A F8         770       mov R0, a
081B 22         771       ret
081C            772   ;-------------------------------------------------------------------------------
081C            773   ; Display Function for LCD                      
081C            774   ;-------------------------------------------------------------------------------
081C            775   LCD_Print_2Digits:
081C 12080A     776       lcall Hex_to_bcd_8bit
081F E8         777       mov a, R0
0820 C4         778       swap a
0821 540F       779       anl a, #0x0F
0823 2430       780       add a, #0x30
0825 120762     781       lcall ?WriteData
0828 E8         782       mov a, R0
0829 540F       783       anl a, #0x0F
082B 2430       784       add a, #0x30
082D 120762     785       lcall ?WriteData
0830 22         786       ret
0831            787   
0831            788   LCD_Display_Update_func:
0831 C0E0       789       push acc
0833            790       
0833            791       ; ==========================================
0833            792       ; PART 1: STATIC TEXT (Title)
0833            793       ; Runs ONLY when the state changes
0833            794       ; ==========================================
0833            795       
0833            796       ; [FIX] "Trampoline" logic for long distance jump
0833            797       ; If signal is SET (1), we stay here and update.
0833            798       ; If signal is CLEAR (0), we Long Jump to the Live Update section.
0833 200D03     799       jb state_change_signal, Do_Static_Update
0836 02096F     800       ljmp Check_Live_Update
0839            801   
0839            802   Do_Static_Update:
0839 C20D       803       clr state_change_signal
083B            804       
083B            805       ; State Changed: Clear Screen and Write Title
083B 1211B0     806       lcall Clear_Screen_Func
083E E56A       807       mov a, Control_FSM_state
0840            808       
0840            809       ; State 0: Welcome
0840 B4003B     810       cjne a, #0, LCD_Check_1
0843 C0E0       811            push acc
0845 7401       811            mov a, #1
0847 14         811            dec a
0848 1207AC     811            lcall ?Set_Cursor_1 ; Select column and row
084B D0E0       811            pop acc
084D C083       812            push dph
084F C082       812            push dpl
0851 C0E0       812            push acc
0853 900330     812            mov dptr, #String_state0_1
0856 12079F     812            lcall ?Send_Constant_String
0859 D0E0       812            pop acc
085B D082       812            pop dpl
085D D083       812            pop dph
085F C0E0       813            push acc
0861 7401       813            mov a, #1
0863 14         813            dec a
0864 1207AA     813            lcall ?Set_Cursor_2 ; Select column and row
0867 D0E0       813            pop acc
0869 C083       814            push dph
086B C082       814            push dpl
086D C0E0       814            push acc
086F 900340     814            mov dptr, #String_state0_2
0872 12079F     814            lcall ?Send_Constant_String
0875 D0E0       814            pop acc
0877 D082       814            pop dpl
0879 D083       814            pop dph
087B 02096C     815       ljmp LCD_Done_Bridge ; Exit
087E            816   
087E            817   LCD_Check_1: ; Setup
087E B4011F     818       cjne a, #1, LCD_Check_2
0881 C0E0       819            push acc
0883 7401       819            mov a, #1
0885 14         819            dec a
0886 1207AC     819            lcall ?Set_Cursor_1 ; Select column and row
0889 D0E0       819            pop acc
088B C083       820            push dph
088D C082       820            push dpl
088F C0E0       820            push acc
0891 9003A5     820            mov dptr, #String_state1
0894 12079F     820            lcall ?Send_Constant_String
0897 D0E0       820            pop acc
0899 D082       820            pop dpl
089B D083       820            pop dph
089D 02096C     821       ljmp LCD_Done_Bridge
08A0            822   
08A0            823   LCD_Check_2: ; Ramp to Soak
08A0 B4021F     824       cjne a, #2, LCD_Check_3
08A3 C0E0       825            push acc
08A5 7401       825            mov a, #1
08A7 14         825            dec a
08A8 1207AC     825            lcall ?Set_Cursor_1 ; Select column and row
08AB D0E0       825            pop acc
08AD C083       826            push dph
08AF C082       826            push dpl
08B1 C0E0       826            push acc
08B3 9003EC     826            mov dptr, #String_state2
08B6 12079F     826            lcall ?Send_Constant_String
08B9 D0E0       826            pop acc
08BB D082       826            pop dpl
08BD D083       826            pop dph
08BF 02098F     827       ljmp LCD_Update_Temp_Value ; Draw Temp immediately!
08C2            828   
08C2            829   LCD_Check_3: ; Soak
08C2 B4031F     830       cjne a, #3, LCD_Check_4
08C5 C0E0       831            push acc
08C7 7401       831            mov a, #1
08C9 14         831            dec a
08CA 1207AC     831            lcall ?Set_Cursor_1 ; Select column and row
08CD D0E0       831            pop acc
08CF C083       832            push dph
08D1 C082       832            push dpl
08D3 C0E0       832            push acc
08D5 9003FC     832            mov dptr, #String_state3
08D8 12079F     832            lcall ?Send_Constant_String
08DB D0E0       832            pop acc
08DD D082       832            pop dpl
08DF D083       832            pop dph
08E1 02098F     833       ljmp LCD_Update_Temp_Value
08E4            834   
08E4            835   LCD_Check_4: ; Ramp to Peak
08E4 B4041F     836       cjne a, #4, LCD_Check_5
08E7 C0E0       837            push acc
08E9 7401       837            mov a, #1
08EB 14         837            dec a
08EC 1207AC     837            lcall ?Set_Cursor_1 ; Select column and row
08EF D0E0       837            pop acc
08F1 C083       838            push dph
08F3 C082       838            push dpl
08F5 C0E0       838            push acc
08F7 90040C     838            mov dptr, #String_state4
08FA 12079F     838            lcall ?Send_Constant_String
08FD D0E0       838            pop acc
08FF D082       838            pop dpl
0901 D083       838            pop dph
0903 02098F     839       ljmp LCD_Update_Temp_Value
0906            840   
0906            841   LCD_Check_5: ; Reflow
0906 B4051F     842       cjne a, #5, LCD_Check_6
0909 C0E0       843            push acc
090B 7401       843            mov a, #1
090D 14         843            dec a
090E 1207AC     843            lcall ?Set_Cursor_1 ; Select column and row
0911 D0E0       843            pop acc
0913 C083       844            push dph
0915 C082       844            push dpl
0917 C0E0       844            push acc
0919 90041C     844            mov dptr, #String_state5
091C 12079F     844            lcall ?Send_Constant_String
091F D0E0       844            pop acc
0921 D082       844            pop dpl
0923 D083       844            pop dph
0925 02098F     845       ljmp LCD_Update_Temp_Value
0928            846   
0928            847   LCD_Check_6: ; Cooling
0928 B4061F     848       cjne a, #6, LCD_Check_7
092B C0E0       849            push acc
092D 7401       849            mov a, #1
092F 14         849            dec a
0930 1207AC     849            lcall ?Set_Cursor_1 ; Select column and row
0933 D0E0       849            pop acc
0935 C083       850            push dph
0937 C082       850            push dpl
0939 C0E0       850            push acc
093B 90042C     850            mov dptr, #String_state6
093E 12079F     850            lcall ?Send_Constant_String
0941 D0E0       850            pop acc
0943 D082       850            pop dpl
0945 D083       850            pop dph
0947 02098F     851       ljmp LCD_Update_Temp_Value
094A            852   
094A            853   LCD_Check_7: ; Done
094A            854       ; [FIX] Check distance safe logic for State 7
094A B4071F     855       cjne a, #7, LCD_Done_Bridge ; If not 7, we are done
094D C0E0       856            push acc
094F 7401       856            mov a, #1
0951 14         856            dec a
0952 1207AC     856            lcall ?Set_Cursor_1 ; Select column and row
0955 D0E0       856            pop acc
0957 C083       857            push dph
0959 C082       857            push dpl
095B C0E0       857            push acc
095D 90043C     857            mov dptr, #String_state7
0960 12079F     857            lcall ?Send_Constant_String
0963 D0E0       857            pop acc
0965 D082       857            pop dpl
0967 D083       857            pop dph
0969 02096C     858       ljmp LCD_Done_Bridge
096C            859   
096C            860   ; Local bridge to reach the far-away LCD_Done
096C            861   LCD_Done_Bridge:
096C 0209F0     862       ljmp LCD_Done
096F            863   
096F            864   ; ==========================================
096F            865   ; PART 2: DYNAMIC VALUES (Temperature)
096F            866   ; Runs every time 'one_second_flag' is set
096F            867   ; ==========================================
096F            868   Check_Live_Update:
096F 3002FA     869       jnb one_second_flag, LCD_Done_Bridge
0972 C202       870       clr one_second_flag
0974            871       
0974            872       ; Only update temp for States 2, 3, 4, 5, 6
0974 E56A       873       mov a, Control_FSM_state
0976 B40202     874       cjne a, #2, Check_St3
0979 8014       875       sjmp LCD_Update_Temp_Value
097B            876   Check_St3:
097B B40302     877       cjne a, #3, Check_St4
097E 800F       878       sjmp LCD_Update_Temp_Value
0980            879   Check_St4:
0980 B40402     880       cjne a, #4, Check_St5
0983 800A       881       sjmp LCD_Update_Temp_Value
0985            882   Check_St5:
0985 B40502     883       cjne a, #5, Check_St6
0988 8005       884       sjmp LCD_Update_Temp_Value
098A            885   Check_St6:
098A B40663     886       cjne a, #6, LCD_Done
098D 8000       887       sjmp LCD_Update_Temp_Value
098F            888   
098F            889   ; --- HELPER: Prints "XXX C" on Line 2 ---
098F            890   LCD_Update_Temp_Value:
098F C0E0       891            push acc
0991 7401       891            mov a, #1
0993 14         891            dec a
0994 1207AA     891            lcall ?Set_Cursor_2 ; Select column and row
0997 D0E0       891            pop acc
0999            892       
0999            893       ; Convert current_temp to BCD
0999 854132     894       mov x, current_temp
099C 854233     895       mov x+1, current_temp+1
099F 854334     896       mov x+2, current_temp+2
09A2 854435     897       mov x+3, current_temp+3
09A5 12002E     898       lcall hex2bcd
09A8            899   
09A8            900       ; Update HEX2-HEX0 with temperature
09A8 1209F3     901       lcall Update_HEX_Temp
09AB            902       
09AB            903       ; Print Hundreds
09AB E53B       904       mov a, bcd+1
09AD 540F       905       anl a, #0x0F
09AF 2430       906       add a, #0x30
09B1 120762     907       lcall ?WriteData
09B4            908       
09B4            909       ; Print Tens
09B4 E53A       910       mov a, bcd+0
09B6 C4         911       swap a
09B7 540F       912       anl a, #0x0F
09B9 2430       913       add a, #0x30
09BB 120762     914       lcall ?WriteData
09BE            915       
09BE            916       ; Print Ones
09BE E53A       917       mov a, bcd+0
09C0 540F       918       anl a, #0x0F
09C2 2430       919       add a, #0x30
09C4 120762     920       lcall ?WriteData
09C7            921       
09C7            922       ; Print 'C'
09C7 7443       923       mov a, #'C'
09C9 120762     924       lcall ?WriteData
09CC            925       
09CC            926       ; Clear remaining line space (prevents garbage)
09CC 7420       927       mov a, #' '
09CE 120762     928       lcall ?WriteData
09D1 120762     929       lcall ?WriteData
09D4            930   
09D4            931       ; Print time MM:SS at bottom right
09D4 C0E0       932            push acc
09D6 740C       932            mov a, #12
09D8 14         932            dec a
09D9 1207AA     932            lcall ?Set_Cursor_2 ; Select column and row
09DC D0E0       932            pop acc
09DE E531       933       mov a, current_time_minute
09E0 12081C     934       lcall LCD_Print_2Digits
09E3 743A       935       mov a, #':'
09E5 120762     936       lcall ?WriteData
09E8 E530       937       mov a, current_time_sec
09EA 12081C     938       lcall LCD_Print_2Digits
09ED            939   
09ED            940       ; Mirror temp to serial (PuTTY/screen)
09ED 12064C     941       lcall Serial_Send_Temp_Line
09F0            942   
09F0            943   LCD_Done:
09F0 D0E0       944       pop acc
09F2 22         945       ret
09F3            946   ;---------------------------------------------------------
09F3            947   
09F3            948   ;-------------------------------------------------------------------------------
09F3            949   ; Update HEX2-HEX0 with temperature (3 digits)
09F3            950   ;-------------------------------------------------------------------------------
09F3            951   Update_HEX_Temp:
09F3 9007C7     952       mov dptr, #T_7seg
09F6            953       ; Hundreds -> HEX2
09F6 E53B       954       mov a, bcd+1
09F8 540F       955       anl a, #0x0F
09FA 93         956       movc a, @a+dptr
09FB F593       957       mov HEX2, a
09FD            958       ; Tens -> HEX1
09FD E53A       959       mov a, bcd+0
09FF C4         960       swap a
0A00 540F       961       anl a, #0x0F
0A02 93         962       movc a, @a+dptr
0A03 F592       963       mov HEX1, a
0A05            964       ; Ones -> HEX0
0A05 E53A       965       mov a, bcd+0
0A07 540F       966       anl a, #0x0F
0A09 93         967       movc a, @a+dptr
0A0A F591       968       mov HEX0, a
0A0C 22         969       ret
0A0D            970   
0A0D            971   KEY1_DEB:
0A0D            972   ;non-blocking state machine for KEY1 debounce
0A0D E568       973       mov a, KEY1_DEB_state
0A0F            974   KEY1_DEB_state0:
0A0F B4000A     975       cjne a, #0, KEY1_DEB_state1
0A12 20F92D     976       jb KEY.1, KEY1_DEB_done
0A15 756600     977       mov KEY1_DEB_timer, #0
0A18 0568       978       inc KEY1_DEB_state
0A1A 8026       979       sjmp KEY1_DEB_done
0A1C            980   KEY1_DEB_state1:
0A1C B40109     981       cjne a, #1, KEY1_DEB_state2
0A1F            982       ; this is the debounce state
0A1F E566       983       mov a, KEY1_DEB_timer
0A21 B4321E     984       cjne a, #50, KEY1_DEB_done ; 50 ms passed?
0A24 0568       985       inc KEY1_DEB_state
0A26 801A       986       sjmp KEY1_DEB_done  
0A28            987   KEY1_DEB_state2:
0A28 B4020C     988       cjne a, #2, KEY1_DEB_state3
0A2B 20F904     989       jb KEY.1, KEY1_DEB_state2b
0A2E 0568       990       inc KEY1_DEB_state
0A30 8010       991       sjmp KEY1_DEB_done  
0A32            992   KEY1_DEB_state2b:
0A32 756800     993       mov KEY1_DEB_state, #0
0A35 800B       994       sjmp KEY1_DEB_done
0A37            995   KEY1_DEB_state3:
0A37 B40308     996       cjne a, #3, KEY1_DEB_done
0A3A 30F905     997       jnb KEY.1, KEY1_DEB_done
0A3D D20E       998       setb Key1_flag ; Suscesfully detected a valid KEY1 press/release
0A3F 756800     999       mov KEY1_DEB_state, #0  
0A42           1000   KEY1_DEB_done:
0A42 22        1001       ret
0A43           1002   ; ------------------------------------------------------------------------------
0A43           1003   ; Non-blocking FSM for the one second counter
0A43           1004   ;-------------------------------------------------------------------------------
0A43           1005   SEC_FSM:
0A43 E569      1006       mov a, SEC_FSM_state
0A45           1007   SEC_FSM_state0:
0A45 B4000C    1008       cjne a, #0, SEC_FSM_state1
0A48 E567      1009       mov a, SEC_FSM_timer
0A4A B4FA4B    1010       cjne a, #250, SEC_FSM_done ; 250 ms passed?
0A4D 756700    1011       mov SEC_FSM_timer, #0
0A50 0569      1012       inc SEC_FSM_state
0A52 8044      1013       sjmp SEC_FSM_done
0A54           1014   SEC_FSM_state1: 
0A54 B4010E    1015       cjne a, #1, SEC_FSM_state2
0A57 D2E9      1016       setb LEDRA.1
0A59 E567      1017       mov a, SEC_FSM_timer
0A5B B4FA3A    1018       cjne a, #250, SEC_FSM_done ; 250 ms passed?
0A5E 756700    1019       mov SEC_FSM_timer, #0
0A61 0569      1020       inc SEC_FSM_state
0A63 8033      1021       sjmp SEC_FSM_done
0A65           1022   SEC_FSM_state2: 
0A65 B4020E    1023       cjne a, #2, SEC_FSM_state3
0A68 D2EA      1024       setb LEDRA.2
0A6A E567      1025       mov a, SEC_FSM_timer
0A6C B4FA29    1026       cjne a, #250, SEC_FSM_done ; 250 ms passed?
0A6F 756700    1027       mov SEC_FSM_timer, #0
0A72 0569      1028       inc SEC_FSM_state
0A74 8022      1029       sjmp SEC_FSM_done
0A76           1030   SEC_FSM_state3: 
0A76 B4031F    1031       cjne a, #3, SEC_FSM_done
0A79 D2EB      1032       setb LEDRA.3
0A7B E567      1033       mov a, SEC_FSM_timer
0A7D B4FA18    1034       cjne a, #250, SEC_FSM_done ; 250 ms passed?
0A80 756700    1035       mov SEC_FSM_timer, #0
0A83 756900    1036       mov SEC_FSM_state, #0
0A86           1037       
0A86           1038       ; --- 1 Second has passed! ---
0A86 D202      1039       setb one_second_flag
0A88           1040       
0A88 E530      1041       mov a, current_time_sec
0A8A B43B07    1042       cjne a, #59, IncCurrentTimeSec 
0A8D           1043       
0A8D           1044       ; --- FIX: 59s -> 0s AND Increment Minute ---
0A8D 753000    1045       mov current_time_sec, #0
0A90 0531      1046       inc current_time_minute    ; <--- YOU WERE MISSING THIS!
0A92           1047       ; -------------------------------------------
0A92           1048       
0A92 8004      1049       sjmp SEC_FSM_done
0A94           1050   
0A94           1051   IncCurrentTimeSec:
0A94 0530      1052       inc current_time_sec
0A96 B2E8      1053       cpl LEDRA.0 
0A98           1054   SEC_FSM_done:
0A98 22        1055       ret
0A99           1056   ;-------------------------------------------------------------------------------
0A99           1057   ; PWM
0A99           1058   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0A99           1059   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0A99           1060   ; ------------------------------------------------------------------------------
0A99           1061   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0A99 100302    1062       jbc one_ms_pwm_flag, pwm_wave_generator
0A9C 8071      1063       sjmp end_pwm_generator
0A9E           1064   
0A9E           1065   pwm_wave_generator:
0A9E C201      1066       clr mf
0AA0           1067       ; move pwm counter value into x for comparison purpose
0AA0 856232    1068       mov x, pwm_counter
0AA3 856333    1069       mov x+1, pwm_counter+1
0AA6 856434    1070       mov x+2, pwm_counter+2
0AA9 856535    1071       mov x+3, pwm_counter+3
0AAC           1072   
0AAC 7536DB    1073            mov y+0, #low (PWM_PERIOD % 0x10000) 
0AAF 753705    1073            mov y+1, #high(PWM_PERIOD % 0x10000) 
0AB2 753800    1073            mov y+2, #low (PWM_PERIOD / 0x10000) 
0AB5 753900    1073            mov y+3, #high(PWM_PERIOD / 0x10000) 
0AB8           1074   
0AB8           1075       ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
0AB8           1076       ; increase x by 1
0AB8 120152    1077       lcall x_eq_y 
0ABB 20011D    1078       jb mf, wrap_pwm_counter
0ABE           1079       ; x not equal 1499, increment by 1
0ABE 753601    1080            mov y+0, #low (1 % 0x10000) 
0AC1 753700    1080            mov y+1, #high(1 % 0x10000) 
0AC4 753800    1080            mov y+2, #low (1 / 0x10000) 
0AC7 753900    1080            mov y+3, #high(1 / 0x10000) 
0ACA 1200D3    1081       lcall add32
0ACD           1082       ; update pwm_counter
0ACD 853262    1083       mov pwm_counter, x
0AD0 853363    1084       mov pwm_counter+1, x+1
0AD3 853464    1085       mov pwm_counter+2, x+2
0AD6 853565    1086       mov pwm_counter+3, x+3
0AD9 8018      1087       sjmp set_pwm
0ADB           1088   
0ADB           1089   wrap_pwm_counter:
0ADB           1090       ; x equal 1499, wrap to 0
0ADB 753200    1091            mov x+0, #low (0 % 0x10000) 
0ADE 753300    1091            mov x+1, #high(0 % 0x10000) 
0AE1 753400    1091            mov x+2, #low (0 / 0x10000) 
0AE4 753500    1091            mov x+3, #high(0 / 0x10000) 
0AE7 853262    1092       mov pwm_counter, x
0AEA 853363    1093       mov pwm_counter+1, x+1
0AED 853464    1094       mov pwm_counter+2, x+2
0AF0 853565    1095       mov pwm_counter+3, x+3
0AF3           1096   
0AF3           1097   set_pwm:
0AF3           1098       ; compare with power_output, if pwm counter smaller than power_output, 
0AF3           1099       ; set pwm pin high; else set pwm pin low load y with power output value
0AF3 855E36    1100       mov y, power_output
0AF6 855F37    1101       mov y+1, power_output+1
0AF9 856038    1102       mov y+2, power_output+2
0AFC 856139    1103       mov y+3, power_output+3
0AFF           1104   
0AFF           1105       ; compare x(pwm counter) with y(power output)
0AFF 12011A    1106       lcall x_lt_y
0B02 200106    1107       jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
0B05           1108       ;output set pwm pin low if pwm counter greater than power output
0B05 C293      1109       clr PWM_OUT
0B07 C2EC      1110       clr LEDRA.4
0B09 8004      1111       sjmp end_pwm_generator
0B0B           1112   
0B0B           1113   set_pwm_high:
0B0B D293      1114       setb PWM_OUT
0B0D D2EC      1115       setb LEDRA.4
0B0F           1116   
0B0F           1117   end_pwm_generator:
0B0F 22        1118       ret
0B10           1119   
0B10           1120   ;-------------------------------------------------------------------------------;
0B10           1121   ; Temp_Compare
0B10           1122   ; Checks if we have reached the user's target temperatures.
0B10           1123   ; Sets 'soak_temp_reached' if current_temp >= soak_temp
0B10           1124   ; Sets 'reflow_temp_reached' if current_temp >= reflow_temp
0B10           1125   ;-------------------------------------------------------------------------------;
0B10           1126   Temp_Compare:
0B10           1127       ; Reset flags initially
0B10 C204      1128       clr soak_temp_reached
0B12 C205      1129       clr reflow_temp_reached
0B14           1130   
0B14 C0E0      1131       push acc
0B16 C0D0      1132       push psw
0B18 C000      1133       push AR0
0B1A C001      1134       push AR1
0B1C C002      1135       push AR2
0B1E           1136       
0B1E           1137       ; --- 1. CHECK SOAK TEMP ---
0B1E           1138       ; Copy current_temp to X
0B1E 7841      1139       mov R0, #current_temp
0B20 7932      1140       mov R1, #x
0B22 120B96    1141       lcall Copy4_Bytes_R0_to_R1
0B25           1142   
0B25           1143       ; Copy soak_temp to Y
0B25 7845      1144       mov R0, #soak_temp
0B27 7936      1145       mov R1, #y
0B29 120B96    1146       lcall Copy4_Bytes_R0_to_R1
0B2C           1147   
0B2C           1148       ; Compare: Is X (Current) < Y (Target)?
0B2C 12011A    1149       lcall x_lt_y
0B2F 200102    1150       jb mf, Check_Reflow_Threshold ; If Current < Target, jump (Flag stays 0)
0B32           1151       
0B32           1152       ; If we are here, Current >= Target
0B32 D204      1153       setb soak_temp_reached
0B34           1154   
0B34           1155   Check_Reflow_Threshold:
0B34           1156       ; --- 2. CHECK REFLOW TEMP ---
0B34           1157       ; Copy current_temp to X (Need to reload X because math32 destroys it)
0B34 7841      1158       mov R0, #current_temp
0B36 7932      1159       mov R1, #x
0B38 120B96    1160       lcall Copy4_Bytes_R0_to_R1
0B3B           1161   
0B3B           1162       ; Copy reflow_temp to Y
0B3B 7849      1163       mov R0, #reflow_temp
0B3D 7936      1164       mov R1, #y
0B3F 120B96    1165       lcall Copy4_Bytes_R0_to_R1
0B42           1166   
0B42           1167       ; Compare
0B42 12011A    1168       lcall x_lt_y
0B45 200102    1169       jb mf, Temp_Compare_Done
0B48           1170       
0B48           1171       ; If Current >= Target
0B48 D205      1172       setb reflow_temp_reached
0B4A           1173   
0B4A           1174   Temp_Compare_Done:
0B4A D002      1175       pop AR2
0B4C D001      1176       pop AR1
0B4E D000      1177       pop AR0
0B50 D0D0      1178       pop psw
0B52 D0E0      1179       pop acc
0B54 22        1180       ret
0B55           1181   ;-------------------------------------------------------------------------------;
0B55           1182   ; Time_Compare
0B55           1183   ;
0B55           1184   ; PURPOSE:
0B55           1185   ;   Compare the elapsed time against soak and reflow
0B55           1186   ;   time limits.
0B55           1187   ;
0B55           1188   ; BEHAVIOR:
0B55           1189   ;   - If current_time >= soak_time   if soak_time_reached    = 1
0B55           1190   ;   - If current_time >= reflow_time if reflow_time_reached = 1
0B55           1191   ;
0B55           1192   ; NOTES:
0B55           1193   ;   - Time values are treated as 32-bit UNSIGNED numbers
0B55           1194   ;     (e.g., milliseconds or seconds).
0B55           1195   ;   - Uses the SAME compare logic as Temp_Compare.
0B55           1196   ;   - This routine ONLY SETS flags.
0B55           1197   ;
0B55           1198   ; EXPECTED VARIABLES:
0B55           1199   ;   current_time[4], soak_time[4], reflow_time[4]
0B55           1200   ;   x[4], y[4]
0B55           1201   ;   mf, soak_time_reached, reflow_time_reached
0B55           1202   ;-------------------------------------------------------------------------------;
0B55           1203   Time_Compare:
0B55 C0E0      1204       push acc
0B57 C0D0      1205       push psw
0B59 C000      1206       push AR0
0B5B C001      1207       push AR1
0B5D C002      1208       push AR2
0B5F           1209   
0B5F           1210   ; Check: current_time >= soak_time ?
0B5F           1211       ; Copy current_time of x
0B5F 7852      1212       mov  R0, #current_time
0B61 7932      1213       mov  R1, #x
0B63 120B96    1214       lcall Copy4_Bytes_R0_to_R1
0B66           1215   
0B66           1216       ; Copy soak_time of y
0B66 7856      1217       mov  R0, #soak_time
0B68 7936      1218       mov  R1, #y
0B6A 120B96    1219       lcall Copy4_Bytes_R0_to_R1
0B6D           1220   
0B6D           1221       ; Compare elapsed time vs soak time
0B6D 12011A    1222       lcall x_lt_y
0B70 200102    1223       jb   mf, Time_Soak_NotReached
0B73 D207      1224       setb soak_time_reached
0B75           1225   
0B75           1226   ; Check: current_time >= reflow_time ?
0B75           1227   Time_Soak_NotReached:
0B75           1228       ; Copy current_time of x
0B75 7852      1229       mov  R0, #current_time
0B77 7932      1230       mov  R1, #x
0B79 120B96    1231       lcall Copy4_Bytes_R0_to_R1
0B7C           1232   
0B7C           1233       ; Copy reflow_time of y
0B7C 785A      1234       mov  R0, #reflow_time
0B7E 7936      1235       mov  R1, #y
0B80 120B96    1236       lcall Copy4_Bytes_R0_to_R1
0B83           1237   
0B83           1238       ; Compare elapsed time vs reflow time
0B83 12011A    1239       lcall x_lt_y
0B86 200102    1240       jb   mf, Time_Reflow_NotReached
0B89 D208      1241       setb reflow_time_reached
0B8B           1242   
0B8B           1243   Time_Reflow_NotReached:
0B8B D002      1244       pop  AR2
0B8D D001      1245       pop  AR1
0B8F D000      1246       pop  AR0
0B91 D0D0      1247       pop  psw
0B93 D0E0      1248       pop  acc
0B95 22        1249       ret
0B96           1250   
0B96           1251   ;-------------------------------------------------------------------------------;
0B96           1252   ; Copy4_Bytes_R0_to_R1
0B96           1253   ;
0B96           1254   ; PURPOSE:
0B96           1255   ;   Utility routine to copy a 32-bit value (4 bytes)
0B96           1256   ;   from one memory location to another.
0B96           1257   ;
0B96           1258   ; INPUTS:
0B96           1259   ;   R0 st source address
0B96           1260   ;   R1 at destination address
0B96           1261   ;
0B96           1262   ; USES:
0B96           1263   ;   R2 as loop counter
0B96           1264   ;
0B96           1265   ; EXAMPLE:
0B96           1266   ;   mov R0, #current_temp
0B96           1267   ;   mov R1, #x
0B96           1268   ;   lcall Copy4_Bytes_R0_to_R1
0B96           1269   ;-------------------------------------------------------------------------------;
0B96           1270   Copy4_Bytes_R0_to_R1:
0B96 7A04      1271       mov  R2, #4
0B98           1272   Copy4_Loop:
0B98 E6        1273       mov  a, @R0
0B99 F7        1274       mov  @R1, a
0B9A 08        1275       inc  R0
0B9B 09        1276       inc  R1
0B9C DAFA      1277       djnz R2, Copy4_Loop
0B9E 22        1278       ret
0B9F           1279   
0B9F           1280   ;-------------------------------------------------------------------------------;
0B9F           1281   ; Abort condition safety check Temperature time
0B9F           1282   ;
0B9F           1283   ; PURPOSE:
0B9F           1284   ;   Automatic cycle termination on error:
0B9F           1285   ;   Abort if oven fails to reach at least 50C in first 60s.
0B9F           1286   ;
0B9F           1287   ; TRIP CONDITION:
0B9F           1288   ;   if (current_time >= 60s) AND (current_temp < 50C)
0B9F           1289   ;       -> set tc_missing_abort
0B9F           1290   ;       -> set stop_signal
0B9F           1291   ;
0B9F           1292   ; ASSUMPTIONS:
0B9F           1293   ;   - current_time is in SECONDS (32-bit, little-endian)
0B9F           1294   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
0B9F           1295   ;
0B9F           1296   ;   the Load_Y constants accordingly.
0B9F           1297   ;-------------------------------------------------------------------------------;
0B9F           1298   Safety_Check_TC:
0B9F C0E0      1299       push acc
0BA1 C0D0      1300       push psw
0BA3 C000      1301       push AR0
0BA5 C001      1302       push AR1
0BA7 C002      1303       push AR2
0BA9           1304   
0BA9           1305       ; ---------------------------------------------------------
0BA9           1306       ; [FIX] GATEKEEPER: IGNORE UNLESS IN STATE 2 (RAMP TO SOAK)
0BA9           1307       ; ---------------------------------------------------------
0BA9 E56A      1308       mov a, Control_FSM_state
0BAB B40202    1309       cjne a, #2, Safety_TC_Exit_Bridge ; If State != 2, skip everything
0BAE 8003      1310       sjmp Safety_Logic_Proceed         ; If State == 2, do the check
0BB0           1311   
0BB0           1312       Safety_TC_Exit_Bridge:
0BB0 020BFE    1313           ljmp Safety_TC_Done               ; Jump to the end
0BB3           1314   
0BB3           1315       Safety_Logic_Proceed:
0BB3           1316           ; If already aborted or startup window closed, do nothing
0BB3 200F48    1317           jb   tc_missing_abort, Safety_TC_Done
0BB6 301045    1318           jnb  tc_startup_window, Safety_TC_Done
0BB9           1319   
0BB9           1320       ; Check: current_time >= 60 ?
0BB9 7852      1321       mov  R0, #current_time
0BBB 7932      1322       mov  R1, #x
0BBD 120B96    1323       lcall Copy4_Bytes_R0_to_R1
0BC0           1324   
0BC0 75363C    1325            mov y+0, #low (60 % 0x10000) 
0BC3 753700    1325            mov y+1, #high(60 % 0x10000) 
0BC6 753800    1325            mov y+2, #low (60 / 0x10000) 
0BC9 753900    1325            mov y+3, #high(60 / 0x10000) 
0BCC 12011A    1326       lcall x_lt_y
0BCF 2001DE    1327       jb   mf, Safety_TC_Exit_Bridge        ; still < 60s ? keep waiting
0BD2           1328   
0BD2           1329       ; We reached 60s: close the startup window so it won't re-check later
0BD2 C210      1330       clr  tc_startup_window
0BD4           1331   
0BD4           1332       ; Now check: current_temp < 50 ?
0BD4 7841      1333       mov  R0, #current_temp
0BD6 7932      1334       mov  R1, #x
0BD8 120B96    1335       lcall Copy4_Bytes_R0_to_R1
0BDB           1336   
0BDB 753632    1337            mov y+0, #low (50 % 0x10000) 
0BDE 753700    1337            mov y+1, #high(50 % 0x10000) 
0BE1 753800    1337            mov y+2, #low (50 / 0x10000) 
0BE4 753900    1337            mov y+3, #high(50 / 0x10000) 
0BE7 12011A    1338       lcall x_lt_y
0BEA 3001C3    1339       jnb  mf, Safety_TC_Exit_Bridge        ; temp >= 50 ? pass
0BED           1340   
0BED           1341       ; FAIL: at 60s, still below 50C ? abort
0BED C293      1342       clr  PWM_OUT
0BEF D20F      1343       setb tc_missing_abort
0BF1 D20A      1344       setb stop_signal
0BF3 120C13    1345            lcall Beep_Ten
0BF6           1346       ; 3. Force FSM to State 0 (Welcome)
0BF6 756A00    1347       mov Control_FSM_state, #0
0BF9           1348       
0BF9           1349       ; 4. Force UI to State 0 (Home Screen)
0BF9 756B00    1350       mov Current_State, #0
0BFC           1351       
0BFC           1352       ; 5. Trigger Screen Refresh
0BFC D20D      1353       setb state_change_signal ; Tell loop to redraw "Welcome"
0BFE           1354   
0BFE           1355   Safety_TC_Done:
0BFE D002      1356       pop  AR2
0C00 D001      1357       pop  AR1
0C02 D000      1358       pop  AR0
0C04 D0D0      1359       pop  psw
0C06 D0E0      1360       pop  acc
0C08 22        1361       ret
0C09           1362   
0C09           1363   ; ============================================================
0C09           1364   ; BUZZER STARTUP FUNCTIONS
0C09           1365   ; ============================================================
0C09           1366   
0C09           1367   Beep_Once:
0C09 757501    1368       mov beep_count, #1
0C0C 800A      1369       sjmp Beep_Start
0C0E           1370   
0C0E           1371   Beep_Five:
0C0E 757505    1372       mov beep_count, #5
0C11 8005      1373       sjmp Beep_Start
0C13           1374   
0C13           1375   Beep_Ten:
0C13 75750A    1376       mov beep_count, #10
0C16 8000      1377       sjmp Beep_Start      ; [FIX] Added explicit jump for safety
0C18           1378   
0C18           1379   Beep_Start:
0C18 C28C      1380       clr TR0              ; [FIX] Stop timer briefly to reset cleanly
0C1A 757601    1381       mov beep_state, #1   ; Set State to ON
0C1D 757700    1382       mov beep_tmr, #0     ; Reset Timer High Byte
0C20 757800    1383       mov beep_tmr+1, #0   ; Reset Timer Low Byte
0C23 D2A9      1384       setb ET0             ; [FIX] Ensure Interrupt is enabled
0C25 D28C      1385       setb TR0             ; START the 2kHz tone
0C27 22        1386       ret
0C28           1387   ;============================================================
0C28           1388   
0C28           1389   ;============================================================
0C28           1390   ; Buzzer beep Task 
0C28           1391   ; Purpose: beeps, holds, stop
0C28           1392   ; Buzzer task:
0C28           1393   ; Beep once when state changes
0C28           1394   ; Beep five times if finished
0C28           1395   ; Beep ten times if meets error
0C28           1396   ;============================================================
0C28           1397   
0C28           1398   Beep_Task:
0C28 301435    1399       jnb one_ms_beep_flag, Beep_Done
0C2B C214      1400       clr one_ms_beep_flag
0C2D           1401   
0C2D E576      1402       mov a, beep_state
0C2F 602F      1403       jz Beep_Done
0C31           1404   
0C31           1405   ; ---- increment 16-bit timer ----
0C31 0577      1406       inc beep_tmr
0C33 E577      1407       mov a, beep_tmr
0C35 7002      1408       jnz Beep_Check
0C37 0578      1409       inc beep_tmr+1
0C39           1410   
0C39           1411   Beep_Check:
0C39           1412       ; [FIX] FUZZY TIMER CHECK
0C39           1413       ; Check if High Byte is non-zero (Time >= 256ms)
0C39 E578      1414       mov a, beep_tmr+1
0C3B 6023      1415       jz Beep_Done        ; If 0, keep beeping
0C3D           1416   
0C3D           1417       ; --- Time Limit Reached ---
0C3D 757700    1418       mov beep_tmr, #0    ; Reset timer
0C40 757800    1419       mov beep_tmr+1, #0
0C43           1420   
0C43 E576      1421       mov a, beep_state
0C45 B40106    1422       cjne a, #1, Beep_Off_State
0C48           1423   
0C48           1424       ; State was 1 (ON) -> Turn OFF
0C48 C28C      1425       clr TR0             ; Hardware Silence
0C4A 757602    1426       mov beep_state, #2  ; Set State to OFF (Pause)
0C4D 22        1427       ret
0C4E           1428   
0C4E           1429   Beep_Off_State:
0C4E           1430   ; ---- OFF finished -> decrement count / next ON ----
0C4E 1575      1431       dec beep_count
0C50 E575      1432       mov a, beep_count
0C52 6006      1433       jz  Beep_Stop
0C54           1434   
0C54 757601    1435       mov beep_state, #1
0C57 D28C      1436       setb TR0
0C59 22        1437       ret
0C5A           1438   
0C5A           1439   Beep_Stop:
0C5A C28C      1440       clr TR0
0C5C 757600    1441       mov beep_state, #0
0C5F 22        1442       ret
0C60           1443   
0C60           1444   Beep_Done:
0C60 22        1445       ret
0C61           1446   ;==================================================================
0C61           1447   
0C61           1448   ;-------------------------------------------------------------------------------;
0C61           1449   ; Main Control FSM for the entire process
0C61           1450   ;-------------------------------------------------------------------------------;
0C61           1451   ;-------------------------------------------------------------------------------;
0C61           1452   ; FSM LOGIC (Button Logic Fixed)
0C61           1453   ;-------------------------------------------------------------------------------;
0C61           1454   Control_FSM:
0C61 E56A      1455       mov a, Control_FSM_state
0C63 8005      1456       sjmp Control_FSM_state0
0C65           1457   
0C65           1458   Control_FSM_state0_a:
0C65 756A00    1459       mov Control_FSM_state, #0
0C68 D20D      1460       setb state_change_signal
0C6A           1461            
0C6A           1462   Control_FSM_state0:
0C6A B4001F    1463       cjne a, #0, Control_FSM_state1
0C6D 201109    1464       jb PB0_flag, Control_FSM_start_from_uart
0C70 209005    1465       jb P1.0, Control_FSM_done_bridge ; If Button High (Not Pressed), Exit
0C73 1211DA    1466       lcall Wait_For_P1_0_Release      ; If Low (Pressed), Wait & Proceed
0C76 8008      1467       sjmp Control_FSM_state1_a  
0C78           1468       
0C78           1469   Control_FSM_done_bridge:
0C78 22        1470       ret
0C79           1471   
0C79           1472   Control_FSM_start_from_uart:
0C79 C211      1473       clr PB0_flag
0C7B 756A01    1474       mov Control_FSM_state, #1
0C7E 8021      1475       sjmp Control_FSM_state2_a
0C80           1476   
0C80           1477   Control_FSM_state1_a:
0C80 056A      1478       inc Control_FSM_state
0C82 756B00    1479       mov Current_State, #0
0C85 1210B8    1480       lcall Update_Screen_Full 
0C88 D20D      1481       setb state_change_signal
0C8A E56A      1482       mov a, Control_FSM_state
0C8C           1483       
0C8C           1484   Control_FSM_state1:
0C8C B40127    1485       cjne a, #1, Control_FSM_state2
0C8F 120EF0    1486       lcall Check_Buttons 
0C92 120F3C    1487       lcall Check_Keypad
0C95           1488       
0C95           1489       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
0C95 209008    1490       jb P1.0, Control_FSM_state1_ret
0C98           1491       
0C98           1492       ; If we get here, Button is LOW (Pressed)
0C98 1211DA    1493       lcall Wait_For_P1_0_Release
0C9B 120E74    1494       lcall Update_FSM_Variables
0C9E 8001      1495       sjmp Control_FSM_state2_a
0CA0           1496   Control_FSM_state1_ret:
0CA0 22        1497       ret
0CA1           1498   
0CA1           1499   ; --- STATE 2: RAMP TO SOAK ---
0CA1           1500   Control_FSM_state2_a:
0CA1 056A      1501       inc Control_FSM_state
0CA3 E56A      1502       mov a, Control_FSM_state   ; [FIX] RELOAD 'A' so it matches the new state!
0CA5 D20D      1503       setb state_change_signal
0CA7 120C09    1504       lcall Beep_Once
0CAA           1505   
0CAA D210      1506       setb tc_startup_window    ; OPEN the safety window
0CAC C20F      1507       clr tc_missing_abort      ; Clear any previous aborts
0CAE 753000    1508       mov current_time_sec, #0  ; Reset Seconds to 0
0CB1 753100    1509       mov current_time_minute, #0 ; Reset Minutes to 0
0CB4           1510       
0CB4           1511       ; [FIX] CLEAR FLAG ON ENTRY
0CB4           1512       ; Force the system to wait for at least one fresh temp reading
0CB4           1513       ; before deciding we are done.
0CB4 C204      1514       clr soak_temp_reached      
0CB6           1515   
0CB6           1516   Control_FSM_state2:
0CB6 B4021F    1517       cjne a, #2, Control_FSM_state3
0CB9 301305    1518       jnb PB2_flag, State2_Check
0CBC C213      1519       clr PB2_flag
0CBE 020D29    1520       ljmp Control_FSM_state6_a ; Pause
0CC1           1521   
0CC1           1522   State2_Check:
0CC1 300413    1523       jnb soak_temp_reached, State2_Ret
0CC4           1524       
0CC4           1525       ; --- We reached Temp! Move to State 3 ---
0CC4 C204      1526       clr soak_temp_reached
0CC6 056A      1527       inc Control_FSM_state
0CC8           1528       
0CC8           1529       ; [FIX] RELOAD 'A' (Good practice)
0CC8 E56A      1530       mov a, Control_FSM_state   
0CCA           1531       
0CCA D20D      1532       setb state_change_signal
0CCC 120C09    1533       lcall Beep_Once
0CCF           1534       
0CCF 753000    1535       mov current_time_sec, #0
0CD2 753100    1536       mov current_time_minute, #0
0CD5           1537       
0CD5           1538       ; Ensure we start State 3 fresh
0CD5 C207      1539       clr soak_time_reached 
0CD7           1540   
0CD7           1541   State2_Ret:
0CD7 22        1542       ret
0CD8           1543   
0CD8           1544   ; --- STATE 3: SOAK PHASE ---
0CD8           1545   Control_FSM_state3:
0CD8 B40315    1546       cjne a, #3, Control_FSM_state4
0CDB 301305    1547       jnb PB2_flag, State3_Check
0CDE C213      1548       clr PB2_flag
0CE0 020D29    1549       ljmp Control_FSM_state6_a
0CE3           1550   State3_Check:
0CE3 300709    1551       jnb soak_time_reached, State3_Ret
0CE6 C207      1552       clr soak_time_reached
0CE8 056A      1553       inc Control_FSM_state      
0CEA D20D      1554       setb state_change_signal 
0CEC 120C09    1555            lcall Beep_Once
0CEF           1556   State3_Ret:
0CEF 22        1557       ret
0CF0           1558   
0CF0           1559   ; --- STATE 4: RAMP TO PEAK ---
0CF0           1560   Control_FSM_state4:
0CF0 B4041D    1561       cjne a, #4, Control_FSM_state5
0CF3 301305    1562       jnb PB2_flag, State4_Check
0CF6 C213      1563       clr PB2_flag
0CF8 020D29    1564       ljmp Control_FSM_state6_a
0CFB           1565   State4_Check:
0CFB 300511    1566       jnb reflow_temp_reached, State4_Ret
0CFE C205      1567       clr reflow_temp_reached
0D00 056A      1568       inc Control_FSM_state
0D02 D20D      1569       setb state_change_signal
0D04 120C09    1570            lcall Beep_Once
0D07 753000    1571       mov current_time_sec, #0
0D0A 753100    1572       mov current_time_minute, #0
0D0D           1573       ; --- ADD THIS LINE ---
0D0D C208      1574       clr reflow_time_reached ; Kill the ghost flag
0D0F           1575       ; ---------------------
0D0F           1576   State4_Ret:
0D0F 22        1577       ret
0D10           1578   
0D10           1579   ; --- STATE 5: REFLOW PHASE ---
0D10           1580   Control_FSM_state5:
0D10 B40502    1581       cjne a, #5, Control_FSM_state6_trampoline
0D13 8003      1582       sjmp State5_Logic
0D15           1583   Control_FSM_state6_trampoline:
0D15 020D30    1584       ljmp Control_FSM_state6
0D18           1585   
0D18           1586   State5_Logic:
0D18 301305    1587       jnb PB2_flag, State5_Check
0D1B C213      1588       clr PB2_flag
0D1D 020D29    1589       ljmp Control_FSM_state6_a
0D20           1590   State5_Check:
0D20 300805    1591       jnb reflow_time_reached, State5_Ret
0D23 C208      1592       clr reflow_time_reached
0D25 020D29    1593       ljmp Control_FSM_state6_a
0D28           1594   State5_Ret:
0D28 22        1595       ret
0D29           1596   
0D29           1597   ; --- STATE 6: COOLING ---
0D29           1598   Control_FSM_state6_a:
0D29 056A      1599       inc Control_FSM_state
0D2B D20D      1600       setb state_change_signal
0D2D 120C0E    1601            lcall Beep_Five
0D30           1602   Control_FSM_state6:
0D30 B4060A    1603       cjne a, #6, Control_FSM_state7
0D33           1604       ; Wait for Cooling Temp Reached
0D33 300606    1605       jnb cooling_temp_reached, State6_Ret
0D36 C206      1606       clr cooling_temp_reached
0D38 056A      1607       inc Control_FSM_state
0D3A D20D      1608       setb state_change_signal
0D3C           1609   State6_Ret:
0D3C 22        1610       ret
0D3D           1611   
0D3D           1612   ; --- STATE 7: DONE ---
0D3D           1613   Control_FSM_state7:
0D3D B40711    1614       cjne a, #7, Control_FSM_done
0D40           1615       
0D40           1616       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
0D40 201109    1617       jb PB0_flag, Control_FSM_Reset_Logic ; Wait, PB0_flag is software flag?
0D43           1618       
0D43           1619       ; Let's assume you meant the physical button P1.0 like State 0
0D43 20900B    1620       jb P1.0, Control_FSM_done
0D46           1621       
0D46 1211DA    1622       lcall Wait_For_P1_0_Release
0D49 020C65    1623       ljmp Control_FSM_state0_a
0D4C           1624   
0D4C           1625   Control_FSM_Reset_Logic:
0D4C           1626       ; If using PB0_flag from ISR, handle here
0D4C C211      1627       clr PB0_flag
0D4E 020C65    1628       ljmp Control_FSM_state0_a
0D51           1629   
0D51           1630   Control_FSM_done:
0D51 22        1631       ret
0D52           1632   ;-------------------------------------------------------------------------------;
0D52           1633   ;         Main program.          
0D52           1634   ;-------------------------------------------------------------------------------;
0D52           1635   main:
0D52           1636   
0D52           1637       ; --------------------------------------------------------
0D52           1638       ; 1. SAFETY SHUTDOWN
0D52           1639       ; --------------------------------------------------------
0D52 C2AF      1640       clr EA              ; FORCE Interrupts OFF immediately
0D54 7581C0    1641       mov SP, #0xC0       ; Reset Stack Pointer to safe location
0D57           1642       
0D57           1643       ; --------------------------------------------------------
0D57           1644       ; 2. THE "DIRTY DELAY" (Fixes Reset Garbage)
0D57           1645       ; We burn ~100ms here using a raw loop. 
0D57           1646       ; We cannot use timers yet because they aren't initialized.
0D57           1647       ; --------------------------------------------------------
0D57 78FA      1648       mov R0, #250
0D59           1649   Reset_Delay_Outer:
0D59 79FF      1650       mov R1, #255
0D5B           1651   Reset_Delay_Inner:
0D5B D9FE      1652       djnz R1, Reset_Delay_Inner
0D5D D8FA      1653       djnz R0, Reset_Delay_Outer
0D5F           1654       ; --------------------------------------------------------
0D5F           1655   
0D5F           1656       ; ... NOW continue with your normal Port Configuration ...
0D5F           1657       
0D5F           1658       ; --- PORT CONFIGURATION ---
0D5F 759AAA    1659       mov P0MOD, #0xAA
0D62           1660   
0D62           1661       ; P1: Mixed usage 
0D62           1662       ; P1.7(LCD_RS), P1.6(Row3), P1.5(Sound), P1.4(Row2)
0D62           1663       ; P1.3(PWM), P1.2(Row1), P1.1(LCD_E) -> All Outputs
0D62           1664       ; P1.0 (Unused/RX) -> Input
0D62           1665       ; Binary: 11111110 -> Hex: 0xFE
0D62 759BFE    1666       mov P1MOD, #0xFE
0D65           1667   
0D65           1668       ; P2: Row4(Out), Cols(In)
0D65           1669       ; P2.0 (Row4) is Out (1). P2.2, P2.4, P2.6 (Cols) are In (0).
0D65           1670       ; Binary: 00000001 -> Hex: 0x01
0D65 759C01    1671       mov P2MOD, #0x01
0D68           1672   
0D68           1673       ; P3: Col4(In)
0D68           1674       ; P3.0 (Col4) is In (0).
0D68 759D40    1675       mov P3MOD, #01000000B
0D6B           1676       ; Turn off all the LEDs
0D6B 75E800    1677       mov LEDRA, #0 ; LEDRA is bit addressable
0D6E 759500    1678       mov LEDRB, #0 ; LEDRB is NOT bit addresable
0D71           1679   
0D71           1680       ; Enable Global interrupts
0D71 D2AF      1681       setb EA  
0D73           1682   
0D73           1683       ; FSM initial states
0D73 756800    1684       mov KEY1_DEB_state, #0
0D76 756900    1685       mov SEC_FSM_state, #0
0D79 756A00    1686       mov Control_FSM_state, #0
0D7C 756B00    1687       mov Current_State, #0
0D7F           1688       
0D7F           1689       ; FSM timers initialization
0D7F 756600    1690       mov KEY1_DEB_timer, #0
0D82 756700    1691       mov SEC_FSM_timer, #0
0D85           1692       ; time counters initialization
0D85 753000    1693       mov current_time_sec, #0
0D88 753100    1694       mov current_time_minute, #0
0D8B           1695       ; Initialize counter to zero
0D8B 756200    1696       mov pwm_counter, #0
0D8E 756300    1697       mov pwm_counter+1, #0
0D91 756400    1698       mov pwm_counter+2, #0
0D94 756500    1699       mov pwm_counter+3, #0
0D97           1700       ; Initialize power output
0D97 756100    1701       mov power_output+3, #0
0D9A 756000    1702       mov power_output+2, #0
0D9D 755F02    1703       mov power_output+1, #02H
0DA0 755EEE    1704       mov power_output, #0EEH ; (initilize to 750 for testing)
0DA3           1705   
0DA3           1706       ; Clear all the flags
0DA3 C20F      1707       clr  tc_missing_abort
0DA5 C20A      1708       clr  stop_signal
0DA7 C211      1709       clr PB0_flag
0DA9 C212      1710       clr PB1_flag
0DAB C213      1711       clr PB2_flag
0DAD C202      1712       clr one_second_flag
0DAF C20C      1713       clr config_finish_signal
0DB1 C204      1714       clr soak_temp_reached
0DB3 C207      1715       clr soak_time_reached
0DB5 C205      1716       clr reflow_temp_reached
0DB7 C208      1717       clr reflow_time_reached
0DB9 C206      1718       clr cooling_temp_reached
0DBB C20D      1719       clr state_change_signal
0DBD C21F      1720       clr one_millisecond_flag_servo
0DBF C200      1721       clr remote_config_mode
0DC1           1722       
0DC1 D20D      1723       setb state_change_signal
0DC3           1724   
0DC3           1725       ; Set bit
0DC3 D210      1726       setb tc_startup_window
0DC5           1727   
0DC5           1728       ; --------------------------------------
0DC5           1729       ; [FIX] ADD THIS BLOCK TO STOP STARTUP BEEP
0DC5           1730       ; --------------------------------------
0DC5 757600    1731       mov beep_state, #0
0DC8 757500    1732       mov beep_count, #0
0DCB 757700    1733       mov beep_tmr, #0
0DCE 757800    1734       mov beep_tmr+1, #0
0DD1 C214      1735       clr one_ms_beep_flag
0DD3 C28C      1736       clr TR0              ; Force buzzer hardware OFF
0DD5           1737       ; --------------------------------------
0DD5           1738   
0DD5           1739   
0DD5 12045D    1740       lcall Timer0_Init
0DD8 12069F    1741       lcall Timer2_Init
0DDB 12076C    1742       lcall ELCD_4BIT
0DDE           1743       ;----- Two new lines I added to initialize the UI
0DDE 121065    1744       lcall Init_All_Buffers
0DE1 1210B8    1745       lcall Update_Screen_Full
0DE4           1746       ;-----
0DE4 120477    1747       lcall Initialize_Serial_Port
0DE7 753F00    1748       mov rx_idx, #0
0DEA 754000    1749       mov rx_ready, #0
0DED           1750   
0DED           1751   ;-------------------------------------------------------------------------------;
0DED           1752   ; while(1) loop
0DED           1753   ;-------------------------------------------------------------------------------;
0DED           1754   loop:
0DED           1755       ; ALWAYS: keep serial alive so PC can send config
0DED 1204AC    1756       lcall Serial_RX_Pump
0DF0 120505    1757       lcall Serial_Process_Line
0DF3           1758   
0DF3           1759       ; Full reset button on P3.7 (active-low to GND)
0DF3 30B702    1760        jnb P3_7, Full_Reset_Trig
0DF6 8003      1761       sjmp Full_Reset_Check_Done
0DF8           1762   
0DF8           1763   Full_Reset_Trig:
0DF8 0211E2    1764       ljmp Full_Reset
0DFB           1765   
0DFB           1766   Full_Reset_Check_Done:
0DFB           1767   
0DFB           1768       ; =========================================================
0DFB           1769       ; FREEZE CONTROL LOGIC DURING REMOTE CONFIG
0DFB           1770       ; (prevents speaker, FSM jumps, timers, etc.)
0DFB           1771       ; =========================================================
0DFB           1772       ; jb remote_config_mode, Remote_Config_Loop
0DFB           1773   
0DFB           1774       ; ---------------------------------------------------------
0DFB           1775       ; NORMAL RUN LOGIC
0DFB           1776       ; ---------------------------------------------------------
0DFB           1777   
0DFB           1778       ; Check the FSM for KEY1 debounce
0DFB 120A0D    1779       lcall KEY1_DEB
0DFE           1780   
0DFE           1781       ; Take temp readings
0DFE 1211E8    1782       lcall Read_Thermocouple
0E01           1783   
0E01           1784       ; 1. Check if we reached temp (Observer)
0E01 120B10    1785       lcall Temp_Compare
0E04           1786   
0E04           1787       ; 2. Decide heater power based on flags (Driver)
0E04 12132A    1788       lcall proportional_power_control
0E07           1789   
0E07           1790       ; 3. Calculate Total Seconds (Minutes * 60 + Seconds)
0E07 853132    1791       mov x+0, current_time_minute
0E0A 753300    1792       mov x+1, #0
0E0D 753400    1793       mov x+2, #0
0E10 753500    1794       mov x+3, #0
0E13           1795   
0E13 75363C    1796            mov y+0, #low (60 % 0x10000) 
0E16 753700    1796            mov y+1, #high(60 % 0x10000) 
0E19 753800    1796            mov y+2, #low (60 / 0x10000) 
0E1C 753900    1796            mov y+3, #high(60 / 0x10000) 
0E1F 12018C    1797       lcall mul32
0E22           1798   
0E22 853036    1799       mov y+0, current_time_sec
0E25 753700    1800       mov y+1, #0
0E28 753800    1801       mov y+2, #0
0E2B 753900    1802       mov y+3, #0
0E2E           1803   
0E2E 1200D3    1804       lcall add32
0E31           1805   
0E31 853252    1806       mov current_time+0, x+0
0E34 853353    1807       mov current_time+1, x+1
0E37 853454    1808       mov current_time+2, x+2
0E3A 853555    1809       mov current_time+3, x+3
0E3D           1810   
0E3D 120B55    1811       lcall Time_Compare
0E40 120B9F    1812       lcall Safety_Check_TC
0E43           1813   
0E43           1814       ; one-second counter
0E43 120A43    1815       lcall SEC_FSM
0E46           1816   
0E46           1817       ; overall FSM
0E46 120C61    1818       lcall Control_FSM
0E49           1819   
0E49           1820       ; LCD update (normal)
0E49 120831    1821       lcall LCD_Display_Update_func
0E4C           1822   
0E4C           1823       ; buzzer tick sync
0E4C 300302    1824       jnb one_ms_pwm_flag, Skip_Beep_Sync
0E4F D214      1825       setb one_ms_beep_flag
0E51           1826   
0E51           1827   Skip_Beep_Sync:
0E51           1828       ; heater PWM
0E51 120A99    1829       lcall PWM_Wave
0E54           1830   
0E54           1831       ; buzzer
0E54 120C28    1832       lcall Beep_Task
0E57           1833   
0E57           1834       ; servo
0E57 1212BD    1835       lcall call_servo_control
0E5A           1836   
0E5A 020DED    1837       ljmp loop
0E5D           1838   
0E5D           1839   
0E5D           1840   Remote_Config_Loop:
0E5D           1841       ; silence outputs
0E5D C28C      1842       clr TR0
0E5F C293      1843       clr PWM_OUT
0E61           1844   
0E61           1845       ; still allow UI navigation / redraw
0E61 120EF0    1846       lcall Check_Buttons
0E64 120F3C    1847       lcall Check_Keypad
0E67           1848       ; Only redraw when something changed (optional but recommended)
0E67 200D02    1849       jb state_change_signal, RC_REDRAW
0E6A 8005      1850       sjmp RC_DONE
0E6C           1851   RC_REDRAW:
0E6C C20D      1852       clr state_change_signal
0E6E 1210B8    1853       lcall Update_Screen_Full
0E71           1854   RC_DONE:
0E71 020DED    1855       ljmp loop
0E74           1856   
0E74           1857   ;-------------------------------------------------------------------------------;
0E74           1858   
0E74           1859   ; ================================================================
0E74           1860   ; UI & HELPER SUBROUTINES
0E74           1861   ; ================================================================
0E74           1862   
0E74           1863   ; ----------------------------------------------------------------
0E74           1864   ; MODULE: BRIDGE (Text to Integer Conversion)
0E74           1865   ; ----------------------------------------------------------------
0E74           1866   Update_FSM_Variables:
0E74           1867       ; --- 1. SOAK TEMP ---
0E74 7880      1868       mov R0, #Buf_Soak_Temp
0E76 120EB3    1869       lcall Parse_Temp_String
0E79 8F45      1870       mov soak_temp+0, R7
0E7B 754600    1871       mov soak_temp+1, #0
0E7E 754700    1872       mov soak_temp+2, #0
0E81 754800    1873       mov soak_temp+3, #0
0E84           1874   
0E84           1875       ; --- 2. REFLOW TEMP ---
0E84 7889      1876       mov R0, #Buf_Refl_Temp
0E86 120EB3    1877       lcall Parse_Temp_String
0E89 8F49      1878       mov reflow_temp+0, R7
0E8B 754A00    1879       mov reflow_temp+1, #0
0E8E 754B00    1880       mov reflow_temp+2, #0
0E91 754C00    1881       mov reflow_temp+3, #0
0E94           1882   
0E94           1883       ; --- 3. SOAK TIME ---
0E94 7884      1884       mov R0, #Buf_Soak_Time
0E96 120EC7    1885       lcall Parse_Time_String
0E99 8F56      1886       mov soak_time+0, R7
0E9B 8E57      1887       mov soak_time+1, R6
0E9D 755800    1888       mov soak_time+2, #0
0EA0 755900    1889       mov soak_time+3, #0
0EA3           1890   
0EA3           1891       ; --- 4. REFLOW TIME ---
0EA3 788D      1892       mov R0, #Buf_Refl_Time
0EA5 120EC7    1893       lcall Parse_Time_String
0EA8 8F5A      1894       mov reflow_time+0, R7
0EAA 8E5B      1895       mov reflow_time+1, R6
0EAC 755C00    1896       mov reflow_time+2, #0
0EAF 755D00    1897       mov reflow_time+3, #0
0EB2 22        1898       ret
0EB3           1899   
0EB3           1900   ; --- Helper: Parse "123" to Integer ---
0EB3           1901   Parse_Temp_String:
0EB3 7F00      1902       mov R7, #0              ; Clear Result
0EB5           1903   Parse_Temp_Loop:
0EB5 E6        1904       mov A, @R0
0EB6 600E      1905       jz Parse_Temp_Done      ; If Null, we are done
0EB8           1906       
0EB8           1907       ; Convert ASCII to Digit
0EB8 C3        1908       clr C
0EB9 9430      1909       subb A, #0x30
0EBB FD        1910       mov R5, A               ; R5 = New Digit
0EBC           1911       
0EBC           1912       ; Result = (Result * 10) + New Digit
0EBC EF        1913       mov A, R7
0EBD 75F00A    1914       mov B, #10
0EC0 A4        1915       mul AB
0EC1 2D        1916       add A, R5
0EC2 FF        1917       mov R7, A
0EC3           1918       
0EC3 08        1919       inc R0
0EC4 80EF      1920       sjmp Parse_Temp_Loop
0EC6           1921   Parse_Temp_Done:
0EC6 22        1922       ret
0EC7           1923   
0EC7           1924   ; --- Helper: Parse "MMSS" to Seconds ---
0EC7           1925   Parse_Time_String:
0EC7           1926       ; 1. Minutes Tens
0EC7 E6        1927       mov A, @R0
0EC8 9430      1928       subb A, #0x30
0ECA 75F00A    1929       mov B, #10
0ECD A4        1930       mul AB
0ECE FD        1931       mov R5, A
0ECF 08        1932       inc R0
0ED0           1933       
0ED0           1934       ; 2. Minutes Ones
0ED0 E6        1935       mov A, @R0
0ED1 9430      1936       subb A, #0x30
0ED3 2D        1937       add A, R5
0ED4 FD        1938       mov R5, A               ; R5 = Total Minutes
0ED5 08        1939       inc R0
0ED6           1940       
0ED6           1941       ; 3. Seconds Tens
0ED6 E6        1942       mov A, @R0
0ED7 9430      1943       subb A, #0x30
0ED9 75F00A    1944       mov B, #10
0EDC A4        1945       mul AB
0EDD FC        1946       mov R4, A
0EDE 08        1947       inc R0
0EDF           1948       
0EDF           1949       ; 4. Seconds Ones
0EDF E6        1950       mov A, @R0
0EE0 9430      1951       subb A, #0x30
0EE2 2C        1952       add A, R4               ; R4 = Total Seconds
0EE3           1953       
0EE3           1954       ; 5. Calculate Total Seconds = (Mins * 60) + Secs
0EE3 ED        1955       mov A, R5
0EE4 75F03C    1956       mov B, #60
0EE7 A4        1957       mul AB
0EE8 2C        1958       add A, R4
0EE9 FF        1959       mov R7, A               ; Low Byte
0EEA E5F0      1960       mov A, B
0EEC 3400      1961       addc A, #0
0EEE FE        1962       mov R6, A               ; High Byte
0EEF 22        1963       ret
0EF0           1964   
0EF0           1965   ; ----------------------------------------------------------------
0EF0           1966   ; MODULE: BUTTON HANDLER (Mode Selection)
0EF0           1967   ; ----------------------------------------------------------------
0EF0           1968   Check_Buttons:
0EF0           1969       ; --- FORCE INPUT MODE ---
0EF0           1970       ; This clears any '0' the LCD library might have written to our buttons
0EF0 438055    1971       orl P0, #055H   ; Sets P0.0, P0.2, P0.4, and P0.6 to '1' (Input Mode)
0EF3           1972       ; ------------------------
0EF3           1973   
0EF3 30800A    1974       jnb BTN_SOAK_TEMP, Btn_Soak_Temp_Press
0EF6 308212    1975       jnb BTN_SOAK_TIME, Btn_Soak_Time_Press
0EF9 30841A    1976       jnb BTN_REFL_TEMP, Btn_Refl_Temp_Press
0EFC 308622    1977       jnb BTN_REFL_TIME, Btn_Refl_Time_Press
0EFF 22        1978       ret
0F00           1979   
0F00           1980   Btn_Soak_Temp_Press:
0F00 1211AA    1981       lcall Wait_25ms_BLOCKING
0F03 756B01    1982       mov Current_State, #1
0F06 757400    1983       mov Cursor_Idx, #0
0F09 8021      1984       sjmp Redraw_Screen
0F0B           1985   
0F0B           1986   Btn_Soak_Time_Press:
0F0B 1211AA    1987       lcall Wait_25ms_BLOCKING
0F0E 756B02    1988       mov Current_State, #2
0F11 757400    1989       mov Cursor_Idx, #0
0F14 8016      1990       sjmp Redraw_Screen
0F16           1991   
0F16           1992   Btn_Refl_Temp_Press:
0F16 1211AA    1993       lcall Wait_25ms_BLOCKING
0F19 756B03    1994       mov Current_State, #3
0F1C 757400    1995       mov Cursor_Idx, #0
0F1F 800B      1996       sjmp Redraw_Screen
0F21           1997   
0F21           1998   Btn_Refl_Time_Press:
0F21 1211AA    1999       lcall Wait_25ms_BLOCKING 
0F24 756B04    2000       mov Current_State, #4
0F27 757400    2001       mov Cursor_Idx, #0
0F2A 8000      2002       sjmp Redraw_Screen
0F2C           2003   
0F2C           2004   Redraw_Screen:
0F2C           2005       ; Wait for button release
0F2C 3080FD    2006       jnb BTN_SOAK_TEMP, $
0F2F 3082FD    2007       jnb BTN_SOAK_TIME, $
0F32 3084FD    2008       jnb BTN_REFL_TEMP, $
0F35 3086FD    2009       jnb BTN_REFL_TIME, $
0F38           2010   
0F38 1210B8    2011       lcall Update_Screen_Full
0F3B 22        2012       ret
0F3C           2013   
0F3C           2014   ; ----------------------------------------------------------------
0F3C           2015   ; MODULE: KEYPAD HANDLER (Input Logic)
0F3C           2016   ; ----------------------------------------------------------------
0F3C           2017   Check_Keypad:
0F3C           2018       ; If State is 0 (Home), ignore keypad
0F3C E56B      2019       mov A, Current_State
0F3E 6050      2020       jz Keypad_Exit
0F40           2021       
0F40 120F91    2022       lcall Keypad_Scan
0F43 504B      2023       jnc Keypad_Exit         ; Carry = 0 means no key pressed
0F45           2024   
0F45           2025       ; --- Check Special Keys ---
0F45 EF        2026       mov A, R7
0F46 B40E0A    2027       cjne A, #14, Check_Hash ; 14 is Star (*)
0F49           2028       
0F49           2029       ; Star Key Pressed: Reset Buffer
0F49 121095    2030       lcall Reset_Current_Buffer
0F4C 1210B8    2031       lcall Update_Screen_Full
0F4F 757400    2032       mov Cursor_Idx, #0
0F52 22        2033       ret
0F53           2034   
0F53           2035   Check_Hash:
0F53 EF        2036       mov A, R7
0F54 B40C01    2037       cjne A, #12, Check_Numeric ; 12 is Hash (#)
0F57 22        2038       ret                     ; Ignore Hash key
0F58           2039   
0F58           2040   Check_Numeric:
0F58           2041       ; Ensure key is 0-9
0F58 EF        2042       mov A, R7
0F59 C3        2043       clr C
0F5A 940A      2044       subb A, #10
0F5C 5031      2045       jnc Symbol_Key_Ignored
0F5E           2046       
0F5E           2047       ; Convert to ASCII
0F5E EF        2048       mov A, R7
0F5F 2430      2049       add A, #0x30
0F61 FD        2050       mov R5, A
0F62           2051   
0F62           2052       ; Save to Buffer
0F62 1211C3    2053       lcall Get_Current_Buffer_Addr
0F65 E574      2054       mov A, Cursor_Idx
0F67 28        2055       add A, R0
0F68 F8        2056       mov R0, A
0F69 ED        2057       mov A, R5
0F6A F6        2058       mov @R0, A
0F6B 0574      2059       inc Cursor_Idx
0F6D           2060   
0F6D           2061       ; --- Check Cursor Limits ---
0F6D E56B      2062       mov A, Current_State
0F6F B40102    2063       cjne A, #1, Check_Limit_Time_1
0F72 8005      2064       sjmp Limit_Temp_3
0F74           2065   
0F74           2066   Check_Limit_Time_1:
0F74 B4030B    2067       cjne A, #3, Limit_Time_4
0F77 8000      2068       sjmp Limit_Temp_3
0F79           2069   
0F79           2070   Limit_Temp_3:
0F79 E574      2071       mov A, Cursor_Idx
0F7B B4030D    2072       cjne A, #3, Do_Refresh
0F7E 1574      2073       dec Cursor_Idx          ; Stay at last digit
0F80 8009      2074       sjmp Do_Refresh
0F82           2075   
0F82           2076   Limit_Time_4:
0F82 E574      2077       mov A, Cursor_Idx
0F84 B40404    2078       cjne A, #4, Do_Refresh
0F87 1574      2079       dec Cursor_Idx          ; Stay at last digit
0F89 8000      2080       sjmp Do_Refresh
0F8B           2081   
0F8B           2082   Do_Refresh:
0F8B 1210B8    2083       lcall Update_Screen_Full
0F8E 22        2084       ret
0F8F           2085   
0F8F           2086   Symbol_Key_Ignored:
0F8F 22        2087       ret
0F90           2088   Keypad_Exit:
0F90 22        2089       ret
0F91           2090   
0F91           2091   ; ----------------------------------------------------------------
0F91           2092   ; MODULE: HARDWARE SCANNER (Matrix Logic)
0F91           2093   ; ----------------------------------------------------------------
0F91           2094   Keypad_Scan:
0F91           2095       ; Step 1: Check if ANY key is pressed (All Rows Low)
0F91 C292      2096       clr ROW1
0F93 C294      2097       clr ROW2
0F95 C296      2098       clr ROW3
0F97 C2A0      2099       clr ROW4
0F99 A2A2      2100       mov C, COL1
0F9B 82A4      2101       anl C, COL2
0F9D 82A6      2102       anl C, COL3
0F9F 82B0      2103       anl C, COL4
0FA1 5002      2104       jnc Keypad_Debounce
0FA3 C3        2105       clr C
0FA4 22        2106       ret
0FA5           2107   
0FA5           2108   Keypad_Debounce:
0FA5 1211AA    2109       lcall Wait_25ms_BLOCKING
0FA8 A2A2      2110       mov C, COL1
0FAA 82A4      2111       anl C, COL2
0FAC 82A6      2112       anl C, COL3
0FAE 82B0      2113       anl C, COL4
0FB0 5002      2114       jnc Keypad_Find_Row
0FB2 C3        2115       clr C
0FB3 22        2116       ret
0FB4           2117   
0FB4           2118   Keypad_Find_Row:
0FB4 D292      2119       setb ROW1
0FB6 D294      2120       setb ROW2
0FB8 D296      2121       setb ROW3
0FBA D2A0      2122       setb ROW4
0FBC           2123   
0FBC           2124       ; Row 1
0FBC C292      2125       clr ROW1
0FBE 30A23D    2126       jnb COL1, Keypad_Key_1
0FC1 30A43E    2127       jnb COL2, Keypad_Key_2
0FC4 30A63F    2128       jnb COL3, Keypad_Key_3
0FC7 30B040    2129       jnb COL4, Keypad_Key_A
0FCA D292      2130       setb ROW1
0FCC           2131   
0FCC           2132       ; Row 2
0FCC C294      2133       clr ROW2
0FCE 30A23D    2134       jnb COL1, Keypad_Key_4
0FD1 30A43E    2135       jnb COL2, Keypad_Key_5
0FD4 30A63F    2136       jnb COL3, Keypad_Key_6
0FD7 30B040    2137       jnb COL4, Keypad_Key_B
0FDA D294      2138       setb ROW2
0FDC           2139   
0FDC           2140       ; Row 3
0FDC C296      2141       clr ROW3
0FDE 30A23D    2142       jnb COL1, Keypad_Key_7
0FE1 30A43E    2143       jnb COL2, Keypad_Key_8
0FE4 30A63F    2144       jnb COL3, Keypad_Key_9
0FE7 30B040    2145       jnb COL4, Keypad_Key_C
0FEA D296      2146       setb ROW3
0FEC           2147   
0FEC           2148       ; Row 4
0FEC C2A0      2149       clr ROW4
0FEE 30A23D    2150       jnb COL1, Keypad_Key_Star
0FF1 30A43E    2151       jnb COL2, Keypad_Key_0
0FF4 30A63F    2152       jnb COL3, Keypad_Key_Hash
0FF7 30B040    2153       jnb COL4, Keypad_Key_D
0FFA D2A0      2154       setb ROW4
0FFC C3        2155       clr C
0FFD 22        2156       ret
0FFE           2157   
0FFE           2158   ; Key Mapping (Renamed to avoid conflicts)
0FFE 7F01      2159   Keypad_Key_1: mov R7, #1
1000 803C      2160          sjmp Wait_Release
1002 7F02      2161   Keypad_Key_2: mov R7, #2
1004 8038      2162          sjmp Wait_Release
1006 7F03      2163   Keypad_Key_3: mov R7, #3
1008 8034      2164          sjmp Wait_Release
100A 7F0A      2165   Keypad_Key_A: mov R7, #10
100C 8030      2166          sjmp Wait_Release
100E 7F04      2167   Keypad_Key_4: mov R7, #4
1010 802C      2168          sjmp Wait_Release
1012 7F05      2169   Keypad_Key_5: mov R7, #5
1014 8028      2170          sjmp Wait_Release
1016 7F06      2171   Keypad_Key_6: mov R7, #6
1018 8024      2172          sjmp Wait_Release
101A 7F0B      2173   Keypad_Key_B: mov R7, #11
101C 8020      2174          sjmp Wait_Release
101E 7F07      2175   Keypad_Key_7: mov R7, #7
1020 801C      2176          sjmp Wait_Release
1022 7F08      2177   Keypad_Key_8: mov R7, #8
1024 8018      2178          sjmp Wait_Release
1026 7F09      2179   Keypad_Key_9: mov R7, #9
1028 8014      2180          sjmp Wait_Release
102A 7F0D      2181   Keypad_Key_C: mov R7, #13
102C 8010      2182          sjmp Wait_Release
102E 7F0E      2183   Keypad_Key_Star: mov R7, #14
1030 800C      2184          sjmp Wait_Release
1032 7F00      2185   Keypad_Key_0: mov R7, #0
1034 8008      2186          sjmp Wait_Release
1036 7F0C      2187   Keypad_Key_Hash: mov R7, #12
1038 8004      2188          sjmp Wait_Release
103A 7F0F      2189   Keypad_Key_D: mov R7, #15
103C 8000      2190          sjmp Wait_Release
103E           2191   
103E           2192   Wait_Release:
103E A2A2      2193       mov C, COL1
1040 82A4      2194       anl C, COL2
1042 82A6      2195       anl C, COL3
1044 82B0      2196       anl C, COL4
1046 50F6      2197       jnc Wait_Release
1048 D3        2198       setb C
1049 D292      2199       setb ROW1
104B D294      2200       setb ROW2
104D D296      2201       setb ROW3
104F D2A0      2202       setb ROW4
1051 22        2203       ret
1052           2204   
1052           2205   Wait_25ms:
1052           2206       ; 1. Check if we are already waiting
1052 20150E    2207       jb wait25_active, Check_Timer_Status
1055           2208       
1055           2209       ; 2. Check if we just finished
1055 301604    2210       jnb wait25_done, Start_New_Timer
1058           2211       
1058           2212       ; 3. Timer is DONE! Reset flags and return True
1058 C216      2213       clr wait25_done
105A D3        2214       setb C          ; Carry = 1 means "Done"
105B 22        2215       ret
105C           2216   
105C           2217   Start_New_Timer:
105C           2218       ; 4. Start a new 25ms wait
105C 755100    2219       mov wait25_count, #0
105F D215      2220       setb wait25_active
1061 C3        2221       clr C           ; Carry = 0 means "Not Done Yet"
1062 22        2222       ret
1063           2223   
1063           2224   Check_Timer_Status:
1063           2225       ; 5. Still waiting... return False immediately
1063 C3        2226       clr C           ; Carry = 0 means "Not Done Yet"
1064 22        2227       ret
1065           2228   
1065           2229   ; ----------------------------------------------------------------
1065           2230   ; MODULE: BUFFER INIT (Reset Logic)
1065           2231   ; ----------------------------------------------------------------
1065           2232   Init_All_Buffers:
1065 7880      2233       mov R0, #Buf_Soak_Temp
1067 12107A    2234       lcall Init_Temp_Template
106A 7889      2235       mov R0, #Buf_Refl_Temp
106C 12107A    2236       lcall Init_Temp_Template
106F 7884      2237       mov R0, #Buf_Soak_Time
1071 121086    2238       lcall Init_Time_Template
1074 788D      2239       mov R0, #Buf_Refl_Time
1076 121086    2240       lcall Init_Time_Template
1079 22        2241       ret
107A           2242   
107A           2243   Init_Temp_Template:
107A 7630      2244       mov @R0, #'0'
107C 08        2245       inc R0
107D 7630      2246       mov @R0, #'0'
107F 08        2247       inc R0
1080 7630      2248       mov @R0, #'0'
1082 08        2249       inc R0
1083 7600      2250       mov @R0, #0
1085 22        2251       ret
1086           2252   
1086           2253   Init_Time_Template:
1086 7630      2254       mov @R0, #'0'
1088 08        2255       inc R0
1089 7630      2256       mov @R0, #'0'
108B 08        2257       inc R0
108C 7630      2258       mov @R0, #'0'
108E 08        2259       inc R0
108F 7630      2260       mov @R0, #'0'
1091 08        2261       inc R0
1092 7600      2262       mov @R0, #0
1094 22        2263       ret
1095           2264   
1095           2265   Reset_Current_Buffer:
1095 E56B      2266       mov A, Current_State
1097 B40106    2267       cjne A, #1, Reset_Chk_2
109A 7880      2268       mov R0, #Buf_Soak_Temp
109C 12107A    2269       lcall Init_Temp_Template
109F 22        2270       ret
10A0           2271   Reset_Chk_2:
10A0 B40206    2272       cjne A, #2, Reset_Chk_3
10A3 7884      2273       mov R0, #Buf_Soak_Time
10A5 121086    2274       lcall Init_Time_Template
10A8 22        2275       ret
10A9           2276   Reset_Chk_3:
10A9 B40306    2277       cjne A, #3, Reset_Chk_4
10AC 7889      2278       mov R0, #Buf_Refl_Temp
10AE 12107A    2279       lcall Init_Temp_Template
10B1 22        2280       ret
10B2           2281   Reset_Chk_4:
10B2 788D      2282       mov R0, #Buf_Refl_Time
10B4 121086    2283       lcall Init_Time_Template
10B7 22        2284       ret
10B8           2285   
10B8           2286   ; ----------------------------------------------------------------
10B8           2287   ; MODULE: SCREEN UPDATE (Visual Logic)
10B8           2288   ; ----------------------------------------------------------------
10B8           2289   Update_Screen_Full:
10B8 1211B0    2290       lcall Clear_Screen_Func
10BB C0E0      2291            push acc
10BD 7401      2291            mov a, #1
10BF 14        2291            dec a
10C0 1207AC    2291            lcall ?Set_Cursor_1 ; Select column and row
10C3 D0E0      2291            pop acc
10C5           2292   
10C5           2293       ; --- Draw Line 1 (Titles) ---
10C5 E56B      2294       mov A, Current_State
10C7 B40013    2295       cjne A, #0, Update_State_1
10CA C083      2296            push dph
10CC C082      2296            push dpl
10CE C0E0      2296            push acc
10D0 900350    2296            mov dptr, #Txt_Home
10D3 12079F    2296            lcall ?Send_Constant_String
10D6 D0E0      2296            pop acc
10D8 D082      2296            pop dpl
10DA D083      2296            pop dph
10DC 22        2297       ret 
10DD           2298   Update_State_1:
10DD B40114    2299       cjne A, #1, Update_State_2
10E0 C083      2300            push dph
10E2 C082      2300            push dpl
10E4 C0E0      2300            push acc
10E6 900361    2300            mov dptr, #Txt_SoakT
10E9 12079F    2300            lcall ?Send_Constant_String
10EC D0E0      2300            pop acc
10EE D082      2300            pop dpl
10F0 D083      2300            pop dph
10F2 8042      2301       sjmp Draw_Temp_Format
10F4           2302   Update_State_2:
10F4 B40214    2303       cjne A, #2, Update_State_3
10F7 C083      2304            push dph
10F9 C082      2304            push dpl
10FB C0E0      2304            push acc
10FD 900372    2304            mov dptr, #Txt_SoakTime
1100 12079F    2304            lcall ?Send_Constant_String
1103 D0E0      2304            pop acc
1105 D082      2304            pop dpl
1107 D083      2304            pop dph
1109 8042      2305       sjmp Draw_Time_Format
110B           2306   Update_State_3:
110B B40314    2307       cjne A, #3, Update_State_4
110E C083      2308            push dph
1110 C082      2308            push dpl
1112 C0E0      2308            push acc
1114 900383    2308            mov dptr, #Txt_ReflT
1117 12079F    2308            lcall ?Send_Constant_String
111A D0E0      2308            pop acc
111C D082      2308            pop dpl
111E D083      2308            pop dph
1120 8014      2309       sjmp Draw_Temp_Format
1122           2310   Update_State_4:
1122 C083      2311            push dph
1124 C082      2311            push dpl
1126 C0E0      2311            push acc
1128 900394    2311            mov dptr, #Txt_ReflTime
112B 12079F    2311            lcall ?Send_Constant_String
112E D0E0      2311            pop acc
1130 D082      2311            pop dpl
1132 D083      2311            pop dph
1134 8017      2312       sjmp Draw_Time_Format
1136           2313   
1136           2314   ; --- Draw Line 2 (Values) ---
1136           2315   Draw_Temp_Format:
1136 C0E0      2316            push acc
1138 7401      2316            mov a, #1
113A 14        2316            dec a
113B 1207AA    2316            lcall ?Set_Cursor_2 ; Select column and row
113E D0E0      2316            pop acc
1140 1211C3    2317       lcall Get_Current_Buffer_Addr
1143 1211A0    2318       lcall Print_String_RAM
1146 7443      2319       mov A, #'C'
1148 120762    2320       lcall ?WriteData
114B 8027      2321       sjmp Restore_Cursor
114D           2322   
114D           2323   Draw_Time_Format:
114D C0E0      2324            push acc
114F 7401      2324            mov a, #1
1151 14        2324            dec a
1152 1207AA    2324            lcall ?Set_Cursor_2 ; Select column and row
1155 D0E0      2324            pop acc
1157 1211C3    2325       lcall Get_Current_Buffer_Addr
115A           2326       ; MM
115A E6        2327       mov A, @R0
115B 120762    2328       lcall ?WriteData
115E 08        2329       inc R0
115F E6        2330       mov A, @R0
1160 120762    2331       lcall ?WriteData
1163 08        2332       inc R0
1164           2333       ; Colon
1164 743A      2334       mov A, #':'
1166 120762    2335       lcall ?WriteData
1169           2336       ; SS
1169 E6        2337       mov A, @R0
116A 120762    2338       lcall ?WriteData
116D 08        2339       inc R0
116E E6        2340       mov A, @R0
116F 120762    2341       lcall ?WriteData
1172           2342       ; Unit
1172           2343       ;got rid of the "s"
1172           2344       ;mov A, #'s'
1172           2345       ;lcall ?WriteData
1172 8000      2346       sjmp Restore_Cursor
1174           2347   
1174           2348   ; --- Restore Cursor Position ---
1174           2349   Restore_Cursor:
1174 E56B      2350       mov A, Current_State
1176 B40202    2351       cjne A, #2, RC_Check_State_4  
1179 800D      2352       sjmp Adjust_Cursor_Time
117B           2353   RC_Check_State_4:             
117B B40402    2354       cjne A, #4, Normal_Cursor
117E 8008      2355       sjmp Adjust_Cursor_Time
1180           2356   
1180           2357   Normal_Cursor:
1180 E574      2358       mov A, Cursor_Idx
1182 24C0      2359       add A, #0xC0
1184 120767    2360       lcall ?WriteCommand
1187 22        2361       ret
1188           2362   
1188           2363   Adjust_Cursor_Time:
1188           2364       ; Skip the colon index (2)
1188 E574      2365       mov A, Cursor_Idx
118A B40201    2366       cjne A, #2, No_Skip
118D 04        2367       inc A 
118E           2368   No_Skip:
118E           2369       ; Add 1 if past the colon
118E C3        2370       clr C
118F 9402      2371       subb A, #2
1191 4005      2372       jc No_Add
1193 E574      2373       mov A, Cursor_Idx
1195 04        2374       inc A
1196 8002      2375       sjmp Final_Cursor_Set
1198           2376   No_Add:
1198 E574      2377       mov A, Cursor_Idx
119A           2378   Final_Cursor_Set:
119A 24C0      2379       add A, #0xC0
119C 120767    2380       lcall ?WriteCommand
119F 22        2381       ret
11A0           2382   
11A0           2383   Print_String_RAM:
11A0 E6        2384       mov A, @R0
11A1 6006      2385       jz Print_String_Done
11A3 120762    2386       lcall ?WriteData
11A6 08        2387       inc R0
11A7 80F7      2388       sjmp Print_String_RAM
11A9           2389   Print_String_Done:
11A9 22        2390       ret
11AA           2391   
11AA           2392   ; Blocking wrapper for LCD clear (keeps old behavior just for this)
11AA           2393   Wait_25ms_BLOCKING:
11AA 121052    2394       lcall Wait_25ms
11AD 50FB      2395       jnc Wait_25ms_BLOCKING ; Keep jumping back until Done (C=1)
11AF 22        2396       ret
11B0           2397   
11B0           2398   Clear_Screen_Func:
11B0 7401      2399       mov A, #0x01
11B2 120767    2400       lcall ?WriteCommand
11B5           2401       
11B5           2402       ; --- FIX: HARDWARE DELAY LOOP (MAX STRENGTH) ---
11B5           2403       ; The LCD needs ~2ms to clear. 
11B5           2404       ; We use R0=255 to guarantee ~5ms+ delay.
11B5           2405       ; This ensures the LCD is 100% ready before we send "Ramp to Soak".
11B5 78FF      2406       mov R0, #255
11B7           2407   Clear_Delay_Loop_Outer:
11B7 79FF      2408       mov R1, #255
11B9           2409   Clear_Delay_Loop_Inner:
11B9 D9FE      2410       djnz R1, Clear_Delay_Loop_Inner
11BB D8FA      2411       djnz R0, Clear_Delay_Loop_Outer
11BD           2412       ; -----------------------------------------------
11BD           2413   
11BD 740C      2414       mov A, #0x0C  ; Display ON, Cursor OFF
11BF 120767    2415       lcall ?WriteCommand
11C2 22        2416       ret
11C3           2417   
11C3           2418   Get_Current_Buffer_Addr:
11C3 E56B      2419       mov A, Current_State
11C5 B40103    2420       cjne A, #1, Get_Buf_2
11C8 7880      2421       mov R0, #Buf_Soak_Temp
11CA 22        2422       ret
11CB           2423   Get_Buf_2:
11CB B40203    2424       cjne A, #2, Get_Buf_3
11CE 7884      2425       mov R0, #Buf_Soak_Time
11D0 22        2426       ret
11D1           2427   Get_Buf_3:
11D1 B40303    2428       cjne A, #3, Get_Buf_4
11D4 7889      2429       mov R0, #Buf_Refl_Temp
11D6 22        2430       ret
11D7           2431   Get_Buf_4:
11D7 788D      2432       mov R0, #Buf_Refl_Time
11D9 22        2433       ret
11DA           2434       
11DA           2435   ; --- Helper to prevent "Machine Gun" button presses ---
11DA           2436   Wait_For_P1_0_Release:
11DA 3090FD    2437       jnb P1.0, $    ; Wait here while the button is still pressed (0)
11DD 22        2438       ret
11DE           2439   
11DE           2440   ; --- Full reset helper for P3.7 (active-low) ---
11DE           2441   Wait_For_P3_7_Release:
11DE 30B7FD    2442       jnb P3_7, $    ; Wait here while the button is still pressed (0)
11E1 22        2443       ret
11E2           2444   
11E2           2445   Full_Reset:
11E2 1211DE    2446       lcall Wait_For_P3_7_Release
11E5 020D52    2447       ljmp main
11E8           2448   
11E8           2449   ; ================================================================
11E8           2450   ; MODULE: THERMOCOUPLE ADC DRIVER (WITH NOISE SUPPRESSION & JUMP FIX)
11E8           2451   ; ================================================================
11E8           2452   Read_Thermocouple:
11E8           2453       ; 1. Check Non-Blocking Timer
11E8 121052    2454       lcall Wait_25ms
11EB           2455       
11EB           2456       ; [FIX] TRAMPOLINE JUMP
11EB           2457       ; "jnc" cannot jump to the end because the code is too long.
11EB           2458       ; We invert logic: If Carry=1 (Time is up), Jump NEARBY.
11EB 4001      2459       jc Proceed_Reading
11ED 22        2460       ret  ; If Carry=0, Return immediately.
11EE           2461   
11EE           2462   Proceed_Reading:
11EE           2463       ; --- 25ms Passed! Time to Read ---
11EE           2464   
11EE           2465       ; [FIX] SILENCE THE BUZZER (Noise Suppression)
11EE           2466       ; Save buzzer state and force it OFF during the sensitive read
11EE E588      2467       mov A, TCON      
11F0 5410      2468       anl A, #0x10     ; Isolate TR0 bit
11F2 C0E0      2469       push acc         ; Save it
11F4 C28C      2470       clr TR0          ; STOP NOISE
11F6           2471   
11F6           2472       ; 2. Initialize / Trigger ADC
11F6 75A180    2473       mov ADC_C, #0x80    ; Reset
11F9 00        2474       nop
11FA 00        2475       nop
11FB 75A101    2476       mov ADC_C, #0x01    ; Start Channel 0
11FE           2477       
11FE           2478       ; 3. Settle Delay
11FE 7DFA      2479       mov R5, #250
1200           2480   ADC_Settle_Loop:
1200 00        2481       nop
1201 00        2482       nop
1202 DDFC      2483       djnz R5, ADC_Settle_Loop
1204           2484       
1204           2485       ; 4. Read Raw Data
1204 85A232    2486       mov x+0, ADC_L
1207 85A333    2487       mov x+1, ADC_H
120A 753400    2488       mov x+2, #0
120D 753500    2489       mov x+3, #0
1210           2490       
1210           2491       ; 5. Mask Data
1210 E533      2492       mov a, x+1
1212 540F      2493       anl a, #0x0F
1214 F533      2494       mov x+1, a
1216           2495       
1216           2496       ; [FIX] RESTORE THE BUZZER
1216 D0E0      2497       pop acc          ; Get previous state
1218 6002      2498       jz Skip_Restore  ; If it was OFF, keep it OFF
121A D28C      2499       setb TR0         ; If it was ON, turn it back ON
121C           2500   Skip_Restore:
121C           2501   
121C           2502       ; 6. Math Conversions
121C 753616    2503            mov y+0, #low (4118 % 0x10000) 
121F 753710    2503            mov y+1, #high(4118 % 0x10000) 
1222 753800    2503            mov y+2, #low (4118 / 0x10000) 
1225 753900    2503            mov y+3, #high(4118 / 0x10000) 
1228 12018C    2504       lcall mul32       
122B           2505   
122B 75A104    2506       mov ADC_C, #0x04    ; Read LM4040
122E 85A236    2507       mov y+0, ADC_L      
1231 85A337    2508       mov y+1, ADC_H      
1234 753800    2509       mov y+2, #0
1237 753900    2510       mov y+3, #0
123A 75A100    2511       mov ADC_C, #0x00    ; Reset
123D           2512       
123D 120280    2513       lcall div32         
1240 753664    2514            mov y+0, #low (100 % 0x10000) 
1243 753700    2514            mov y+1, #high(100 % 0x10000) 
1246 753800    2514            mov y+2, #low (100 / 0x10000) 
1249 753900    2514            mov y+3, #high(100 / 0x10000) 
124C 12018C    2515       lcall mul32
124F 75362B    2516            mov y+0, #low (1323 % 0x10000) 
1252 753705    2516            mov y+1, #high(1323 % 0x10000) 
1255 753800    2516            mov y+2, #low (1323 / 0x10000) 
1258 753900    2516            mov y+3, #high(1323 / 0x10000)         
125B 120280    2517       lcall div32    
125E 753614    2518            mov y+0, #low (COLD_JUNCTION_TEMP % 0x10000) 
1261 753700    2518            mov y+1, #high(COLD_JUNCTION_TEMP % 0x10000) 
1264 753800    2518            mov y+2, #low (COLD_JUNCTION_TEMP / 0x10000) 
1267 753900    2518            mov y+3, #high(COLD_JUNCTION_TEMP / 0x10000) 
126A 1200D3    2519       lcall add32     
126D           2520       
126D           2521       ; 8. Store Result
126D 853241    2522       mov current_temp+0, x+0
1270 853342    2523       mov current_temp+1, x+1
1273 853443    2524       mov current_temp+2, x+2
1276 853544    2525       mov current_temp+3, x+3
1279           2526   
1279 22        2527       ret
127A           2528       
127A           2529   ; ================================================================
127A           2530   ; MODULE: POWER CONTROLLER (The Brain)
127A           2531   ; ================================================================
127A           2532   Power_Control:
127A           2533       ; Default: Turn Heat OFF (Safety)
127A 755E00    2534       mov power_output+0, #0
127D 755F00    2535       mov power_output+1, #0
1280 756000    2536       mov power_output+2, #0
1283 756100    2537       mov power_output+3, #0
1286           2538   
1286 E56A      2539       mov a, Control_FSM_state
1288           2540   
1288           2541       ; --- State 2: RAMP TO SOAK ---
1288 B40202    2542       cjne a, #2, PC_Check_Soak
128B           2543       ; Mode: Full Speed Ahead
128B 8016      2544       sjmp Set_Max_Power
128D           2545   
128D           2546   PC_Check_Soak:
128D           2547       ; --- State 3: SOAK PHASE ---
128D B40305    2548       cjne a, #3, PC_Check_Ramp_Reflow
1290           2549       ; Mode: Maintenance (Low Power)
1290           2550       ; If Temp > Target, OFF. If Temp < Target, 20% Power.
1290 20040F    2551       jb soak_temp_reached, PC_Done ; If hot enough, stay OFF
1293 801B      2552       sjmp Set_20_Percent_Power     ; If cold, use 20%
1295           2553   
1295           2554   PC_Check_Ramp_Reflow:
1295           2555       ; --- State 4: RAMP TO REFLOW ---
1295 B40402    2556       cjne a, #4, PC_Check_Reflow
1298           2557       ; Mode: Full Speed Ahead
1298 8009      2558       sjmp Set_Max_Power
129A           2559   
129A           2560   PC_Check_Reflow:
129A           2561       ; --- State 5: REFLOW PHASE ---
129A B40505    2562       cjne a, #5, PC_Done
129D           2563       ; Mode: Maintenance (Low Power)
129D 200502    2564       jb reflow_temp_reached, PC_Done
12A0 800E      2565       sjmp Set_20_Percent_Power
12A2           2566   
12A2           2567   PC_Done:
12A2 22        2568       ret
12A3           2569   
12A3           2570   ; --- Power Helpers ---
12A3           2571   
12A3           2572   Set_Max_Power:
12A3           2573       ; Load 1500 (0x05DC) = 100% Duty Cycle
12A3 755EDC    2574       mov power_output+0, #0xDC
12A6 755F05    2575       mov power_output+1, #0x05
12A9 756000    2576       mov power_output+2, #0
12AC 756100    2577       mov power_output+3, #0
12AF 22        2578       ret
12B0           2579   
12B0           2580   Set_20_Percent_Power:
12B0           2581       ; Load 300 (0x012C) = 20% Duty Cycle
12B0 755E2C    2582       mov power_output+0, #0x2C
12B3 755F01    2583       mov power_output+1, #0x01
12B6 756000    2584       mov power_output+2, #0
12B9 756100    2585       mov power_output+3, #0
12BC 22        2586       ret
12BD           2587   
12BD           2588   
12BD           2589   ;--------------------------------------------------------------
12BD           2590   ; set servo angle according to the state
12BD           2591   ; call servo control function every 1ms
12BD           2592   ;--------------------------------------------------------------
12BD           2593   call_servo_control:
12BD           2594            ; check current state and change servo angle
12BD E56A      2595            mov a, Control_FSM_state
12BF           2596            
12BF           2597            ; handle state 0
12BF B40004    2598            cjne a, #0, servo_state1
12C2 C220      2599            clr servo_angle_zero ; close door at state 0
12C4 802C      2600            sjmp check_servo_flag
12C6           2601   
12C6           2602            ; handle state 1
12C6           2603            servo_state1:
12C6 B40104    2604            cjne a, #1, servo_state2
12C9 D220      2605            setb servo_angle_zero ; open door at state 1
12CB 8025      2606            sjmp check_servo_flag
12CD           2607   
12CD           2608            ; handle state 2
12CD           2609            servo_state2:
12CD B40204    2610            cjne a, #2, servo_state3
12D0 C220      2611            clr servo_angle_zero ; close door at state 2
12D2 801E      2612            sjmp check_servo_flag
12D4           2613   
12D4           2614            ; handle state 3
12D4           2615            servo_state3:
12D4 B40304    2616            cjne a, #3, servo_state4
12D7 C220      2617            clr servo_angle_zero ; close door at state 3
12D9 8017      2618            sjmp check_servo_flag
12DB           2619   
12DB           2620            ; handle state 4
12DB           2621            servo_state4:
12DB B40404    2622            cjne a, #4, servo_state5
12DE C220      2623            clr servo_angle_zero ; close door at state 4
12E0 8010      2624            sjmp check_servo_flag
12E2           2625   
12E2           2626            ; handle state 5
12E2           2627            servo_state5:
12E2 B40504    2628            cjne a, #5, servo_state6
12E5 C220      2629            clr servo_angle_zero ; close door at state 5
12E7 8009      2630            sjmp check_servo_flag
12E9           2631   
12E9           2632            ; handle state 6
12E9           2633            servo_state6:
12E9 B40604    2634            cjne a, #6, servo_state7
12EC C220      2635            clr servo_angle_zero ; close door at state 6
12EE 8002      2636            sjmp check_servo_flag
12F0           2637   
12F0           2638            ; handle state 7
12F0           2639            servo_state7:
12F0 D220      2640            setb servo_angle_zero ; open door at state 7
12F2           2641   
12F2           2642   check_servo_flag:
12F2           2643            ; check 1 ms flag
12F2 101F01    2644            jbc one_millisecond_flag_servo, run_servo_control
12F5 22        2645            ret
12F6           2646   
12F6           2647   run_servo_control:
12F6 1212FA    2648            lcall servo_control
12F9 22        2649            ret
12FA           2650   
12FA           2651   
12FA           2652   ;---------------------------------------------------------------
12FA           2653   ; servo control
12FA           2654   ; generate a 20 ms period pwm signal to control the servo motor
12FA           2655   ; able to make the servo motor stay at 0 degree and 180 degree
12FA           2656   ;---------------------------------------------------------------
12FA           2657   servo_control:
12FA D2ED      2658       setb LEDRA.5
12FC C0E0      2659            push acc
12FE C0D0      2660            push psw
1300 E579      2661            mov a, servo_pwm_counter ; move servo counter to accumulator
1302 04        2662            inc A ; a += 1
1303 B41402    2663            cjne a, #SERVO_PERIOD, servo_pwm_angle_compare ; jump if wrapup not needed
1306 7400      2664            mov a, #0
1308           2665   
1308           2666   servo_pwm_angle_compare: ; read target angle
1308 F579      2667            mov servo_pwm_counter, A
130A 202009    2668            jb servo_angle_zero, set_zero_degree ; set servo motor to 0 degree
130D           2669            ; set servo motor to 180 degrees
130D E579      2670            mov a, servo_pwm_counter
130F C3        2671            clr c
1310 9402      2672            subb a, #SERVO_180
1312 400B      2673            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 180 degrees duty cycle
1314 800D      2674            sjmp servo_pwm_set_low ; set low if greater
1316           2675   
1316           2676   set_zero_degree:
1316           2677            ; set servo motor to 0 degree
1316 E579      2678            mov a, servo_pwm_counter
1318 C3        2679            clr c
1319 9401      2680            subb a, #SERVO_0
131B 4002      2681            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 0 degrees duty cycle
131D 8004      2682            sjmp servo_pwm_set_low ; set low if greater
131F           2683   
131F           2684   servo_pwm_set_high:
131F           2685            ; set pwm pin high
131F D2B6      2686            setb SERVO_OUT
1321 8002      2687            sjmp servo_control_done
1323           2688   
1323           2689   servo_pwm_set_low:
1323           2690            ; set pwm pin low
1323 C2B6      2691            clr SERVO_OUT
1325           2692   
1325           2693   servo_control_done:
1325 D0D0      2694            pop psw
1327 D0E0      2695            pop acc
1329 22        2696            ret
132A           2697   
132A           2698   ;-------------------------------------------------------------------------------
132A           2699   ; power_control
132A           2700   ;-------------------------------------------------------------------------------
132A           2701   ; Determine the power output based on current state and current temperature 
132A           2702   ; input parameter: Control_FSM_state
132A           2703   ;-------------------------------------------------------------------------------
132A           2704   
132A           2705   proportional_power_control:
132A E56A      2706            mov a, Control_FSM_state
132C           2707   
132C           2708   state0_power_control:
132C           2709            ; idle
132C           2710            ; 0% power
132C B4000F    2711            cjne a, #0, state1_power_control
132F 755E00    2712            mov power_output, #low(NO_POWER)
1332 755F00    2713            mov power_output+1, #low(NO_POWER)
1335 756000    2714            mov power_output+2, #0
1338 756100    2715            mov power_output+3, #0
133B 0214D6    2716            ljmp power_control_done
133E           2717   
133E           2718   state1_power_control:
133E           2719            ; idle
133E           2720            ; 0% power
133E B4010F    2721            cjne a, #1, state2_power_control
1341 755E00    2722            mov power_output, #low(NO_POWER)
1344 755F00    2723            mov power_output+1, #low(NO_POWER)
1347 756000    2724            mov power_output+2, #0
134A 756100    2725            mov power_output+3, #0
134D 0214D6    2726            ljmp power_control_done
1350           2727            
1350           2728   state2_power_control:
1350           2729            ; ramp to soak, ramp to ~150C
1350           2730            ; 100% power
1350 B4020F    2731            cjne a, #2, state3_power_control
1353 755EDC    2732            mov power_output, #low(MAX_POWER)
1356 755F05    2733            mov power_output+1, #high(MAX_POWER)
1359 756000    2734            mov power_output+2, #0
135C 756100    2735            mov power_output+3, #0
135F 0214D6    2736            ljmp power_control_done
1362           2737   
1362           2738   state3_power_control:
1362           2739            ; soak period, hold at 150C
1362           2740            ; 20% base power + proportional calculated power
1362 B40302    2741            cjne a, #3, jump_state4_power_control
1365 8003      2742            sjmp state3_power_control_calculation
1367           2743   
1367           2744   jump_state4_power_control:
1367 021494    2745            ljmp state4_power_control
136A           2746   
136A           2747   state3_power_control_calculation:
136A           2748            ; move soak_temp to x
136A 854532    2749            mov x, soak_temp
136D 854633    2750            mov x+1, soak_temp+1
1370 854734    2751            mov x+2, soak_temp+2
1373 854835    2752            mov x+3, soak_temp+3
1376           2753            ; move current_temp to y
1376 854136    2754            mov y, current_temp
1379 854237    2755            mov y+1, current_temp+1
137C 854338    2756            mov y+2, current_temp+2
137F 854439    2757            mov y+3, current_temp+3
1382           2758   
1382           2759            ; compare between soak_temp and current_temp
1382 C201      2760            clr mf
1384 120178    2761            lcall x_gteq_y
1387 10012B    2762            jbc mf, st_sub_ct
138A           2763            ; current_temp - soak_temp if st < ct
138A C221      2764            clr soak_temp_greater
138C           2765            ; move current_temp to y
138C 854536    2766            mov y, soak_temp
138F 854637    2767            mov y+1, soak_temp+1
1392 854738    2768            mov y+2, soak_temp+2
1395 854839    2769            mov y+3, soak_temp+3
1398           2770            ; move current_temp to x
1398 854132    2771            mov x, current_temp
139B 854233    2772            mov x+1, current_temp+1
139E 854334    2773            mov x+2, current_temp+2
13A1 854435    2774            mov x+3, current_temp+3
13A4 1200F6    2775            lcall sub32
13A7 85326C    2776            mov soak_temp_diff, x
13AA 85336D    2777            mov soak_temp_diff+1, x+1
13AD 85346E    2778            mov soak_temp_diff+2, x+2
13B0 85356F    2779            mov soak_temp_diff+3, x+3
13B3 8011      2780            sjmp proportional_input_soak
13B5           2781   
13B5           2782   st_sub_ct:
13B5           2783            ; soak_temp - current_temp
13B5 D221      2784            setb soak_temp_greater
13B7 1200F6    2785            lcall sub32
13BA 85326C    2786            mov soak_temp_diff, x
13BD 85336D    2787            mov soak_temp_diff+1, x+1
13C0 85346E    2788            mov soak_temp_diff+2, x+2
13C3 85356F    2789            mov soak_temp_diff+3, x+3
13C6           2790   
13C6           2791   proportional_input_soak:
13C6           2792            ; proportaional block calculation       
13C6           2793            ; move soak_temp_diff to x
13C6 856C32    2794            mov x, soak_temp_diff
13C9 856D33    2795            mov x+1, soak_temp_diff+1
13CC 856E34    2796            mov x+2, soak_temp_diff+2
13CF 856F35    2797            mov x+3, soak_temp_diff+3
13D2           2798            ; move proportional gain to y
13D2 753605    2799            mov y+0, #low (KP % 0x10000) 
13D5 753700    2799            mov y+1, #high(KP % 0x10000) 
13D8 753800    2799            mov y+2, #low (KP / 0x10000) 
13DB 753900    2799            mov y+3, #high(KP / 0x10000) 
13DE 12018C    2800            lcall mul32 ; proportional_output = proportional_gain * difference
13E1           2801            
13E1 853270    2802            mov proportional_gain_var, x
13E4 853371    2803            mov proportional_gain_var+1, x+1
13E7 853472    2804            mov proportional_gain_var+2, x+2
13EA 853573    2805            mov proportional_gain_var+3, x+3
13ED           2806   
13ED           2807            ; base_power + soak_power when soak_temp > current_temp
13ED 302129    2808            jnb soak_temp_greater, sub_proportional_soak
13F0 857032    2809            mov x, proportional_gain_var
13F3 857133    2810            mov x+1, proportional_gain_var+1
13F6 857234    2811            mov x+2, proportional_gain_var+2
13F9 857335    2812            mov x+3, proportional_gain_var+3
13FC 75362C    2813            mov y+0, #low (BASE_POWER % 0x10000) 
13FF 753701    2813            mov y+1, #high(BASE_POWER % 0x10000) 
1402 753800    2813            mov y+2, #low (BASE_POWER / 0x10000) 
1405 753900    2813            mov y+3, #high(BASE_POWER / 0x10000) 
1408 1200D3    2814            lcall add32
140B           2815            ; x now holds the power output before the saturator
140B 853270    2816            mov proportional_gain_var, x
140E 853371    2817            mov proportional_gain_var+1, x+1
1411 853472    2818            mov proportional_gain_var+2, x+2
1414 853573    2819            mov proportional_gain_var+3, x+3
1417 803D      2820            sjmp saturator_soak
1419           2821   
1419           2822   sub_proportional_soak:
1419           2823            ; base_power - soak_power when soak_temp <= current_temp
1419 75322C    2824            mov x+0, #low (BASE_POWER % 0x10000) 
141C 753301    2824            mov x+1, #high(BASE_POWER % 0x10000) 
141F 753400    2824            mov x+2, #low (BASE_POWER / 0x10000) 
1422 753500    2824            mov x+3, #high(BASE_POWER / 0x10000) 
1425 857036    2825            mov y, proportional_gain_var
1428 857137    2826            mov y+1, proportional_gain_var+1
142B 857238    2827            mov y+2, proportional_gain_var+2
142E 857339    2828            mov y+3, proportional_gain_var+3
1431           2829   
1431           2830            ; compare whether base_power < proportional_gain_var
1431 C201      2831            clr mf
1433 12011A    2832            lcall x_lt_y ; set mf to 1 if base_power < proportional_gain_var, clamp output to 0
1436 30010E    2833            jnb mf, bp_gteq_pgv
1439 757000    2834            mov proportional_gain_var, #low(NO_POWER)
143C 757100    2835            mov proportional_gain_var+1, #high(NO_POWER)
143F 757200    2836            mov proportional_gain_var+2, #0
1442 757300    2837            mov proportional_gain_var+3, #0
1445 800F      2838            sjmp saturator_soak
1447           2839   
1447           2840   bp_gteq_pgv:
1447           2841            ; calculate subtracted gain
1447 1200F6    2842            lcall sub32
144A           2843            ; x now holds the power output before the saturator
144A 853270    2844            mov proportional_gain_var, x
144D 853371    2845            mov proportional_gain_var+1, x+1
1450 853472    2846            mov proportional_gain_var+2, x+2
1453 853573    2847            mov proportional_gain_var+3, x+3
1456           2848   
1456           2849   saturator_soak:
1456           2850            ; proportional_gain_var now holds the power output before the saturator
1456           2851            ; saturate power output to max power
1456 857032    2852            mov x, proportional_gain_var
1459 857133    2853            mov x+1, proportional_gain_var+1
145C 857234    2854            mov x+2, proportional_gain_var+2
145F 857335    2855            mov x+3, proportional_gain_var+3
1462           2856   
1462 7536DC    2857            mov y+0, #low (MAX_POWER % 0x10000) 
1465 753705    2857            mov y+1, #high(MAX_POWER % 0x10000) 
1468 753800    2857            mov y+2, #low (MAX_POWER / 0x10000) 
146B 753900    2857            mov y+3, #high(MAX_POWER / 0x10000) 
146E           2858   
146E C201      2859            clr mf
1470 120136    2860            lcall x_gt_y ; set mf to 1 if calculated power output greater than max power
1473 20010F    2861            jb mf, saturated_soak
1476           2862            ; set power_output to calculated power if not saturated
1476 85705E    2863            mov power_output, proportional_gain_var
1479 85715F    2864            mov power_output+1, proportional_gain_var+1
147C 857260    2865            mov power_output+2, proportional_gain_var+2
147F 857361    2866            mov power_output+3, proportional_gain_var+3
1482 0214D6    2867            ljmp power_control_done
1485           2868   
1485           2869   saturated_soak:
1485 755EDC    2870            mov power_output, #low(MAX_POWER)
1488 755F05    2871            mov power_output+1, #high(MAX_POWER)
148B 756000    2872            mov power_output+2, #0
148E 756100    2873            mov power_output+3, #0
1491 0214D6    2874            ljmp power_control_done
1494           2875   
1494           2876   
1494           2877   state4_power_control:
1494           2878            ; ramp to reflow, max power
1494 B4040F    2879            cjne a, #4, state5_power_control
1497 755EDC    2880            mov power_output, #low(MAX_POWER)
149A 755F05    2881            mov power_output+1, #high(MAX_POWER)
149D 756000    2882            mov power_output+2, #0
14A0 756100    2883            mov power_output+3, #0
14A3 0214D6    2884            ljmp power_control_done
14A6           2885   
14A6           2886   state5_power_control:
14A6           2887            ; reflow 20% base power
14A6 B4050F    2888            cjne a, #5, state6_power_control
14A9 755E2C    2889            mov power_output, #low(BASE_POWER)  
14AC 755F01    2890            mov power_output+1, #high(BASE_POWER)
14AF 756000    2891            mov power_output+2, #0
14B2 756100    2892            mov power_output+3, #0
14B5 0214D6    2893            ljmp power_control_done
14B8           2894   
14B8           2895   state6_power_control:
14B8           2896            ; cooling 0% power
14B8 B4060F    2897            cjne a, #6, state_7_power_control
14BB 755E00    2898            mov power_output, #low(NO_POWER)
14BE 755F00    2899            mov power_output+1, #high(NO_POWER)
14C1 756000    2900            mov power_output+2, #0
14C4 756100    2901            mov power_output+3, #0
14C7 0214D6    2902            ljmp power_control_done
14CA           2903   
14CA           2904   state_7_power_control:
14CA           2905            ; idle 0% power
14CA 755E00    2906            mov power_output, #low(NO_POWER)
14CD 755F00    2907            mov power_output+1, #high(NO_POWER)
14D0 756000    2908            mov power_output+2, #0
14D3 756100    2909            mov power_output+3, #0
14D6           2910   
14D6           2911   power_control_done:
14D6 22        2912            ret
14D7           2913   
14D7           2914   END
