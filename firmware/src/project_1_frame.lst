0000              1   ; Project 1
0000              2   ; CV-8052 microcontroller in DE10-Lite board
0000              3   ;-------------------------------------------------------------------------------
0000              4   ; Reset vector
0000              5   org 0x0000
0000 020BC1       6       ljmp main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9       reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 02046E      12       ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15       reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18       reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 32          21       reti
0024             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
002B 02052E      24       ljmp Timer2_ISR
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 32   $LIST
0320             34   ; ----------------------------------------------------------------------------------------------;
0320             35   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             36   dseg at 0x30
0030             37   current_time_sec:     ds 1
0031             38   current_time_minute:  ds 1
0032             39   ; math32 buffer variables
0032             40   x:      ds  4
0036             41   y:      ds  4
003A             42   bcd:    ds  5
003F             43   
003F             44   current_temp: ds 4 ;
0043             45   soak_temp:    ds 4 ;
0047             46   reflow_temp:  ds 4 ;
004B             47   
004B             48   wait25_btn_cnt:    ds 1
004C             49   wait25_keypad_cnt: ds 1
004D             50   wait25_adc_cnt:    ds 1
004E             51   wait25_lcd_cnt:    ds 1
004F             52   wait25_count: ds 1  
0050             53   
0050             54   current_time: ds 4 ;
0054             55   soak_time:    ds 4 ;
0058             56   reflow_time:  ds 4 ;
005C             57   
005C             58   power_output:  ds 4 ;
0060             59   pwm_counter: ds 4 ; counter for pwm (0-1500)
0064             60   
0064             61   KEY1_DEB_timer: ds 1
0065             62   SEC_FSM_timer:  ds 1
0066             63   KEY1_DEB_state:    ds 1
0067             64   SEC_FSM_state:     ds 1
0068             65   Control_FSM_state: ds 1 
0069             66   
0069             67   Current_State:     ds 1
006A             68   soak_temp_diff: ds 4 ; temperature difference between target soak temp and current oven temp 
006E             69   proportional_gain_var: ds 4 ; power gain calculated from the proportional block
0072             70   Cursor_Idx: ds 1 ; UI buffers I added
0073             71   
0073             72   ; Buzzer state
0073             73   beep_count:  ds 1      ; remaining beeps
0074             74   beep_state:  ds 1      ; 0=idle, 1=ON, 2=OFF
0075             75   beep_tmr:    ds 2      ; 16-bit ms timer (needs to reach 500)
0077             76   
0077             77   servo_pwm_counter: ds 1 ; counter for the servo pwm signal
0078             78   
0080             79   iseg at 0x80
0080             80   Buf_Soak_Temp: ds 4   
0084             81   Buf_Soak_Time: ds 5   
0089             82   Buf_Refl_Temp: ds 4   
008D             83   Buf_Refl_Time: ds 5
0092             84   ; 46d bytes used
0092             85   ;-------------------------------------------------------------------------------
0092             86   ; bit operation setb, clr, jb, and jnb
0000             87   bseg
0000             88   mf:     dbit 1 ; math32 sign
0001             89   one_second_flag: dbit 1
0002             90   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003             91   
0003             92   soak_temp_reached: dbit 1
0004             93   reflow_temp_reached: dbit 1
0005             94   cooling_temp_reached: dbit 1
0006             95   
0006             96   soak_time_reached: dbit 1
0007             97   reflow_time_reached: dbit 1
0008             98   
0008             99   reset_signal: dbit 1
0009            100   stop_signal: dbit 1
000A            101   start_signal: dbit 1
000B            102   config_finish_signal: dbit 1
000C            103   
000C            104   state_change_signal: dbit 1
000D            105   
000D            106   Key1_flag: dbit 1
000E            107   
000E            108   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
000F            109   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0010            110   PB0_flag: dbit 1 ; start entire program
0011            111   PB1_flag: dbit 1 ; start soak
0012            112   PB2_flag: dbit 1 ; pause process
0013            113   
0013            114   ;buzzer beep
0013            115   one_ms_beep_flag: dbit 1
0014            116   
0014            117   ; BSEG (Bit Segment)
0014            118   wait25_active: dbit 1 ; 1 = We are currently waiting
0015            119   wait25_done:   dbit 1 ; 1 = The 25ms has finished
0016            120   wait25_btn_active:    dbit 1
0017            121   wait25_btn_done:      dbit 1
0018            122   wait25_keypad_active: dbit 1
0019            123   wait25_keypad_done:   dbit 1
001A            124   wait25_adc_active:    dbit 1
001B            125   wait25_adc_done:      dbit 1
001C            126   wait25_lcd_active:    dbit 1
001D            127   wait25_lcd_done:      dbit 1
001E            128   
001E            129   one_millisecond_flag_servo: dbit 1 ; set the one millsiecond flag for servo pwm signal generation
001F            130   servo_angle_zero: dbit 1 ; flag for indicating whether the servo angle should be at 0 or not: 1 -> 0; 0 -> 180
0020            131   soak_temp_greater: dbit 1 ; target soak_temp greater than current_temp
0021            132   ; 11 bits used
0021            133   ;-------------------------------------------------------------------------------
0320            134   cseg
0320            135   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            136   BAUD           EQU 57600
0320            137   
0320            138   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            139   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            140   ; is always 12 unlike the N76E003 where is selectable.
0320            141   
0320            142   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            143   
0320            144   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            145   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            146   
0320            147   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            148   
0320            149   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            150   
0320            151   PWM_OUT        EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            152   DC_OUT         EQU P4.0
0320            153   
0320            154   ; These 'equ' must match the wiring between the DE10Lite board and the LCD
0320            155   ; P0 is in connector JPIO.
0320            156   ;Added correct I/O definitions
0320            157   ;-- LCD Pins ---
0320            158   ELCD_RS equ P1.7
0320            159   ELCD_E  equ P1.1
0320            160   ELCD_D4 equ P0.7
0320            161   ELCD_D5 equ P0.5
0320            162   ELCD_D6 equ P0.3
0320            163   ELCD_D7 equ P0.1
0320            164   
0320            165   ; -- Buttons --
0320            166   BTN_SOAK_TEMP equ P0.0
0320            167   BTN_SOAK_TIME equ P0.2
0320            168   BTN_REFL_TEMP equ P0.4
0320            169   BTN_REFL_TIME equ P0.6
0320            170   
0320            171   ; --- KEYPAD ---
0320            172   ROW1 equ P1.2
0320            173   ROW2 equ P1.4
0320            174   ROW3 equ P1.6
0320            175   ROW4 equ P2.0
0320            176   COL1 equ P2.2
0320            177   COL2 equ P2.4
0320            178   COL3 equ P2.6
0320            179   COL4 equ P3.0
0320            180   
0320            181   SERVO_OUT      EQU p3.6 ; servo pin
0320            182   LED_LEFT       EQU P3.4 ; left LED (PB3.4)
0320            183   LED_MID        EQU P3.3 ; middle LED (PB3.3)
0320            184   LED_RIGHT      EQU P3.2 ; right LED (PB3.2)
0320            185   
0320            186   SERVO_PERIOD   EQU 20 ; pwm signal period for the servo motor (20 ms)
0320            187   SERVO_0        EQU 1 ; pwm high time for the servo motor to stay at 0 degree
0320            188   SERVO_180      EQU 2 ; pwm high time for the servo motor to stay at 180 degrees
0320            189   
0320            190   COLD_JUNCTION_TEMP equ 22
0320            191   MAX_POWER           EQU 1500 ; max oven power
0320            192   NO_POWER            EQU 0    ; no power
0320            193   BASE_POWER     EQU (MAX_POWER/5) ; 20% base power for state 2, 4
0320            194   HALF_POWER     EQU (MAX_POWER/2) ; 50% power indicator
0320            195   KP                          EQU 5 ; proportional gain
0320            196   
0320            197   ;1234567890123456 <-- 16 characters per line LCD
0320 696E6974   198   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   199   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   200   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            201   
0350            202   ;UI STRINGS (REQUIRED FOR KEYPAD LOGIC), <- I can fix if duplicates
0350 53656C65   203   Txt_Home:     db 'Select Mode:    ', 0
     6374204D
     6F64653A
     20202020
     00
0361 53657420   204   Txt_SoakT:    db 'Set Soak Temp   ', 0
     536F616B
     2054656D
     70202020
     00
0372 53657420   205   Txt_SoakTime: db 'Set Soak Time   ', 0
     536F616B
     2054696D
     65202020
     00
0383 53657420   206   Txt_ReflT:    db 'Set Reflow Temp ', 0
     5265666C
     6F772054
     656D7020
     00
0394 53657420   207   Txt_ReflTime: db 'Set Reflow Time ', 0
     5265666C
     6F772054
     696D6520
     00
03A5            208   
03A5            209   ; 1234567890123456
03A5 53657420   210   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
03B5 536F616B   211   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
03C0 5265666C   212   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
03CD 536F616B   213   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
03D8 5265666C   214   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03E5            215   
03E5 54656D70   216   String_temp_line:  db 'Temp: ', 0
     3A2000
03EC            217   
03EC            218   ; 1234567890123456
03EC 52616D70   219   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03FC 536F616B   220   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
040C 52616D70   221   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
041C 5265666C   222   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
042C 436F6F6C   223   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
043C 50726F63   224   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
044C            225   
044C 20202020   226   String_Blank:    db '                ', 0
     20202020
     20202020
     20202020
     00
045D            227   
045D            228   ;-------------------------------------------------------------------------------
045D            229   ; Timers Setting:
045D            230   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
045D            231   ;   Timer 1: Serial port baud rate 57600 generator
045D            232   ;   Timer 2: 1ms interrupt for BCD counter increment/decrement
045D            233   ;-------------------------------------------------------------------------------
045D            234   ; Routine to initialize the ISR for Timer 0 ;
045D            235   Timer0_Init:
045D E589       236       mov a, TMOD
045F 54F0       237       anl a, #0xf0 ; Clear the bits for timer 0
0461 4401       238       orl a, #0x01 ; Configure timer 0 as 16-timer
0463 F589       239       mov TMOD, a
0465 758CFD     240       mov TH0, #high(TIMER0_RELOAD)
0468 758A5A     241       mov TL0, #low(TIMER0_RELOAD)
046B            242       ; Enable the timer and interrupts
046B D2A9       243       setb ET0  ; Enable timer 0 interrupt
046D            244       ; setb TR0  (no need to open at first)
046D 22         245       ret
046E            246   ; ISR for timer 0.  Set to execute every 1/4096Hz 
046E            247   ; to generate a 2048 Hz square wave at pin P1.5 
046E            248   Timer0_ISR:
046E            249       ;clr TF0  ; According to the data sheet this is done for us already.
046E 758CFD     250       mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
0471 758A5A     251       mov TL0, #low(TIMER0_RELOAD)
0474 B295       252       cpl SOUND_OUT ; Connect speaker to P1.5
0476 32         253       reti
0477            254   ; -----------------------------------------------------------------------------------------------;
0477            255   
0477            256   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
0477            257   Initialize_Serial_Port:
0477            258       ; Configure serial port and baud rate
0477 C28E       259       clr TR1 ; Disable timer 1
0479 53890F     260       anl TMOD, #0x0f ; Mask the bits for timer 1
047C 438920     261       orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
047F 438780     262       orl PCON, #80H ; Set SMOD to 1
0482 758DFD     263       mov TH1, #low(TIMER_1_RELOAD)
0485 758BFD     264       mov TL1, #low(TIMER_1_RELOAD) 
0488 D28E       265       setb TR1 ; Enable timer 1
048A 759852     266       mov SCON, #52H
048D 22         267       ret
048E            268   
048E            269   ; uart sending functions
048E            270   putchar:
048E 109902     271       jbc TI, putchar_L1
0491 80FB       272       sjmp putchar
0493            273   putchar_L1:
0493 F599       274       mov SBUF,a
0495 22         275       ret
0496            276   
0496            277   SendString:
0496 E4         278       clr a
0497 93         279       movc a, @a+dptr
0498 6006       280       jz SendString_L1
049A 12048E     281       lcall putchar
049D A3         282       inc dptr
049E 80F6       283       sjmp SendString  
04A0            284   SendString_L1:
04A0 22         285       ret
04A1            286   
04A1            287   ;-------------------------------------------------------------------------------
04A1            288   ; serial debugging
04A1            289   ; send a four byte number via serial to laptop
04A1            290   ; need to be used with python script
04A1            291   ; content needed to be sent should be stored in the varaible x
04A1            292   ;-------------------------------------------------------------------------------
04A1            293   Send32:
04A1            294       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
04A1 74AA       295       mov A, #0AAH
04A3 12048E     296       lcall putchar
04A6 7455       297       mov A, #055H
04A8 12048E     298       lcall putchar
04AB            299   
04AB E535       300       mov A, x+3
04AD 12048E     301       lcall putchar
04B0 E534       302       mov A, x+2
04B2 12048E     303       lcall putchar
04B5 E533       304       mov A, x+1
04B7 12048E     305       lcall putchar
04BA E532       306       mov A, x+0
04BC 12048E     307       lcall putchar
04BF            308   
04BF 740A       309       mov A, #0AH
04C1 12048E     310       lcall putchar
04C4 22         311       ret
04C5            312   ;-------------------------------------------------------------------------------
04C5            313   ; Serial temperature line for PuTTY/screen
04C5            314   ; Outputs: "Temp: XXXC\r\n"
04C5            315   ;-------------------------------------------------------------------------------
04C5            316   Serial_Send_Temp_Line:
04C5 9003E5     317       mov dptr, #String_temp_line
04C8 120496     318       lcall SendString
04CB            319   
04CB            320       ; Convert current_temp to BCD (same as LCD)
04CB 853F32     321       mov x, current_temp
04CE 854033     322       mov x+1, current_temp+1
04D1 854134     323       mov x+2, current_temp+2
04D4 854235     324       mov x+3, current_temp+3
04D7 12002E     325       lcall hex2bcd
04DA            326   
04DA 7F00       327       mov R7, #0          ; printed_flag = 0
04DC            328   
04DC            329       ; Print Hundreds (if non-zero)
04DC E53B       330       mov a, bcd+1
04DE 540F       331       anl a, #0x0F
04E0 6007       332       jz Serial_Skip_Hundreds
04E2 2430       333       add a, #0x30
04E4 12048E     334       lcall putchar
04E7 7F01       335       mov R7, #1
04E9            336   Serial_Skip_Hundreds:
04E9            337   
04E9            338       ; Print Tens (if non-zero or if hundreds already printed)
04E9 E53A       339       mov a, bcd+0
04EB C4         340       swap a
04EC 540F       341       anl a, #0x0F
04EE 7003       342       jnz Serial_Print_Tens
04F0 EF         343       mov a, R7
04F1 600C       344       jz Serial_Skip_Tens
04F3            345   Serial_Print_Tens:
04F3 E53A       346       mov a, bcd+0
04F5 C4         347       swap a
04F6 540F       348       anl a, #0x0F
04F8 2430       349       add a, #0x30
04FA 12048E     350       lcall putchar
04FD 7F01       351       mov R7, #1
04FF            352   Serial_Skip_Tens:
04FF            353   
04FF            354       ; Print Ones (always)
04FF E53A       355       mov a, bcd+0
0501 540F       356       anl a, #0x0F
0503 2430       357       add a, #0x30
0505 12048E     358       lcall putchar
0508            359   
0508            360       ; Print 'C' and newline
0508 7443       361       mov a, #'C'
050A 12048E     362       lcall putchar
050D 740D       363       mov a, #0DH     ; CR
050F 12048E     364       lcall putchar
0512 740A       365       mov a, #0AH     ; LF
0514 12048E     366       lcall putchar
0517 22         367       ret
0518            368   ;-------------------------------------------------------------------------------
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
0518              1   ;-------------------------------------------------------------------------------
0518              2   ; Timer2_ISR.inc
0518              3   ; Contains Initialization and ISR for the 1ms System Timer
0518              4   ;-------------------------------------------------------------------------------
0518              5   
0518              6   ;-------------------------------------------------------------------------------
0518              7   ; Routine to initialize the ISR for timer 2
0518              8   ;-------------------------------------------------------------------------------
0518              9   Timer2_Init:
0518 75C800      10       mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
051B 75CDF5      11       mov TH2, #high(TIMER2_RELOAD)
051E 75CC27      12       mov TL2, #low(TIMER2_RELOAD)
0521             13       ; Set the reload value
0521 75CBF5      14       mov RCAP2H, #high(TIMER2_RELOAD)
0524 75CA27      15       mov RCAP2L, #low(TIMER2_RELOAD)
0527             16       
0527 C2CF        17       clr TF2       ; Clear flag just in case
0529             18       ; Enable the timer and interrupts
0529 D2AD        19       setb ET2      ; Enable timer 2 interrupt
052B D2CA        20       setb TR2      ; Enable timer 2
052D 22          21       ret
052E             22   
052E             23   ;-------------------------------------------------------------------------------
052E             24   ; ISR for timer 2.  Runs every 1 ms
052E             25   ;-------------------------------------------------------------------------------
052E             26   Timer2_ISR:
052E C0E0        27       push acc
0530 C0D0        28       push psw
0532             29       
0532 C2CF        30       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
0534             31   
0534             32       ; --- 1. Existing FSM Timers ---
0534 0564        33       inc KEY1_DEB_timer
0536 0565        34       inc SEC_FSM_timer
0538 D202        35       setb one_ms_pwm_flag 
053A D213        36       setb one_ms_beep_flag
053C D21E        37       setb one_millisecond_flag_servo
053E             38   
053E             39       ; --- 2. NEW: Non-Blocking Delay Counters ---
053E             40       
053E             41       ; A. BUTTON DELAY
053E 30160B      42       jnb wait25_btn_active, T2_Check_Keypad
0541 054B        43       inc wait25_btn_cnt
0543 E54B        44       mov a, wait25_btn_cnt
0545 B41904      45       cjne a, #25, T2_Check_Keypad
0548 D217        46       setb wait25_btn_done
054A C216        47       clr wait25_btn_active
054C             48       
054C             49       ; B. KEYPAD DELAY
054C             50   T2_Check_Keypad:
054C 30180B      51       jnb wait25_keypad_active, T2_Check_ADC
054F 054C        52       inc wait25_keypad_cnt
0551 E54C        53       mov a, wait25_keypad_cnt
0553 B41904      54       cjne a, #25, T2_Check_ADC
0556 D219        55       setb wait25_keypad_done
0558 C218        56       clr wait25_keypad_active
055A             57   
055A             58       ; C. ADC DELAY (Thermocouple)
055A             59   T2_Check_ADC:
055A 301A0B      60       jnb wait25_adc_active, T2_Check_LCD
055D 054D        61       inc wait25_adc_cnt
055F E54D        62       mov a, wait25_adc_cnt
0561 B41904      63       cjne a, #25, T2_Check_LCD
0564 D21B        64       setb wait25_adc_done
0566 C21A        65       clr wait25_adc_active
0568             66   
0568             67       ; D. LCD DELAY
0568             68   T2_Check_LCD:
0568 301C0B      69       jnb wait25_lcd_active, T2_Check_Generic
056B 054E        70       inc wait25_lcd_cnt
056D E54E        71       mov a, wait25_lcd_cnt
056F B41904      72       cjne a, #25, T2_Check_Generic
0572 D21D        73       setb wait25_lcd_done
0574 C21C        74       clr wait25_lcd_active
0576             75   
0576             76       ; E. GENERIC DELAY (Used by Wait_25ms in Main)
0576             77   T2_Check_Generic:
0576 30140B      78       jnb wait25_active, Timer2_ISR_done
0579 054F        79       inc wait25_count
057B E54F        80       mov a, wait25_count
057D B41904      81       cjne a, #25, Timer2_ISR_done
0580 D215        82       setb wait25_done      ; Tells Wait_25ms that we are finished
0582 C214        83       clr wait25_active     ; Stop counting
0584             84   
0584             85   Timer2_ISR_done:
0584 D0D0        86       pop psw
0586 D0E0        87       pop acc
0588 32          88       reti
0589             89            
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
0589              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
0589              2   cseg
0589              3   
0589              4   ; When using a 33.333333MHz crystal clock
0589              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
0589              6   
0589              7   ;---------------------------------;
0589              8   ; Wait 40 microseconds            ;
0589              9   ;---------------------------------;
0589             10   Wait40uSec:
0589 C000        11            push AR0
058B 78BE        12            mov R0, #190
058D             13   L0: 
058D 00          14            nop
058E 00          15            nop
058F 00          16            nop
0590 00          17            nop
0591 D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
0593 D000        19            pop AR0
0595 22          20       ret
0596             21   
0596             22   ;---------------------------------;
0596             23   ; Wait 'R2' milliseconds          ;
0596             24   ;---------------------------------;
                 25   Wait_Milli_Seconds mac
                 26   	push AR2
                 27   	mov R2, %0
                 28   	lcall ?Wait_Milli_Seconds
                 29   	pop AR2
                 30   endmac
0596             31   
0596             32   ?Wait_Milli_Seconds:
0596 C000        33            push AR0
0598 C001        34            push AR1
059A 7932        35   L3: mov R1, #50
059C 78DF        36   L2: mov R0, #223
059E D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
05A0 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
05A2 DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
05A4 D001        40       pop AR1
05A6 D000        41       pop AR0
05A8 22          42       ret
05A9             43            
05A9             44   ;---------------------------------;
05A9             45   ; Toggles the 'E' pin in the LCD  ;
05A9             46   ;---------------------------------;
05A9             47   ELCD_pulse:
05A9 D291        48            setb ELCD_E
05AB 120589      49            lcall Wait40uSec
05AE C291        50            clr ELCD_E
05B0 120589      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
05B3 22          52       ret
05B4             53   
05B4             54   ;---------------------------------;
05B4             55   ; Writes acc to LCD in 4-bit mode ;
05B4             56   ;---------------------------------;
05B4             57   ELCD_byte:
05B4             58            ; Write high 4 bits first
05B4 A2E7        59            mov c, ACC.7
05B6 9281        60            mov ELCD_D7, c
05B8 A2E6        61            mov c, ACC.6
05BA 9283        62            mov ELCD_D6, c
05BC A2E5        63            mov c, ACC.5
05BE 9285        64            mov ELCD_D5, c
05C0 A2E4        65            mov c, ACC.4
05C2 9287        66            mov ELCD_D4, c
05C4 1205A9      67       lcall ELCD_pulse
05C7             68            ; Write low 4 bits next
05C7 A2E3        69            mov c, ACC.3
05C9 9281        70            mov ELCD_D7, c
05CB A2E2        71            mov c, ACC.2
05CD 9283        72            mov ELCD_D6, c
05CF A2E1        73            mov c, ACC.1
05D1 9285        74            mov ELCD_D5, c
05D3 A2E0        75            mov c, ACC.0
05D5 9287        76            mov ELCD_D4, c
05D7 1205A9      77       lcall ELCD_pulse
05DA 22          78            ret
05DB             79   
05DB             80   ;---------------------------------;
05DB             81   ; Write data to LCD               ;
05DB             82   ;---------------------------------;
                 83   WriteData mac
                 84   	mov a, %0
                 85   	lcall ?WriteData
                 86   endmac
05DB             87            
05DB             88   ?WriteData:
05DB D297        89            setb ELCD_RS
05DD 0205B4      90            ljmp ELCD_byte
05E0             91   
05E0             92   ;---------------------------------;
05E0             93   ; Write command to LCD            ;
05E0             94   ;---------------------------------;
                 95   WriteCommand mac
                 96   	mov a, %0
                 97   	lcall ?WriteCommand
                 98   endmac
05E0             99   
05E0            100   ?WriteCommand:
05E0 C297       101            clr ELCD_RS
05E2 0205B4     102            ljmp ELCD_byte
05E5            103   
05E5            104   ;---------------------------------;
05E5            105   ; Configure LCD in 4-bit mode     ;
05E5            106   ;---------------------------------;
05E5            107   ELCD_4BIT:
05E5 C291       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
05E7            109            ;clr ELCD_RW  ; RW forced to zero
05E7            110            
05E7            111            ; After power on, let the LCD start up before initializing
05E7 C002       112            push AR2
05E9 7A28       112            mov R2, #40
05EB 120596     112            lcall ?Wait_Milli_Seconds
05EE D002       112            pop AR2
05F0            113            
05F0            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
05F0 7433       115            mov a, #0x33
05F2 1205E0     115            lcall ?WriteCommand
05F5 7433       116            mov a, #0x33
05F7 1205E0     116            lcall ?WriteCommand
05FA 7432       117            mov a, #0x32
05FC 1205E0     117            lcall ?WriteCommand ; change to 4-bit mode
05FF            118   
05FF            119            ; Configure the LCD
05FF 7428       120            mov a, #0x28
0601 1205E0     120            lcall ?WriteCommand
0604 740C       121            mov a, #0x0c
0606 1205E0     121            lcall ?WriteCommand
0609 7401       122            mov a, #0x01
060B 1205E0     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
060E            123   
060E            124       ;Wait for the clear screen command to finish.
060E C002       125            push AR2
0610 7A02       125            mov R2, #2
0612 120596     125            lcall ?Wait_Milli_Seconds
0615 D002       125            pop AR2
0617 22         126       ret
0618            127   
0618            128   ;---------------------------------;
0618            129   ; Send a constant string to LCD   ;
0618            130   ;---------------------------------;
                131   Send_Constant_String mac
                132   	push dph
                133   	push dpl
                134   	push acc
                135   	mov dptr, %0
                136   	lcall ?Send_Constant_String
                137   	pop acc
                138   	pop dpl
                139   	pop dph
                140   endmac
0618            141   
0618            142   ?Send_Constant_String:
0618 E4         143       clr a
0619 93         144       movc a, @a+dptr
061A 6006       145       jz ?Send_Constant_String_Done
061C 1205DB     146       lcall ?WriteData
061F A3         147       inc dptr
0620 80F6       148       sjmp ?Send_Constant_String
0622            149   ?Send_Constant_String_Done:
0622 22         150       ret  
0623            151   
0623            152   ;---------------------------------;
0623            153   ; Set LCD cursor at row, column   ;
0623            154   ;---------------------------------;
                155   Set_Cursor mac
                156   	push acc
                157   	mov a, #%1
                158   	dec a
                159   	lcall ?Set_Cursor_%0 ; Select column and row
                160   	pop acc
                161   endmac
0623            162   
0623            163   ?Set_Cursor_2:
0623 4440       164            orl a, #01000000B
0625            165   ?Set_Cursor_1:
0625 4480       166            orl a, #10000000B
0627 0205E0     167            ljmp ?WriteCommand ; Select column and row
062A            168   
062A            169   ;---------------------------------;
062A            170   ; Display a BCD number in the LCD ;
062A            171   ;---------------------------------;
                172   Display_BCD mac
                173   	push ar0
                174   	mov r0, %0
                175   	lcall ?Display_BCD
                176   	pop ar0
                177   endmac
062A            178   
062A            179   ?Display_BCD:
062A C0E0       180            push acc
062C            181            ; Write most significant digit
062C E8         182            mov a, r0
062D C4         183            swap a
062E 540F       184            anl a, #0fh
0630 4430       185            orl a, #30h
0632 1205DB     186            lcall ?WriteData
0635            187            ; write least significant digit
0635 E8         188            mov a, r0
0636 540F       189            anl a, #0fh
0638 4430       190            orl a, #30h
063A 1205DB     191            lcall ?WriteData
063D D0E0       192            pop acc
063F 22         193            ret
0640            194   
0640            195   ;------------------------------------;
0640            196   ; Display a char in the LCD          ;
0640            197   ;------------------------------------;
                198   Display_char mac
                199   	push acc
                200   	mov a, %0
                201   	lcall ?WriteData
                202   	pop acc
                203   endmac
0640            204   
0640            371            ;-------------------------------------------------------------------------------
0640            372   ; Display Function for 7-segment displays       
0640            373   ;-------------------------------------------------------------------------------
0640            374   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
0640            375   T_7seg:
0640 C0F9A4B0   376       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
0645 9282F880   377       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
064A 8883C6A1   378       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
0650            379   
0650            380   ; Displays a BCD number pased in R0 in HEX5-HEX0
0650            381   Display_BCD_7_Seg_HEX10:
0650 900640     382       mov dptr, #T_7seg
0653 E8         383       mov a, R0
0654 C4         384       swap a
0655 540F       385       anl a, #0FH
0657 93         386       movc a, @a+dptr
0658 F592       387       mov HEX1, a
065A E8         388       mov a, R0
065B 540F       389       anl a, #0FH
065D 93         390       movc a, @a+dptr
065E F591       391       mov HEX0, a
0660 22         392       ret
0661            393   
0661            394   Display_BCD_7_Seg_HEX32:
0661 900640     395       mov dptr, #T_7seg
0664 E8         396       mov a, R0
0665 C4         397       swap a
0666 540F       398       anl a, #0FH
0668 93         399       movc a, @a+dptr
0669 F594       400       mov HEX3, a
066B E8         401       mov a, R0
066C 540F       402       anl a, #0FH
066E 93         403       movc a, @a+dptr
066F F593       404       mov HEX2, a
0671 22         405       ret
0672            406   
0672            407   Display_BCD_7_Seg_HEX54:
0672 900640     408       mov dptr, #T_7seg
0675 E8         409       mov a, R0
0676 C4         410       swap a
0677 540F       411       anl a, #0FH
0679 93         412       movc a, @a+dptr
067A F58F       413       mov HEX5, a
067C E8         414       mov a, R0
067D 540F       415       anl a, #0FH
067F 93         416       movc a, @a+dptr
0680 F58E       417       mov HEX4, a
0682 22         418       ret
0683            419   
0683            420   ; The 8-bit hex number passed in the accumulator is converted to
0683            421   ; BCD and stored in [R1, R0]
0683            422   Hex_to_bcd_8bit:
0683 75F064     423       mov b, #100
0686 84         424       div ab
0687 F9         425       mov R1, a   ; After dividing, a has the 100s
0688 E5F0       426       mov a, b    ; Remainder is in register b
068A 75F00A     427       mov b, #10
068D 84         428       div ab ; The tens are stored in a, the units are stored in b 
068E C4         429       swap a
068F 54F0       430       anl a, #0xf0
0691 45F0       431       orl a, b
0693 F8         432       mov R0, a
0694 22         433       ret
0695            434   ;-------------------------------------------------------------------------------
0695            435   ; Display Function for LCD                      
0695            436   ;-------------------------------------------------------------------------------
0695            437   LCD_Print_2Digits:
0695 120683     438       lcall Hex_to_bcd_8bit
0698 E8         439       mov a, R0
0699 C4         440       swap a
069A 540F       441       anl a, #0x0F
069C 2430       442       add a, #0x30
069E 1205DB     443       lcall ?WriteData
06A1 E8         444       mov a, R0
06A2 540F       445       anl a, #0x0F
06A4 2430       446       add a, #0x30
06A6 1205DB     447       lcall ?WriteData
06A9 22         448       ret
06AA            449   
06AA            450   LCD_Display_Update_func:
06AA C0E0       451       push acc
06AC            452       
06AC            453   ;-------------------------------------------------------------------------------
06AC            454   ; static text
06AC            455   ; runs only when the state changes
06AC            456   ;-------------------------------------------------------------------------------
06AC 200C03     457       jb state_change_signal, Do_Static_Update
06AF 0207E8     458       ljmp Check_Live_Update
06B2            459   
06B2            460   Do_Static_Update:
06B2 C20C       461       clr state_change_signal
06B4            462       
06B4            463       ; State Changed: Clear Screen and Write Title
06B4 121008     464       lcall Clear_Screen_Func
06B7 E568       465       mov a, Control_FSM_state
06B9            466       
06B9            467       ; State 0: Welcome
06B9 B4003B     468       cjne a, #0, LCD_Check_1
06BC C0E0       469            push acc
06BE 7401       469            mov a, #1
06C0 14         469            dec a
06C1 120625     469            lcall ?Set_Cursor_1 ; Select column and row
06C4 D0E0       469            pop acc
06C6 C083       470            push dph
06C8 C082       470            push dpl
06CA C0E0       470            push acc
06CC 900330     470            mov dptr, #String_state0_1
06CF 120618     470            lcall ?Send_Constant_String
06D2 D0E0       470            pop acc
06D4 D082       470            pop dpl
06D6 D083       470            pop dph
06D8 C0E0       471            push acc
06DA 7401       471            mov a, #1
06DC 14         471            dec a
06DD 120623     471            lcall ?Set_Cursor_2 ; Select column and row
06E0 D0E0       471            pop acc
06E2 C083       472            push dph
06E4 C082       472            push dpl
06E6 C0E0       472            push acc
06E8 900340     472            mov dptr, #String_state0_2
06EB 120618     472            lcall ?Send_Constant_String
06EE D0E0       472            pop acc
06F0 D082       472            pop dpl
06F2 D083       472            pop dph
06F4 0207E5     473       ljmp LCD_Done_Bridge ; Exit
06F7            474   
06F7            475   LCD_Check_1: ; Setup
06F7 B4011F     476       cjne a, #1, LCD_Check_2
06FA C0E0       477            push acc
06FC 7401       477            mov a, #1
06FE 14         477            dec a
06FF 120625     477            lcall ?Set_Cursor_1 ; Select column and row
0702 D0E0       477            pop acc
0704 C083       478            push dph
0706 C082       478            push dpl
0708 C0E0       478            push acc
070A 9003A5     478            mov dptr, #String_state1
070D 120618     478            lcall ?Send_Constant_String
0710 D0E0       478            pop acc
0712 D082       478            pop dpl
0714 D083       478            pop dph
0716 0207E5     479       ljmp LCD_Done_Bridge
0719            480   
0719            481   LCD_Check_2: ; Ramp to Soak
0719 B4021F     482       cjne a, #2, LCD_Check_3
071C C0E0       483            push acc
071E 7401       483            mov a, #1
0720 14         483            dec a
0721 120625     483            lcall ?Set_Cursor_1 ; Select column and row
0724 D0E0       483            pop acc
0726 C083       484            push dph
0728 C082       484            push dpl
072A C0E0       484            push acc
072C 9003EC     484            mov dptr, #String_state2
072F 120618     484            lcall ?Send_Constant_String
0732 D0E0       484            pop acc
0734 D082       484            pop dpl
0736 D083       484            pop dph
0738 020808     485       ljmp LCD_Update_Temp_Value
073B            486   
073B            487   LCD_Check_3: ; Soak
073B B4031F     488       cjne a, #3, LCD_Check_4
073E C0E0       489            push acc
0740 7401       489            mov a, #1
0742 14         489            dec a
0743 120625     489            lcall ?Set_Cursor_1 ; Select column and row
0746 D0E0       489            pop acc
0748 C083       490            push dph
074A C082       490            push dpl
074C C0E0       490            push acc
074E 9003FC     490            mov dptr, #String_state3
0751 120618     490            lcall ?Send_Constant_String
0754 D0E0       490            pop acc
0756 D082       490            pop dpl
0758 D083       490            pop dph
075A 020808     491       ljmp LCD_Update_Temp_Value
075D            492   
075D            493   LCD_Check_4: ; Ramp to Peak
075D B4041F     494       cjne a, #4, LCD_Check_5
0760 C0E0       495            push acc
0762 7401       495            mov a, #1
0764 14         495            dec a
0765 120625     495            lcall ?Set_Cursor_1 ; Select column and row
0768 D0E0       495            pop acc
076A C083       496            push dph
076C C082       496            push dpl
076E C0E0       496            push acc
0770 90040C     496            mov dptr, #String_state4
0773 120618     496            lcall ?Send_Constant_String
0776 D0E0       496            pop acc
0778 D082       496            pop dpl
077A D083       496            pop dph
077C 020808     497       ljmp LCD_Update_Temp_Value
077F            498   
077F            499   LCD_Check_5: ; Reflow
077F B4051F     500       cjne a, #5, LCD_Check_6
0782 C0E0       501            push acc
0784 7401       501            mov a, #1
0786 14         501            dec a
0787 120625     501            lcall ?Set_Cursor_1 ; Select column and row
078A D0E0       501            pop acc
078C C083       502            push dph
078E C082       502            push dpl
0790 C0E0       502            push acc
0792 90041C     502            mov dptr, #String_state5
0795 120618     502            lcall ?Send_Constant_String
0798 D0E0       502            pop acc
079A D082       502            pop dpl
079C D083       502            pop dph
079E 020808     503       ljmp LCD_Update_Temp_Value
07A1            504   
07A1            505   LCD_Check_6: ; Cooling
07A1 B4061F     506       cjne a, #6, LCD_Check_7
07A4 C0E0       507            push acc
07A6 7401       507            mov a, #1
07A8 14         507            dec a
07A9 120625     507            lcall ?Set_Cursor_1 ; Select column and row
07AC D0E0       507            pop acc
07AE C083       508            push dph
07B0 C082       508            push dpl
07B2 C0E0       508            push acc
07B4 90042C     508            mov dptr, #String_state6
07B7 120618     508            lcall ?Send_Constant_String
07BA D0E0       508            pop acc
07BC D082       508            pop dpl
07BE D083       508            pop dph
07C0 020808     509       ljmp LCD_Update_Temp_Value
07C3            510   
07C3            511   LCD_Check_7: ; Done
07C3 B4071F     512       cjne a, #7, LCD_Done_Bridge ; If not 7, we are done
07C6 C0E0       513            push acc
07C8 7401       513            mov a, #1
07CA 14         513            dec a
07CB 120625     513            lcall ?Set_Cursor_1 ; Select column and row
07CE D0E0       513            pop acc
07D0 C083       514            push dph
07D2 C082       514            push dpl
07D4 C0E0       514            push acc
07D6 90043C     514            mov dptr, #String_state7
07D9 120618     514            lcall ?Send_Constant_String
07DC D0E0       514            pop acc
07DE D082       514            pop dpl
07E0 D083       514            pop dph
07E2 0207E5     515       ljmp LCD_Done_Bridge
07E5            516   
07E5            517   ; Local bridge to reach the far-away LCD_Done
07E5            518   LCD_Done_Bridge:
07E5 020869     519       ljmp LCD_Done
07E8            520   
07E8            521   ;-------------------------------------------------------------------------------
07E8            522   ; PART 2: dyanmic for temp
07E8            523   ; runs every time 'one_second_flag' is set
07E8            524   ;-------------------------------------------------------------------------------
07E8            525   Check_Live_Update:
07E8 3001FA     526       jnb one_second_flag, LCD_Done_Bridge
07EB C201       527       clr one_second_flag
07ED            528       
07ED            529       ; Only update temp for States 2, 3, 4, 5, 6
07ED E568       530       mov a, Control_FSM_state
07EF B40202     531       cjne a, #2, Check_St3
07F2 8014       532       sjmp LCD_Update_Temp_Value
07F4            533   Check_St3:
07F4 B40302     534       cjne a, #3, Check_St4
07F7 800F       535       sjmp LCD_Update_Temp_Value
07F9            536   Check_St4:
07F9 B40402     537       cjne a, #4, Check_St5
07FC 800A       538       sjmp LCD_Update_Temp_Value
07FE            539   Check_St5:
07FE B40502     540       cjne a, #5, Check_St6
0801 8005       541       sjmp LCD_Update_Temp_Value
0803            542   Check_St6:
0803 B40663     543       cjne a, #6, LCD_Done
0806 8000       544       sjmp LCD_Update_Temp_Value
0808            545   
0808            546   LCD_Update_Temp_Value:
0808 C0E0       547            push acc
080A 7401       547            mov a, #1
080C 14         547            dec a
080D 120623     547            lcall ?Set_Cursor_2 ; Select column and row
0810 D0E0       547            pop acc
0812 853F32     548       mov x, current_temp
0815 854033     549       mov x+1, current_temp+1
0818 854134     550       mov x+2, current_temp+2
081B 854235     551       mov x+3, current_temp+3
081E 12002E     552       lcall hex2bcd
0821 12086C     553       lcall Update_HEX_Temp 
0824 E53B       554       mov a, bcd+1
0826 540F       555       anl a, #0x0F
0828 2430       556       add a, #0x30
082A 1205DB     557       lcall ?WriteData
082D E53A       558       mov a, bcd+0
082F C4         559       swap a
0830 540F       560       anl a, #0x0F
0832 2430       561       add a, #0x30
0834 1205DB     562       lcall ?WriteData
0837 E53A       563       mov a, bcd+0
0839 540F       564       anl a, #0x0F
083B 2430       565       add a, #0x30
083D 1205DB     566       lcall ?WriteData
0840 7443       567       mov a, #'C'
0842 1205DB     568       lcall ?WriteData
0845 7420       569       mov a, #' '
0847 1205DB     570       lcall ?WriteData
084A 1205DB     571       lcall ?WriteData
084D C0E0       572            push acc
084F 740C       572            mov a, #12
0851 14         572            dec a
0852 120623     572            lcall ?Set_Cursor_2 ; Select column and row
0855 D0E0       572            pop acc
0857 E531       573       mov a, current_time_minute
0859 120695     574       lcall LCD_Print_2Digits
085C 743A       575       mov a, #':'
085E 1205DB     576       lcall ?WriteData
0861 E530       577       mov a, current_time_sec
0863 120695     578       lcall LCD_Print_2Digits
0866 1204C5     579       lcall Serial_Send_Temp_Line
0869            580   
0869            581   LCD_Done:
0869 D0E0       582       pop acc
086B 22         583       ret
086C            584   ;-------------------------------------------------------------------------------
086C            585   ; Update HEX2-HEX0 with temperature (3 digits)
086C            586   ;-------------------------------------------------------------------------------
086C            587   Update_HEX_Temp:
086C 900640     588       mov dptr, #T_7seg
086F            589       ; Hundreds -> HEX2
086F E53B       590       mov a, bcd+1
0871 540F       591       anl a, #0x0F
0873 93         592       movc a, @a+dptr
0874 F593       593       mov HEX2, a
0876            594       ; Tens -> HEX1
0876 E53A       595       mov a, bcd+0
0878 C4         596       swap a
0879 540F       597       anl a, #0x0F
087B 93         598       movc a, @a+dptr
087C F592       599       mov HEX1, a
087E            600       ; Ones -> HEX0
087E E53A       601       mov a, bcd+0
0880 540F       602       anl a, #0x0F
0882 93         603       movc a, @a+dptr
0883 F591       604       mov HEX0, a
0885 22         605       ret
0886            606   
0886            607   KEY1_DEB:
0886            608   ;non-blocking state machine for KEY1 debounce
0886 E566       609       mov a, KEY1_DEB_state
0888            610   KEY1_DEB_state0:
0888 B4000A     611       cjne a, #0, KEY1_DEB_state1
088B 20F92D     612       jb KEY.1, KEY1_DEB_done
088E 756400     613       mov KEY1_DEB_timer, #0
0891 0566       614       inc KEY1_DEB_state
0893 8026       615       sjmp KEY1_DEB_done
0895            616   KEY1_DEB_state1:
0895 B40109     617       cjne a, #1, KEY1_DEB_state2
0898            618       ; this is the debounce state
0898 E564       619       mov a, KEY1_DEB_timer
089A B4321E     620       cjne a, #50, KEY1_DEB_done ; 50 ms passed?
089D 0566       621       inc KEY1_DEB_state
089F 801A       622       sjmp KEY1_DEB_done  
08A1            623   KEY1_DEB_state2:
08A1 B4020C     624       cjne a, #2, KEY1_DEB_state3
08A4 20F904     625       jb KEY.1, KEY1_DEB_state2b
08A7 0566       626       inc KEY1_DEB_state
08A9 8010       627       sjmp KEY1_DEB_done  
08AB            628   KEY1_DEB_state2b:
08AB 756600     629       mov KEY1_DEB_state, #0
08AE 800B       630       sjmp KEY1_DEB_done
08B0            631   KEY1_DEB_state3:
08B0 B40308     632       cjne a, #3, KEY1_DEB_done
08B3 30F905     633       jnb KEY.1, KEY1_DEB_done
08B6 D20D       634       setb Key1_flag ; Suscesfully detected a valid KEY1 press/release
08B8 756600     635       mov KEY1_DEB_state, #0  
08BB            636   KEY1_DEB_done:
08BB 22         637       ret
08BC            638   ;-------------------------------------------------------------------------------
08BC            639   ; Non-blocking FSM for the one second counter
08BC            640   ;-------------------------------------------------------------------------------
08BC            641   SEC_FSM:
08BC E567       642       mov a, SEC_FSM_state
08BE            643   SEC_FSM_state0:
08BE B4000C     644       cjne a, #0, SEC_FSM_state1
08C1 E565       645       mov a, SEC_FSM_timer
08C3 B4FA4B     646       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08C6 756500     647       mov SEC_FSM_timer, #0
08C9 0567       648       inc SEC_FSM_state
08CB 8044       649       sjmp SEC_FSM_done
08CD            650   SEC_FSM_state1: 
08CD B4010E     651       cjne a, #1, SEC_FSM_state2
08D0 D2E9       652       setb LEDRA.1
08D2 E565       653       mov a, SEC_FSM_timer
08D4 B4FA3A     654       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08D7 756500     655       mov SEC_FSM_timer, #0
08DA 0567       656       inc SEC_FSM_state
08DC 8033       657       sjmp SEC_FSM_done
08DE            658   SEC_FSM_state2: 
08DE B4020E     659       cjne a, #2, SEC_FSM_state3
08E1 D2EA       660       setb LEDRA.2
08E3 E565       661       mov a, SEC_FSM_timer
08E5 B4FA29     662       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08E8 756500     663       mov SEC_FSM_timer, #0
08EB 0567       664       inc SEC_FSM_state
08ED 8022       665       sjmp SEC_FSM_done
08EF            666   SEC_FSM_state3: 
08EF B4031F     667       cjne a, #3, SEC_FSM_done
08F2 D2EB       668       setb LEDRA.3
08F4 E565       669       mov a, SEC_FSM_timer
08F6 B4FA18     670       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08F9 756500     671       mov SEC_FSM_timer, #0
08FC 756700     672       mov SEC_FSM_state, #0
08FF D201       673       setb one_second_flag
0901 E530       674       mov a, current_time_sec
0903 B43B07     675       cjne a, #59, IncCurrentTimeSec 
0906 753000     676       mov current_time_sec, #0
0909 0531       677       inc current_time_minute 
090B            678       
090B 8004       679       sjmp SEC_FSM_done
090D            680   
090D            681   IncCurrentTimeSec:
090D 0530       682       inc current_time_sec
090F B2E8       683       cpl LEDRA.0 
0911            684   SEC_FSM_done:
0911 22         685       ret
0912            686   ;-------------------------------------------------------------------------------
0912            687   ; PWM
0912            688   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0912            689   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0912            690   ; ------------------------------------------------------------------------------
0912            691   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0912 100202     692       jbc one_ms_pwm_flag, pwm_wave_generator
0915 8071       693       sjmp end_pwm_generator
0917            694   
0917            695   pwm_wave_generator:
0917 C200       696       clr mf
0919            697       ; move pwm counter value into x for comparison purpose
0919 856032     698       mov x, pwm_counter
091C 856133     699       mov x+1, pwm_counter+1
091F 856234     700       mov x+2, pwm_counter+2
0922 856335     701       mov x+3, pwm_counter+3
0925            702   
0925 7536DB     703            mov y+0, #low (PWM_PERIOD % 0x10000) 
0928 753705     703            mov y+1, #high(PWM_PERIOD % 0x10000) 
092B 753800     703            mov y+2, #low (PWM_PERIOD / 0x10000) 
092E 753900     703            mov y+3, #high(PWM_PERIOD / 0x10000) 
0931            704   
0931            705       ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
0931            706       ; increase x by 1
0931 120152     707       lcall x_eq_y 
0934 20001D     708       jb mf, wrap_pwm_counter
0937            709       ; x not equal 1499, increment by 1
0937 753601     710            mov y+0, #low (1 % 0x10000) 
093A 753700     710            mov y+1, #high(1 % 0x10000) 
093D 753800     710            mov y+2, #low (1 / 0x10000) 
0940 753900     710            mov y+3, #high(1 / 0x10000) 
0943 1200D3     711       lcall add32
0946            712       ; update pwm_counter
0946 853260     713       mov pwm_counter, x
0949 853361     714       mov pwm_counter+1, x+1
094C 853462     715       mov pwm_counter+2, x+2
094F 853563     716       mov pwm_counter+3, x+3
0952 8018       717       sjmp set_pwm
0954            718   
0954            719   wrap_pwm_counter:
0954            720       ; x equal 1499, wrap to 0
0954 753200     721            mov x+0, #low (0 % 0x10000) 
0957 753300     721            mov x+1, #high(0 % 0x10000) 
095A 753400     721            mov x+2, #low (0 / 0x10000) 
095D 753500     721            mov x+3, #high(0 / 0x10000) 
0960 853260     722       mov pwm_counter, x
0963 853361     723       mov pwm_counter+1, x+1
0966 853462     724       mov pwm_counter+2, x+2
0969 853563     725       mov pwm_counter+3, x+3
096C            726   
096C            727   set_pwm:
096C            728       ; compare with power_output, if pwm counter smaller than power_output, 
096C            729       ; set pwm pin high; else set pwm pin low load y with power output value
096C 855C36     730       mov y, power_output
096F 855D37     731       mov y+1, power_output+1
0972 855E38     732       mov y+2, power_output+2
0975 855F39     733       mov y+3, power_output+3
0978            734   
0978            735       ; compare x(pwm counter) with y(power output)
0978 12011A     736       lcall x_lt_y
097B 200006     737       jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
097E            738       ;output set pwm pin low if pwm counter greater than power output
097E C293       739       clr PWM_OUT
0980 C2EC       740       clr LEDRA.4
0982 8004       741       sjmp end_pwm_generator
0984            742   
0984            743   set_pwm_high:
0984 D293       744       setb PWM_OUT
0986 D2EC       745       setb LEDRA.4
0988            746   
0988            747   end_pwm_generator:
0988 22         748       ret
0989            749   ;-------------------------------------------------------------------------------;
0989            750   ; Temp_Compare
0989            751   ; Checks if we have reached the user's target temperatures.
0989            752   ; Sets 'soak_temp_reached' if current_temp >= soak_temp
0989            753   ; Sets 'reflow_temp_reached' if current_temp >= reflow_temp
0989            754   ;-------------------------------------------------------------------------------;
0989            755   Temp_Compare:
0989            756       ; Reset flags initially
0989 C203       757       clr soak_temp_reached
098B C204       758       clr reflow_temp_reached
098D            759   
098D C0E0       760       push acc
098F C0D0       761       push psw
0991 C000       762       push AR0
0993 C001       763       push AR1
0995 C002       764       push AR2
0997            765       
0997            766       ; --- 1. CHECK SOAK TEMP ---
0997            767       ; Copy current_temp to X
0997 783F       768       mov R0, #current_temp
0999 7932       769       mov R1, #x
099B 120A0F     770       lcall Copy4_Bytes_R0_to_R1
099E            771   
099E            772       ; Copy soak_temp to Y
099E 7843       773       mov R0, #soak_temp
09A0 7936       774       mov R1, #y
09A2 120A0F     775       lcall Copy4_Bytes_R0_to_R1
09A5            776   
09A5            777       ; Compare: Is X (Current) < Y (Target)?
09A5 12011A     778       lcall x_lt_y
09A8 200002     779       jb mf, Check_Reflow_Threshold ; If Current < Target, jump (Flag stays 0)
09AB            780       
09AB            781       ; If we are here, Current >= Target
09AB D203       782       setb soak_temp_reached
09AD            783   
09AD            784   Check_Reflow_Threshold:
09AD            785       ; --- 2. CHECK REFLOW TEMP ---
09AD            786       ; Copy current_temp to X (Need to reload X because math32 destroys it)
09AD 783F       787       mov R0, #current_temp
09AF 7932       788       mov R1, #x
09B1 120A0F     789       lcall Copy4_Bytes_R0_to_R1
09B4            790   
09B4            791       ; Copy reflow_temp to Y
09B4 7847       792       mov R0, #reflow_temp
09B6 7936       793       mov R1, #y
09B8 120A0F     794       lcall Copy4_Bytes_R0_to_R1
09BB            795   
09BB            796       ; Compare
09BB 12011A     797       lcall x_lt_y
09BE 200002     798       jb mf, Temp_Compare_Done
09C1            799       
09C1            800       ; If Current >= Target
09C1 D204       801       setb reflow_temp_reached
09C3            802   
09C3            803   Temp_Compare_Done:
09C3 D002       804       pop AR2
09C5 D001       805       pop AR1
09C7 D000       806       pop AR0
09C9 D0D0       807       pop psw
09CB D0E0       808       pop acc
09CD 22         809       ret
09CE            810   ;-------------------------------------------------------------------------------;
09CE            811   ; Time_Compare
09CE            812   ;
09CE            813   ; PURPOSE:
09CE            814   ;   Compare the elapsed time against soak and reflow
09CE            815   ;   time limits.
09CE            816   ;
09CE            817   ; BEHAVIOR:
09CE            818   ;   - If current_time >= soak_time   if soak_time_reached    = 1
09CE            819   ;   - If current_time >= reflow_time if reflow_time_reached = 1
09CE            820   ;
09CE            821   ; NOTES:
09CE            822   ;   - Time values are treated as 32-bit UNSIGNED numbers
09CE            823   ;     (e.g., milliseconds or seconds).
09CE            824   ;   - Uses the SAME compare logic as Temp_Compare.
09CE            825   ;   - This routine ONLY SETS flags.
09CE            826   ;
09CE            827   ; EXPECTED VARIABLES:
09CE            828   ;   current_time[4], soak_time[4], reflow_time[4]
09CE            829   ;   x[4], y[4]
09CE            830   ;   mf, soak_time_reached, reflow_time_reached
09CE            831   ;-------------------------------------------------------------------------------;
09CE            832   Time_Compare:
09CE C0E0       833       push acc
09D0 C0D0       834       push psw
09D2 C000       835       push AR0
09D4 C001       836       push AR1
09D6 C002       837       push AR2
09D8            838   
09D8            839   ; Check: current_time >= soak_time ?
09D8            840       ; Copy current_time of x
09D8 7850       841       mov  R0, #current_time
09DA 7932       842       mov  R1, #x
09DC 120A0F     843       lcall Copy4_Bytes_R0_to_R1
09DF            844   
09DF            845       ; Copy soak_time of y
09DF 7854       846       mov  R0, #soak_time
09E1 7936       847       mov  R1, #y
09E3 120A0F     848       lcall Copy4_Bytes_R0_to_R1
09E6            849   
09E6            850       ; Compare elapsed time vs soak time
09E6 12011A     851       lcall x_lt_y
09E9 200002     852       jb   mf, Time_Soak_NotReached
09EC D206       853       setb soak_time_reached
09EE            854   
09EE            855   ; Check: current_time >= reflow_time ?
09EE            856   Time_Soak_NotReached:
09EE            857       ; Copy current_time of x
09EE 7850       858       mov  R0, #current_time
09F0 7932       859       mov  R1, #x
09F2 120A0F     860       lcall Copy4_Bytes_R0_to_R1
09F5            861   
09F5            862       ; Copy reflow_time of y
09F5 7858       863       mov  R0, #reflow_time
09F7 7936       864       mov  R1, #y
09F9 120A0F     865       lcall Copy4_Bytes_R0_to_R1
09FC            866   
09FC            867       ; Compare elapsed time vs reflow time
09FC 12011A     868       lcall x_lt_y
09FF 200002     869       jb   mf, Time_Reflow_NotReached
0A02 D207       870       setb reflow_time_reached
0A04            871   
0A04            872   Time_Reflow_NotReached:
0A04 D002       873       pop  AR2
0A06 D001       874       pop  AR1
0A08 D000       875       pop  AR0
0A0A D0D0       876       pop  psw
0A0C D0E0       877       pop  acc
0A0E 22         878       ret
0A0F            879   
0A0F            880   ;-------------------------------------------------------------------------------;
0A0F            881   ; Copy4_Bytes_R0_to_R1
0A0F            882   ;
0A0F            883   ; PURPOSE:
0A0F            884   ;   Utility routine to copy a 32-bit value (4 bytes)
0A0F            885   ;   from one memory location to another.
0A0F            886   ;
0A0F            887   ; INPUTS:
0A0F            888   ;   R0 st source address
0A0F            889   ;   R1 at destination address
0A0F            890   ;
0A0F            891   ; USES:
0A0F            892   ;   R2 as loop counter
0A0F            893   ;
0A0F            894   ; EXAMPLE:
0A0F            895   ;   mov R0, #current_temp
0A0F            896   ;   mov R1, #x
0A0F            897   ;   lcall Copy4_Bytes_R0_to_R1
0A0F            898   ;-------------------------------------------------------------------------------;
0A0F            899   Copy4_Bytes_R0_to_R1:
0A0F 7A04       900       mov  R2, #4
0A11            901   Copy4_Loop:
0A11 E6         902       mov  a, @R0
0A12 F7         903       mov  @R1, a
0A13 08         904       inc  R0
0A14 09         905       inc  R1
0A15 DAFA       906       djnz R2, Copy4_Loop
0A17 22         907       ret
0A18            908   
0A18            909   ;-------------------------------------------------------------------------------;
0A18            910   ; Abort condition safety check Temperature time
0A18            911   ;
0A18            912   ; PURPOSE:
0A18            913   ;   Automatic cycle termination on error:
0A18            914   ;   Abort if oven fails to reach at least 50C in first 60s.
0A18            915   ;
0A18            916   ; TRIP CONDITION:
0A18            917   ;   if (current_time >= 60s) AND (current_temp < 50C)
0A18            918   ;       -> set tc_missing_abort
0A18            919   ;       -> set stop_signal
0A18            920   ;
0A18            921   ; ASSUMPTIONS:
0A18            922   ;   - current_time is in SECONDS (32-bit, little-endian)
0A18            923   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
0A18            924   ;
0A18            925   ;   the Load_Y constants accordingly.
0A18            926   ;-------------------------------------------------------------------------------;
0A18            927   Safety_Check_TC:
0A18 C0E0       928       push acc
0A1A C0D0       929       push psw
0A1C C000       930       push AR0
0A1E C001       931       push AR1
0A20 C002       932       push AR2
0A22            933   
0A22            934       ; ---------------------------------------------------------
0A22            935       ; [FIX] GATEKEEPER: IGNORE UNLESS IN STATE 2 (RAMP TO SOAK)
0A22            936       ; ---------------------------------------------------------
0A22 E568       937       mov a, Control_FSM_state
0A24 B40202     938       cjne a, #2, Safety_TC_Exit_Bridge ; If State != 2, skip everything
0A27 8003       939       sjmp Safety_Logic_Proceed         ; If State == 2, do the check
0A29            940   
0A29            941       Safety_TC_Exit_Bridge:
0A29 020A77     942           ljmp Safety_TC_Done               ; Jump to the end
0A2C            943   
0A2C            944       Safety_Logic_Proceed:
0A2C            945           ; If already aborted or startup window closed, do nothing
0A2C 200E48     946           jb   tc_missing_abort, Safety_TC_Done
0A2F 300F45     947           jnb  tc_startup_window, Safety_TC_Done
0A32            948   
0A32            949       ; Check: current_time >= 60 ?
0A32 7850       950       mov  R0, #current_time
0A34 7932       951       mov  R1, #x
0A36 120A0F     952       lcall Copy4_Bytes_R0_to_R1
0A39            953   
0A39 75363C     954            mov y+0, #low (60 % 0x10000) 
0A3C 753700     954            mov y+1, #high(60 % 0x10000) 
0A3F 753800     954            mov y+2, #low (60 / 0x10000) 
0A42 753900     954            mov y+3, #high(60 / 0x10000) 
0A45 12011A     955       lcall x_lt_y
0A48 2000DE     956       jb   mf, Safety_TC_Exit_Bridge        ; still < 60s  keep waiting
0A4B            957   
0A4B            958       ; We reached 60s: close the startup window so it won't re-check later
0A4B C20F       959       clr  tc_startup_window
0A4D            960   
0A4D            961       ; Now check: current_temp < 50 ?
0A4D 783F       962       mov  R0, #current_temp
0A4F 7932       963       mov  R1, #x
0A51 120A0F     964       lcall Copy4_Bytes_R0_to_R1
0A54            965   
0A54 753632     966            mov y+0, #low (50 % 0x10000) 
0A57 753700     966            mov y+1, #high(50 % 0x10000) 
0A5A 753800     966            mov y+2, #low (50 / 0x10000) 
0A5D 753900     966            mov y+3, #high(50 / 0x10000) 
0A60 12011A     967       lcall x_lt_y
0A63 3000C3     968       jnb  mf, Safety_TC_Exit_Bridge        ; temp >= 50  pass
0A66            969   
0A66            970       ; FAIL: at 60s, still below 50C  abort
0A66 C293       971       clr  PWM_OUT
0A68 D20E       972       setb tc_missing_abort
0A6A D209       973       setb stop_signal
0A6C 120A8C     974            lcall Beep_Ten
0A6F            975       ; 3. Force FSM to State 0 (Welcome)
0A6F 756800     976       mov Control_FSM_state, #0
0A72            977       
0A72            978       ; 4. Force UI to State 0 (Home Screen)
0A72 756900     979       mov Current_State, #0
0A75            980       
0A75            981       ; 5. Trigger Screen Refresh
0A75 D20C       982       setb state_change_signal ; Tell loop to redraw "Welcome"
0A77            983   
0A77            984   Safety_TC_Done:
0A77 D002       985       pop  AR2
0A79 D001       986       pop  AR1
0A7B D000       987       pop  AR0
0A7D D0D0       988       pop  psw
0A7F D0E0       989       pop  acc
0A81 22         990       ret
0A82            991   
0A82            992   ; ============================================================
0A82            993   ; BUZZER STARTUP FUNCTIONS
0A82            994   ; ============================================================
0A82            995   
0A82            996   Beep_Once:
0A82 757301     997       mov beep_count, #1
0A85 800A       998       sjmp Beep_Start
0A87            999   
0A87           1000   Beep_Five:
0A87 757305    1001       mov beep_count, #5
0A8A 8005      1002       sjmp Beep_Start
0A8C           1003   
0A8C           1004   Beep_Ten:
0A8C 75730A    1005       mov beep_count, #10
0A8F 8000      1006       sjmp Beep_Start      ; [FIX] Added explicit jump for safety
0A91           1007   
0A91           1008   Beep_Start:
0A91 C28C      1009       clr TR0              ; [FIX] Stop timer briefly to reset cleanly
0A93 757401    1010       mov beep_state, #1   ; Set State to ON
0A96 757500    1011       mov beep_tmr, #0     ; Reset Timer High Byte
0A99 757600    1012       mov beep_tmr+1, #0   ; Reset Timer Low Byte
0A9C D2A9      1013       setb ET0             ; [FIX] Ensure Interrupt is enabled
0A9E D28C      1014       setb TR0             ; START the 2kHz tone
0AA0 22        1015       ret
0AA1           1016   ;-------------------------------------------------------------------------------
0AA1           1017   ; Buzzer beep Task 
0AA1           1018   ; Purpose: beeps, holds, stop
0AA1           1019   ; Buzzer task:
0AA1           1020   ; Beep once when state changes
0AA1           1021   ; Beep five times if finished
0AA1           1022   ; Beep ten times if meets error
0AA1           1023   ;-------------------------------------------------------------------------------
0AA1           1024   Beep_Task:
0AA1 301335    1025       jnb one_ms_beep_flag, Beep_Done
0AA4 C213      1026       clr one_ms_beep_flag
0AA6           1027   
0AA6 E574      1028       mov a, beep_state
0AA8 602F      1029       jz Beep_Done
0AAA           1030   
0AAA           1031   ; ---- increment 16-bit timer ----
0AAA 0575      1032       inc beep_tmr
0AAC E575      1033       mov a, beep_tmr
0AAE 7002      1034       jnz Beep_Check
0AB0 0576      1035       inc beep_tmr+1
0AB2           1036   
0AB2           1037   Beep_Check:
0AB2           1038       ; FUZZY TIMER CHECK
0AB2           1039       ; Check if High Byte is non-zero (Time >= 256ms)
0AB2 E576      1040       mov a, beep_tmr+1
0AB4 6023      1041       jz Beep_Done        ; If 0, keep beeping
0AB6           1042   
0AB6           1043       ; --- Time Limit Reached ---
0AB6 757500    1044       mov beep_tmr, #0    ; Reset timer
0AB9 757600    1045       mov beep_tmr+1, #0
0ABC           1046   
0ABC E574      1047       mov a, beep_state
0ABE B40106    1048       cjne a, #1, Beep_Off_State
0AC1           1049   
0AC1           1050       ; State was 1 (ON) -> Turn OFF
0AC1 C28C      1051       clr TR0             ; Hardware Silence
0AC3 757402    1052       mov beep_state, #2  ; Set State to OFF (Pause)
0AC6 22        1053       ret
0AC7           1054   
0AC7           1055   Beep_Off_State:
0AC7           1056   ; ---- OFF finished -> decrement count / next ON ----
0AC7 1573      1057       dec beep_count
0AC9 E573      1058       mov a, beep_count
0ACB 6006      1059       jz  Beep_Stop
0ACD           1060   
0ACD 757401    1061       mov beep_state, #1
0AD0 D28C      1062       setb TR0
0AD2 22        1063       ret
0AD3           1064   
0AD3           1065   Beep_Stop:
0AD3 C28C      1066       clr TR0
0AD5 757400    1067       mov beep_state, #0
0AD8 22        1068       ret
0AD9           1069   
0AD9           1070   Beep_Done:
0AD9 22        1071       ret
0ADA           1072   ;-------------------------------------------------------------------------------;
0ADA           1073   ; Main Control FSM for the entire process
0ADA           1074   ;-------------------------------------------------------------------------------;
0ADA           1075   Control_FSM:
0ADA E568      1076       mov a, Control_FSM_state
0ADC 8005      1077       sjmp Control_FSM_state0
0ADE           1078   
0ADE           1079   Control_FSM_state0_a:
0ADE 756800    1080       mov Control_FSM_state, #0
0AE1 D20C      1081       setb state_change_signal
0AE3           1082            
0AE3           1083   Control_FSM_state0:
0AE3 B40015    1084       cjne a, #0, Control_FSM_state1
0AE6 209005    1085       jb P1.0, Control_FSM_done_bridge ; If Button High (Not Pressed), Exit
0AE9 121032    1086       lcall Wait_For_P1_0_Release      ; If Low (Pressed), Wait & Proceed
0AEC 8001      1087       sjmp Control_FSM_state1_a  
0AEE           1088       
0AEE           1089   Control_FSM_done_bridge:
0AEE 22        1090       ret
0AEF           1091   
0AEF           1092   Control_FSM_state1_a:
0AEF 0568      1093       inc Control_FSM_state
0AF1 756900    1094       mov Current_State, #0
0AF4 120F10    1095       lcall Update_Screen_Full 
0AF7 D20C      1096       setb state_change_signal
0AF9 E568      1097       mov a, Control_FSM_state
0AFB           1098       
0AFB           1099   Control_FSM_state1:
0AFB B40127    1100       cjne a, #1, Control_FSM_state2
0AFE 120D48    1101       lcall Check_Buttons 
0B01 120D94    1102       lcall Check_Keypad
0B04           1103       
0B04           1104       ; Check if Button is HIGH (Not Pressed). If so, exit.
0B04 209008    1105       jb P1.0, Control_FSM_state1_ret
0B07           1106       
0B07           1107       ; If we get here, Button is LOW (Pressed)
0B07 121032    1108       lcall Wait_For_P1_0_Release
0B0A 120CCC    1109       lcall Update_FSM_Variables
0B0D 8001      1110       sjmp Control_FSM_state2_a
0B0F           1111   Control_FSM_state1_ret:
0B0F 22        1112       ret
0B10           1113   
0B10           1114   ; --- STATE 2: RAMP TO SOAK ---
0B10           1115   Control_FSM_state2_a:
0B10 0568      1116       inc Control_FSM_state
0B12 E568      1117       mov a, Control_FSM_state   ; RELOAD 'A' so it matches the new state!
0B14 D20C      1118       setb state_change_signal
0B16 120A82    1119       lcall Beep_Once
0B19           1120   
0B19 D20F      1121       setb tc_startup_window    ; OPEN the safety window
0B1B C20E      1122       clr tc_missing_abort      ; Clear any previous aborts
0B1D 753000    1123       mov current_time_sec, #0  ; Reset Seconds to 0
0B20 753100    1124       mov current_time_minute, #0 ; Reset Minutes to 0
0B23           1125       
0B23           1126       ; CLEAR FLAG ON ENTRY
0B23           1127       ; Force the system to wait for at least one fresh temp reading
0B23           1128       ; before deciding we are done.
0B23 C203      1129       clr soak_temp_reached      
0B25           1130   
0B25           1131   Control_FSM_state2:
0B25 B4021F    1132       cjne a, #2, Control_FSM_state3
0B28 301205    1133       jnb PB2_flag, State2_Check
0B2B C212      1134       clr PB2_flag
0B2D 020B98    1135       ljmp Control_FSM_state6_a ; Pause
0B30           1136   
0B30           1137   State2_Check:
0B30 300313    1138       jnb soak_temp_reached, State2_Ret
0B33           1139       
0B33           1140       ; --- Move to State 3 ---
0B33 C203      1141       clr soak_temp_reached
0B35 0568      1142       inc Control_FSM_state
0B37           1143       
0B37           1144       ; RELOAD 'A'
0B37 E568      1145       mov a, Control_FSM_state   
0B39           1146       
0B39 D20C      1147       setb state_change_signal
0B3B 120A82    1148       lcall Beep_Once
0B3E           1149       
0B3E 753000    1150       mov current_time_sec, #0
0B41 753100    1151       mov current_time_minute, #0
0B44           1152       
0B44           1153       ; Ensure we start State 3 fresh
0B44 C206      1154       clr soak_time_reached 
0B46           1155   
0B46           1156   State2_Ret:
0B46 22        1157       ret
0B47           1158   
0B47           1159   ; --- STATE 3: SOAK PHASE ---
0B47           1160   Control_FSM_state3:
0B47 B40315    1161       cjne a, #3, Control_FSM_state4
0B4A 301205    1162       jnb PB2_flag, State3_Check
0B4D C212      1163       clr PB2_flag
0B4F 020B98    1164       ljmp Control_FSM_state6_a
0B52           1165   State3_Check:
0B52 300609    1166       jnb soak_time_reached, State3_Ret
0B55 C206      1167       clr soak_time_reached
0B57 0568      1168       inc Control_FSM_state      
0B59 D20C      1169       setb state_change_signal 
0B5B 120A82    1170            lcall Beep_Once
0B5E           1171   State3_Ret:
0B5E 22        1172       ret
0B5F           1173   
0B5F           1174   ; --- STATE 4: RAMP TO PEAK ---
0B5F           1175   Control_FSM_state4:
0B5F B4041D    1176       cjne a, #4, Control_FSM_state5
0B62 301205    1177       jnb PB2_flag, State4_Check
0B65 C212      1178       clr PB2_flag
0B67 020B98    1179       ljmp Control_FSM_state6_a
0B6A           1180   State4_Check:
0B6A 300411    1181       jnb reflow_temp_reached, State4_Ret
0B6D C204      1182       clr reflow_temp_reached
0B6F 0568      1183       inc Control_FSM_state
0B71 D20C      1184       setb state_change_signal
0B73 120A82    1185            lcall Beep_Once
0B76 753000    1186       mov current_time_sec, #0
0B79 753100    1187       mov current_time_minute, #0
0B7C C207      1188       clr reflow_time_reached ; Kill the ghost flag
0B7E           1189   State4_Ret:
0B7E 22        1190       ret
0B7F           1191   
0B7F           1192   ; --- STATE 5: REFLOW PHASE ---
0B7F           1193   Control_FSM_state5:
0B7F B40502    1194       cjne a, #5, Control_FSM_state6_trampoline
0B82 8003      1195       sjmp State5_Logic
0B84           1196   Control_FSM_state6_trampoline:
0B84 020B9F    1197       ljmp Control_FSM_state6
0B87           1198   
0B87           1199   State5_Logic:
0B87 301205    1200       jnb PB2_flag, State5_Check
0B8A C212      1201       clr PB2_flag
0B8C 020B98    1202       ljmp Control_FSM_state6_a
0B8F           1203   State5_Check:
0B8F 300705    1204       jnb reflow_time_reached, State5_Ret
0B92 C207      1205       clr reflow_time_reached
0B94 020B98    1206       ljmp Control_FSM_state6_a
0B97           1207   State5_Ret:
0B97 22        1208       ret
0B98           1209   
0B98           1210   ; --- STATE 6: COOLING ---
0B98           1211   Control_FSM_state6_a:
0B98 0568      1212       inc Control_FSM_state
0B9A D20C      1213       setb state_change_signal
0B9C 120A87    1214            lcall Beep_Five
0B9F           1215   Control_FSM_state6:
0B9F B4060A    1216       cjne a, #6, Control_FSM_state7
0BA2           1217       ; Wait for Cooling Temp Reached
0BA2 300506    1218       jnb cooling_temp_reached, State6_Ret
0BA5 C205      1219       clr cooling_temp_reached
0BA7 0568      1220       inc Control_FSM_state
0BA9 D20C      1221       setb state_change_signal
0BAB           1222   State6_Ret:
0BAB 22        1223       ret
0BAC           1224   
0BAC           1225   ; --- STATE 7: DONE ---
0BAC           1226   Control_FSM_state7:
0BAC B40711    1227       cjne a, #7, Control_FSM_done
0BAF           1228       
0BAF 201009    1229       jb PB0_flag, Control_FSM_Reset_Logic
0BB2           1230       
0BB2 20900B    1231       jb P1.0, Control_FSM_done
0BB5           1232       
0BB5 121032    1233       lcall Wait_For_P1_0_Release
0BB8 020ADE    1234       ljmp Control_FSM_state0_a
0BBB           1235   
0BBB           1236   Control_FSM_Reset_Logic:
0BBB C210      1237       clr PB0_flag
0BBD 020ADE    1238       ljmp Control_FSM_state0_a
0BC0           1239   
0BC0           1240   Control_FSM_done:
0BC0 22        1241       ret
0BC1           1242   ;-------------------------------------------------------------------------------
0BC1           1243   ; Main program.          
0BC1           1244   ;-------------------------------------------------------------------------------;
0BC1           1245   main:
0BC1           1246   
0BC1 C2AF      1247       clr EA              ; FORCE Interrupts OFF immediately
0BC3 7581C0    1248       mov SP, #0xC0       ; Reset Stack Pointer to safe location
0BC6           1249       
0BC6 78FA      1250       mov R0, #250
0BC8           1251   Reset_Delay_Outer:
0BC8 79FF      1252       mov R1, #255
0BCA           1253   Reset_Delay_Inner:
0BCA D9FE      1254       djnz R1, Reset_Delay_Inner
0BCC D8FA      1255       djnz R0, Reset_Delay_Outer
0BCE           1256       
0BCE           1257       ; --- port config ---
0BCE 759AAA    1258       mov P0MOD, #0xAA
0BD1           1259   
0BD1           1260       ; P1: Mixed usage 
0BD1           1261       ; P1.7(LCD_RS), P1.6(Row3), P1.5(Sound), P1.4(Row2)
0BD1           1262       ; P1.3(PWM), P1.2(Row1), P1.1(LCD_E) -> All Outputs
0BD1           1263       ; P1.0 (Unused/RX) -> Input
0BD1           1264       ; Binary: 11111110 -> Hex: 0xFE
0BD1 759BFE    1265       mov P1MOD, #0xFE
0BD4           1266   
0BD4           1267       ; P2: Row4(Out), Cols(In)
0BD4           1268       ; P2.0 (Row4) is Out (1). P2.2, P2.4, P2.6 (Cols) are In (0).
0BD4           1269       ; Binary: 00000001 -> Hex: 0x01
0BD4 759C01    1270       mov P2MOD, #0x01
0BD7           1271   
0BD7           1272       ; P3: Col4(In), Servo + LED outputs
0BD7           1273       ; P3.0 (Col4) is In (0). P3.6 (Servo) is Out (1).
0BD7           1274       ; P3.4/3.3/3.2 (LEDs) are Out (1).
0BD7           1275       ; Binary: 01011100 -> Hex: 0x5C
0BD7 759D5C    1276       mov P3MOD, #01011100B
0BDA           1277       ; P4.0 used for dc output
0BDA 75C101    1278       mov P4MOD, #00000001B
0BDD           1279       ; Turn off all the LEDs
0BDD 75E800    1280       mov LEDRA, #0 ; LEDRA is bit addressable
0BE0 759500    1281       mov LEDRB, #0 ; LEDRB is NOT bit addresable
0BE3           1282   
0BE3           1283       ; Enable Global interrupts
0BE3 D2AF      1284       setb EA  
0BE5           1285   
0BE5           1286       ; FSM initial states
0BE5 756600    1287       mov KEY1_DEB_state, #0
0BE8 756700    1288       mov SEC_FSM_state, #0
0BEB 756800    1289       mov Control_FSM_state, #0
0BEE 756900    1290       mov Current_State, #0
0BF1           1291       
0BF1           1292       ; FSM timers initialization
0BF1 756400    1293       mov KEY1_DEB_timer, #0
0BF4 756500    1294       mov SEC_FSM_timer, #0
0BF7           1295       ; time counters initialization
0BF7 753000    1296       mov current_time_sec, #0
0BFA 753100    1297       mov current_time_minute, #0
0BFD           1298       ; Initialize counter to zero
0BFD 756000    1299       mov pwm_counter, #0
0C00 756100    1300       mov pwm_counter+1, #0
0C03 756200    1301       mov pwm_counter+2, #0
0C06 756300    1302       mov pwm_counter+3, #0
0C09           1303       ; Initialize power output
0C09 755F00    1304       mov power_output+3, #0
0C0C 755E00    1305       mov power_output+2, #0
0C0F 755D02    1306       mov power_output+1, #02H
0C12 755CEE    1307       mov power_output, #0EEH ; (initilize to 750 for testing)
0C15           1308   
0C15           1309       ; Clear all the flags
0C15 C20E      1310       clr  tc_missing_abort
0C17 C209      1311       clr  stop_signal
0C19 C210      1312       clr PB0_flag
0C1B C211      1313       clr PB1_flag
0C1D C212      1314       clr PB2_flag
0C1F C201      1315       clr one_second_flag
0C21 C20B      1316       clr config_finish_signal
0C23 C203      1317       clr soak_temp_reached
0C25 C206      1318       clr soak_time_reached
0C27 C204      1319       clr reflow_temp_reached
0C29 C207      1320       clr reflow_time_reached
0C2B C205      1321       clr cooling_temp_reached
0C2D C20C      1322       clr state_change_signal
0C2F C21E      1323       clr one_millisecond_flag_servo
0C31 C2C0      1324       clr DC_OUT
0C33           1325   
0C33           1326       
0C33 D20C      1327       setb state_change_signal
0C35           1328   
0C35           1329       ; Set bit
0C35 D20F      1330       setb tc_startup_window
0C37 757400    1331       mov beep_state, #0
0C3A 757300    1332       mov beep_count, #0
0C3D 757500    1333       mov beep_tmr, #0
0C40 757600    1334       mov beep_tmr+1, #0
0C43 C213      1335       clr one_ms_beep_flag
0C45 C28C      1336       clr TR0              ; Force buzzer hardware OFF
0C47           1337   
0C47 12045D    1338       lcall Timer0_Init
0C4A 120518    1339       lcall Timer2_Init
0C4D 1205E5    1340       lcall ELCD_4BIT
0C50           1341       ;----- Two new lines I added to initialize the UI
0C50 120EBD    1342       lcall Init_All_Buffers
0C53 120F10    1343       lcall Update_Screen_Full
0C56           1344       ;-----
0C56 120477    1345       lcall Initialize_Serial_Port
0C59           1346   
0C59 1213B6    1347       lcall music ; boot up music
0C5C           1348   ;-------------------------------------------------------------------------------;
0C5C           1349   ; while(1) loop
0C5C           1350   ;-------------------------------------------------------------------------------;
0C5C           1351   loop:
0C5C           1352       ; Full reset button on P3.7 (active-low to GND)
0C5C 30B702    1353        jnb P3_7, Full_Reset_Trig
0C5F 8003      1354       sjmp Full_Reset_Check_Done
0C61           1355   
0C61           1356   Full_Reset_Trig:
0C61 02103A    1357       ljmp Full_Reset
0C64           1358   
0C64           1359   Full_Reset_Check_Done:
0C64           1360       ; Check the FSM for KEY1 debounce
0C64 120886    1361       lcall KEY1_DEB
0C67           1362       
0C67           1363       ; Added to take temp readings
0C67 121040    1364       lcall Read_Thermocouple
0C6A           1365       
0C6A           1366       ; 1. Check if we reached temp (Observer)
0C6A 120989    1367       lcall Temp_Compare
0C6D           1368       
0C6D           1369       ; 2. Decide heater power based on flags (Driver)
0C6D           1370       ;lcall Power_Control
0C6D 121209    1371       lcall proportional_power_control
0C70           1372       ; 2b. Update LED power indicators (PB3.4/3.3/3.2)
0C70 1211B8    1373       lcall Update_Power_LEDs
0C73           1374   
0C73 853132    1375       mov x+0, current_time_minute
0C76 753300    1376       mov x+1, #0
0C79 753400    1377       mov x+2, #0
0C7C 753500    1378       mov x+3, #0
0C7F           1379       
0C7F           1380       ; Multiply by 60 (Minutes -> Seconds)
0C7F 75363C    1381            mov y+0, #low (60 % 0x10000) 
0C82 753700    1381            mov y+1, #high(60 % 0x10000) 
0C85 753800    1381            mov y+2, #low (60 / 0x10000) 
0C88 753900    1381            mov y+3, #high(60 / 0x10000) 
0C8B 12018C    1382       lcall mul32
0C8E           1383       
0C8E           1384       ; Load Seconds into Y
0C8E 853036    1385       mov y+0, current_time_sec
0C91 753700    1386       mov y+1, #0
0C94 753800    1387       mov y+2, #0
0C97 753900    1388       mov y+3, #0
0C9A           1389       
0C9A           1390       ; Add them together (Total Seconds = X + Y)
0C9A 1200D3    1391       lcall add32
0C9D           1392       
0C9D           1393       ; Store Final Result into 'current_time'
0C9D 853250    1394       mov current_time+0, x+0
0CA0 853351    1395       mov current_time+1, x+1
0CA3 853452    1396       mov current_time+2, x+2
0CA6 853553    1397       mov current_time+3, x+3
0CA9           1398       
0CA9 1209CE    1399       lcall Time_Compare
0CAC           1400       
0CAC 120A18    1401       lcall Safety_Check_TC
0CAF           1402   
0CAF           1403       ; Check the FSM for one second counter
0CAF 1208BC    1404       lcall SEC_FSM
0CB2           1405   
0CB2           1406       ; Check the FSM for the overall control flow of the reflow process
0CB2 120ADA    1407       lcall Control_FSM
0CB5           1408   
0CB5           1409       ; Update the LCD display based on the current state
0CB5 1206AA    1410       lcall LCD_Display_Update_func
0CB8           1411   
0CB8 300202    1412       jnb one_ms_pwm_flag, Skip_Beep_Sync
0CBB D213      1413       setb one_ms_beep_flag  ; Give the buzzer its own copy of the time tick
0CBD           1414   
0CBD           1415   Skip_Beep_Sync:
0CBD           1416       ; Update the pwm output for the ssr
0CBD 120912    1417       lcall PWM_Wave 
0CC0           1418            ; Update the Buzzer 
0CC0 120AA1    1419            lcall Beep_Task
0CC3           1420       ; Update the pwm output for the servo
0CC3 121115    1421       lcall call_servo_control
0CC6           1422       ; Update the output for the dc motor
0CC6 121182    1423       lcall dc_control
0CC9           1424       ; After initialization the program stays in this 'forever' loop
0CC9 020C5C    1425       ljmp loop
0CCC           1426   ;-------------------------------------------------------------------------------;
0CCC           1427   Update_FSM_Variables:
0CCC           1428       ; --- 1. SOAK TEMP ---
0CCC 7880      1429       mov R0, #Buf_Soak_Temp
0CCE 120D0B    1430       lcall Parse_Temp_String
0CD1 8F43      1431       mov soak_temp+0, R7
0CD3 754400    1432       mov soak_temp+1, #0
0CD6 754500    1433       mov soak_temp+2, #0
0CD9 754600    1434       mov soak_temp+3, #0
0CDC           1435   
0CDC           1436       ; --- 2. REFLOW TEMP ---
0CDC 7889      1437       mov R0, #Buf_Refl_Temp
0CDE 120D0B    1438       lcall Parse_Temp_String
0CE1 8F47      1439       mov reflow_temp+0, R7
0CE3 754800    1440       mov reflow_temp+1, #0
0CE6 754900    1441       mov reflow_temp+2, #0
0CE9 754A00    1442       mov reflow_temp+3, #0
0CEC           1443   
0CEC           1444       ; --- 3. SOAK TIME ---
0CEC 7884      1445       mov R0, #Buf_Soak_Time
0CEE 120D1F    1446       lcall Parse_Time_String
0CF1 8F54      1447       mov soak_time+0, R7
0CF3 8E55      1448       mov soak_time+1, R6
0CF5 755600    1449       mov soak_time+2, #0
0CF8 755700    1450       mov soak_time+3, #0
0CFB           1451   
0CFB           1452       ; --- 4. REFLOW TIME ---
0CFB 788D      1453       mov R0, #Buf_Refl_Time
0CFD 120D1F    1454       lcall Parse_Time_String
0D00 8F58      1455       mov reflow_time+0, R7
0D02 8E59      1456       mov reflow_time+1, R6
0D04 755A00    1457       mov reflow_time+2, #0
0D07 755B00    1458       mov reflow_time+3, #0
0D0A 22        1459       ret
0D0B           1460   
0D0B           1461   ; --- Helper: Parse "123" to Integer ---
0D0B           1462   Parse_Temp_String:
0D0B 7F00      1463       mov R7, #0              ; Clear Result
0D0D           1464   Parse_Temp_Loop:
0D0D E6        1465       mov A, @R0
0D0E 600E      1466       jz Parse_Temp_Done      ; If Null, we are done
0D10           1467       
0D10           1468       ; Convert ASCII to Digit
0D10 C3        1469       clr C
0D11 9430      1470       subb A, #0x30
0D13 FD        1471       mov R5, A               ; R5 = New Digit
0D14           1472       
0D14           1473       ; Result = (Result * 10) + New Digit
0D14 EF        1474       mov A, R7
0D15 75F00A    1475       mov B, #10
0D18 A4        1476       mul AB
0D19 2D        1477       add A, R5
0D1A FF        1478       mov R7, A
0D1B           1479       
0D1B 08        1480       inc R0
0D1C 80EF      1481       sjmp Parse_Temp_Loop
0D1E           1482   Parse_Temp_Done:
0D1E 22        1483       ret
0D1F           1484   
0D1F           1485   ; --- Parse "MMSS" to ceconds ---
0D1F           1486   Parse_Time_String:
0D1F           1487       ; 1. minutes tens
0D1F E6        1488       mov A, @R0
0D20 9430      1489       subb A, #0x30
0D22 75F00A    1490       mov B, #10
0D25 A4        1491       mul AB
0D26 FD        1492       mov R5, A
0D27 08        1493       inc R0
0D28           1494       
0D28           1495       ;2. minutes ones
0D28 E6        1496       mov A, @R0
0D29 9430      1497       subb A, #0x30
0D2B 2D        1498       add A, R5
0D2C FD        1499       mov R5, A        
0D2D 08        1500       inc R0
0D2E           1501       
0D2E           1502       ; 3. seconds tens
0D2E E6        1503       mov A, @R0
0D2F 9430      1504       subb A, #0x30
0D31 75F00A    1505       mov B, #10
0D34 A4        1506       mul AB
0D35 FC        1507       mov R4, A
0D36 08        1508       inc R0
0D37           1509       
0D37           1510       ;4. seconds ones
0D37 E6        1511       mov A, @R0
0D38 9430      1512       subb A, #0x30
0D3A 2C        1513       add A, R4            
0D3B           1514       
0D3B           1515       ; 5. calc total seconds = (Mins * 60) + Secs
0D3B ED        1516       mov A, R5
0D3C 75F03C    1517       mov B, #60
0D3F A4        1518       mul AB
0D40 2C        1519       add A, R4
0D41 FF        1520       mov R7, A          
0D42 E5F0      1521       mov A, B
0D44 3400      1522       addc A, #0
0D46 FE        1523       mov R6, A     
0D47 22        1524       ret
0D48           1525   
0D48           1526   ;-------------------------------------------------------------------------------
0D48           1527   ; mode selection
0D48           1528   ;-------------------------------------------------------------------------------
0D48           1529   Check_Buttons:
0D48           1530       ; This clears any '0' the LCD library might have written to our buttons
0D48 438055    1531       orl P0, #055H   ;ets P0.0, P0.2, P0.4, and P0.6 to '1' (Input Mode)
0D4B           1532   
0D4B 30800A    1533       jnb BTN_SOAK_TEMP, Btn_Soak_Temp_Press
0D4E 308212    1534       jnb BTN_SOAK_TIME, Btn_Soak_Time_Press
0D51 30841A    1535       jnb BTN_REFL_TEMP, Btn_Refl_Temp_Press
0D54 308622    1536       jnb BTN_REFL_TIME, Btn_Refl_Time_Press
0D57 22        1537       ret
0D58           1538   
0D58           1539   Btn_Soak_Temp_Press:
0D58 121002    1540       lcall Wait_25ms_BLOCKING
0D5B 756901    1541       mov Current_State, #1
0D5E 757200    1542       mov Cursor_Idx, #0
0D61 8021      1543       sjmp Redraw_Screen
0D63           1544   
0D63           1545   Btn_Soak_Time_Press:
0D63 121002    1546       lcall Wait_25ms_BLOCKING
0D66 756902    1547       mov Current_State, #2
0D69 757200    1548       mov Cursor_Idx, #0
0D6C 8016      1549       sjmp Redraw_Screen
0D6E           1550   
0D6E           1551   Btn_Refl_Temp_Press:
0D6E 121002    1552       lcall Wait_25ms_BLOCKING
0D71 756903    1553       mov Current_State, #3
0D74 757200    1554       mov Cursor_Idx, #0
0D77 800B      1555       sjmp Redraw_Screen
0D79           1556   
0D79           1557   Btn_Refl_Time_Press:
0D79 121002    1558       lcall Wait_25ms_BLOCKING 
0D7C 756904    1559       mov Current_State, #4
0D7F 757200    1560       mov Cursor_Idx, #0
0D82 8000      1561       sjmp Redraw_Screen
0D84           1562   
0D84           1563   Redraw_Screen:
0D84           1564       ; Wait for button release
0D84 3080FD    1565       jnb BTN_SOAK_TEMP, $
0D87 3082FD    1566       jnb BTN_SOAK_TIME, $
0D8A 3084FD    1567       jnb BTN_REFL_TEMP, $
0D8D 3086FD    1568       jnb BTN_REFL_TIME, $
0D90           1569   
0D90 120F10    1570       lcall Update_Screen_Full
0D93 22        1571       ret
0D94           1572   ; ----------------------------------------------------------------
0D94           1573   ; MODULE: KEYPAD HANDLER (Input Logic)
0D94           1574   ; ----------------------------------------------------------------
0D94           1575   Check_Keypad:
0D94           1576       ; If State is 0 (Home), ignore keypad
0D94 E569      1577       mov A, Current_State
0D96 6050      1578       jz Keypad_Exit
0D98           1579       
0D98 120DE9    1580       lcall Keypad_Scan
0D9B 504B      1581       jnc Keypad_Exit         ; Carry = 0 means no key pressed
0D9D           1582   
0D9D EF        1583       mov A, R7
0D9E B40E0A    1584       cjne A, #14, Check_Hash ; 14 is Star (*)
0DA1           1585       
0DA1 120EED    1586       lcall Reset_Current_Buffer
0DA4 120F10    1587       lcall Update_Screen_Full
0DA7 757200    1588       mov Cursor_Idx, #0
0DAA 22        1589       ret
0DAB           1590   
0DAB           1591   Check_Hash:
0DAB EF        1592       mov A, R7
0DAC B40C01    1593       cjne A, #12, Check_Numeric 
0DAF 22        1594       ret                
0DB0           1595   
0DB0           1596   Check_Numeric:
0DB0           1597       ; Ensure key is 0-9
0DB0 EF        1598       mov A, R7
0DB1 C3        1599       clr C
0DB2 940A      1600       subb A, #10
0DB4 5031      1601       jnc Symbol_Key_Ignored
0DB6           1602       
0DB6           1603       ; Convert to ASCII
0DB6 EF        1604       mov A, R7
0DB7 2430      1605       add A, #0x30
0DB9 FD        1606       mov R5, A
0DBA           1607   
0DBA           1608       ;save to Buffer
0DBA 12101B    1609       lcall Get_Current_Buffer_Addr
0DBD E572      1610       mov A, Cursor_Idx
0DBF 28        1611       add A, R0
0DC0 F8        1612       mov R0, A
0DC1 ED        1613       mov A, R5
0DC2 F6        1614       mov @R0, A
0DC3 0572      1615       inc Cursor_Idx
0DC5           1616   
0DC5           1617       ;Check cursor limits ---
0DC5 E569      1618       mov A, Current_State
0DC7 B40102    1619       cjne A, #1, Check_Limit_Time_1
0DCA 8005      1620       sjmp Limit_Temp_3
0DCC           1621   
0DCC           1622   Check_Limit_Time_1:
0DCC B4030B    1623       cjne A, #3, Limit_Time_4
0DCF 8000      1624       sjmp Limit_Temp_3
0DD1           1625   
0DD1           1626   Limit_Temp_3:
0DD1 E572      1627       mov A, Cursor_Idx
0DD3 B4030D    1628       cjne A, #3, Do_Refresh
0DD6 1572      1629       dec Cursor_Idx          
0DD8 8009      1630       sjmp Do_Refresh
0DDA           1631   
0DDA           1632   Limit_Time_4:
0DDA E572      1633       mov A, Cursor_Idx
0DDC B40404    1634       cjne A, #4, Do_Refresh
0DDF 1572      1635       dec Cursor_Idx         
0DE1 8000      1636       sjmp Do_Refresh
0DE3           1637   
0DE3           1638   Do_Refresh:
0DE3 120F10    1639       lcall Update_Screen_Full
0DE6 22        1640       ret
0DE7           1641   
0DE7           1642   Symbol_Key_Ignored:
0DE7 22        1643       ret
0DE8           1644   Keypad_Exit:
0DE8 22        1645       ret
0DE9           1646   
0DE9           1647   ;-------------------------------------------------------------------------------
0DE9           1648   ; hardware
0DE9           1649   ;-------------------------------------------------------------------------------
0DE9           1650   Keypad_Scan:
0DE9 C292      1651       clr ROW1
0DEB C294      1652       clr ROW2
0DED C296      1653       clr ROW3
0DEF C2A0      1654       clr ROW4
0DF1 A2A2      1655       mov C, COL1
0DF3 82A4      1656       anl C, COL2
0DF5 82A6      1657       anl C, COL3
0DF7 82B0      1658       anl C, COL4
0DF9 5002      1659       jnc Keypad_Debounce
0DFB C3        1660       clr C
0DFC 22        1661       ret
0DFD           1662   
0DFD           1663   Keypad_Debounce:
0DFD 121002    1664       lcall Wait_25ms_BLOCKING
0E00 A2A2      1665       mov C, COL1
0E02 82A4      1666       anl C, COL2
0E04 82A6      1667       anl C, COL3
0E06 82B0      1668       anl C, COL4
0E08 5002      1669       jnc Keypad_Find_Row
0E0A C3        1670       clr C
0E0B 22        1671       ret
0E0C           1672   
0E0C           1673   Keypad_Find_Row:
0E0C D292      1674       setb ROW1
0E0E D294      1675       setb ROW2
0E10 D296      1676       setb ROW3
0E12 D2A0      1677       setb ROW4
0E14           1678   
0E14           1679       ; Row 1
0E14 C292      1680       clr ROW1
0E16 30A23D    1681       jnb COL1, Keypad_Key_1
0E19 30A43E    1682       jnb COL2, Keypad_Key_2
0E1C 30A63F    1683       jnb COL3, Keypad_Key_3
0E1F 30B040    1684       jnb COL4, Keypad_Key_A
0E22 D292      1685       setb ROW1
0E24           1686   
0E24           1687       ; Row 2
0E24 C294      1688       clr ROW2
0E26 30A23D    1689       jnb COL1, Keypad_Key_4
0E29 30A43E    1690       jnb COL2, Keypad_Key_5
0E2C 30A63F    1691       jnb COL3, Keypad_Key_6
0E2F 30B040    1692       jnb COL4, Keypad_Key_B
0E32 D294      1693       setb ROW2
0E34           1694   
0E34           1695       ; Row 3
0E34 C296      1696       clr ROW3
0E36 30A23D    1697       jnb COL1, Keypad_Key_7
0E39 30A43E    1698       jnb COL2, Keypad_Key_8
0E3C 30A63F    1699       jnb COL3, Keypad_Key_9
0E3F 30B040    1700       jnb COL4, Keypad_Key_C
0E42 D296      1701       setb ROW3
0E44           1702   
0E44           1703       ; Row 4
0E44 C2A0      1704       clr ROW4
0E46 30A23D    1705       jnb COL1, Keypad_Key_Star
0E49 30A43E    1706       jnb COL2, Keypad_Key_0
0E4C 30A63F    1707       jnb COL3, Keypad_Key_Hash
0E4F 30B040    1708       jnb COL4, Keypad_Key_D
0E52 D2A0      1709       setb ROW4
0E54 C3        1710       clr C
0E55 22        1711       ret
0E56           1712   
0E56           1713   ; Key Mapping
0E56 7F01      1714   Keypad_Key_1: mov R7, #1
0E58 803C      1715          sjmp Wait_Release
0E5A 7F02      1716   Keypad_Key_2: mov R7, #2
0E5C 8038      1717          sjmp Wait_Release
0E5E 7F03      1718   Keypad_Key_3: mov R7, #3
0E60 8034      1719          sjmp Wait_Release
0E62 7F0A      1720   Keypad_Key_A: mov R7, #10
0E64 8030      1721          sjmp Wait_Release
0E66 7F04      1722   Keypad_Key_4: mov R7, #4
0E68 802C      1723          sjmp Wait_Release
0E6A 7F05      1724   Keypad_Key_5: mov R7, #5
0E6C 8028      1725          sjmp Wait_Release
0E6E 7F06      1726   Keypad_Key_6: mov R7, #6
0E70 8024      1727          sjmp Wait_Release
0E72 7F0B      1728   Keypad_Key_B: mov R7, #11
0E74 8020      1729          sjmp Wait_Release
0E76 7F07      1730   Keypad_Key_7: mov R7, #7
0E78 801C      1731          sjmp Wait_Release
0E7A 7F08      1732   Keypad_Key_8: mov R7, #8
0E7C 8018      1733          sjmp Wait_Release
0E7E 7F09      1734   Keypad_Key_9: mov R7, #9
0E80 8014      1735          sjmp Wait_Release
0E82 7F0D      1736   Keypad_Key_C: mov R7, #13
0E84 8010      1737          sjmp Wait_Release
0E86 7F0E      1738   Keypad_Key_Star: mov R7, #14
0E88 800C      1739          sjmp Wait_Release
0E8A 7F00      1740   Keypad_Key_0: mov R7, #0
0E8C 8008      1741          sjmp Wait_Release
0E8E 7F0C      1742   Keypad_Key_Hash: mov R7, #12
0E90 8004      1743          sjmp Wait_Release
0E92 7F0F      1744   Keypad_Key_D: mov R7, #15
0E94 8000      1745          sjmp Wait_Release
0E96           1746   
0E96           1747   Wait_Release:
0E96 A2A2      1748       mov C, COL1
0E98 82A4      1749       anl C, COL2
0E9A 82A6      1750       anl C, COL3
0E9C 82B0      1751       anl C, COL4
0E9E 50F6      1752       jnc Wait_Release
0EA0 D3        1753       setb C
0EA1 D292      1754       setb ROW1
0EA3 D294      1755       setb ROW2
0EA5 D296      1756       setb ROW3
0EA7 D2A0      1757       setb ROW4
0EA9 22        1758       ret
0EAA           1759   
0EAA           1760   Wait_25ms:
0EAA           1761       ; 1. Check if we are already waiting
0EAA 20140E    1762       jb wait25_active, Check_Timer_Status
0EAD           1763       
0EAD           1764       ; 2. Check if we just finished
0EAD 301504    1765       jnb wait25_done, Start_New_Timer
0EB0           1766       
0EB0           1767       ; 3. Timer is done
0EB0 C215      1768       clr wait25_done
0EB2 D3        1769       setb C          ; Carry = 1 means done
0EB3 22        1770       ret
0EB4           1771   
0EB4           1772   Start_New_Timer:
0EB4           1773       ; 4. Start a new 25ms wait
0EB4 754F00    1774       mov wait25_count, #0
0EB7 D214      1775       setb wait25_active
0EB9 C3        1776       clr C           ; Carry = 0 means not yet
0EBA 22        1777       ret
0EBB           1778   
0EBB           1779   Check_Timer_Status:
0EBB           1780       ; 5. Still waiting... return False immediately
0EBB C3        1781       clr C           ; Carry = 0 means "Not Done Yet"
0EBC 22        1782       ret
0EBD           1783   
0EBD           1784   ;-------------------------------------------------------------------------------
0EBD           1785   ; reset logic
0EBD           1786   ;-------------------------------------------------------------------------------
0EBD           1787   Init_All_Buffers:
0EBD 7880      1788       mov R0, #Buf_Soak_Temp
0EBF 120ED2    1789       lcall Init_Temp_Template
0EC2 7889      1790       mov R0, #Buf_Refl_Temp
0EC4 120ED2    1791       lcall Init_Temp_Template
0EC7 7884      1792       mov R0, #Buf_Soak_Time
0EC9 120EDE    1793       lcall Init_Time_Template
0ECC 788D      1794       mov R0, #Buf_Refl_Time
0ECE 120EDE    1795       lcall Init_Time_Template
0ED1 22        1796       ret
0ED2           1797   
0ED2           1798   Init_Temp_Template:
0ED2 7630      1799       mov @R0, #'0'
0ED4 08        1800       inc R0
0ED5 7630      1801       mov @R0, #'0'
0ED7 08        1802       inc R0
0ED8 7630      1803       mov @R0, #'0'
0EDA 08        1804       inc R0
0EDB 7600      1805       mov @R0, #0
0EDD 22        1806       ret
0EDE           1807   
0EDE           1808   Init_Time_Template:
0EDE 7630      1809       mov @R0, #'0'
0EE0 08        1810       inc R0
0EE1 7630      1811       mov @R0, #'0'
0EE3 08        1812       inc R0
0EE4 7630      1813       mov @R0, #'0'
0EE6 08        1814       inc R0
0EE7 7630      1815       mov @R0, #'0'
0EE9 08        1816       inc R0
0EEA 7600      1817       mov @R0, #0
0EEC 22        1818       ret
0EED           1819   
0EED           1820   Reset_Current_Buffer:
0EED E569      1821       mov A, Current_State
0EEF B40106    1822       cjne A, #1, Reset_Chk_2
0EF2 7880      1823       mov R0, #Buf_Soak_Temp
0EF4 120ED2    1824       lcall Init_Temp_Template
0EF7 22        1825       ret
0EF8           1826   Reset_Chk_2:
0EF8 B40206    1827       cjne A, #2, Reset_Chk_3
0EFB 7884      1828       mov R0, #Buf_Soak_Time
0EFD 120EDE    1829       lcall Init_Time_Template
0F00 22        1830       ret
0F01           1831   Reset_Chk_3:
0F01 B40306    1832       cjne A, #3, Reset_Chk_4
0F04 7889      1833       mov R0, #Buf_Refl_Temp
0F06 120ED2    1834       lcall Init_Temp_Template
0F09 22        1835       ret
0F0A           1836   Reset_Chk_4:
0F0A 788D      1837       mov R0, #Buf_Refl_Time
0F0C 120EDE    1838       lcall Init_Time_Template
0F0F 22        1839       ret
0F10           1840   
0F10           1841   ; ----------------------------------------------------------------
0F10           1842   ; screen update 
0F10           1843   ; ----------------------------------------------------------------
0F10           1844   Update_Screen_Full:
0F10 121008    1845       lcall Clear_Screen_Func
0F13 C0E0      1846            push acc
0F15 7401      1846            mov a, #1
0F17 14        1846            dec a
0F18 120625    1846            lcall ?Set_Cursor_1 ; Select column and row
0F1B D0E0      1846            pop acc
0F1D           1847   
0F1D E569      1848       mov A, Current_State
0F1F B40013    1849       cjne A, #0, Update_State_1
0F22 C083      1850            push dph
0F24 C082      1850            push dpl
0F26 C0E0      1850            push acc
0F28 900350    1850            mov dptr, #Txt_Home
0F2B 120618    1850            lcall ?Send_Constant_String
0F2E D0E0      1850            pop acc
0F30 D082      1850            pop dpl
0F32 D083      1850            pop dph
0F34 22        1851       ret 
0F35           1852   Update_State_1:
0F35 B40114    1853       cjne A, #1, Update_State_2
0F38 C083      1854            push dph
0F3A C082      1854            push dpl
0F3C C0E0      1854            push acc
0F3E 900361    1854            mov dptr, #Txt_SoakT
0F41 120618    1854            lcall ?Send_Constant_String
0F44 D0E0      1854            pop acc
0F46 D082      1854            pop dpl
0F48 D083      1854            pop dph
0F4A 8042      1855       sjmp Draw_Temp_Format
0F4C           1856   Update_State_2:
0F4C B40214    1857       cjne A, #2, Update_State_3
0F4F C083      1858            push dph
0F51 C082      1858            push dpl
0F53 C0E0      1858            push acc
0F55 900372    1858            mov dptr, #Txt_SoakTime
0F58 120618    1858            lcall ?Send_Constant_String
0F5B D0E0      1858            pop acc
0F5D D082      1858            pop dpl
0F5F D083      1858            pop dph
0F61 8042      1859       sjmp Draw_Time_Format
0F63           1860   Update_State_3:
0F63 B40314    1861       cjne A, #3, Update_State_4
0F66 C083      1862            push dph
0F68 C082      1862            push dpl
0F6A C0E0      1862            push acc
0F6C 900383    1862            mov dptr, #Txt_ReflT
0F6F 120618    1862            lcall ?Send_Constant_String
0F72 D0E0      1862            pop acc
0F74 D082      1862            pop dpl
0F76 D083      1862            pop dph
0F78 8014      1863       sjmp Draw_Temp_Format
0F7A           1864   Update_State_4:
0F7A C083      1865            push dph
0F7C C082      1865            push dpl
0F7E C0E0      1865            push acc
0F80 900394    1865            mov dptr, #Txt_ReflTime
0F83 120618    1865            lcall ?Send_Constant_String
0F86 D0E0      1865            pop acc
0F88 D082      1865            pop dpl
0F8A D083      1865            pop dph
0F8C 8017      1866       sjmp Draw_Time_Format
0F8E           1867   
0F8E           1868   Draw_Temp_Format:
0F8E C0E0      1869            push acc
0F90 7401      1869            mov a, #1
0F92 14        1869            dec a
0F93 120623    1869            lcall ?Set_Cursor_2 ; Select column and row
0F96 D0E0      1869            pop acc
0F98 12101B    1870       lcall Get_Current_Buffer_Addr
0F9B 120FF8    1871       lcall Print_String_RAM
0F9E 7443      1872       mov A, #'C'
0FA0 1205DB    1873       lcall ?WriteData
0FA3 8027      1874       sjmp Restore_Cursor
0FA5           1875   
0FA5           1876   Draw_Time_Format:
0FA5 C0E0      1877            push acc
0FA7 7401      1877            mov a, #1
0FA9 14        1877            dec a
0FAA 120623    1877            lcall ?Set_Cursor_2 ; Select column and row
0FAD D0E0      1877            pop acc
0FAF 12101B    1878       lcall Get_Current_Buffer_Addr
0FB2 E6        1879       mov A, @R0
0FB3 1205DB    1880       lcall ?WriteData
0FB6 08        1881       inc R0
0FB7 E6        1882       mov A, @R0
0FB8 1205DB    1883       lcall ?WriteData
0FBB 08        1884       inc R0
0FBC 743A      1885       mov A, #':'
0FBE 1205DB    1886       lcall ?WriteData
0FC1 E6        1887       mov A, @R0
0FC2 1205DB    1888       lcall ?WriteData
0FC5 08        1889       inc R0
0FC6 E6        1890       mov A, @R0
0FC7 1205DB    1891       lcall ?WriteData
0FCA 8000      1892       sjmp Restore_Cursor
0FCC           1893   
0FCC           1894   Restore_Cursor:
0FCC E569      1895       mov A, Current_State
0FCE B40202    1896       cjne A, #2, RC_Check_State_4  
0FD1 800D      1897       sjmp Adjust_Cursor_Time
0FD3           1898   RC_Check_State_4:             
0FD3 B40402    1899       cjne A, #4, Normal_Cursor
0FD6 8008      1900       sjmp Adjust_Cursor_Time
0FD8           1901   
0FD8           1902   Normal_Cursor:
0FD8 E572      1903       mov A, Cursor_Idx
0FDA 24C0      1904       add A, #0xC0
0FDC 1205E0    1905       lcall ?WriteCommand
0FDF 22        1906       ret
0FE0           1907   
0FE0           1908   Adjust_Cursor_Time:
0FE0           1909       ; Skip the colon index (2)
0FE0 E572      1910       mov A, Cursor_Idx
0FE2 B40201    1911       cjne A, #2, No_Skip
0FE5 04        1912       inc A 
0FE6           1913   No_Skip:
0FE6 C3        1914       clr C
0FE7 9402      1915       subb A, #2
0FE9 4005      1916       jc No_Add
0FEB E572      1917       mov A, Cursor_Idx
0FED 04        1918       inc A
0FEE 8002      1919       sjmp Final_Cursor_Set
0FF0           1920   No_Add:
0FF0 E572      1921       mov A, Cursor_Idx
0FF2           1922   Final_Cursor_Set:
0FF2 24C0      1923       add A, #0xC0
0FF4 1205E0    1924       lcall ?WriteCommand
0FF7 22        1925       ret
0FF8           1926   
0FF8           1927   Print_String_RAM:
0FF8 E6        1928       mov A, @R0
0FF9 6006      1929       jz Print_String_Done
0FFB 1205DB    1930       lcall ?WriteData
0FFE 08        1931       inc R0
0FFF 80F7      1932       sjmp Print_String_RAM
1001           1933   Print_String_Done:
1001 22        1934       ret
1002           1935   
1002           1936   Wait_25ms_BLOCKING:
1002 120EAA    1937       lcall Wait_25ms
1005 50FB      1938       jnc Wait_25ms_BLOCKING ; Keep jumping back until Done (C=1)
1007 22        1939       ret
1008           1940   
1008           1941   Clear_Screen_Func:
1008 7401      1942       mov A, #0x01
100A 1205E0    1943       lcall ?WriteCommand
100D 78FF      1944       mov R0, #255
100F           1945   Clear_Delay_Loop_Outer:
100F 79FF      1946       mov R1, #255
1011           1947   Clear_Delay_Loop_Inner:
1011 D9FE      1948       djnz R1, Clear_Delay_Loop_Inner
1013 D8FA      1949       djnz R0, Clear_Delay_Loop_Outer
1015           1950   
1015 740C      1951       mov A, #0x0C  ; Display ON, Cursor OFF
1017 1205E0    1952       lcall ?WriteCommand
101A 22        1953       ret
101B           1954   
101B           1955   Get_Current_Buffer_Addr:
101B E569      1956       mov A, Current_State
101D B40103    1957       cjne A, #1, Get_Buf_2
1020 7880      1958       mov R0, #Buf_Soak_Temp
1022 22        1959       ret
1023           1960   Get_Buf_2:
1023 B40203    1961       cjne A, #2, Get_Buf_3
1026 7884      1962       mov R0, #Buf_Soak_Time
1028 22        1963       ret
1029           1964   Get_Buf_3:
1029 B40303    1965       cjne A, #3, Get_Buf_4
102C 7889      1966       mov R0, #Buf_Refl_Temp
102E 22        1967       ret
102F           1968   Get_Buf_4:
102F 788D      1969       mov R0, #Buf_Refl_Time
1031 22        1970       ret
1032           1971       
1032           1972   ; --- Helper to prevent "Machine Gun" button presses ---
1032           1973   Wait_For_P1_0_Release:
1032 3090FD    1974       jnb P1.0, $    ; Wait here while the button is still pressed (0)
1035 22        1975       ret
1036           1976   
1036           1977   ; --- Full reset helper for P3.7 (active-low) ---
1036           1978   Wait_For_P3_7_Release:
1036 30B7FD    1979       jnb P3_7, $    ; Wait here while the button is still pressed (0)
1039 22        1980       ret
103A           1981   
103A           1982   Full_Reset:
103A 121036    1983       lcall Wait_For_P3_7_Release
103D 020BC1    1984       ljmp main
1040           1985   
1040           1986   ;-------------------------------------------------------------------------------
1040           1987   ; thermocouple
1040           1988   ;-------------------------------------------------------------------------------
1040           1989   Read_Thermocouple:
1040 120EAA    1990       lcall Wait_25ms
1043 4001      1991       jc Proceed_Reading
1045 22        1992       ret 
1046           1993   
1046           1994   Proceed_Reading:
1046 E588      1995       mov A, TCON      
1048 5410      1996       anl A, #0x10    
104A C0E0      1997       push acc         
104C C28C      1998       clr TR0         
104E           1999   
104E 75A180    2000       mov ADC_C, #0x80    
1051 00        2001       nop
1052 00        2002       nop
1053 75A101    2003       mov ADC_C, #0x01   
1056           2004       
1056 7DFA      2005       mov R5, #250
1058           2006   ADC_Settle_Loop:
1058 00        2007       nop
1059 00        2008       nop
105A DDFC      2009       djnz R5, ADC_Settle_Loop
105C           2010       
105C 85A232    2011       mov x+0, ADC_L
105F 85A333    2012       mov x+1, ADC_H
1062 753400    2013       mov x+2, #0
1065 753500    2014       mov x+3, #0
1068           2015       
1068 E533      2016       mov a, x+1
106A 540F      2017       anl a, #0x0F
106C F533      2018       mov x+1, a
106E           2019       
106E D0E0      2020       pop acc         
1070 6002      2021       jz Skip_Restore 
1072 D28C      2022       setb TR0       
1074           2023   Skip_Restore:
1074           2024   
1074           2025            ; as per our volatge reference (measured using the DMM)
1074 753616    2026            mov y+0, #low (4118 % 0x10000) 
1077 753710    2026            mov y+1, #high(4118 % 0x10000) 
107A 753800    2026            mov y+2, #low (4118 / 0x10000) 
107D 753900    2026            mov y+3, #high(4118 / 0x10000) 
1080 12018C    2027       lcall mul32       
1083           2028   
1083 75A104    2029       mov ADC_C, #0x04   
1086 85A236    2030       mov y+0, ADC_L      
1089 85A337    2031       mov y+1, ADC_H      
108C 753800    2032       mov y+2, #0
108F 753900    2033       mov y+3, #0
1092 75A100    2034       mov ADC_C, #0x00   
1095           2035       
1095 120280    2036       lcall div32         
1098 753664    2037            mov y+0, #low (100 % 0x10000) 
109B 753700    2037            mov y+1, #high(100 % 0x10000) 
109E 753800    2037            mov y+2, #low (100 / 0x10000) 
10A1 753900    2037            mov y+3, #high(100 / 0x10000) 
10A4 12018C    2038       lcall mul32
10A7 75362B    2039            mov y+0, #low (1323 % 0x10000) 
10AA 753705    2039            mov y+1, #high(1323 % 0x10000) 
10AD 753800    2039            mov y+2, #low (1323 / 0x10000) 
10B0 753900    2039            mov y+3, #high(1323 / 0x10000)  ;using our amplifiers resistance ratio and 41uV   
10B3 120280    2040       lcall div32    
10B6 753616    2041            mov y+0, #low (COLD_JUNCTION_TEMP % 0x10000) 
10B9 753700    2041            mov y+1, #high(COLD_JUNCTION_TEMP % 0x10000) 
10BC 753800    2041            mov y+2, #low (COLD_JUNCTION_TEMP / 0x10000) 
10BF 753900    2041            mov y+3, #high(COLD_JUNCTION_TEMP / 0x10000) 
10C2 1200D3    2042       lcall add32     
10C5           2043       
10C5 85323F    2044       mov current_temp+0, x+0
10C8 853340    2045       mov current_temp+1, x+1
10CB 853441    2046       mov current_temp+2, x+2
10CE 853542    2047       mov current_temp+3, x+3
10D1           2048   
10D1 22        2049       ret
10D2           2050       
10D2           2051   ;-------------------------------------------------------------------------------
10D2           2052   ; power control
10D2           2053   ;-------------------------------------------------------------------------------
10D2           2054   Power_Control:
10D2 755C00    2055       mov power_output+0, #0
10D5 755D00    2056       mov power_output+1, #0
10D8 755E00    2057       mov power_output+2, #0
10DB 755F00    2058       mov power_output+3, #0
10DE           2059   
10DE E568      2060       mov a, Control_FSM_state
10E0           2061   
10E0           2062       ; --- State 2: RAMP TO SOAK ---
10E0 B40202    2063       cjne a, #2, PC_Check_Soak
10E3 8016      2064       sjmp Set_Max_Power
10E5           2065   
10E5           2066   PC_Check_Soak:
10E5           2067       ; --- State 3: SOAK PHASE ---
10E5 B40305    2068       cjne a, #3, PC_Check_Ramp_Reflow
10E8 20030F    2069       jb soak_temp_reached, PC_Done 
10EB 801B      2070       sjmp Set_20_Percent_Power     
10ED           2071   
10ED           2072   PC_Check_Ramp_Reflow:
10ED           2073       ; --- State 4: RAMP TO REFLOW ---
10ED B40402    2074       cjne a, #4, PC_Check_Reflow
10F0 8009      2075       sjmp Set_Max_Power
10F2           2076   
10F2           2077   PC_Check_Reflow:
10F2           2078       ; --- State 5: REFLOW PHASE ---
10F2 B40505    2079       cjne a, #5, PC_Done
10F5 200402    2080       jb reflow_temp_reached, PC_Done
10F8 800E      2081       sjmp Set_20_Percent_Power
10FA           2082   
10FA           2083   PC_Done:
10FA 22        2084       ret
10FB           2085   
10FB           2086   Set_Max_Power:
10FB           2087       ; Load 1500 (0x05DC) = 100% Duty Cycle
10FB 755CDC    2088       mov power_output+0, #0xDC
10FE 755D05    2089       mov power_output+1, #0x05
1101 755E00    2090       mov power_output+2, #0
1104 755F00    2091       mov power_output+3, #0
1107 22        2092       ret
1108           2093   
1108           2094   Set_20_Percent_Power:
1108           2095       ; Load 300 (0x012C) = 20% Duty Cycle
1108 755C2C    2096       mov power_output+0, #0x2C
110B 755D01    2097       mov power_output+1, #0x01
110E 755E00    2098       mov power_output+2, #0
1111 755F00    2099       mov power_output+3, #0
1114 22        2100       ret
1115           2101   ;--------------------------------------------------------------
1115           2102   ; set servo angle according to the state
1115           2103   ; call servo control function every 1ms
1115           2104   ;--------------------------------------------------------------
1115           2105   call_servo_control:
1115           2106            ; check current state and change servo angle
1115 E568      2107            mov a, Control_FSM_state
1117           2108            
1117           2109            ; handle state 0
1117 B40004    2110            cjne a, #0, servo_state1
111A C21F      2111            clr servo_angle_zero ; close door at state 0
111C 802C      2112            sjmp check_servo_flag
111E           2113   
111E           2114            ; handle state 1
111E           2115            servo_state1:
111E B40104    2116            cjne a, #1, servo_state2
1121 D21F      2117            setb servo_angle_zero ; open door at state 1
1123 8025      2118            sjmp check_servo_flag
1125           2119   
1125           2120            ; handle state 2
1125           2121            servo_state2:
1125 B40204    2122            cjne a, #2, servo_state3
1128 C21F      2123            clr servo_angle_zero ; close door at state 2
112A 801E      2124            sjmp check_servo_flag
112C           2125   
112C           2126            ; handle state 3
112C           2127            servo_state3:
112C B40304    2128            cjne a, #3, servo_state4
112F C21F      2129            clr servo_angle_zero ; close door at state 3
1131 8017      2130            sjmp check_servo_flag
1133           2131   
1133           2132            ; handle state 4
1133           2133            servo_state4:
1133 B40404    2134            cjne a, #4, servo_state5
1136 C21F      2135            clr servo_angle_zero ; close door at state 4
1138 8010      2136            sjmp check_servo_flag
113A           2137   
113A           2138            ; handle state 5
113A           2139            servo_state5:
113A B40504    2140            cjne a, #5, servo_state6
113D C21F      2141            clr servo_angle_zero ; close door at state 5
113F 8009      2142            sjmp check_servo_flag
1141           2143   
1141           2144            ; handle state 6
1141           2145            servo_state6:
1141 B40604    2146            cjne a, #6, servo_state7
1144 C21F      2147            clr servo_angle_zero ; close door at state 6
1146 8002      2148            sjmp check_servo_flag
1148           2149   
1148           2150            ; handle state 7
1148           2151            servo_state7:
1148 D21F      2152            setb servo_angle_zero ; open door at state 7
114A           2153   
114A           2154   check_servo_flag:
114A           2155            ; check 1 ms flag
114A 101E01    2156            jbc one_millisecond_flag_servo, run_servo_control
114D 22        2157            ret
114E           2158   
114E           2159   run_servo_control:
114E 121152    2160            lcall servo_control
1151 22        2161            ret
1152           2162   
1152           2163   ;---------------------------------------------------------------
1152           2164   ; servo control
1152           2165   ; generate a 20 ms period pwm signal to control the servo motor
1152           2166   ; able to make the servo motor stay at 0 degree and 180 degree
1152           2167   ;---------------------------------------------------------------
1152           2168   servo_control:
1152 D2ED      2169       setb LEDRA.5
1154 C0E0      2170            push acc
1156 C0D0      2171            push psw
1158 E577      2172            mov a, servo_pwm_counter ; move servo counter to accumulator
115A 04        2173            inc A ; a += 1
115B B41402    2174            cjne a, #SERVO_PERIOD, servo_pwm_angle_compare ; jump if wrapup not needed
115E 7400      2175            mov a, #0
1160           2176   
1160           2177   servo_pwm_angle_compare: ; read target angle
1160 F577      2178            mov servo_pwm_counter, A
1162 201F09    2179            jb servo_angle_zero, set_zero_degree ; set servo motor to 0 degree
1165           2180            ; set servo motor to 180 degrees
1165 E577      2181            mov a, servo_pwm_counter
1167 C3        2182            clr c
1168 9402      2183            subb a, #SERVO_180
116A 400B      2184            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 180 degrees duty cycle
116C 800D      2185            sjmp servo_pwm_set_low ; set low if greater
116E           2186   
116E           2187   set_zero_degree:
116E           2188            ; set servo motor to 0 degree
116E E577      2189            mov a, servo_pwm_counter
1170 C3        2190            clr c
1171 9401      2191            subb a, #SERVO_0
1173 4002      2192            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 0 degrees duty cycle
1175 8004      2193            sjmp servo_pwm_set_low ; set low if greater
1177           2194   
1177           2195   servo_pwm_set_high:
1177           2196            ; set pwm pin high
1177 D2B6      2197            setb SERVO_OUT
1179 8002      2198            sjmp servo_control_done
117B           2199   
117B           2200   servo_pwm_set_low:
117B           2201            ; set pwm pin low
117B C2B6      2202            clr SERVO_OUT
117D           2203   
117D           2204   servo_control_done:
117D D0D0      2205            pop psw
117F D0E0      2206            pop acc
1181 22        2207            ret
1182           2208   
1182           2209   ;------------------------------------------------------------------------------
1182           2210   ; dc_control
1182           2211   ; turns on the dc motor in cooling stage
1182           2212   ;------------------------------------------------------------------------------
1182           2213   dc_control:
1182 E568      2214       mov a, Control_FSM_state
1184           2215            
1184           2216            ; handle state 0
1184 B40004    2217            cjne a, #0, dc_state1
1187 C2C0      2218            clr DC_OUT
1189 802C      2219       sjmp dc_control_done
118B           2220   
118B           2221            ; handle state 1
118B           2222            dc_state1:
118B B40104    2223            cjne a, #1, dc_state2
118E C2C0      2224            clr DC_OUT
1190 8025      2225       sjmp dc_control_done
1192           2226   
1192           2227            ; handle state 2
1192           2228            dc_state2:
1192 B40204    2229            cjne a, #2, dc_state3
1195 C2C0      2230            clr DC_OUT
1197 801E      2231       sjmp dc_control_done
1199           2232   
1199           2233            ; handle state 3
1199           2234            dc_state3:
1199 B40304    2235            cjne a, #3, dc_state4
119C C2C0      2236            clr DC_OUT
119E 8017      2237       sjmp dc_control_done
11A0           2238   
11A0           2239            ; handle state 4
11A0           2240            dc_state4:
11A0 B40404    2241            cjne a, #4, dc_state5
11A3 C2C0      2242            clr DC_OUT
11A5 8010      2243       sjmp dc_control_done
11A7           2244   
11A7           2245            ; handle state 5
11A7           2246            dc_state5:
11A7 B40504    2247            cjne a, #5, dc_state6
11AA C2C0      2248            clr DC_OUT
11AC 8009      2249       sjmp dc_control_done
11AE           2250   
11AE           2251            ; handle state 6
11AE           2252            dc_state6:
11AE B40604    2253       cjne a, #6, dc_state7
11B1 D2C0      2254            setb DC_OUT
11B3 8002      2255       sjmp dc_control_done
11B5           2256   
11B5           2257            ; handle state 7
11B5           2258            dc_state7:
11B5 C2C0      2259            clr DC_OUT  
11B7           2260   
11B7           2261   dc_control_done:
11B7 22        2262       ret
11B8           2263    
11B8           2264   ;-------------------------------------------------------------------------------
11B8           2265   ; power_control
11B8           2266   ;-------------------------------------------------------------------------------
11B8           2267   ; Determine the power output based on current state and current temperature 
11B8           2268   ; input parameter: Control_FSM_state
11B8           2269   ;-------------------------------------------------------------------------------
11B8           2270   ; Update LED indicators based on power_output
11B8           2271   ; 0%  -> all off
11B8           2272   ; <50% -> LED_LEFT on
11B8           2273   ; 50%-99% -> LED_LEFT + LED_MID on
11B8           2274   ; >=100% -> LED_LEFT + LED_MID + LED_RIGHT on
11B8           2275   Update_Power_LEDs:
11B8           2276       ; Check for exact 0 (all bytes zero)
11B8 E55C      2277       mov a, power_output
11BA 455D      2278       orl a, power_output+1
11BC 455E      2279       orl a, power_output+2
11BE 455F      2280       orl a, power_output+3
11C0 6032      2281       jz power_leds_low
11C2           2282   
11C2 855C32    2283       mov x, power_output
11C5 855D33    2284       mov x+1, power_output+1
11C8 855E34    2285       mov x+2, power_output+2
11CB 855F35    2286       mov x+3, power_output+3
11CE           2287   
11CE 7536EE    2288            mov y+0, #low (HALF_POWER % 0x10000) 
11D1 753702    2288            mov y+1, #high(HALF_POWER % 0x10000) 
11D4 753800    2288            mov y+2, #low (HALF_POWER / 0x10000) 
11D7 753900    2288            mov y+3, #high(HALF_POWER / 0x10000) 
11DA 12011A    2289       lcall x_lt_y
11DD 200014    2290       jb mf, power_leds_low
11E0           2291   
11E0 7536DC    2292            mov y+0, #low (MAX_POWER % 0x10000) 
11E3 753705    2292            mov y+1, #high(MAX_POWER % 0x10000) 
11E6 753800    2292            mov y+2, #low (MAX_POWER / 0x10000) 
11E9 753900    2292            mov y+3, #high(MAX_POWER / 0x10000) 
11EC 12011A    2293       lcall x_lt_y
11EF 200009    2294       jb mf, power_leds_mid
11F2           2295   
11F2 800E      2296       sjmp power_leds_high
11F4           2297   
11F4           2298   power_leds_low:
11F4 C2B4      2299       clr  LED_LEFT
11F6 C2B3      2300       clr  LED_MID
11F8 C2B2      2301       clr  LED_RIGHT
11FA 22        2302       ret
11FB           2303   
11FB           2304   power_leds_mid:
11FB D2B4      2305       setb LED_LEFT
11FD D2B3      2306       setb LED_MID
11FF C2B2      2307       clr  LED_RIGHT
1201 22        2308       ret
1202           2309   
1202           2310   power_leds_high:
1202 D2B4      2311       setb LED_LEFT
1204 D2B3      2312       setb LED_MID
1206 D2B2      2313       setb LED_RIGHT
1208 22        2314       ret
1209           2315   
1209           2316   proportional_power_control:
1209 E568      2317            mov a, Control_FSM_state
120B           2318   
120B           2319   state0_power_control:
120B           2320            ; idle
120B           2321            ; 0% power
120B B4000F    2322            cjne a, #0, state1_power_control
120E 755C00    2323            mov power_output, #low(NO_POWER)
1211 755D00    2324            mov power_output+1, #low(NO_POWER)
1214 755E00    2325            mov power_output+2, #0
1217 755F00    2326            mov power_output+3, #0
121A 0213B5    2327            ljmp power_control_done
121D           2328   
121D           2329   state1_power_control:
121D           2330            ; idle
121D           2331            ; 0% power
121D B4010F    2332            cjne a, #1, state2_power_control
1220 755C00    2333            mov power_output, #low(NO_POWER)
1223 755D00    2334            mov power_output+1, #low(NO_POWER)
1226 755E00    2335            mov power_output+2, #0
1229 755F00    2336            mov power_output+3, #0
122C 0213B5    2337            ljmp power_control_done
122F           2338            
122F           2339   state2_power_control:
122F           2340            ; ramp to soak, ramp to ~150C
122F           2341            ; 100% power
122F B4020F    2342            cjne a, #2, state3_power_control
1232 755CDC    2343            mov power_output, #low(MAX_POWER)
1235 755D05    2344            mov power_output+1, #high(MAX_POWER)
1238 755E00    2345            mov power_output+2, #0
123B 755F00    2346            mov power_output+3, #0
123E 0213B5    2347            ljmp power_control_done
1241           2348   
1241           2349   state3_power_control:
1241           2350            ; soak period, hold at 150C
1241           2351            ; 20% base power + proportional calculated power
1241 B40302    2352            cjne a, #3, jump_state4_power_control
1244 8003      2353            sjmp state3_power_control_calculation
1246           2354   
1246           2355   jump_state4_power_control:
1246 021373    2356            ljmp state4_power_control
1249           2357   
1249           2358   state3_power_control_calculation:
1249           2359            ; move soak_temp to x
1249 854332    2360            mov x, soak_temp
124C 854433    2361            mov x+1, soak_temp+1
124F 854534    2362            mov x+2, soak_temp+2
1252 854635    2363            mov x+3, soak_temp+3
1255           2364            ; move current_temp to y
1255 853F36    2365            mov y, current_temp
1258 854037    2366            mov y+1, current_temp+1
125B 854138    2367            mov y+2, current_temp+2
125E 854239    2368            mov y+3, current_temp+3
1261           2369   
1261           2370            ; compare between soak_temp and current_temp
1261 C200      2371            clr mf
1263 120178    2372            lcall x_gteq_y
1266 10002B    2373            jbc mf, st_sub_ct
1269           2374            ; current_temp - soak_temp if st < ct
1269 C220      2375            clr soak_temp_greater
126B           2376            ; move current_temp to y
126B 854336    2377            mov y, soak_temp
126E 854437    2378            mov y+1, soak_temp+1
1271 854538    2379            mov y+2, soak_temp+2
1274 854639    2380            mov y+3, soak_temp+3
1277           2381            ; move current_temp to x
1277 853F32    2382            mov x, current_temp
127A 854033    2383            mov x+1, current_temp+1
127D 854134    2384            mov x+2, current_temp+2
1280 854235    2385            mov x+3, current_temp+3
1283 1200F6    2386            lcall sub32
1286 85326A    2387            mov soak_temp_diff, x
1289 85336B    2388            mov soak_temp_diff+1, x+1
128C 85346C    2389            mov soak_temp_diff+2, x+2
128F 85356D    2390            mov soak_temp_diff+3, x+3
1292 8011      2391            sjmp proportional_input_soak
1294           2392   
1294           2393   st_sub_ct:
1294           2394            ; soak_temp - current_temp
1294 D220      2395            setb soak_temp_greater
1296 1200F6    2396            lcall sub32
1299 85326A    2397            mov soak_temp_diff, x
129C 85336B    2398            mov soak_temp_diff+1, x+1
129F 85346C    2399            mov soak_temp_diff+2, x+2
12A2 85356D    2400            mov soak_temp_diff+3, x+3
12A5           2401   
12A5           2402   proportional_input_soak:
12A5           2403            ; proportaional block calculation       
12A5           2404            ; move soak_temp_diff to x
12A5 856A32    2405            mov x, soak_temp_diff
12A8 856B33    2406            mov x+1, soak_temp_diff+1
12AB 856C34    2407            mov x+2, soak_temp_diff+2
12AE 856D35    2408            mov x+3, soak_temp_diff+3
12B1           2409            ; move proportional gain to y
12B1 753605    2410            mov y+0, #low (KP % 0x10000) 
12B4 753700    2410            mov y+1, #high(KP % 0x10000) 
12B7 753800    2410            mov y+2, #low (KP / 0x10000) 
12BA 753900    2410            mov y+3, #high(KP / 0x10000) 
12BD 12018C    2411            lcall mul32 ; proportional_output = proportional_gain * difference
12C0           2412            
12C0 85326E    2413            mov proportional_gain_var, x
12C3 85336F    2414            mov proportional_gain_var+1, x+1
12C6 853470    2415            mov proportional_gain_var+2, x+2
12C9 853571    2416            mov proportional_gain_var+3, x+3
12CC           2417   
12CC           2418            ; base_power + soak_power when soak_temp > current_temp
12CC 302029    2419            jnb soak_temp_greater, sub_proportional_soak
12CF 856E32    2420            mov x, proportional_gain_var
12D2 856F33    2421            mov x+1, proportional_gain_var+1
12D5 857034    2422            mov x+2, proportional_gain_var+2
12D8 857135    2423            mov x+3, proportional_gain_var+3
12DB 75362C    2424            mov y+0, #low (BASE_POWER % 0x10000) 
12DE 753701    2424            mov y+1, #high(BASE_POWER % 0x10000) 
12E1 753800    2424            mov y+2, #low (BASE_POWER / 0x10000) 
12E4 753900    2424            mov y+3, #high(BASE_POWER / 0x10000) 
12E7 1200D3    2425            lcall add32
12EA           2426            ; x now holds the power output before the saturator
12EA 85326E    2427            mov proportional_gain_var, x
12ED 85336F    2428            mov proportional_gain_var+1, x+1
12F0 853470    2429            mov proportional_gain_var+2, x+2
12F3 853571    2430            mov proportional_gain_var+3, x+3
12F6 803D      2431            sjmp saturator_soak
12F8           2432   
12F8           2433   sub_proportional_soak:
12F8           2434            ; base_power - soak_power when soak_temp <= current_temp
12F8 75322C    2435            mov x+0, #low (BASE_POWER % 0x10000) 
12FB 753301    2435            mov x+1, #high(BASE_POWER % 0x10000) 
12FE 753400    2435            mov x+2, #low (BASE_POWER / 0x10000) 
1301 753500    2435            mov x+3, #high(BASE_POWER / 0x10000) 
1304 856E36    2436            mov y, proportional_gain_var
1307 856F37    2437            mov y+1, proportional_gain_var+1
130A 857038    2438            mov y+2, proportional_gain_var+2
130D 857139    2439            mov y+3, proportional_gain_var+3
1310           2440   
1310           2441            ; compare whether base_power < proportional_gain_var
1310 C200      2442            clr mf
1312 12011A    2443            lcall x_lt_y ; set mf to 1 if base_power < proportional_gain_var, clamp output to 0
1315 30000E    2444            jnb mf, bp_gteq_pgv
1318 756E00    2445            mov proportional_gain_var, #low(NO_POWER)
131B 756F00    2446            mov proportional_gain_var+1, #high(NO_POWER)
131E 757000    2447            mov proportional_gain_var+2, #0
1321 757100    2448            mov proportional_gain_var+3, #0
1324 800F      2449            sjmp saturator_soak
1326           2450   
1326           2451   bp_gteq_pgv:
1326           2452            ; calculate subtracted gain
1326 1200F6    2453            lcall sub32
1329           2454            ; x now holds the power output before the saturator
1329 85326E    2455            mov proportional_gain_var, x
132C 85336F    2456            mov proportional_gain_var+1, x+1
132F 853470    2457            mov proportional_gain_var+2, x+2
1332 853571    2458            mov proportional_gain_var+3, x+3
1335           2459   
1335           2460   saturator_soak:
1335           2461            ; proportional_gain_var now holds the power output before the saturator
1335           2462            ; saturate power output to max power
1335 856E32    2463            mov x, proportional_gain_var
1338 856F33    2464            mov x+1, proportional_gain_var+1
133B 857034    2465            mov x+2, proportional_gain_var+2
133E 857135    2466            mov x+3, proportional_gain_var+3
1341           2467   
1341 7536DC    2468            mov y+0, #low (MAX_POWER % 0x10000) 
1344 753705    2468            mov y+1, #high(MAX_POWER % 0x10000) 
1347 753800    2468            mov y+2, #low (MAX_POWER / 0x10000) 
134A 753900    2468            mov y+3, #high(MAX_POWER / 0x10000) 
134D           2469   
134D C200      2470            clr mf
134F 120136    2471            lcall x_gt_y ; set mf to 1 if calculated power output greater than max power
1352 20000F    2472            jb mf, saturated_soak
1355           2473            ; set power_output to calculated power if not saturated
1355 856E5C    2474            mov power_output, proportional_gain_var
1358 856F5D    2475            mov power_output+1, proportional_gain_var+1
135B 85705E    2476            mov power_output+2, proportional_gain_var+2
135E 85715F    2477            mov power_output+3, proportional_gain_var+3
1361 0213B5    2478            ljmp power_control_done
1364           2479   
1364           2480   saturated_soak:
1364 755CDC    2481            mov power_output, #low(MAX_POWER)
1367 755D05    2482            mov power_output+1, #high(MAX_POWER)
136A 755E00    2483            mov power_output+2, #0
136D 755F00    2484            mov power_output+3, #0
1370 0213B5    2485            ljmp power_control_done
1373           2486   
1373           2487   
1373           2488   state4_power_control:
1373           2489            ; ramp to reflow, max power
1373 B4040F    2490            cjne a, #4, state5_power_control
1376 755CDC    2491            mov power_output, #low(MAX_POWER)
1379 755D05    2492            mov power_output+1, #high(MAX_POWER)
137C 755E00    2493            mov power_output+2, #0
137F 755F00    2494            mov power_output+3, #0
1382 0213B5    2495            ljmp power_control_done
1385           2496   
1385           2497   state5_power_control:
1385           2498            ; reflow 20% base power
1385 B4050F    2499            cjne a, #5, state6_power_control
1388 755C2C    2500            mov power_output, #low(BASE_POWER)  
138B 755D01    2501            mov power_output+1, #high(BASE_POWER)
138E 755E00    2502            mov power_output+2, #0
1391 755F00    2503            mov power_output+3, #0
1394 0213B5    2504            ljmp power_control_done
1397           2505   
1397           2506   state6_power_control:
1397           2507            ; cooling 0% power
1397 B4060F    2508            cjne a, #6, state_7_power_control
139A 755C00    2509            mov power_output, #low(NO_POWER)
139D 755D00    2510            mov power_output+1, #high(NO_POWER)
13A0 755E00    2511            mov power_output+2, #0
13A3 755F00    2512            mov power_output+3, #0
13A6 0213B5    2513            ljmp power_control_done
13A9           2514   
13A9           2515   state_7_power_control:
13A9           2516            ; idle 0% power
13A9 755C00    2517            mov power_output, #low(NO_POWER)
13AC 755D00    2518            mov power_output+1, #high(NO_POWER)
13AF 755E00    2519            mov power_output+2, #0
13B2 755F00    2520            mov power_output+3, #0
13B5           2521   
13B5           2522   power_control_done:
13B5 22        2523            ret
13B6           2524   
13B6           2525   ; function for playing the boot up music
13B6           2526   music:
13B6           2527            ; 1
13B6 12140E    2528            lcall playC
13B9 12149E    2529            lcall delayHalfSec
13BC           2530            ; 1
13BC 12140E    2531            lcall playC
13BF 12149E    2532            lcall delayHalfSec
13C2           2533            ; 5
13C2 121426    2534            lcall playG
13C5 12149E    2535            lcall delayHalfSec
13C8           2536            ; 5
13C8 121426    2537            lcall playG
13CB 12149E    2538            lcall delayHalfSec
13CE           2539            ; 6
13CE 12143E    2540            lcall PlayA
13D1 12149E    2541            lcall delayHalfSec
13D4           2542            ; 6
13D4 12143E    2543            lcall PlayA
13D7 12149E    2544            lcall delayHalfSec
13DA           2545            ; 5
13DA 121426    2546            lcall playG
13DD 12149E    2547            lcall delayHalfSec
13E0           2548            ; 4
13E0 121456    2549            lcall playF
13E3 12149E    2550            lcall delayHalfSec
13E6           2551   
13E6           2552            ; 4
13E6 121456    2553            lcall playF
13E9 12149E    2554            lcall delayHalfSec
13EC           2555            ; 3
13EC 12146E    2556            lcall playE
13EF 12149E    2557            lcall delayHalfSec
13F2           2558   
13F2           2559            ; 3
13F2 12146E    2560            lcall playE
13F5 12149E    2561            lcall delayHalfSec
13F8           2562   
13F8           2563            ; 2
13F8 121486    2564            lcall playD
13FB 12149E    2565            lcall delayHalfSec
13FE           2566   
13FE           2567            ; 2
13FE 121486    2568            lcall playD
1401 12149E    2569            lcall delayHalfSec
1404           2570            ; 1
1404 12140E    2571            lcall playC
1407 12149E    2572            lcall delayHalfSec
140A           2573            
140A 12149E    2574            lcall delayHalfSec
140D 22        2575            ret
140E           2576   
140E           2577   ;------------------------------------
140E           2578   ; Play_C_0p5s
140E           2579   ; Plays ~523 Hz on P1.7 for 0.5 seconds
140E           2580   ;------------------------------------
140E           2581   playC:
140E 7F14      2582       MOV R7, #20        ; outer loop counter
1410           2583   
1410           2584   OUTER_LOOP:
1410 7E1A      2585       MOV R6, #26        ; inner loop counter
1412           2586   
1412           2587   INNER_LOOP:
1412 B295      2588       CPL SOUND_OUT           ; toggle buzzer pin
1414 12141E    2589       LCALL Delay_C      ; ~960 s delay
1417 DEF9      2590       DJNZ R6, INNER_LOOP
1419           2591   
1419 DFF5      2592       DJNZ R7, OUTER_LOOP
141B           2593   
141B C295      2594       CLR SOUND_OUT           ; stop sound (pin low)
141D 22        2595       RET
141E           2596       
141E           2597   Delay_C:
141E 7D18      2598       MOV R5, #24        ; 24  40 s = 960 s
1420           2599   DELAY_LOOP:
1420 120589    2600       LCALL Wait40uSec
1423 DDFB      2601       DJNZ R5, DELAY_LOOP
1425 22        2602       RET
1426           2603       
1426           2604   
1426           2605   ;------------------------------------
1426           2606   ; Play_G_0p5s
1426           2607   ; Plays ~784 Hz on P1.7 for 0.5 seconds
1426           2608   ;------------------------------------
1426           2609   playG:
1426 7F1F      2610       MOV R7, #31        ; outer loop
1428           2611   
1428           2612   OUTER_G:
1428 7E19      2613       MOV R6, #25        ; inner loop 31  25 = 775 toggles
142A           2614   
142A           2615   INNER_G:
142A B295      2616       CPL SOUND_OUT           ; toggle buzzer pin
142C 121436    2617       LCALL Delay_G      ; ~640 s delay
142F DEF9      2618       DJNZ R6, INNER_G
1431           2619   
1431 DFF5      2620       DJNZ R7, OUTER_G
1433           2621   
1433 C295      2622       CLR SOUND_OUT           ; stop sound
1435 22        2623       RET
1436           2624       
1436           2625   Delay_G:
1436 7D10      2626       MOV R5, #16        ; 16  40 s = 640 s
1438           2627   DELAY_G_LOOP:
1438 120589    2628       LCALL Wait40uSec
143B DDFB      2629       DJNZ R5, DELAY_G_LOOP
143D 22        2630       RET
143E           2631            
143E           2632    
143E           2633    ;------------------------------------
143E           2634   ; Play_A_0p5s
143E           2635   ; Plays ~880 Hz on P1.7 for 0.5 seconds
143E           2636   ;------------------------------------
143E           2637   playA:
143E 7F22      2638       MOV R7, #34        ; outer loop counter
1440           2639   
1440           2640   OUTER_A:
1440 7E1A      2641       MOV R6, #26        ; inner loop ? 34  26 = 884 toggles
1442           2642   
1442           2643   INNER_A:
1442 B295      2644       CPL SOUND_OUT           ; toggle buzzer pin
1444 12144E    2645       LCALL Delay_A      ; ~560 s delay
1447 DEF9      2646       DJNZ R6, INNER_A
1449           2647   
1449 DFF5      2648       DJNZ R7, OUTER_A
144B           2649   
144B C295      2650       CLR SOUND_OUT          ; stop sound
144D 22        2651       RET
144E           2652   
144E           2653   Delay_A:
144E 7D0E      2654       MOV R5, #14        ; 14  40 s = 560 s
1450           2655   DELAY_A_LOOP:
1450 120589    2656       LCALL Wait40uSec
1453 DDFB      2657       DJNZ R5, DELAY_A_LOOP
1455 22        2658       RET
1456           2659   
1456           2660   ;------------------------------------
1456           2661   ; Play_F_0p5s
1456           2662   ; Plays ~698 Hz on P1.7 for 0.5 seconds
1456           2663   ;------------------------------------
1456           2664   playF:
1456 7F1A      2665       MOV R7, #26        ; outer loop
1458           2666   
1458           2667   OUTER_F:
1458 7E1B      2668       MOV R6, #27        ; inner loop ? 26  27 = 702 toggles
145A           2669   
145A           2670   INNER_F:
145A B295      2671       CPL SOUND_OUT          ; toggle buzzer pin
145C 121466    2672       LCALL Delay_F      ; ~720 s delay
145F DEF9      2673       DJNZ R6, INNER_F
1461           2674   
1461 DFF5      2675       DJNZ R7, OUTER_F
1463           2676   
1463 C295      2677       CLR SOUND_OUT           ; stop sound
1465 22        2678       RET
1466           2679   
1466           2680   Delay_F:
1466 7D12      2681       MOV R5, #18        ; 18  40 s = 720 s
1468           2682   DELAY_F_LOOP:
1468 120589    2683       LCALL Wait40uSec
146B DDFB      2684       DJNZ R5, DELAY_F_LOOP
146D 22        2685       RET
146E           2686   
146E           2687   
146E           2688   ;------------------------------------
146E           2689   ; Play_E_0p5s
146E           2690   ; Plays ~659 Hz on P1.7 for 0.5 seconds
146E           2691   ;------------------------------------
146E           2692   playE:
146E 7F1A      2693       MOV R7, #26        ; outer loop
1470           2694   
1470           2695   OUTER_E:
1470 7E19      2696       MOV R6, #25        ; inner loop ? 26  25 = 650 toggles
1472           2697   
1472           2698   INNER_E:
1472 B295      2699       CPL SOUND_OUT           ; toggle buzzer pin
1474 12147E    2700       LCALL Delay_E      ; ~760 s delay
1477 DEF9      2701       DJNZ R6, INNER_E
1479           2702   
1479 DFF5      2703       DJNZ R7, OUTER_E
147B           2704   
147B C295      2705       CLR SOUND_OUT          ; stop sound
147D 22        2706       RET
147E           2707       
147E           2708   Delay_E:
147E 7D13      2709       MOV R5, #19        ; 19  40 s = 760 s
1480           2710   DELAY_E_LOOP:
1480 120589    2711       LCALL Wait40uSec
1483 DDFB      2712       DJNZ R5, DELAY_E_LOOP
1485 22        2713       RET
1486           2714   
1486           2715   
1486           2716   ;------------------------------------
1486           2717   ; Play_D_0p5s
1486           2718   ; Plays ~587 Hz on P1.7 for 0.5 seconds
1486           2719   ;------------------------------------
1486           2720   playD:
1486 7F19      2721       MOV R7, #25        ; outer loop
1488           2722   
1488           2723   OUTER_D:
1488 7E18      2724       MOV R6, #24        ; inner loop ? 25  24 = 600 toggles
148A           2725   
148A           2726   INNER_D:
148A B295      2727       CPL SOUND_OUT          ; toggle buzzer pin
148C 121496    2728       LCALL Delay_D      ; ~840 s delay
148F DEF9      2729       DJNZ R6, INNER_D
1491           2730   
1491 DFF5      2731       DJNZ R7, OUTER_D
1493           2732   
1493 C295      2733       CLR SOUND_OUT         ; stop sound
1495 22        2734       RET
1496           2735       
1496           2736   Delay_D:
1496 7D15      2737       MOV R5, #21        ; 21  40 s = 840 s
1498           2738   DELAY_D_LOOP:
1498 120589    2739       LCALL Wait40uSec
149B DDFB      2740       DJNZ R5, DELAY_D_LOOP
149D 22        2741       RET
149E           2742   
149E           2743   delayHalfSec:
149E 7AFA      2744            mov     R2, #250
14A0 1214A4    2745            lcall WaitmilliSec
14A3           2746            ;lcall WaitmilliSec
14A3 22        2747            ret
14A4           2748   
14A4           2749   ;---------------------------------;
14A4           2750   ; Wait 'R2' milliseconds, blocking;
14A4           2751   ;---------------------------------;
14A4           2752   WaitmilliSec:
14A4 C000      2753       push AR0
14A6 C001      2754       push AR1
14A8 7928      2755   loop3: mov R1, #40
14AA 7868      2756   loop2: mov R0, #104
14AC D8FE      2757   loop1: djnz R0, loop1 ; 4 cycles->4*60.24ns*104=25.0us
14AE D9FA      2758       djnz R1, loop2 ; 25us*40=1.0ms
14B0 DAF6      2759       djnz R2, loop3 ; number of millisecons to wait passed in R2
14B2 D001      2760       pop AR1
14B4 D000      2761       pop AR0
14B6 22        2762       ret
14B7           2763   ;-------------------------------------------------------------------------------
14B7           2764   END
