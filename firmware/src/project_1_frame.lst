0000              1   ; Project 1
0000              2   ; CV-8052 microcontroller in DE10-Lite board
0000              3   ;-------------------------------------------------------------------------------
0000              4   ; Reset vector
0000              5   org 0x0000
0000 0214FF       6       ljmp main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9       reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 02046E      12       ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15       reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18       reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 32          21       reti
0024             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
002B 0206BC      24       ljmp Timer2_ISR
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 32   $LIST
0320             34   ; ----------------------------------------------------------------------------------------------;
0320             35   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             36   dseg at 0x30
0030             37   ; time buffer 
0030             38   current_time_sec:     ds 1
0031             39   current_time_minute:  ds 1
0032             40   soak_time_sec:        ds 1
0033             41   soak_time_minute:     ds 1
0034             42   reflow_time_sec:      ds 1
0035             43   reflow_time_minute:   ds 1
0036             44   soak_end_time_sec:      ds 1
0037             45   soak_end_time_minute:   ds 1
0038             46   reflow_end_time_sec:    ds 1
0039             47   reflow_end_time_minute: ds 1
003A             48   
003A             49   ; math32 buffer variables
003A             50   x:      ds  4
003E             51   y:      ds  4
0042             52   bcd:    ds  5
0047             53   
0047             54   current_temp: ds 4 ;
004B             55   soak_temp:    ds 4 ;
004F             56   reflow_temp:  ds 4 ;
0053             57   
0053             58   wait25_btn_cnt:    ds 1
0054             59   wait25_keypad_cnt: ds 1
0055             60   wait25_adc_cnt:    ds 1
0056             61   wait25_lcd_cnt:    ds 1
0057             62   wait25_count:      ds 1
0058             63   
0058             64   power_output:  ds 4 ;
005C             65   pwm_counter:   ds 4 ; counter for pwm (0-1500_timer: ds 1
0060             66   
0060             67   Control_FSM_state: ds 1 
0061             68   Current_State:     ds 1
0062             69   
0062             70   soak_temp_diff: ds 4 ; temperature difference between target soak temp and current oven temp 
0066             71   proportional_gain_var: ds 4 ; power gain calculated from the proportional block
006A             72   
006A             73   ;-- UI buffers I added (ayaan)
006A             74   Cursor_Idx: ds 1
006B             75   
006B             76   ; Buzzer module variables
006B             77   buzz_state:      ds 1   ; 0=IDLE, 1=ON, 2=OFF
006C             78   buzz_timer:      ds 1   ; counts ms within ON/OFF window
006D             79   buzz_beeps_left: ds 1   ; how many beeps remaining
006E             80   buzz_priority:   ds 1   ; 0 none, 1=state, 2=done, 3=error
006F             81   
006F             82   SEC_FSM_timer: ds 1
0070             83   SEC_FSM_state: ds 1
0071             84   ; Push buttons for globel interrupt 
0071             85   PB0_DEB_timer:  ds 1
0072             86   PB0_DEB_state:  ds 1
0073             87   PB2_DEB_timer:  ds 1
0074             88   PB2_DEB_state:  ds 1
0075             89   
0075             90   ; Buzzer state
0075             91   beep_count:  ds 1      ; remaining beeps
0076             92   beep_state:  ds 1      ; 0=idle, 1=ON, 2=OFF
0077             93   beep_tmr:    ds 2      ; 16-bit ms timer (needs to reach 500)
0079             94   
0079             95   servo_pwm_counter: ds 1 ; counter for the servo pwm signal
007A             96   ; In your data section
007A             97   BTN_DEB_state: ds 1
007B             98   BTN_DEB_timer: ds 1
007C             99   BTN_DEB_id:    ds 1
007D            100   
007D            101   ; UART RX state (polling)
007D            102   rx_idx:    ds 1
007E            103   rx_ready:  ds 1
007F            104   ; 79
007F            105   
0080            106   iseg at 0x80
0080            107   Buf_Soak_Temp: ds 4   
0084            108   Buf_Soak_Time: ds 5   
0089            109   Buf_Refl_Temp: ds 4   
008D            110   Buf_Refl_Time: ds 5
0092            111   
0092            112   ; UART RX line buffer (polling) in upper RAM
0092            113   rx_buf:        ds 40    ; null-terminated command line
00BA            114   ; 
00BA            115   ;-------------------------------------------------------------------------------
00BA            116   ; bit operation setb, clr, jb, and jnb
0000            117   bseg
0000            118   mf:     dbit 1 ; math32 sign
0001            119   one_second_flag: dbit 1
0002            120   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003            121   one_ms_buzz_flag: dbit 1 ; one_millisecond_flag for buzz
0004            122   one_second_lcd_flag: dbit 1
0005            123   
0005            124   soak_temp_reached: dbit 1
0006            125   reflow_temp_reached: dbit 1
0007            126   cooling_temp_reached: dbit 1
0008            127   
0008            128   soak_time_reached: dbit 1
0009            129   reflow_time_reached: dbit 1
000A            130   
000A            131   reset_signal: dbit 1
000B            132   stop_signal: dbit 1
000C            133   start_signal_count: dbit 1
000D            134   time_count_doing_signal: dbit 1
000E            135   config_finish_signal: dbit 1
000F            136   
000F            137   state_change_signal: dbit 1
0010            138   state_change_signal_TC: dbit 1
0011            139   state_change_signal_Count: dbit 1
0012            140   state_change_beep_signal: dbit 1
0013            141   
0013            142   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
0014            143   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0015            144   
0015            145   PB0_flag: dbit 1 ; start entire program
0016            146   PB1_flag: dbit 1 ; start soak
0017            147   PB2_flag: dbit 1 ; pause process
0018            148   
0018            149   ;buzzer beep
0018            150   one_ms_beep_flag: dbit 1
0019            151   beep_error_done: dbit 1
001A            152   
001A            153   ; BSEG (Bit Segment)
001A            154   wait25_active: dbit 1 ; 1 = We are currently waiting
001B            155   wait25_done:   dbit 1 ; 1 = The 25ms has finished
001C            156   wait25_btn_active:    dbit 1
001D            157   wait25_btn_done:      dbit 1
001E            158   wait25_keypad_active: dbit 1
001F            159   wait25_keypad_done:   dbit 1
0020            160   wait25_adc_active:    dbit 1
0021            161   wait25_adc_done:      dbit 1
0022            162   wait25_lcd_active:    dbit 1
0023            163   wait25_lcd_done:      dbit 1
0024            164   
0024            165   fullscreen_update_signal: dbit 1
0025            166   
0025            167   one_second_flag_test: dbit 1
0026            168   one_millisecond_flag_servo: dbit 1 ; set the one millsiecond flag for servo pwm signal generation
0027            169   
0027            170   servo_angle_zero: dbit 1 ; flag for indicating whether the servo angle should be at 0 or not: 1 -> 0; 0 -> 180
0028            171   soak_temp_greater: dbit 1 ; target soak_temp greater than current_temp
0029            172   
0029            173   remote_config_mode: dbit 1
002A            174   ; 40 bits used
002A            175   
002A            176   ;-------------------------------------------------------------------------------
0320            177   cseg
0320            178   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            179   BAUD           EQU 57600
0320            180   
0320            181   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            182   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            183   ; is always 12 unlike the N76E003 where is selectable.
0320            184   
0320            185   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            186   
0320            187   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            188   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            189   
0320            190   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            191   
0320            192   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            193   BEEP_ON_MS          EQU 100  ; 100ms
0320            194   BEEP_OFF_MS    EQU 100  ; 100ms
0320            195   
0320            196   PWM_OUT        EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            197   
0320            198   ; These 'equ' must match the wiring between the DE10Lite board and the LCD!
0320            199   ; P0 is in connector JPIO.
0320            200   
0320            201   ;Added correct I/O definitions
0320            202   ;-- LCD Pins ---
0320            203   ELCD_RS equ P1.7
0320            204   ELCD_E  equ P1.1
0320            205   ELCD_D4 equ P0.7
0320            206   ELCD_D5 equ P0.5
0320            207   ELCD_D6 equ P0.3
0320            208   ELCD_D7 equ P0.1
0320            209   
0320            210   ; -- Buttons --
0320            211   BTN_SOAK_TEMP equ P0.0
0320            212   BTN_SOAK_TIME equ P0.2
0320            213   BTN_REFL_TEMP equ P0.4
0320            214   BTN_REFL_TIME equ P0.6
0320            215   PB0                equ P1.0
0320            216   PB2                equ P3.7
0320            217   
0320            218   ; --- PB0PAD ---
0320            219   ROW1 equ P1.2
0320            220   ROW2 equ P1.4
0320            221   ROW3 equ P1.6
0320            222   ROW4 equ P2.0
0320            223   COL1 equ P2.2
0320            224   COL2 equ P2.4
0320            225   COL3 equ P2.6
0320            226   COL4 equ P3.0
0320            227   
0320            228   SERVO_OUT      EQU P3.6 ; servo pin
0320            229   
0320            230   SERVO_PERIOD   EQU 20 ; pwm signal period for the servo motor (20 ms)
0320            231   SERVO_0        EQU 1 ; pwm high time for the servo motor to stay at 0 degree
0320            232   SERVO_180      EQU 2 ; pwm high time for the servo motor to stay at 180 degrees
0320            233   
0320            234   COLD_JUNCTION_TEMP equ 20
0320            235   MAX_POWER           EQU 1500 ; max oven power
0320            236   NO_POWER            EQU 0    ; no power
0320            237   BASE_POWER     EQU (MAX_POWER/5) ; 20% base power for state 2, 4
0320            238   KP                          EQU 5 ; proportional gain
0320            239   
0320            240   ;                     1234567890123456 <-- 16 characters per line LCD
0320 696E6974   241   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   242   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   243   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            244   
0350            245   ; --- UI STRINGS (REQUIRED FOR PB0PAD LOGIC), <- I can fix if duplicates
0350 53656C65   246   Txt_Home:     db 'Select Mode:    ', 0
     6374204D
     6F64653A
     20202020
     00
0361 53657420   247   Txt_SoakT:    db 'Set Soak Temp   ', 0
     536F616B
     2054656D
     70202020
     00
0372 53657420   248   Txt_SoakTime: db 'Set Soak Time   ', 0
     536F616B
     2054696D
     65202020
     00
0383 53657420   249   Txt_ReflT:    db 'Set Reflow Temp ', 0
     5265666C
     6F772054
     656D7020
     00
0394 53657420   250   Txt_ReflTime: db 'Set Reflow Time ', 0
     5265666C
     6F772054
     696D6520
     00
03A5            251   
03A5            252   ;                       1234567890123456
03A5 53657420   253   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
03B5 536F616B   254   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
03C0 5265666C   255   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
03CD 536F616B   256   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
03D8 5265666C   257   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03E5            258   
03E5 54656D70   259   String_temp_line:  db 'Temp: ', 0
     3A2000
03EC            260   
03EC            261   ;                     1234567890123456
03EC 52616D70   262   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03FC 536F616B   263   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
040C 52616D70   264   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
041C 5265666C   265   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
042C 436F6F6C   266   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
043C 50726F63   267   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
044C            268   
044C 20202020   269   String_Blank:    db '                ', 0
     20202020
     20202020
     20202020
     00
045D            270   
045D            271   ;-------------------------------------------------------------------------------
045D            272   ; Timers Setting:
045D            273   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
045D            274   ;   Timer 1: Serial port baud rate 57600 generator
045D            275   ;   Timer 2: 1ms interrupt for BCD counter increment/decrement
045D            276   ;-------------------------------------------------------------------------------
045D            277   ; Routine to initialize the ISR for Timer 0 ;
045D            278   Timer0_Init:
045D E589       279       mov a, TMOD
045F 54F0       280       anl a, #0xf0 ; Clear the bits for timer 0
0461 4401       281       orl a, #0x01 ; Configure timer 0 as 16-timer
0463 F589       282       mov TMOD, a
0465 758CFD     283       mov TH0, #high(TIMER0_RELOAD)
0468 758A5A     284       mov TL0, #low(TIMER0_RELOAD)
046B            285       ; Enable the timer and interrupts
046B D2A9       286       setb ET0  ; Enable timer 0 interrupt
046D            287       ; setb TR0  (no need to open at first)
046D 22         288       ret
046E            289   ; ISR for timer 0.  Set to execute every 1/4096Hz 
046E            290   ; to generate a 2048 Hz square wave at pin P1.5 
046E            291   Timer0_ISR:
046E            292       ;clr TF0  ; According to the data sheet this is done for us already.
046E 758CFD     293       mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
0471 758A5A     294       mov TL0, #low(TIMER0_RELOAD)
0474 B295       295       cpl SOUND_OUT ; Connect speaker to P1.5
0476 32         296       reti
0477            297   ; -----------------------------------------------------------------------------------------------;
0477            298   
0477            299   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
0477            300   Initialize_Serial_Port:
0477            301       ; Configure serial port and baud rate
0477 C28E       302       clr TR1 ; Disable timer 1
0479 53890F     303       anl TMOD, #0x0f ; Mask the bits for timer 1
047C 438920     304       orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
047F 438780     305       orl PCON, #80H ; Set SMOD to 1
0482 758DFD     306       mov TH1, #low(TIMER_1_RELOAD)
0485 758BFD     307       mov TL1, #low(TIMER_1_RELOAD) 
0488 D28E       308       setb TR1 ; Enable timer 1
048A 759852     309       mov SCON, #52H
048D 22         310       ret
048E            311   
048E            312   ; uart sending functions
048E            313   putchar:
048E 109902     314       jbc TI, putchar_L1
0491 80FB       315       sjmp putchar
0493            316   putchar_L1:
0493 F599       317       mov SBUF,a
0495 22         318       ret
0496            319   
0496            320   SendString:
0496 E4         321       clr a
0497 93         322       movc a, @a+dptr
0498 6006       323       jz SendString_L1
049A 12048E     324       lcall putchar
049D A3         325       inc dptr
049E 80F6       326       sjmp SendString  
04A0            327   SendString_L1:
04A0 22         328       ret
04A1            329   
04A1            330   ;------------------------------------------------------------
04A1            331   ; getchar_nb (non-blocking)
04A1            332   ; OUT: C=1 if got byte, A=byte
04A1            333   ;      C=0 if none
04A1            334   ;------------------------------------------------------------
04A1            335   getchar_nb:
04A1 309806     336       jnb RI, rx_none
04A4 E599       337       mov A, SBUF
04A6 C298       338       clr RI
04A8 D3         339       setb C
04A9 22         340       ret
04AA            341   rx_none:
04AA C3         342       clr C
04AB 22         343       ret
04AC            344   ;------------------------------------------------------------
04AC            345   ; Serial_RX_Pump
04AC            346   ; Builds a null-terminated line in rx_buf.
04AC            347   ; Sets rx_ready=1 when a full line received.
04AC            348   ;------------------------------------------------------------
04AC            349   Serial_RX_Pump:
04AC E57E       350       mov A, rx_ready
04AE 7034       351       jnz rxp_done          ; don't overwrite unprocessed line
04B0            352   
04B0            353   rxp_more:
04B0 1204A1     354       lcall getchar_nb
04B3 502F       355       jnc rxp_done          ; no new byte
04B5 F5F0       356       mov B, A              ; save received byte
04B7            357   
04B7            358       ; ignore CR
04B7 B40D02     359       cjne A, #0DH, rxp_not_cr
04BA 80F4       360       sjmp rxp_more
04BC            361   
04BC            362   rxp_not_cr:
04BC            363       ; if LF -> finish line
04BC B40A0F     364       cjne A, #0AH, rxp_store
04BF            365   
04BF            366       ; terminate string
04BF E57D       367       mov A, rx_idx
04C1 2492       368       add A, #rx_buf
04C3 F8         369       mov R0, A
04C4 7600       370       mov @R0, #0
04C6 757E01     371       mov rx_ready, #1
04C9 757D00     372       mov rx_idx, #0
04CC 8016       373       sjmp rxp_done
04CE            374   
04CE            375   rxp_store:
04CE            376       ; store char if room (max 39 chars)
04CE E57D       377       mov A, rx_idx
04D0 B42705     378       cjne A, #39, rxp_ok
04D3 757D00     379       mov rx_idx, #0        ; overflow: reset
04D6 800C       380       sjmp rxp_done
04D8            381   
04D8            382   rxp_ok:
04D8 E57D       383       mov A, rx_idx
04DA 2492       384       add A, #rx_buf
04DC F8         385       mov R0, A
04DD E5F0       386       mov A, B
04DF F6         387       mov @R0, A
04E0 057D       388       inc rx_idx
04E2 80CC       389       sjmp rxp_more
04E4            390   
04E4            391   rxp_done:
04E4 22         392       ret
04E5            393   ; copies 3 ASCII digits to buffer at R1, null terminates
04E5            394   ; R0 = src (first digit), R1 = dst
04E5            395   Copy3DigitsToBuf:
04E5 E6         396       mov A, @R0
04E6 F7         397       mov @R1, A
04E7 08         398       inc R0
04E8 09         399       inc R1
04E9 E6         400       mov A, @R0
04EA F7         401       mov @R1, A
04EB 08         402       inc R0
04EC 09         403       inc R1
04ED E6         404       mov A, @R0
04EE F7         405       mov @R1, A
04EF 09         406       inc R1
04F0 7700       407       mov @R1, #0
04F2 22         408       ret
04F3            409   
04F3            410   ; copies 4 ASCII digits to buffer at R1, null terminates
04F3            411   Copy4DigitsToBuf:
04F3 E6         412       mov A, @R0
04F4 F7         413       mov @R1, A
04F5 08         414       inc R0
04F6 09         415       inc R1
04F7 E6         416       mov A, @R0
04F8 F7         417       mov @R1, A
04F9 08         418       inc R0
04FA 09         419       inc R1
04FB E6         420       mov A, @R0
04FC F7         421       mov @R1, A
04FD 08         422       inc R0
04FE 09         423       inc R1
04FF E6         424       mov A, @R0
0500 F7         425       mov @R1, A
0501 09         426       inc R1
0502 7700       427       mov @R1, #0
0504 22         428       ret
0505            429   
0505            430   ;------------------------------------------------------------
0505            431   ; Serial_Process_Line
0505            432   ; Handles: UI:REMOTE, RUN:0/1, S:TTT, K:MMSS, R:TTT, L:MMSS, 
0505            433   ;          CFG:APPLY, CFG {json}, SAVE:1
0505            434   ;------------------------------------------------------------
0505            435   Serial_Process_Line:
0505 E57E       436       mov A, rx_ready
0507 7001       437       jnz SPL_HAVE
0509 22         438       ret
050A            439   SPL_HAVE:
050A 757E00     440       mov rx_ready, #0
050D 7892       441       mov R0, #rx_buf
050F E6         442       mov A, @R0
0510            443   
0510            444       ; Branch by first character (with trampolines for distance)
0510 B45502     445       cjne A, #'U', SPL_not_U
0513 801C       446       sjmp do_chk_UI_REMOTE
0515            447   SPL_not_U:
0515 B45202     448       cjne A, #'R', SPL_not_R
0518 801A       449       sjmp do_chk_R_commands
051A            450   SPL_not_R:
051A B45302     451       cjne A, #'S', SPL_not_S
051D 8018       452       sjmp do_chk_S_commands
051F            453   SPL_not_S:
051F B44B02     454       cjne A, #'K', SPL_not_K
0522 8016       455       sjmp do_chk_K
0524            456   SPL_not_K:
0524 B44C02     457       cjne A, #'L', SPL_not_L
0527 8014       458       sjmp do_chk_L
0529            459   SPL_not_L:
0529 B44302     460       cjne A, #'C', SPL_not_C
052C 8012       461       sjmp do_chk_CFG_commands
052E            462   SPL_not_C:
052E 02062E     463       ljmp spl_done
0531            464   
0531            465   ; --- Trampolines ---
0531            466   do_chk_UI_REMOTE:
0531 020543     467       ljmp chk_UI_REMOTE
0534            468   do_chk_R_commands:
0534 02055D     469       ljmp chk_R_commands
0537            470   do_chk_S_commands:
0537 020597     471       ljmp chk_S_commands
053A            472   do_chk_K:
053A 0205CB     473       ljmp chk_K
053D            474   do_chk_L:
053D 0205DD     475       ljmp chk_L
0540            476   do_chk_CFG_commands:
0540 0205EF     477       ljmp chk_CFG_commands
0543            478   
0543            479   ;------------------------------------------------------------
0543            480   ; UI:REMOTE - Switch to remote control mode
0543            481   ;------------------------------------------------------------
0543            482   chk_UI_REMOTE:
0543 7892       483       mov R0, #rx_buf
0545 E6         484       mov A, @R0
0546 B45511     485       cjne A, #'U', spl_done_bridge1
0549 08         486       inc R0
054A E6         487       mov A, @R0
054B B4490C     488       cjne A, #'I', spl_done_bridge1
054E 08         489       inc R0
054F E6         490       mov A, @R0
0550 B43A07     491       cjne A, #':', spl_done_bridge1
0553 08         492       inc R0
0554 E6         493       mov A, @R0
0555 B45202     494       cjne A, #'R', spl_done_bridge1
0558            495       ; Good enough - it's UI:R...
0558 8000       496       sjmp spl_done_bridge1
055A            497   
055A            498   spl_done_bridge1:
055A 02062E     499       ljmp spl_done
055D            500   
055D            501   ;------------------------------------------------------------
055D            502   ; R commands: R:TTT (reflow temp) or RUN:0/1
055D            503   ;------------------------------------------------------------
055D            504   chk_R_commands:
055D 7892       505       mov R0, #rx_buf
055F 08         506       inc R0                     ; Point to second char
0560 E6         507       mov A, @R0
0561 B43A08     508       cjne A, #':', chk_RUN_jump ; If not ':', check for RUN
0564            509       ; It's "R:" - Reflow temperature
0564 08         510       inc R0
0565 7989       511       mov R1, #Buf_Refl_Temp
0567 1204E5     512       lcall Copy3DigitsToBuf
056A 8002       513       sjmp spl_done_bridge2
056C            514   
056C            515   chk_RUN_jump:
056C 8003       516       sjmp chk_RUN
056E            517   
056E            518   spl_done_bridge2:
056E 02062E     519       ljmp spl_done
0571            520   
0571            521   chk_RUN:
0571            522       ; Check for "RUN:"
0571 7892       523       mov R0, #rx_buf
0573 08         524       inc R0
0574 E6         525       mov A, @R0
0575 B4551C     526       cjne A, #'U', spl_done_bridge3
0578 08         527       inc R0
0579 E6         528       mov A, @R0
057A B44E17     529       cjne A, #'N', spl_done_bridge3
057D 08         530       inc R0
057E E6         531       mov A, @R0
057F B43A12     532       cjne A, #':', spl_done_bridge3
0582 08         533       inc R0
0583 E6         534       mov A, @R0
0584            535       
0584            536       ; Check for '1' or '0'
0584 B43105     537       cjne A, #'1', chk_RUN_zero
0587            538       
0587            539       ; RUN:1 - Start the process
0587 020EA4     540       ljmp Control_FSM_state2_a
058A 8008       541       sjmp spl_done_bridge3
058C            542   
058C            543   chk_RUN_zero:
058C B43005     544       cjne A, #'0', spl_done_bridge3
058F            545       ; RUN:0 - Stop the process
058F 020E77     546       ljmp Control_FSM_state0_a
0592 8000       547       sjmp spl_done_bridge3
0594            548   
0594            549   spl_done_bridge3:
0594 02062E     550       ljmp spl_done
0597            551   
0597            552   ;------------------------------------------------------------
0597            553   ; S commands: S:TTT (soak temp) or SAVE:1
0597            554   ;------------------------------------------------------------
0597            555   chk_S_commands:
0597 7892       556       mov R0, #rx_buf
0599 08         557       inc R0                     ; Point to second char
059A E6         558       mov A, @R0
059B B43A08     559       cjne A, #':', chk_SAVE_jump
059E            560       ; It's "S:" - Soak temperature
059E 08         561       inc R0
059F 7980       562       mov R1, #Buf_Soak_Temp
05A1 1204E5     563       lcall Copy3DigitsToBuf
05A4 8002       564       sjmp spl_done_bridge4
05A6            565   
05A6            566   chk_SAVE_jump:
05A6 8003       567       sjmp chk_SAVE
05A8            568   
05A8            569   spl_done_bridge4:
05A8 02062E     570       ljmp spl_done
05AB            571   
05AB            572   chk_SAVE:
05AB            573       ; Check for "SAVE:"
05AB 7892       574       mov R0, #rx_buf
05AD 08         575       inc R0
05AE E6         576       mov A, @R0
05AF B44116     577       cjne A, #'A', spl_done_bridge5
05B2 08         578       inc R0
05B3 E6         579       mov A, @R0
05B4 B45611     580       cjne A, #'V', spl_done_bridge5
05B7 08         581       inc R0
05B8 E6         582       mov A, @R0
05B9 B4450C     583       cjne A, #'E', spl_done_bridge5
05BC 08         584       inc R0
05BD E6         585       mov A, @R0
05BE B43A07     586       cjne A, #':', spl_done_bridge5
05C1 08         587       inc R0
05C2 E6         588       mov A, @R0
05C3 B43102     589       cjne A, #'1', spl_done_bridge5
05C6            590       
05C6            591       ; SAVE:1 - Save to non-volatile memory (stub)
05C6 8000       592       sjmp spl_done_bridge5
05C8            593   
05C8            594   spl_done_bridge5:
05C8 02062E     595       ljmp spl_done
05CB            596   
05CB            597   ;------------------------------------------------------------
05CB            598   ; K:MMSS - Soak time
05CB            599   ;------------------------------------------------------------
05CB            600   chk_K:
05CB 7892       601       mov R0, #rx_buf
05CD 08         602       inc R0
05CE E6         603       mov A, @R0
05CF B43A08     604       cjne A, #':', spl_done_bridge6
05D2 08         605       inc R0
05D3 7984       606       mov R1, #Buf_Soak_Time
05D5 1204F3     607       lcall Copy4DigitsToBuf
05D8 8000       608       sjmp spl_done_bridge6
05DA            609   
05DA            610   spl_done_bridge6:
05DA 02062E     611       ljmp spl_done
05DD            612   
05DD            613   ;------------------------------------------------------------
05DD            614   ; L:MMSS - Reflow time
05DD            615   ;------------------------------------------------------------
05DD            616   chk_L:
05DD 7892       617       mov R0, #rx_buf
05DF 08         618       inc R0
05E0 E6         619       mov A, @R0
05E1 B43A08     620       cjne A, #':', spl_done_bridge7
05E4 08         621       inc R0
05E5 798D       622       mov R1, #Buf_Refl_Time
05E7 1204F3     623       lcall Copy4DigitsToBuf
05EA 8000       624       sjmp spl_done_bridge7
05EC            625   
05EC            626   spl_done_bridge7:
05EC 02062E     627       ljmp spl_done
05EF            628   
05EF            629   ;------------------------------------------------------------
05EF            630   ; CFG commands: CFG:APPLY or CFG {json}
05EF            631   ;------------------------------------------------------------
05EF            632   chk_CFG_commands:
05EF 7892       633       mov R0, #rx_buf
05F1 E6         634       mov A, @R0
05F2 B44336     635       cjne A, #'C', spl_done_bridge8
05F5 08         636       inc R0
05F6 E6         637       mov A, @R0
05F7 B44631     638       cjne A, #'F', spl_done_bridge8
05FA 08         639       inc R0
05FB E6         640       mov A, @R0
05FC B4472C     641       cjne A, #'G', spl_done_bridge8
05FF 08         642       inc R0
0600 E6         643       mov A, @R0
0601            644       
0601            645       ; Check if ':' (CFG:APPLY) or ' ' (CFG {json})
0601 B43A22     646       cjne A, #':', chk_CFG_json
0604            647       
0604            648       ; It's "CFG:" - check for APPLY
0604 08         649       inc R0
0605 E6         650       mov A, @R0
0606 B44122     651       cjne A, #'A', spl_done_bridge8
0609 08         652       inc R0
060A E6         653       mov A, @R0
060B B4501D     654       cjne A, #'P', spl_done_bridge8
060E 08         655       inc R0
060F E6         656       mov A, @R0
0610 B45018     657       cjne A, #'P', spl_done_bridge8
0613 08         658       inc R0
0614 E6         659       mov A, @R0
0615 B44C13     660       cjne A, #'L', spl_done_bridge8
0618 08         661       inc R0
0619 E6         662       mov A, @R0
061A B4590E     663       cjne A, #'Y', spl_done_bridge8
061D            664       
061D            665       ; CFG:APPLY - Apply configuration
061D 120F4E     666       lcall Update_FSM_Variables
0620 D20F       667       setb state_change_signal
0622 D224       668       setb fullscreen_update_signal
0624 8005       669       sjmp spl_done_bridge8
0626            670   
0626            671   chk_CFG_json:
0626            672       ; Check for space (CFG {json})
0626 B42002     673       cjne A, #' ', spl_done_bridge8
0629            674       ; It's "CFG {...}" - JSON config (ignored)
0629 8000       675       sjmp spl_done_bridge8
062B            676   
062B            677   spl_done_bridge8:
062B 02062E     678       ljmp spl_done
062E            679   
062E            680   ;------------------------------------------------------------
062E            681   spl_done:
062E 22         682       ret
062F            683   
062F            684   
062F            685   ;-------------------------------------------------------------------------------
062F            686   ; serial debugging
062F            687   ; send a four byte number via serial to laptop
062F            688   ; need to be used with python script
062F            689   ; content needed to be sent should be stored in the varaible x
062F            690   ;-------------------------------------------------------------------------------
062F            691   Send32:
062F            692       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
062F 74AA       693       mov A, #0AAH
0631 12048E     694       lcall putchar
0634 7455       695       mov A, #055H
0636 12048E     696       lcall putchar
0639            697   
0639 E53D       698       mov A, x+3
063B 12048E     699       lcall putchar
063E E53C       700       mov A, x+2
0640 12048E     701       lcall putchar
0643 E53B       702       mov A, x+1
0645 12048E     703       lcall putchar
0648 E53A       704       mov A, x+0
064A 12048E     705       lcall putchar
064D            706   
064D 740A       707       mov A, #0AH
064F 12048E     708       lcall putchar
0652 22         709       ret
0653            710   ; -----------------------------------------------------------------------------------------------;
0653            711   
0653            712   ;-------------------------------------------------------------------------------
0653            713   ; Serial temperature line for PuTTY/screen
0653            714   ; Outputs: "Temp: XXXC\r\n"
0653            715   ;-------------------------------------------------------------------------------
0653            716   Serial_Send_Temp_Line:
0653 9003E5     717       mov dptr, #String_temp_line
0656 120496     718       lcall SendString
0659            719   
0659            720       ; Convert current_temp to BCD (same as LCD)
0659 85473A     721       mov x, current_temp
065C 85483B     722       mov x+1, current_temp+1
065F 85493C     723       mov x+2, current_temp+2
0662 854A3D     724       mov x+3, current_temp+3
0665 12002E     725       lcall hex2bcd
0668            726   
0668 7F00       727       mov R7, #0          ; printed_flag = 0
066A            728   
066A            729       ; Print Hundreds (if non-zero)
066A E543       730       mov a, bcd+1
066C 540F       731       anl a, #0x0F
066E 6007       732       jz Serial_Skip_Hundreds
0670 2430       733       add a, #0x30
0672 12048E     734       lcall putchar
0675 7F01       735       mov R7, #1
0677            736   Serial_Skip_Hundreds:
0677            737   
0677            738       ; Print Tens (if non-zero or if hundreds already printed)
0677 E542       739       mov a, bcd+0
0679 C4         740       swap a
067A 540F       741       anl a, #0x0F
067C 7003       742       jnz Serial_Print_Tens
067E EF         743       mov a, R7
067F 600C       744       jz Serial_Skip_Tens
0681            745   Serial_Print_Tens:
0681 E542       746       mov a, bcd+0
0683 C4         747       swap a
0684 540F       748       anl a, #0x0F
0686 2430       749       add a, #0x30
0688 12048E     750       lcall putchar
068B 7F01       751       mov R7, #1
068D            752   Serial_Skip_Tens:
068D            753   
068D            754       ; Print Ones (always)
068D E542       755       mov a, bcd+0
068F 540F       756       anl a, #0x0F
0691 2430       757       add a, #0x30
0693 12048E     758       lcall putchar
0696            759   
0696            760       ; Print 'C' and newline
0696 7443       761       mov a, #'C'
0698 12048E     762       lcall putchar
069B 740D       763       mov a, #0DH     ; CR
069D 12048E     764       lcall putchar
06A0 740A       765       mov a, #0AH     ; LF
06A2 12048E     766       lcall putchar
06A5 22         767       ret
06A6            768   
06A6            769   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
06A6              1   ;-------------------------------------------------------------------------------
06A6              2   ; Timer2_ISR.inc
06A6              3   ; Contains Initialization and ISR for the 1ms System Timer
06A6              4   ;-------------------------------------------------------------------------------
06A6              5   
06A6              6   ;-------------------------------------------------------------------------------
06A6              7   ; Routine to initialize the ISR for timer 2
06A6              8   ;-------------------------------------------------------------------------------
06A6              9   Timer2_Init:
06A6 75C800      10       mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
06A9 75CDF5      11       mov TH2, #high(TIMER2_RELOAD)
06AC 75CC27      12       mov TL2, #low(TIMER2_RELOAD)
06AF             13       ; Set the reload value
06AF 75CBF5      14       mov RCAP2H, #high(TIMER2_RELOAD)
06B2 75CA27      15       mov RCAP2L, #low(TIMER2_RELOAD)
06B5             16       
06B5 C2CF        17       clr TF2       ; Clear flag just in case
06B7             18       ; Enable the timer and interrupts
06B7 D2AD        19       setb ET2      ; Enable timer 2 interrupt
06B9 D2CA        20       setb TR2      ; Enable timer 2
06BB 22          21       ret
06BC             22   
06BC             23   ;-------------------------------------------------------------------------------
06BC             24   ; ISR for timer 2.  Runs every 1 ms
06BC             25   ;-------------------------------------------------------------------------------
06BC             26   Timer2_ISR:
06BC C0E0        27       push acc
06BE C0D0        28       push psw
06C0             29       
06C0 C2CF        30       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
06C2             31   
06C2             32       ; --- 1. Existing Non-Blocking Seconds Increment and Periphals Debounce Timers ---
06C2 056F        33       inc SEC_FSM_timer
06C4 D202        34       setb one_ms_pwm_flag 
06C6 D203        35            setb one_ms_buzz_flag
06C8 D218        36       setb one_ms_beep_flag
06CA D226        37       setb one_millisecond_flag_servo
06CC             38     
06CC 0571        39       inc PB0_DEB_timer
06CE 0573        40       inc PB2_DEB_timer
06D0 057B        41       inc BTN_DEB_timer
06D2             42   
06D2             43       ; --- 2. NEW: Non-Blocking Delay Counters ---
06D2             44       ; A. BUTTON DELAY
06D2 301C0B      45       jnb wait25_btn_active, T2_Check_Keypad
06D5 0553        46       inc wait25_btn_cnt
06D7 E553        47       mov a, wait25_btn_cnt
06D9 B41904      48       cjne a, #25, T2_Check_Keypad
06DC D21D        49       setb wait25_btn_done
06DE C21C        50       clr wait25_btn_active
06E0             51       
06E0             52       ; B. KEYPAD DELAY
06E0             53   T2_Check_Keypad:
06E0 301E0B      54       jnb wait25_keypad_active, T2_Check_ADC
06E3 0554        55       inc wait25_keypad_cnt
06E5 E554        56       mov a, wait25_keypad_cnt
06E7 B41904      57       cjne a, #25, T2_Check_ADC
06EA D21F        58       setb wait25_keypad_done
06EC C21E        59       clr wait25_keypad_active
06EE             60   
06EE             61       ; C. ADC DELAY (Thermocouple)
06EE             62   T2_Check_ADC:
06EE 30200B      63       jnb wait25_adc_active, T2_Check_LCD
06F1 0555        64       inc wait25_adc_cnt
06F3 E555        65       mov a, wait25_adc_cnt
06F5 B41904      66       cjne a, #25, T2_Check_LCD
06F8 D221        67       setb wait25_adc_done
06FA C220        68       clr wait25_adc_active
06FC             69   
06FC             70       ; D. LCD DELAY
06FC             71   T2_Check_LCD:
06FC 30220B      72       jnb wait25_lcd_active, T2_Check_Generic
06FF 0556        73       inc wait25_lcd_cnt
0701 E556        74       mov a, wait25_lcd_cnt
0703 B41904      75       cjne a, #25, T2_Check_Generic
0706 D223        76       setb wait25_lcd_done
0708 C222        77       clr wait25_lcd_active
070A             78   
070A             79       ; E. GENERIC DELAY (Used by Wait_25ms in Main)
070A             80   T2_Check_Generic:
070A 301A0B      81       jnb wait25_active, Timer2_ISR_done
070D 0557        82       inc wait25_count
070F E557        83       mov a, wait25_count
0711 B41904      84       cjne a, #25, Timer2_ISR_done
0714 D21B        85       setb wait25_done      ; Tells Wait_25ms that we are finished
0716 C21A        86       clr wait25_active     ; Stop counting
0718             87   
0718             88   Timer2_ISR_done:
0718 D0D0        89       pop psw
071A D0E0        90       pop acc
071C 32          91       reti
071D             92            
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
071D              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
071D              2   cseg
071D              3   
071D              4   ; When using a 33.333333MHz crystal clock
071D              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
071D              6   
071D              7   ;---------------------------------;
071D              8   ; Wait 40 microseconds            ;
071D              9   ;---------------------------------;
071D             10   Wait40uSec:
071D C000        11            push AR0
071F 78BE        12            mov R0, #190
0721             13   L0: 
0721 00          14            nop
0722 00          15            nop
0723 00          16            nop
0724 00          17            nop
0725 D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
0727 D000        19            pop AR0
0729 22          20       ret
072A             21   
072A             22   ;---------------------------------;
072A             23   ; Wait 'R2' milliseconds          ;
072A             24   ;---------------------------------;
                 25   Wait_Milli_Seconds mac
                 26   	push AR2
                 27   	mov R2, %0
                 28   	lcall ?Wait_Milli_Seconds
                 29   	pop AR2
                 30   endmac
072A             31   
072A             32   ?Wait_Milli_Seconds:
072A C000        33            push AR0
072C C001        34            push AR1
072E 7932        35   L3: mov R1, #50
0730 78DF        36   L2: mov R0, #223
0732 D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
0734 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
0736 DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
0738 D001        40       pop AR1
073A D000        41       pop AR0
073C 22          42       ret
073D             43            
073D             44   ;---------------------------------;
073D             45   ; Toggles the 'E' pin in the LCD  ;
073D             46   ;---------------------------------;
073D             47   ELCD_pulse:
073D D291        48            setb ELCD_E
073F 12071D      49            lcall Wait40uSec
0742 C291        50            clr ELCD_E
0744 12071D      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
0747 22          52       ret
0748             53   
0748             54   ;---------------------------------;
0748             55   ; Writes acc to LCD in 4-bit mode ;
0748             56   ;---------------------------------;
0748             57   ELCD_byte:
0748             58            ; Write high 4 bits first
0748 A2E7        59            mov c, ACC.7
074A 9281        60            mov ELCD_D7, c
074C A2E6        61            mov c, ACC.6
074E 9283        62            mov ELCD_D6, c
0750 A2E5        63            mov c, ACC.5
0752 9285        64            mov ELCD_D5, c
0754 A2E4        65            mov c, ACC.4
0756 9287        66            mov ELCD_D4, c
0758 12073D      67       lcall ELCD_pulse
075B             68            ; Write low 4 bits next
075B A2E3        69            mov c, ACC.3
075D 9281        70            mov ELCD_D7, c
075F A2E2        71            mov c, ACC.2
0761 9283        72            mov ELCD_D6, c
0763 A2E1        73            mov c, ACC.1
0765 9285        74            mov ELCD_D5, c
0767 A2E0        75            mov c, ACC.0
0769 9287        76            mov ELCD_D4, c
076B 12073D      77       lcall ELCD_pulse
076E 22          78            ret
076F             79   
076F             80   ;---------------------------------;
076F             81   ; Write data to LCD               ;
076F             82   ;---------------------------------;
                 83   WriteData mac
                 84   	mov a, %0
                 85   	lcall ?WriteData
                 86   endmac
076F             87            
076F             88   ?WriteData:
076F D297        89            setb ELCD_RS
0771 020748      90            ljmp ELCD_byte
0774             91   
0774             92   ;---------------------------------;
0774             93   ; Write command to LCD            ;
0774             94   ;---------------------------------;
                 95   WriteCommand mac
                 96   	mov a, %0
                 97   	lcall ?WriteCommand
                 98   endmac
0774             99   
0774            100   ?WriteCommand:
0774 C297       101            clr ELCD_RS
0776 020748     102            ljmp ELCD_byte
0779            103   
0779            104   ;---------------------------------;
0779            105   ; Configure LCD in 4-bit mode     ;
0779            106   ;---------------------------------;
0779            107   ELCD_4BIT:
0779 C291       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
077B            109            ;clr ELCD_RW  ; RW forced to zero
077B            110            
077B            111            ; After power on, let the LCD start up before initializing
077B C002       112            push AR2
077D 7A28       112            mov R2, #40
077F 12072A     112            lcall ?Wait_Milli_Seconds
0782 D002       112            pop AR2
0784            113            
0784            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
0784 7433       115            mov a, #0x33
0786 120774     115            lcall ?WriteCommand
0789 7433       116            mov a, #0x33
078B 120774     116            lcall ?WriteCommand
078E 7432       117            mov a, #0x32
0790 120774     117            lcall ?WriteCommand ; change to 4-bit mode
0793            118   
0793            119            ; Configure the LCD
0793 7428       120            mov a, #0x28
0795 120774     120            lcall ?WriteCommand
0798 740C       121            mov a, #0x0c
079A 120774     121            lcall ?WriteCommand
079D 7401       122            mov a, #0x01
079F 120774     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
07A2            123   
07A2            124       ;Wait for the clear screen command to finish.
07A2 C002       125            push AR2
07A4 7A02       125            mov R2, #2
07A6 12072A     125            lcall ?Wait_Milli_Seconds
07A9 D002       125            pop AR2
07AB 22         126       ret
07AC            127   
07AC            128   ;---------------------------------;
07AC            129   ; Send a constant string to LCD   ;
07AC            130   ;---------------------------------;
                131   Send_Constant_String mac
                132   	push dph
                133   	push dpl
                134   	push acc
                135   	mov dptr, %0
                136   	lcall ?Send_Constant_String
                137   	pop acc
                138   	pop dpl
                139   	pop dph
                140   endmac
07AC            141   
07AC            142   ?Send_Constant_String:
07AC E4         143       clr a
07AD 93         144       movc a, @a+dptr
07AE 6006       145       jz ?Send_Constant_String_Done
07B0 12076F     146       lcall ?WriteData
07B3 A3         147       inc dptr
07B4 80F6       148       sjmp ?Send_Constant_String
07B6            149   ?Send_Constant_String_Done:
07B6 22         150       ret  
07B7            151   
07B7            152   ;---------------------------------;
07B7            153   ; Set LCD cursor at row, column   ;
07B7            154   ;---------------------------------;
                155   Set_Cursor mac
                156   	push acc
                157   	mov a, #%1
                158   	dec a
                159   	lcall ?Set_Cursor_%0 ; Select column and row
                160   	pop acc
                161   endmac
07B7            162   
07B7            163   ?Set_Cursor_2:
07B7 4440       164            orl a, #01000000B
07B9            165   ?Set_Cursor_1:
07B9 4480       166            orl a, #10000000B
07BB 020774     167            ljmp ?WriteCommand ; Select column and row
07BE            168   
07BE            169   ;---------------------------------;
07BE            170   ; Display a BCD number in the LCD ;
07BE            171   ;---------------------------------;
                172   Display_BCD mac
                173   	push ar0
                174   	mov r0, %0
                175   	lcall ?Display_BCD
                176   	pop ar0
                177   endmac
07BE            178   
07BE            179   ?Display_BCD:
07BE C0E0       180            push acc
07C0            181            ; Write most significant digit
07C0 E8         182            mov a, r0
07C1 C4         183            swap a
07C2 540F       184            anl a, #0fh
07C4 4430       185            orl a, #30h
07C6 12076F     186            lcall ?WriteData
07C9            187            ; write least significant digit
07C9 E8         188            mov a, r0
07CA 540F       189            anl a, #0fh
07CC 4430       190            orl a, #30h
07CE 12076F     191            lcall ?WriteData
07D1 D0E0       192            pop acc
07D3 22         193            ret
07D4            194   
07D4            195   ;------------------------------------;
07D4            196   ; Display a char in the LCD          ;
07D4            197   ;------------------------------------;
                198   Display_char mac
                199   	push acc
                200   	mov a, %0
                201   	lcall ?WriteData
                202   	pop acc
                203   endmac
07D4            204   
07D4            772            ;-----------------------------------------------------------------------------------------------;
07D4            773   
07D4            774   ;-------------------------------------------------------------------------------
07D4            775   ; Display Function for 7-segment displays       
07D4            776   ;-------------------------------------------------------------------------------
07D4            777   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
07D4            778   T_7seg:
07D4 C0F9A4B0   779       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
07D9 9282F880   780       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
07DE 8883C6A1   781       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
07E4            782   
07E4            783   ; Displays a BCD number pased in R0 in HEX5-HEX0
07E4            784   Display_BCD_7_Seg_HEX10:
07E4 9007D4     785       mov dptr, #T_7seg
07E7 E8         786       mov a, R0
07E8 C4         787       swap a
07E9 540F       788       anl a, #0FH
07EB 93         789       movc a, @a+dptr
07EC F592       790       mov HEX1, a
07EE E8         791       mov a, R0
07EF 540F       792       anl a, #0FH
07F1 93         793       movc a, @a+dptr
07F2 F591       794       mov HEX0, a
07F4 22         795       ret
07F5            796   
07F5            797   Display_BCD_7_Seg_HEX32:
07F5 9007D4     798       mov dptr, #T_7seg
07F8 E8         799       mov a, R0
07F9 C4         800       swap a
07FA 540F       801       anl a, #0FH
07FC 93         802       movc a, @a+dptr
07FD F594       803       mov HEX3, a
07FF E8         804       mov a, R0
0800 540F       805       anl a, #0FH
0802 93         806       movc a, @a+dptr
0803 F593       807       mov HEX2, a
0805 22         808       ret
0806            809   
0806            810   Display_BCD_7_Seg_HEX54:
0806 9007D4     811       mov dptr, #T_7seg
0809 E8         812       mov a, R0
080A C4         813       swap a
080B 540F       814       anl a, #0FH
080D 93         815       movc a, @a+dptr
080E F58F       816       mov HEX5, a
0810 E8         817       mov a, R0
0811 540F       818       anl a, #0FH
0813 93         819       movc a, @a+dptr
0814 F58E       820       mov HEX4, a
0816 22         821       ret
0817            822   
0817            823   ; The 8-bit hex number passed in the accumulator is converted to
0817            824   ; BCD and stored in [R1, R0]
0817            825   Hex_to_bcd_8bit:
0817 75F064     826       mov b, #100
081A 84         827       div ab
081B F9         828       mov R1, a   ; After dividing, a has the 100s
081C E5F0       829       mov a, b    ; Remainder is in register b
081E 75F00A     830       mov b, #10
0821 84         831       div ab ; The tens are stored in a, the units are stored in b 
0822 C4         832       swap a
0823 54F0       833       anl a, #0xf0
0825 45F0       834       orl a, b
0827 F8         835       mov R0, a
0828 22         836       ret
0829            837   ;-------------------------------------------------------------------------------
0829            838   ; Display Function for LCD                      
0829            839   ;-------------------------------------------------------------------------------
0829            840   LCD_Print_2Digits:
0829 120817     841       lcall Hex_to_bcd_8bit
082C E8         842       mov a, R0
082D C4         843       swap a
082E 540F       844       anl a, #0x0F
0830 2430       845       add a, #0x30
0832 12076F     846       lcall ?WriteData
0835 E8         847       mov a, R0
0836 540F       848       anl a, #0x0F
0838 2430       849       add a, #0x30
083A 12076F     850       lcall ?WriteData
083D 22         851       ret
083E            852   
083E            853   LCD_Display_Update_func:
083E C0E0       854       push acc
0840            855       
0840            856       ; ==========================================
0840            857       ; PART 1: STATIC TEXT (Title)
0840            858       ; Runs ONLY when the state changes
0840            859       ; ==========================================
0840            860       
0840            861       ; [FIX] "Trampoline" logic for long distance jump
0840            862       ; If signal is SET (1), we stay here and update.
0840            863       ; If signal is CLEAR (0), we Long Jump to the Live Update section.
0840 300F04     864       jnb state_change_signal, Do_Dynamic_Update
0843 C20F       865            clr state_change_signal
0845 8003       866            sjmp Do_Static_Update
0847            867   Do_Dynamic_Update:
0847 02097E     868            ljmp Check_Live_Update
084A            869   
084A            870   Do_Static_Update:
084A            871       ; State Changed: Clear Screen and Write Title
084A 120B11     872       lcall Clear_Screen_Func
084D E560       873       mov a, Control_FSM_state
084F            874       
084F            875       ; State 0: Welcome
084F B4003B     876       cjne a, #0, LCD_Check_1
0852 C0E0       877            push acc
0854 7401       877            mov a, #1
0856 14         877            dec a
0857 1207B9     877            lcall ?Set_Cursor_1 ; Select column and row
085A D0E0       877            pop acc
085C C083       878            push dph
085E C082       878            push dpl
0860 C0E0       878            push acc
0862 900330     878            mov dptr, #String_state0_1
0865 1207AC     878            lcall ?Send_Constant_String
0868 D0E0       878            pop acc
086A D082       878            pop dpl
086C D083       878            pop dph
086E C0E0       879            push acc
0870 7401       879            mov a, #1
0872 14         879            dec a
0873 1207B7     879            lcall ?Set_Cursor_2 ; Select column and row
0876 D0E0       879            pop acc
0878 C083       880            push dph
087A C082       880            push dpl
087C C0E0       880            push acc
087E 900340     880            mov dptr, #String_state0_2
0881 1207AC     880            lcall ?Send_Constant_String
0884 D0E0       880            pop acc
0886 D082       880            pop dpl
0888 D083       880            pop dph
088A 02097B     881       ljmp LCD_Done_Bridge ; Exit
088D            882   
088D            883   LCD_Check_1: ; Setup
088D B4011F     884       cjne a, #1, LCD_Check_2
0890 C0E0       885            push acc
0892 7401       885            mov a, #1
0894 14         885            dec a
0895 1207B9     885            lcall ?Set_Cursor_1 ; Select column and row
0898 D0E0       885            pop acc
089A C083       886            push dph
089C C082       886            push dpl
089E C0E0       886            push acc
08A0 9003A5     886            mov dptr, #String_state1
08A3 1207AC     886            lcall ?Send_Constant_String
08A6 D0E0       886            pop acc
08A8 D082       886            pop dpl
08AA D083       886            pop dph
08AC 02097B     887       ljmp LCD_Done_Bridge
08AF            888   
08AF            889   LCD_Check_2: ; Ramp to Soak
08AF B4021F     890       cjne a, #2, LCD_Check_3
08B2 C0E0       891            push acc
08B4 7401       891            mov a, #1
08B6 14         891            dec a
08B7 1207B9     891            lcall ?Set_Cursor_1 ; Select column and row
08BA D0E0       891            pop acc
08BC C083       892            push dph
08BE C082       892            push dpl
08C0 C0E0       892            push acc
08C2 9003EC     892            mov dptr, #String_state2
08C5 1207AC     892            lcall ?Send_Constant_String
08C8 D0E0       892            pop acc
08CA D082       892            pop dpl
08CC D083       892            pop dph
08CE 02099E     893       ljmp LCD_Update_Temp_Value ; Draw Temp immediately!
08D1            894   
08D1            895   LCD_Check_3: ; Soak
08D1 B4031F     896       cjne a, #3, LCD_Check_4
08D4 C0E0       897            push acc
08D6 7401       897            mov a, #1
08D8 14         897            dec a
08D9 1207B9     897            lcall ?Set_Cursor_1 ; Select column and row
08DC D0E0       897            pop acc
08DE C083       898            push dph
08E0 C082       898            push dpl
08E2 C0E0       898            push acc
08E4 9003FC     898            mov dptr, #String_state3
08E7 1207AC     898            lcall ?Send_Constant_String
08EA D0E0       898            pop acc
08EC D082       898            pop dpl
08EE D083       898            pop dph
08F0 02099E     899       ljmp LCD_Update_Temp_Value
08F3            900   
08F3            901   LCD_Check_4: ; Ramp to Peak
08F3 B4041F     902       cjne a, #4, LCD_Check_5
08F6 C0E0       903            push acc
08F8 7401       903            mov a, #1
08FA 14         903            dec a
08FB 1207B9     903            lcall ?Set_Cursor_1 ; Select column and row
08FE D0E0       903            pop acc
0900 C083       904            push dph
0902 C082       904            push dpl
0904 C0E0       904            push acc
0906 90040C     904            mov dptr, #String_state4
0909 1207AC     904            lcall ?Send_Constant_String
090C D0E0       904            pop acc
090E D082       904            pop dpl
0910 D083       904            pop dph
0912 02099E     905       ljmp LCD_Update_Temp_Value
0915            906   
0915            907   LCD_Check_5: ; Reflow
0915 B4051F     908       cjne a, #5, LCD_Check_6
0918 C0E0       909            push acc
091A 7401       909            mov a, #1
091C 14         909            dec a
091D 1207B9     909            lcall ?Set_Cursor_1 ; Select column and row
0920 D0E0       909            pop acc
0922 C083       910            push dph
0924 C082       910            push dpl
0926 C0E0       910            push acc
0928 90041C     910            mov dptr, #String_state5
092B 1207AC     910            lcall ?Send_Constant_String
092E D0E0       910            pop acc
0930 D082       910            pop dpl
0932 D083       910            pop dph
0934 02099E     911       ljmp LCD_Update_Temp_Value
0937            912   
0937            913   LCD_Check_6: ; Cooling
0937 B4061F     914       cjne a, #6, LCD_Check_7
093A C0E0       915            push acc
093C 7401       915            mov a, #1
093E 14         915            dec a
093F 1207B9     915            lcall ?Set_Cursor_1 ; Select column and row
0942 D0E0       915            pop acc
0944 C083       916            push dph
0946 C082       916            push dpl
0948 C0E0       916            push acc
094A 90042C     916            mov dptr, #String_state6
094D 1207AC     916            lcall ?Send_Constant_String
0950 D0E0       916            pop acc
0952 D082       916            pop dpl
0954 D083       916            pop dph
0956 02099E     917       ljmp LCD_Update_Temp_Value
0959            918   
0959            919   LCD_Check_7: ; Done
0959            920       ; [FIX] Check distance safe logic for State 7
0959 B4071F     921       cjne a, #7, LCD_Done_Bridge ; If not 7, we are done
095C C0E0       922            push acc
095E 7401       922            mov a, #1
0960 14         922            dec a
0961 1207B9     922            lcall ?Set_Cursor_1 ; Select column and row
0964 D0E0       922            pop acc
0966 C083       923            push dph
0968 C082       923            push dpl
096A C0E0       923            push acc
096C 90043C     923            mov dptr, #String_state7
096F 1207AC     923            lcall ?Send_Constant_String
0972 D0E0       923            pop acc
0974 D082       923            pop dpl
0976 D083       923            pop dph
0978 02097B     924       ljmp LCD_Done_Bridge
097B            925   
097B            926   ; Local bridge to reach the far-away LCD_Done
097B            927   LCD_Done_Bridge:
097B 0209FF     928       ljmp LCD_Done
097E            929   
097E            930   ; ==========================================
097E            931   ; PART 2: DYNAMIC VALUES (Temperature)
097E            932   ; Runs every time 'one_second_flag' is set
097E            933   ; ==========================================
097E            934   Check_Live_Update:
097E 3001FA     935       jnb one_second_flag, LCD_Done_Bridge
0981 C201       936       clr one_second_flag
0983            937       
0983            938       ; Only update temp for States 2, 3, 4, 5, 6
0983 E560       939       mov a, Control_FSM_state
0985 B40202     940       cjne a, #2, Check_St3
0988 8014       941       sjmp LCD_Update_Temp_Value
098A            942   Check_St3:
098A B40302     943       cjne a, #3, Check_St4
098D 800F       944       sjmp LCD_Update_Temp_Value
098F            945   Check_St4:
098F B40402     946       cjne a, #4, Check_St5
0992 800A       947       sjmp LCD_Update_Temp_Value
0994            948   Check_St5:
0994 B40502     949       cjne a, #5, Check_St6
0997 8005       950       sjmp LCD_Update_Temp_Value
0999            951   Check_St6:
0999 B40663     952       cjne a, #6, LCD_Done
099C 8000       953       sjmp LCD_Update_Temp_Value
099E            954   
099E            955   ; --- HELPER: Prints "XXX C" on Line 2 ---
099E            956   LCD_Update_Temp_Value:
099E C0E0       957            push acc
09A0 7401       957            mov a, #1
09A2 14         957            dec a
09A3 1207B7     957            lcall ?Set_Cursor_2 ; Select column and row
09A6 D0E0       957            pop acc
09A8            958       
09A8            959       ; Convert current_temp to BCD
09A8 85473A     960       mov x, current_temp
09AB 85483B     961       mov x+1, current_temp+1
09AE 85493C     962       mov x+2, current_temp+2
09B1 854A3D     963       mov x+3, current_temp+3
09B4 12002E     964       lcall hex2bcd
09B7            965   
09B7            966       ; Update HEX2-HEX0 with temperature
09B7 120B3C     967       lcall Update_HEX_Temp
09BA            968       
09BA            969       ; Print Hundreds
09BA E543       970       mov a, bcd+1
09BC 540F       971       anl a, #0x0F
09BE 2430       972       add a, #0x30
09C0 12076F     973       lcall ?WriteData
09C3            974       
09C3            975       ; Print Tens
09C3 E542       976       mov a, bcd+0
09C5 C4         977       swap a
09C6 540F       978       anl a, #0x0F
09C8 2430       979       add a, #0x30
09CA 12076F     980       lcall ?WriteData
09CD            981       
09CD            982       ; Print Ones
09CD E542       983       mov a, bcd+0
09CF 540F       984       anl a, #0x0F
09D1 2430       985       add a, #0x30
09D3 12076F     986       lcall ?WriteData
09D6            987       
09D6            988       ; Print 'C'
09D6 7443       989       mov a, #'C'
09D8 12076F     990       lcall ?WriteData
09DB            991       
09DB            992       ; Clear remaining line space (prevents garbage)
09DB 7420       993       mov a, #' '
09DD 12076F     994       lcall ?WriteData
09E0 12076F     995       lcall ?WriteData
09E3            996   
09E3            997       ; Print time MM:SS at bottom right
09E3 C0E0       998            push acc
09E5 740C       998            mov a, #12
09E7 14         998            dec a
09E8 1207B7     998            lcall ?Set_Cursor_2 ; Select column and row
09EB D0E0       998            pop acc
09ED E531       999       mov a, current_time_minute
09EF 120829    1000       lcall LCD_Print_2Digits
09F2 743A      1001       mov a, #':'
09F4 12076F    1002       lcall ?WriteData
09F7 E530      1003       mov a, current_time_sec
09F9 120829    1004       lcall LCD_Print_2Digits
09FC           1005   
09FC           1006       ; Mirror temp to serial (PuTTY/screen)
09FC 120653    1007       lcall Serial_Send_Temp_Line
09FF           1008   
09FF           1009   LCD_Done:
09FF D0E0      1010       pop acc
0A01 22        1011       ret
0A02           1012   
0A02           1013   ; ----------------------------------------------------------------
0A02           1014   ; MODULE: SCREEN UPDATE (Visual Logic)
0A02           1015   ; ----------------------------------------------------------------
0A02           1016   Update_Screen_Full:
0A02 E560      1017            mov a, Control_FSM_state
0A04 B40102    1018            cjne a, #1, Update_Screen_Full_ret
0A07 8001      1019            sjmp Update_Screen_Full_do
0A09           1020   Update_Screen_Full_ret:
0A09 22        1021            ret
0A0A           1022   Update_Screen_Full_do:
0A0A 3024FC    1023       jnb fullscreen_update_signal, Update_Screen_Full_ret
0A0D C224      1024       clr fullscreen_update_signal
0A0F           1025   
0A0F 120B11    1026       lcall Clear_Screen_Func
0A12 C0E0      1027            push acc
0A14 7401      1027            mov a, #1
0A16 14        1027            dec a
0A17 1207B9    1027            lcall ?Set_Cursor_1 ; Select column and row
0A1A D0E0      1027            pop acc
0A1C           1028       ; --- Draw Line 1 (Titles) ---
0A1C E561      1029       mov A, Current_State
0A1E B40013    1030       cjne A, #0, Update_State_1
0A21 C083      1031            push dph
0A23 C082      1031            push dpl
0A25 C0E0      1031            push acc
0A27 900350    1031            mov dptr, #Txt_Home
0A2A 1207AC    1031            lcall ?Send_Constant_String
0A2D D0E0      1031            pop acc
0A2F D082      1031            pop dpl
0A31 D083      1031            pop dph
0A33 22        1032       ret 
0A34           1033   Update_State_1:
0A34 B40114    1034       cjne A, #1, Update_State_2
0A37 C083      1035            push dph
0A39 C082      1035            push dpl
0A3B C0E0      1035            push acc
0A3D 900361    1035            mov dptr, #Txt_SoakT
0A40 1207AC    1035            lcall ?Send_Constant_String
0A43 D0E0      1035            pop acc
0A45 D082      1035            pop dpl
0A47 D083      1035            pop dph
0A49 8042      1036       sjmp Draw_Temp_Format
0A4B           1037   Update_State_2:
0A4B B40214    1038       cjne A, #2, Update_State_3
0A4E C083      1039            push dph
0A50 C082      1039            push dpl
0A52 C0E0      1039            push acc
0A54 900372    1039            mov dptr, #Txt_SoakTime
0A57 1207AC    1039            lcall ?Send_Constant_String
0A5A D0E0      1039            pop acc
0A5C D082      1039            pop dpl
0A5E D083      1039            pop dph
0A60 8046      1040       sjmp Draw_Time_Format
0A62           1041   Update_State_3:
0A62 B40314    1042       cjne A, #3, Update_State_4
0A65 C083      1043            push dph
0A67 C082      1043            push dpl
0A69 C0E0      1043            push acc
0A6B 900383    1043            mov dptr, #Txt_ReflT
0A6E 1207AC    1043            lcall ?Send_Constant_String
0A71 D0E0      1043            pop acc
0A73 D082      1043            pop dpl
0A75 D083      1043            pop dph
0A77 8014      1044       sjmp Draw_Temp_Format
0A79           1045   Update_State_4:
0A79 C083      1046            push dph
0A7B C082      1046            push dpl
0A7D C0E0      1046            push acc
0A7F 900394    1046            mov dptr, #Txt_ReflTime
0A82 1207AC    1046            lcall ?Send_Constant_String
0A85 D0E0      1046            pop acc
0A87 D082      1046            pop dpl
0A89 D083      1046            pop dph
0A8B 801B      1047       sjmp Draw_Time_Format
0A8D           1048   
0A8D           1049   ; --- Draw Line 2 (Values) ---
0A8D           1050   Draw_Temp_Format:
0A8D C0E0      1051            push acc
0A8F 7401      1051            mov a, #1
0A91 14        1051            dec a
0A92 1207B7    1051            lcall ?Set_Cursor_2 ; Select column and row
0A95 D0E0      1051            pop acc
0A97 120B25    1052       lcall Get_Current_Buffer_Addr
0A9A 120B07    1053       lcall Print_String_RAM
0A9D C0E0      1054            push acc
0A9F 7443      1054            mov a, #'C'
0AA1 12076F    1054            lcall ?WriteData
0AA4 D0E0      1054            pop acc
0AA6 8034      1055       sjmp Restore_Cursor
0AA8           1056   
0AA8           1057   Draw_Time_Format:
0AA8 C0E0      1058            push acc
0AAA 7401      1058            mov a, #1
0AAC 14        1058            dec a
0AAD 1207B7    1058            lcall ?Set_Cursor_2 ; Select column and row
0AB0 D0E0      1058            pop acc
0AB2 120B25    1059       lcall Get_Current_Buffer_Addr
0AB5           1060       ; MM
0AB5 E6        1061       mov A, @R0
0AB6 12076F    1062       lcall ?WriteData
0AB9 08        1063       inc R0
0ABA E6        1064       mov A, @R0
0ABB 12076F    1065       lcall ?WriteData
0ABE 08        1066       inc R0
0ABF           1067       ; Colon
0ABF C0E0      1068            push acc
0AC1 743A      1068            mov a, #':'
0AC3 12076F    1068            lcall ?WriteData
0AC6 D0E0      1068            pop acc
0AC8           1069       ; SS
0AC8 E6        1070       mov A, @R0
0AC9 12076F    1071       lcall ?WriteData
0ACC 08        1072       inc R0
0ACD E6        1073       mov A, @R0
0ACE 12076F    1074       lcall ?WriteData
0AD1           1075       ; Unit
0AD1 C0E0      1076            push acc
0AD3 7473      1076            mov a, #'s'
0AD5 12076F    1076            lcall ?WriteData
0AD8 D0E0      1076            pop acc
0ADA 8000      1077       sjmp Restore_Cursor
0ADC           1078   
0ADC           1079   ; --- Restore Cursor Position ---
0ADC           1080   Restore_Cursor:
0ADC E561      1081       mov A, Current_State
0ADE B40202    1082       cjne A, #2, RC_Check_State_4  
0AE1 800C      1083       sjmp Adjust_Cursor_Time
0AE3           1084   RC_Check_State_4:             
0AE3 B40402    1085       cjne A, #4, Normal_Cursor
0AE6 8007      1086       sjmp Adjust_Cursor_Time
0AE8           1087   
0AE8           1088   Normal_Cursor:
0AE8 E56A      1089       mov A, Cursor_Idx
0AEA 24C0      1090       add A, #0xC0
0AEC 120774    1091       lcall ?WriteCommand
0AEF           1092   
0AEF           1093   Adjust_Cursor_Time:
0AEF           1094       ; Skip the colon index (2)
0AEF E56A      1095       mov A, Cursor_Idx
0AF1 B40201    1096       cjne A, #2, No_Skip
0AF4 04        1097       inc A 
0AF5           1098   No_Skip:
0AF5           1099       ; Add 1 if past the colon
0AF5 C3        1100       clr C
0AF6 9402      1101       subb A, #2
0AF8 4005      1102       jc No_Add
0AFA E56A      1103       mov A, Cursor_Idx
0AFC 04        1104       inc A
0AFD 8002      1105       sjmp Final_Cursor_Set
0AFF           1106   No_Add:
0AFF E56A      1107       mov A, Cursor_Idx
0B01           1108   Final_Cursor_Set:
0B01 24C0      1109       add A, #0xC0
0B03 120774    1110       lcall ?WriteCommand
0B06 22        1111       ret
0B07           1112   
0B07           1113   Print_String_RAM:
0B07 E6        1114       mov A, @R0
0B08 6006      1115       jz Print_String_Done
0B0A 12076F    1116       lcall ?WriteData
0B0D 08        1117       inc R0
0B0E 80F7      1118       sjmp Print_String_RAM
0B10           1119   Print_String_Done:
0B10 22        1120       ret
0B11           1121   
0B11           1122   ; --- Clear Screen with hardware delay ---
0B11           1123   Clear_Screen_Func:
0B11 7401      1124            mov a, #0x01
0B13 120774    1124            lcall ?WriteCommand        ; Clear display command
0B16 C002      1125            push AR2
0B18 7A02      1125            mov R2, #2
0B1A 12072A    1125            lcall ?Wait_Milli_Seconds
0B1D D002      1125            pop AR2     ; LCD needs ~2ms to clear
0B1F 740C      1126            mov a, #0x0C
0B21 120774    1126            lcall ?WriteCommand        ; Display ON, Cursor OFF
0B24 22        1127       ret
0B25           1128   
0B25           1129   Get_Current_Buffer_Addr:
0B25 E561      1130       mov A, Current_State
0B27 B40103    1131       cjne A, #1, Get_Buf_2
0B2A 7880      1132       mov R0, #Buf_Soak_Temp
0B2C 22        1133       ret
0B2D           1134   Get_Buf_2:
0B2D B40203    1135       cjne A, #2, Get_Buf_3
0B30 7884      1136       mov R0, #Buf_Soak_Time
0B32 22        1137       ret
0B33           1138   Get_Buf_3:
0B33 B40303    1139       cjne A, #3, Get_Buf_4
0B36 7889      1140       mov R0, #Buf_Refl_Temp
0B38 22        1141       ret
0B39           1142   Get_Buf_4:
0B39 788D      1143       mov R0, #Buf_Refl_Time
0B3B 22        1144       ret
0B3C           1145   
0B3C           1146   ;-------------------------------------------------------------------------------
0B3C           1147   ; Update HEX2-HEX0 with temperature (3 digits)
0B3C           1148   ;-------------------------------------------------------------------------------
0B3C           1149   Update_HEX_Temp:
0B3C 9007D4    1150       mov dptr, #T_7seg
0B3F           1151       ; Hundreds -> HEX2
0B3F E543      1152       mov a, bcd+1
0B41 540F      1153       anl a, #0x0F
0B43 93        1154       movc a, @a+dptr
0B44 F593      1155       mov HEX2, a
0B46           1156       ; Tens -> HEX1
0B46 E542      1157       mov a, bcd+0
0B48 C4        1158       swap a
0B49 540F      1159       anl a, #0x0F
0B4B 93        1160       movc a, @a+dptr
0B4C F592      1161       mov HEX1, a
0B4E           1162       ; Ones -> HEX0
0B4E E542      1163       mov a, bcd+0
0B50 540F      1164       anl a, #0x0F
0B52 93        1165       movc a, @a+dptr
0B53 F591      1166       mov HEX0, a
0B55 22        1167       ret
0B56           1168       
0B56           1169   ;---------------------------------------------------------
0B56           1170   PB0_DEB:
0B56           1171   ;non-blocking state machine for PB0 debounce
0B56 E572      1172       mov a, PB0_DEB_state
0B58           1173   PB0_DEB_state0:
0B58 B4000A    1174       cjne a, #0, PB0_DEB_state1
0B5B 20902F    1175       jb PB0, PB0_DEB_done
0B5E 757100    1176       mov PB0_DEB_timer, #0
0B61 0572      1177       inc PB0_DEB_state
0B63 8028      1178       sjmp PB0_DEB_done
0B65           1179   PB0_DEB_state1:
0B65 B40109    1180       cjne a, #1, PB0_DEB_state2
0B68           1181       ; this is the debounce state
0B68 E571      1182       mov a, PB0_DEB_timer
0B6A B43220    1183       cjne a, #50, PB0_DEB_done ; 50 ms passed?
0B6D 0572      1184       inc PB0_DEB_state
0B6F 801C      1185       sjmp PB0_DEB_done  
0B71           1186   PB0_DEB_state2:
0B71 B4020C    1187       cjne a, #2, PB0_DEB_state3
0B74 209004    1188       jb PB0, PB0_DEB_state2b
0B77 0572      1189       inc PB0_DEB_state
0B79 8012      1190       sjmp PB0_DEB_done  
0B7B           1191   PB0_DEB_state2b:
0B7B 757200    1192       mov PB0_DEB_state, #0
0B7E 800D      1193       sjmp PB0_DEB_done
0B80           1194   PB0_DEB_state3:
0B80 B4030A    1195       cjne a, #3, PB0_DEB_done
0B83 309007    1196       jnb PB0, PB0_DEB_done
0B86 D215      1197       setb PB0_flag ; Suscesfully detected a valid PB0 press/release
0B88 B2ED      1198            cpl LEDRA.5
0B8A 757200    1199       mov PB0_DEB_state, #0  
0B8D           1200   PB0_DEB_done:
0B8D 22        1201       ret
0B8E           1202   
0B8E           1203   PB2_DEB:
0B8E           1204   ;non-blocking state machine for PB2 debounce
0B8E E574      1205       mov a, PB2_DEB_state
0B90           1206   PB2_DEB_state0:
0B90 B4000A    1207       cjne a, #0, PB2_DEB_state1
0B93 20B72D    1208       jb PB2, PB2_DEB_done
0B96 757300    1209       mov PB2_DEB_timer, #0
0B99 0574      1210       inc PB2_DEB_state
0B9B 8026      1211       sjmp PB2_DEB_done
0B9D           1212   PB2_DEB_state1:
0B9D B40109    1213       cjne a, #1, PB2_DEB_state2
0BA0           1214       ; this is the debounce state
0BA0 E573      1215       mov a, PB2_DEB_timer
0BA2 B4321E    1216       cjne a, #50, PB2_DEB_done ; 50 ms passed?
0BA5 0574      1217       inc PB2_DEB_state
0BA7 801A      1218       sjmp PB2_DEB_done  
0BA9           1219   PB2_DEB_state2:
0BA9 B4020C    1220       cjne a, #2, PB2_DEB_state3
0BAC 20B704    1221       jb PB2, PB2_DEB_state2b
0BAF 0574      1222       inc PB2_DEB_state
0BB1 8010      1223       sjmp PB2_DEB_done  
0BB3           1224   PB2_DEB_state2b:
0BB3 757400    1225       mov PB2_DEB_state, #0
0BB6 800B      1226       sjmp PB2_DEB_done
0BB8           1227   PB2_DEB_state3:
0BB8 B40308    1228       cjne a, #3, PB2_DEB_done
0BBB 30B705    1229       jnb PB2, PB2_DEB_done
0BBE D217      1230       setb PB2_flag ; Suscesfully detected a valid PB2 press/release
0BC0 757400    1231       mov PB2_DEB_state, #0  
0BC3           1232   PB2_DEB_done:
0BC3 22        1233       ret
0BC4           1234   
0BC4           1235   ; ------------------------------------------------------------------------------
0BC4           1236   ; Non-blocking FSM for the one second counter
0BC4           1237   ;-------------------------------------------------------------------------------
0BC4           1238   SEC_FSM:
0BC4 E570      1239       mov a, SEC_FSM_state
0BC6           1240   SEC_FSM_state0:
0BC6 B4000C    1241       cjne a, #0, SEC_FSM_state1
0BC9 E56F      1242       mov a, SEC_FSM_timer
0BCB B4FA51    1243       cjne a, #250, SEC_FSM_done
0BCE 756F00    1244       mov SEC_FSM_timer, #0
0BD1 0570      1245       inc SEC_FSM_state
0BD3 804A      1246       sjmp SEC_FSM_done
0BD5           1247   SEC_FSM_state1:  
0BD5 B4010E    1248       cjne a, #1, SEC_FSM_state2
0BD8 D2E9      1249       setb LEDRA.1
0BDA E56F      1250       mov a, SEC_FSM_timer
0BDC B4FA40    1251       cjne a, #250, SEC_FSM_done
0BDF 756F00    1252       mov SEC_FSM_timer, #0
0BE2 0570      1253       inc SEC_FSM_state
0BE4 8039      1254       sjmp SEC_FSM_done
0BE6           1255   SEC_FSM_state2:  
0BE6 B4020E    1256       cjne a, #2, SEC_FSM_state3
0BE9 D2EA      1257       setb LEDRA.2
0BEB E56F      1258       mov a, SEC_FSM_timer
0BED B4FA2F    1259       cjne a, #250, SEC_FSM_done
0BF0 756F00    1260       mov SEC_FSM_timer, #0
0BF3 0570      1261       inc SEC_FSM_state
0BF5 8028      1262       sjmp SEC_FSM_done
0BF7           1263   SEC_FSM_state3:  
0BF7 B40325    1264       cjne a, #3, SEC_FSM_done
0BFA D2EB      1265       setb LEDRA.3
0BFC E56F      1266       mov a, SEC_FSM_timer
0BFE B4FA1E    1267       cjne a, #250, SEC_FSM_done
0C01 756F00    1268       mov SEC_FSM_timer, #0
0C04 757000    1269       mov SEC_FSM_state, #0
0C07           1270       
0C07           1271       ; These flags are always set (global use)
0C07 D204      1272       setb one_second_lcd_flag
0C09 D201      1273       setb one_second_flag
0C0B           1274       
0C0B           1275       ; Heartbeat LED always toggles
0C0B B2E8      1276       cpl LEDRA.0
0C0D           1277       
0C0D           1278       ; Only update time if counting is enabled
0C0D 300D0F    1279       jnb time_count_doing_signal, SEC_FSM_done
0C10           1280       
0C10           1281       ; Update current time (only when counting)
0C10 E530      1282       mov a, current_time_sec
0C12 04        1283       inc a
0C13 B43C07    1284       cjne a, #60, SEC_NoMinuteCarry
0C16 753000    1285       mov current_time_sec, #0
0C19 0531      1286       inc current_time_minute
0C1B 8002      1287       sjmp SEC_FSM_done
0C1D           1288   SEC_NoMinuteCarry:
0C1D F530      1289       mov current_time_sec, a
0C1F           1290   SEC_FSM_done:
0C1F 22        1291       ret
0C20           1292   
0C20           1293   ; ------------------------------------------------------------------------------
0C20           1294   ; Counting the processing time 
0C20           1295   ;-------------------------------------------------------------------------------
0C20           1296   Time_Counter:
0C20 C0E0      1297       push ACC
0C22 C0D0      1298       push psw
0C24 E560      1299       mov a, Control_FSM_state
0C26           1300       
0C26           1301       ; State 2: Start counting
0C26 B4020F    1302       cjne a, #2, Time_Counter_Nstate2
0C29 101102    1303       jbc state_change_signal_Count, Time_Counter_Start
0C2C 800F      1304       sjmp Time_Counter_Done
0C2E           1305   
0C2E           1306   Time_Counter_Start:
0C2E 753000    1307       mov current_time_sec, #0
0C31 753100    1308       mov current_time_minute, #0
0C34 D20D      1309       setb time_count_doing_signal
0C36 8005      1310       sjmp Time_Counter_Done
0C38           1311   
0C38           1312   Time_Counter_Nstate2:
0C38           1313       ; State 6: Stop counting
0C38 B40602    1314       cjne a, #6, Time_Counter_Done
0C3B C20D      1315       clr time_count_doing_signal
0C3D           1316   
0C3D           1317   Time_Counter_Done:
0C3D D0D0      1318       pop psw
0C3F D0E0      1319       pop ACC
0C41 22        1320       ret
0C42           1321   
0C42           1322   
0C42           1323   ;-------------------------------------------------------------------------------
0C42           1324   ; Time_Compare_MMSS
0C42           1325   ;
0C42           1326   ; PURPOSE:
0C42           1327   ;   Compare elapsed time (current_time_minute:current_time_sec)
0C42           1328   ;   against soak and reflow setpoints (soak_time_*, reflow_time_*).
0C42           1329   ;
0C42           1330   ; BEHAVIOR:
0C42           1331   ;   - If current_time >= soak_end_time   then soak_time_reached = 1
0C42           1332   ;   - If current_time >= reflow_end_time then reflow_time_reached = 1
0C42           1333   ;
0C42           1334   ; NOTES:
0C42           1335   ;   Compare minutes first, then seconds.
0C42           1336   ;-------------------------------------------------------------------------------
0C42           1337   Time_Compare_MMSS:
0C42 C0E0      1338       push acc
0C44 C0D0      1339       push psw
0C46           1340   
0C46 E560      1341       mov a, Control_FSM_state
0C48 B4032E    1342       cjne a, #3, TC_Not_Soak
0C4B           1343   
0C4B           1344   ; ============================================================
0C4B           1345   ; STATE 3: SOAK TIME COMPARISON
0C4B           1346   ; ============================================================
0C4B 101002    1347       jbc state_change_signal_TC, TC_Soak_Start_Record
0C4E 8015      1348       sjmp TC_Soak_Comparing
0C50           1349   
0C50           1350   TC_Soak_Start_Record:
0C50           1351       ; Calculate end time = current_time + soak_time
0C50 E531      1352       mov a, current_time_minute
0C52 2533      1353       add a, soak_time_minute
0C54 F537      1354       mov soak_end_time_minute, a
0C56           1355   
0C56 E530      1356       mov a, current_time_sec
0C58 2532      1357       add a, soak_time_sec
0C5A F536      1358       mov soak_end_time_sec, a
0C5C           1359   
0C5C           1360       ; Check for seconds overflow (>= 60)
0C5C C3        1361       clr c
0C5D 943C      1362       subb a, #60
0C5F 4004      1363       jc TC_Soak_Comparing           ; No overflow, skip adjustment
0C61           1364   
0C61           1365       ; Overflow: adjust seconds and add 1 to minutes
0C61 F536      1366       mov soak_end_time_sec, a
0C63 0537      1367       inc soak_end_time_minute
0C65           1368   
0C65           1369   TC_Soak_Comparing:
0C65           1370       ; Compare minutes first
0C65 E531      1371       mov  a, current_time_minute
0C67 C3        1372       clr  c
0C68 9537      1373       subb a, soak_end_time_minute
0C6A 403E      1374       jc   TC_Done                   ; current_min < end_min -> not reached
0C6C 7007      1375       jnz  TC_Soak_Reached           ; current_min > end_min -> reached
0C6E           1376   
0C6E           1377       ; Minutes equal -> compare seconds
0C6E E530      1378       mov  a, current_time_sec
0C70 C3        1379       clr  c
0C71 9536      1380       subb a, soak_end_time_sec
0C73 4035      1381       jc   TC_Done                   ; current_sec < end_sec -> not reached
0C75           1382                                      ; current_sec >= end_sec -> fall through to reached
0C75           1383   
0C75           1384   TC_Soak_Reached:
0C75 D208      1385       setb soak_time_reached
0C77 8031      1386       sjmp TC_Done
0C79           1387   
0C79           1388   ; ============================================================
0C79           1389   ; STATE 5: REFLOW TIME COMPARISON
0C79           1390   ; ============================================================
0C79           1391   TC_Not_Soak:
0C79 E560      1392       mov a, Control_FSM_state
0C7B B4052C    1393       cjne a, #5, TC_Done
0C7E           1394   
0C7E 101002    1395       jbc state_change_signal_TC, TC_Reflow_Start_Record
0C81 8015      1396       sjmp TC_Reflow_Comparing
0C83           1397   
0C83           1398   TC_Reflow_Start_Record:
0C83           1399       ; Calculate end time = current_time + reflow_time
0C83 E531      1400       mov a, current_time_minute
0C85 2535      1401       add a, reflow_time_minute
0C87 F539      1402       mov reflow_end_time_minute, a
0C89           1403   
0C89 E530      1404       mov a, current_time_sec
0C8B 2534      1405       add a, reflow_time_sec
0C8D F538      1406       mov reflow_end_time_sec, a
0C8F           1407   
0C8F           1408       ; Check for seconds overflow (>= 60)
0C8F C3        1409       clr c
0C90 943C      1410       subb a, #60
0C92 4004      1411       jc TC_Reflow_Comparing         ; No overflow, skip adjustment
0C94           1412   
0C94           1413       ; Overflow: adjust seconds and add 1 to minutes
0C94 F538      1414       mov reflow_end_time_sec, a
0C96 0539      1415       inc reflow_end_time_minute
0C98           1416   
0C98           1417   TC_Reflow_Comparing:
0C98           1418       ; Compare minutes first
0C98 E531      1419       mov  a, current_time_minute
0C9A C3        1420       clr  c
0C9B 9539      1421       subb a, reflow_end_time_minute
0C9D 400B      1422       jc   TC_Done                   ; current_min < end_min -> not reached
0C9F 7007      1423       jnz  TC_Reflow_Reached         ; current_min > end_min -> reached
0CA1           1424   
0CA1           1425       ; Minutes equal -> compare seconds
0CA1 E530      1426       mov  a, current_time_sec
0CA3 C3        1427       clr  c
0CA4 9538      1428       subb a, reflow_end_time_sec
0CA6 4002      1429       jc   TC_Done                   ; current_sec < end_sec -> not reached
0CA8           1430                                      ; current_sec >= end_sec -> fall through to reached
0CA8           1431   
0CA8           1432   TC_Reflow_Reached:
0CA8 D209      1433       setb reflow_time_reached
0CAA           1434   
0CAA           1435   TC_Done:
0CAA D0D0      1436       pop  psw
0CAC D0E0      1437       pop  acc
0CAE 22        1438       ret
0CAF           1439   
0CAF           1440   ;-------------------------------------------------------------------------------;
0CAF           1441   ; Temp_Compare
0CAF           1442   ; Checks if we have reached the user's target temperatures.
0CAF           1443   ; Only compares relevant temperature based on current Control_FSM_state:
0CAF           1444   ;   State 2: Sets 'soak_temp_reached' if current_temp >= soak_temp
0CAF           1445   ;   State 4: Sets 'reflow_temp_reached' if current_temp >= reflow_temp
0CAF           1446   ;   State 6: Sets 'cooling_temp_reached' if current_temp < 100C
0CAF           1447   ;-------------------------------------------------------------------------------;
0CAF           1448   Temp_Compare:
0CAF C0E0      1449       push acc
0CB1 C0D0      1450       push psw
0CB3 C000      1451       push AR0
0CB5 C001      1452       push AR1
0CB7 C002      1453       push AR2
0CB9           1454       
0CB9 E560      1455       mov a, Control_FSM_state
0CBB           1456       
0CBB           1457       ; --- CHECK STATE 2: SOAK TEMP ---
0CBB B40202    1458       cjne a, #2, Temp_Compare_Check_State4
0CBE 800A      1459       sjmp Check_Soak_Threshold
0CC0           1460       
0CC0           1461   Temp_Compare_Check_State4:
0CC0           1462       ; --- CHECK STATE 4: REFLOW TEMP ---
0CC0 B40402    1463       cjne a, #4, Temp_Compare_Check_State6
0CC3 801D      1464       sjmp Check_Reflow_Threshold
0CC5           1465       
0CC5           1466   Temp_Compare_Check_State6:
0CC5           1467       ; --- CHECK STATE 6: COOLING TEMP ---
0CC5 B4064D    1468       cjne a, #6, Temp_Compare_Done
0CC8 8030      1469       sjmp Check_Cooling_Threshold
0CCA           1470   
0CCA           1471   Check_Soak_Threshold:
0CCA           1472       ; Copy current_temp to X
0CCA 7847      1473       mov R0, #current_temp
0CCC 793A      1474       mov R1, #x
0CCE 120D20    1475       lcall Copy4_Bytes_R0_to_R1
0CD1           1476   
0CD1           1477       ; Copy soak_temp to Y
0CD1 784B      1478       mov R0, #soak_temp
0CD3 793E      1479       mov R1, #y
0CD5 120D20    1480       lcall Copy4_Bytes_R0_to_R1
0CD8           1481   
0CD8           1482       ; Compare: Is X (Current) < Y (Target)?
0CD8 12011A    1483       lcall x_lt_y
0CDB 200037    1484       jb mf, Temp_Compare_Done          ; If Current < Target, not reached yet
0CDE           1485       
0CDE           1486       ; If Current >= Target
0CDE D205      1487       setb soak_temp_reached
0CE0 8033      1488       sjmp Temp_Compare_Done
0CE2           1489   
0CE2           1490   Check_Reflow_Threshold:
0CE2           1491       ; Copy current_temp to X
0CE2 7847      1492       mov R0, #current_temp
0CE4 793A      1493       mov R1, #x
0CE6 120D20    1494       lcall Copy4_Bytes_R0_to_R1
0CE9           1495   
0CE9           1496       ; Copy reflow_temp to Y
0CE9 784F      1497       mov R0, #reflow_temp
0CEB 793E      1498       mov R1, #y
0CED 120D20    1499       lcall Copy4_Bytes_R0_to_R1
0CF0           1500   
0CF0           1501       ; Compare
0CF0 12011A    1502       lcall x_lt_y
0CF3 20001F    1503       jb mf, Temp_Compare_Done          ; If Current < Target, not reached yet
0CF6           1504       
0CF6           1505       ; If Current >= Target
0CF6 D206      1506       setb reflow_temp_reached
0CF8 801B      1507       sjmp Temp_Compare_Done
0CFA           1508   
0CFA           1509   Check_Cooling_Threshold:
0CFA           1510       ; Copy current_temp to X
0CFA 7847      1511       mov R0, #current_temp
0CFC 793A      1512       mov R1, #x
0CFE 120D20    1513       lcall Copy4_Bytes_R0_to_R1
0D01           1514       
0D01 753E64    1515            mov y+0, #low (100 % 0x10000) 
0D04 753F00    1515            mov y+1, #high(100 % 0x10000) 
0D07 754000    1515            mov y+2, #low (100 / 0x10000) 
0D0A 754100    1515            mov y+3, #high(100 / 0x10000)                         ; Cooling target = 100C
0D0D 12011A    1516       lcall x_lt_y
0D10 300002    1517       jnb mf, Temp_Compare_Done         ; If temp >= 100, not cooled yet
0D13           1518       
0D13           1519       ; If Current < 100C
0D13 D207      1520       setb cooling_temp_reached
0D15           1521   
0D15           1522   ; ---------------------------------------------------------
0D15           1523   Temp_Compare_Done:
0D15 D002      1524       pop AR2
0D17 D001      1525       pop AR1
0D19 D000      1526       pop AR0
0D1B D0D0      1527       pop psw
0D1D D0E0      1528       pop acc
0D1F 22        1529       ret
0D20           1530   
0D20           1531   ;-------------------------------------------------------------------------------;
0D20           1532   ; Copy4_Bytes_R0_to_R1
0D20           1533   ;
0D20           1534   ; PURPOSE:
0D20           1535   ;   Utility routine to copy a 32-bit value (4 bytes)
0D20           1536   ;   from one memory location to another.
0D20           1537   ;
0D20           1538   ; INPUTS:
0D20           1539   ;   R0 st source address
0D20           1540   ;   R1 at destination address
0D20           1541   ;
0D20           1542   ; USES:
0D20           1543   ;   R2 as loop counter
0D20           1544   ;
0D20           1545   ; EXAMPLE:
0D20           1546   ;   mov R0, #current_temp
0D20           1547   ;   mov R1, #x
0D20           1548   ;   lcall Copy4_Bytes_R0_to_R1
0D20           1549   ;-------------------------------------------------------------------------------;
0D20           1550   Copy4_Bytes_R0_to_R1:
0D20 7A04      1551       mov  R2, #4
0D22           1552   Copy4_Loop:
0D22 E6        1553       mov  a, @R0
0D23 F7        1554       mov  @R1, a
0D24 08        1555       inc  R0
0D25 09        1556       inc  R1
0D26 DAFA      1557       djnz R2, Copy4_Loop
0D28 22        1558       ret
0D29           1559   
0D29           1560   ;-------------------------------------------------------------------------------
0D29           1561   ; PWM
0D29           1562   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0D29           1563   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0D29           1564   ; ------------------------------------------------------------------------------
0D29           1565   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0D29 100202    1566       jbc one_ms_pwm_flag, pwm_wave_generator
0D2C 8071      1567       sjmp end_pwm_generator
0D2E           1568   
0D2E           1569   pwm_wave_generator:
0D2E C200      1570       clr mf
0D30           1571       ; move pwm counter value into x for comparison purpose
0D30 855C3A    1572       mov x, pwm_counter
0D33 855D3B    1573       mov x+1, pwm_counter+1
0D36 855E3C    1574       mov x+2, pwm_counter+2
0D39 855F3D    1575       mov x+3, pwm_counter+3
0D3C           1576   
0D3C 753EDB    1577            mov y+0, #low (PWM_PERIOD % 0x10000) 
0D3F 753F05    1577            mov y+1, #high(PWM_PERIOD % 0x10000) 
0D42 754000    1577            mov y+2, #low (PWM_PERIOD / 0x10000) 
0D45 754100    1577            mov y+3, #high(PWM_PERIOD / 0x10000) 
0D48           1578   
0D48           1579       ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
0D48           1580       ; increase x by 1
0D48 120152    1581       lcall x_eq_y 
0D4B 20001D    1582       jb mf, wrap_pwm_counter
0D4E           1583       ; x not equal 1499, increment by 1
0D4E 753E01    1584            mov y+0, #low (1 % 0x10000) 
0D51 753F00    1584            mov y+1, #high(1 % 0x10000) 
0D54 754000    1584            mov y+2, #low (1 / 0x10000) 
0D57 754100    1584            mov y+3, #high(1 / 0x10000) 
0D5A 1200D3    1585       lcall add32
0D5D           1586       ; update pwm_counter
0D5D 853A5C    1587       mov pwm_counter, x
0D60 853B5D    1588       mov pwm_counter+1, x+1
0D63 853C5E    1589       mov pwm_counter+2, x+2
0D66 853D5F    1590       mov pwm_counter+3, x+3
0D69 8018      1591       sjmp set_pwm
0D6B           1592   
0D6B           1593   wrap_pwm_counter:
0D6B           1594       ; x equal 1499, wrap to 0
0D6B 753A00    1595            mov x+0, #low (0 % 0x10000) 
0D6E 753B00    1595            mov x+1, #high(0 % 0x10000) 
0D71 753C00    1595            mov x+2, #low (0 / 0x10000) 
0D74 753D00    1595            mov x+3, #high(0 / 0x10000) 
0D77 853A5C    1596       mov pwm_counter, x
0D7A 853B5D    1597       mov pwm_counter+1, x+1
0D7D 853C5E    1598       mov pwm_counter+2, x+2
0D80 853D5F    1599       mov pwm_counter+3, x+3
0D83           1600   
0D83           1601   set_pwm:
0D83           1602       ; compare with power_output, if pwm counter smaller than power_output, 
0D83           1603       ; set pwm pin high; else set pwm pin low load y with power output value
0D83 85583E    1604       mov y, power_output
0D86 85593F    1605       mov y+1, power_output+1
0D89 855A40    1606       mov y+2, power_output+2
0D8C 855B41    1607       mov y+3, power_output+3
0D8F           1608   
0D8F           1609       ; compare x(pwm counter) with y(power output)
0D8F 12011A    1610       lcall x_lt_y
0D92 200006    1611       jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
0D95           1612       ;output set pwm pin low if pwm counter greater than power output
0D95 C293      1613       clr PWM_OUT
0D97 C2EC      1614       clr LEDRA.4
0D99 8004      1615       sjmp end_pwm_generator
0D9B           1616   
0D9B           1617   set_pwm_high:
0D9B D293      1618       setb PWM_OUT
0D9D D2EC      1619       setb LEDRA.4
0D9F           1620   
0D9F           1621   end_pwm_generator:
0D9F 22        1622       ret
0DA0           1623   
0DA0           1624   ;-------------------------------------------------------------------------------
0DA0           1625   
0DA0           1626   ;-------------------------------------------------------------------------------;
0DA0           1627   ; Abort condition safety check Temperature time
0DA0           1628   ;
0DA0           1629   ; PURPOSE:
0DA0           1630   ;   Automatic cycle termination on error:
0DA0           1631   ;   Abort if oven fails to reach at least 50C in first 60s (1 minute).
0DA0           1632   ;
0DA0           1633   ; TRIP CONDITION:
0DA0           1634   ;   if (current_time_minute >= 1) AND (current_temp < 50C)
0DA0           1635   ;       -> set tc_missing_abort
0DA0           1636   ;       -> set stop_signal
0DA0           1637   ;
0DA0           1638   ; ASSUMPTIONS:
0DA0           1639   ;   - current_time_sec (byte): seconds 0-59
0DA0           1640   ;   - current_time_minute (byte): minutes counter
0DA0           1641   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
0DA0           1642   ;-------------------------------------------------------------------------------;
0DA0           1643   Safety_Check_TC:
0DA0 C0E0      1644       push acc
0DA2 C0D0      1645       push psw
0DA4 C000      1646       push AR0
0DA6 C001      1647       push AR1
0DA8           1648   
0DA8           1649       ; ---------------------------------------------------------
0DA8           1650       ; GATEKEEPER: IGNORE UNLESS IN STATE 2 (RAMP TO SOAK)
0DA8           1651       ; ---------------------------------------------------------
0DA8 E560      1652       mov a, Control_FSM_state
0DAA B40202    1653       cjne a, #2, Safety_TC_Exit_Bridge ; If State != 2, skip everything
0DAD 8003      1654       sjmp Safety_Logic_Proceed         ; If State == 2, do the check
0DAF           1655   
0DAF           1656   Safety_TC_Exit_Bridge:
0DAF 020DE8    1657       ljmp Safety_TC_Done               ; Jump to the end
0DB2           1658   
0DB2           1659   Safety_Logic_Proceed:
0DB2           1660       ; If already aborted or startup window closed, do nothing
0DB2 201333    1661       jb   tc_missing_abort, Safety_TC_Done
0DB5 301430    1662       jnb  tc_startup_window, Safety_TC_Done
0DB8           1663   
0DB8           1664       ; Check: current_time_minute >= 1 ? (has 1 minute passed?)
0DB8 E531      1665       mov  a, current_time_minute
0DBA 602C      1666       jz   Safety_TC_Done               ; minute == 0, still waiting
0DBC           1667   
0DBC           1668       ; We reached 1 minute: close the startup window so it won't re-check later
0DBC C214      1669       clr  tc_startup_window
0DBE           1670   
0DBE           1671       ; Now check: current_temp < 50 ?
0DBE 7847      1672       mov  R0, #current_temp
0DC0 793A      1673       mov  R1, #x
0DC2 120D20    1674       lcall Copy4_Bytes_R0_to_R1
0DC5           1675   
0DC5 753E32    1676            mov y+0, #low (50 % 0x10000) 
0DC8 753F00    1676            mov y+1, #high(50 % 0x10000) 
0DCB 754000    1676            mov y+2, #low (50 / 0x10000) 
0DCE 754100    1676            mov y+3, #high(50 / 0x10000) 
0DD1 12011A    1677       lcall x_lt_y
0DD4 300011    1678       jnb  mf, Safety_TC_Done           ; temp >= 50  pass
0DD7           1679   
0DD7           1680       ; FAIL: at 1 minute, still below 50C  abort
0DD7 C293      1681       clr  PWM_OUT
0DD9 D213      1682       setb tc_missing_abort
0DDB D20B      1683       setb stop_signal
0DDD 120E25    1684       lcall Beep_Ten
0DE0           1685       
0DE0           1686       ; Force FSM to State 0 (Welcome)
0DE0 756000    1687       mov Control_FSM_state, #0
0DE3           1688       
0DE3           1689       ; Force UI to State 0 (Home Screen)
0DE3 756100    1690       mov Current_State, #0
0DE6           1691       
0DE6           1692       ; Trigger Screen Refresh
0DE6 D20F      1693       setb state_change_signal          ; Tell loop to redraw "Welcome"
0DE8           1694   
0DE8           1695   Safety_TC_Done:
0DE8 D001      1696       pop  AR1
0DEA D000      1697       pop  AR0
0DEC D0D0      1698       pop  psw
0DEE D0E0      1699       pop  acc
0DF0 22        1700       ret
0DF1           1701   
0DF1           1702   ; ============================================================
0DF1           1703   ; BUZZER STARTUP FUNCTIONS
0DF1           1704   ; ============================================================
0DF1           1705   ;============================================================
0DF1           1706   ; Beep_Judge
0DF1           1707   ; Purpose: Trigger appropriate beep pattern based on events
0DF1           1708   ;   - Beep once when state changes
0DF1           1709   ;   - Beep five times when entering state 6 (cooling/finished)
0DF1           1710   ;   - Beep ten times if tc_missing_abort = 1 (error)
0DF1           1711   ;
0DF1           1712   ; Call this in main loop after Control_FSM
0DF1           1713   ;============================================================
0DF1           1714   Beep_Judge:
0DF1 C0E0      1715       push acc
0DF3 C0D0      1716       push psw
0DF5           1717   
0DF5           1718       ; --- Priority 1: Error condition (highest priority) ---
0DF5 30130A    1719       jnb tc_missing_abort, Beep_Judge_Check_State6
0DF8           1720       ; Error detected - beep 10 times (only once per error)
0DF8 20191B    1721       jb beep_error_done, Beep_Judge_Done   ; Already beeped for this error?
0DFB D219      1722       setb beep_error_done                   ; Mark as handled
0DFD 120E25    1723       lcall Beep_Ten
0E00 8014      1724       sjmp Beep_Judge_Done
0E02           1725   
0E02           1726   Beep_Judge_Check_State6:
0E02           1727       ; --- Priority 2: Entering State 6 (finished) ---
0E02 301211    1728       jnb state_change_beep_signal, Beep_Judge_Done  ; No state change? Exit
0E05           1729       
0E05 E560      1730       mov a, Control_FSM_state
0E07 B40607    1731       cjne a, #6, Beep_Judge_Normal_Change
0E0A           1732       ; Entering state 6 - beep 5 times
0E0A C212      1733       clr state_change_beep_signal               ; Consume the signal
0E0C 120E20    1734       lcall Beep_Five
0E0F 8005      1735       sjmp Beep_Judge_Done
0E11           1736   
0E11           1737   Beep_Judge_Normal_Change:
0E11           1738       ; --- Priority 3: Normal state change - beep once ---
0E11 C212      1739       clr state_change_beep_signal               ; Consume the signal
0E13 120E1B    1740       lcall Beep_Once
0E16           1741   
0E16           1742   Beep_Judge_Done:
0E16 D0D0      1743       pop psw
0E18 D0E0      1744       pop acc
0E1A 22        1745       ret
0E1B           1746   
0E1B           1747   Beep_Once:
0E1B 757501    1748       mov beep_count, #1
0E1E 800A      1749       sjmp Beep_Start
0E20           1750   
0E20           1751   Beep_Five:
0E20 757505    1752       mov beep_count, #5
0E23 8005      1753       sjmp Beep_Start
0E25           1754   
0E25           1755   Beep_Ten:
0E25 75750A    1756       mov beep_count, #10
0E28 8000      1757       sjmp Beep_Start      ; [FIX] Added explicit jump for safety
0E2A           1758   
0E2A           1759   Beep_Start:
0E2A C28C      1760       clr TR0              ; [FIX] Stop timer briefly to reset cleanly
0E2C 757601    1761       mov beep_state, #1   ; Set State to ON
0E2F 757700    1762       mov beep_tmr, #0     ; Reset Timer High Byte
0E32 757800    1763       mov beep_tmr+1, #0   ; Reset Timer Low Byte
0E35 D2A9      1764       setb ET0             ; [FIX] Ensure Interrupt is enabled
0E37 D28C      1765       setb TR0             ; START the 2kHz tone
0E39 22        1766       ret
0E3A           1767   ;============================================================
0E3A           1768   
0E3A           1769   ;============================================================
0E3A           1770   ; Buzzer beep Task 
0E3A           1771   ; Purpose: beeps, holds, stop
0E3A           1772   ; Buzzer task:
0E3A           1773   ; Beep once when state changes
0E3A           1774   ; Beep five times if finished
0E3A           1775   ; Beep ten times if meets error
0E3A           1776   ;============================================================
0E3A           1777   Beep_Task:
0E3A 301835    1778       jnb one_ms_beep_flag, Beep_Done
0E3D C218      1779       clr one_ms_beep_flag
0E3F           1780   
0E3F E576      1781       mov a, beep_state
0E41 602F      1782       jz Beep_Done
0E43           1783   
0E43           1784   ; ---- increment 16-bit timer ----
0E43 0577      1785       inc beep_tmr
0E45 E577      1786       mov a, beep_tmr
0E47 7002      1787       jnz Beep_Check
0E49 0578      1788       inc beep_tmr+1
0E4B           1789   
0E4B           1790   Beep_Check:
0E4B           1791       ; [FIX] FUZZY TIMER CHECK
0E4B           1792       ; Check if High Byte is non-zero (Time >= 256ms)
0E4B E578      1793       mov a, beep_tmr+1
0E4D 6023      1794       jz Beep_Done        ; If 0, keep beeping
0E4F           1795   
0E4F           1796       ; --- Time Limit Reached ---
0E4F 757700    1797       mov beep_tmr, #0    ; Reset timer
0E52 757800    1798       mov beep_tmr+1, #0
0E55           1799   
0E55 E576      1800       mov a, beep_state
0E57 B40106    1801       cjne a, #1, Beep_Off_State
0E5A           1802   
0E5A           1803       ; State was 1 (ON) -> Turn OFF
0E5A C28C      1804       clr TR0             ; Hardware Silence
0E5C 757602    1805       mov beep_state, #2  ; Set State to OFF (Pause)
0E5F 22        1806       ret
0E60           1807   
0E60           1808   Beep_Off_State:
0E60           1809   ; ---- OFF finished -> decrement count / next ON ----
0E60 1575      1810       dec beep_count
0E62 E575      1811       mov a, beep_count
0E64 6006      1812       jz  Beep_Stop
0E66           1813   
0E66 757601    1814       mov beep_state, #1
0E69 D28C      1815       setb TR0
0E6B 22        1816       ret
0E6C           1817   
0E6C           1818   Beep_Stop:
0E6C C28C      1819       clr TR0
0E6E 757600    1820       mov beep_state, #0
0E71 22        1821       ret
0E72           1822   
0E72           1823   Beep_Done:
0E72 22        1824       ret
0E73           1825   ;==================================================================
0E73           1826   
0E73           1827   ;-------------------------------------------------------------------------------;
0E73           1828   ; Main Control FSM for the entire process
0E73           1829   ;-------------------------------------------------------------------------------;
0E73           1830   ;-------------------------------------------------------------------------------;
0E73           1831   ; FSM LOGIC (Button Logic Fixed)
0E73           1832   ;-------------------------------------------------------------------------------;
0E73           1833   Control_FSM:
0E73 E560      1834       mov a, Control_FSM_state
0E75 8008      1835       sjmp Control_FSM_state0
0E77           1836   
0E77           1837   Control_FSM_state0_a:
0E77 756000    1838            mov Control_FSM_state, #0
0E7A D20F      1839            setb state_change_signal
0E7C D210      1840            setb state_change_signal_TC
0E7E 22        1841            ret
0E7F           1842   Control_FSM_state0:
0E7F B40017    1843       cjne a, #0, Control_FSM_state1
0E82 C219      1844       clr beep_error_done
0E84 301504    1845       jnb PB0_flag, Control_FSM_state0_ret  ; Check flag
0E87 C215      1846       clr PB0_flag                 
0E89 8001      1847       sjmp Control_FSM_state1_a
0E8B           1848   Control_FSM_state0_ret:
0E8B 22        1849       ret
0E8C           1850   
0E8C           1851   Control_FSM_state1_a:
0E8C 756001    1852       mov Control_FSM_state, #1
0E8F 756100    1853       mov Current_State, #0
0E92 D20F      1854       setb state_change_signal
0E94 D210      1855            setb state_change_signal_TC
0E96 D212      1856       setb state_change_beep_signal
0E98 22        1857            ret
0E99           1858   Control_FSM_state1:
0E99 B40116    1859       cjne a, #1, Control_FSM_state2
0E9C 301504    1860       jnb PB0_flag, Control_FSM_state1_ret  ; Check flag
0E9F C215      1861       clr PB0_flag                    
0EA1 8001      1862       sjmp Control_FSM_state2_a
0EA3           1863   Control_FSM_state1_ret:
0EA3 22        1864       ret
0EA4           1865   
0EA4           1866   ; --- STATE 2: RAMP TO SOAK ---
0EA4           1867   Control_FSM_state2_a:
0EA4 756002    1868            mov Control_FSM_state, #2
0EA7 D20F      1869            setb state_change_signal
0EA9 D210      1870            setb state_change_signal_TC
0EAB D211      1871            setb state_change_signal_Count
0EAD D212      1872       setb state_change_beep_signal
0EAF C205      1873       clr soak_temp_reached
0EB1 22        1874            ret
0EB2           1875   Control_FSM_state2:
0EB2 B4021C    1876       cjne a, #2, Control_FSM_state3
0EB5 301705    1877       jnb PB2_flag, State2_Check
0EB8 C217      1878       clr PB2_flag
0EBA 020F1F    1879       ljmp Control_FSM_state6_a ; Pause
0EBD           1880   
0EBD           1881   State2_Check:
0EBD 300506    1882       jnb soak_temp_reached, State2_Ret
0EC0           1883       
0EC0           1884       ; --- We reached Temp! Move to State 3 ---
0EC0 C205      1885       clr soak_temp_reached
0EC2 C208      1886       clr soak_time_reached
0EC4 8001      1887            sjmp Control_FSM_state3_a
0EC6           1888   State2_Ret:
0EC6 22        1889       ret
0EC7           1890   
0EC7           1891   ; --- STATE 3: SOAK PHASE ---
0EC7           1892   Control_FSM_state3_a:
0EC7 756003    1893            mov Control_FSM_state, #3
0ECA D20F      1894            setb state_change_signal
0ECC D210      1895            setb state_change_signal_TC
0ECE D212      1896       setb state_change_beep_signal
0ED0 22        1897            ret
0ED1           1898   Control_FSM_state3:
0ED1 B4031A    1899       cjne a, #3, Control_FSM_state4
0ED4 301705    1900       jnb PB2_flag, State3_Check
0ED7 C217      1901       clr PB2_flag
0ED9 020F1F    1902       ljmp Control_FSM_state6_a
0EDC           1903   State3_Check:
0EDC 300804    1904       jnb soak_time_reached, State3_Ret
0EDF C208      1905       clr soak_time_reached
0EE1 8001      1906       sjmp Control_FSM_state4_a
0EE3           1907   State3_Ret:
0EE3 22        1908       ret
0EE4           1909   
0EE4           1910   ; --- STATE 4: RAMP TO PEAK ---
0EE4           1911   Control_FSM_state4_a:
0EE4 756004    1912            mov Control_FSM_state, #4
0EE7 D20F      1913            setb state_change_signal
0EE9 D210      1914            setb state_change_signal_TC
0EEB D212      1915       setb state_change_beep_signal
0EED 22        1916            ret
0EEE           1917   Control_FSM_state4:
0EEE B4041C    1918       cjne a, #4, Control_FSM_state5
0EF1 301705    1919       jnb PB2_flag, State4_Check
0EF4 C217      1920       clr PB2_flag
0EF6 020F1F    1921       ljmp Control_FSM_state6_a
0EF9           1922   State4_Check:
0EF9 300606    1923       jnb reflow_temp_reached, State4_Ret
0EFC C206      1924       clr reflow_temp_reached
0EFE C209      1925       clr reflow_time_reached
0F00 8001      1926            sjmp Control_FSM_state5_a
0F02           1927   State4_Ret:
0F02 22        1928       ret
0F03           1929   
0F03           1930   ; --- STATE 5: REFLOW PHASE ---
0F03           1931   Control_FSM_state5_a:
0F03 756005    1932            mov Control_FSM_state, #5
0F06 D20F      1933            setb state_change_signal
0F08 D210      1934            setb state_change_signal_TC
0F0A D212      1935       setb state_change_beep_signal
0F0C 22        1936            ret
0F0D           1937   Control_FSM_state5:
0F0D B4051D    1938       cjne a, #5, Control_FSM_state6
0F10 301704    1939       jnb PB2_flag, State5_Check
0F13 C217      1940       clr PB2_flag
0F15 8008      1941       sjmp Control_FSM_state6_a
0F17           1942   State5_Check:
0F17 300904    1943       jnb reflow_time_reached, State5_Ret
0F1A C209      1944       clr reflow_time_reached
0F1C 8001      1945       sjmp Control_FSM_state6_a
0F1E           1946   State5_Ret:
0F1E 22        1947       ret
0F1F           1948   
0F1F           1949   ; --- STATE 6: COOLING ---
0F1F           1950   Control_FSM_state6_a:
0F1F 756006    1951            mov Control_FSM_state, #6
0F22 D20F      1952            setb state_change_signal
0F24 D210      1953            setb state_change_signal_TC
0F26 D211      1954            setb state_change_signal_Count
0F28 D212      1955       setb state_change_beep_signal
0F2A C207      1956       clr cooling_temp_reached
0F2C 22        1957            ret
0F2D           1958   Control_FSM_state6:
0F2D B40612    1959       cjne a, #6, Control_FSM_state7
0F30           1960       ; Wait for Cooling Temp Reached
0F30 300704    1961       jnb cooling_temp_reached, State6_Ret
0F33 C207      1962       clr cooling_temp_reached
0F35 8001      1963       sjmp Control_FSM_state7_a
0F37           1964   State6_Ret:
0F37 22        1965       ret
0F38           1966   
0F38           1967   ; --- STATE 7: DONE ---
0F38           1968   Control_FSM_state7_a:
0F38 756007    1969            mov Control_FSM_state, #7
0F3B D20F      1970            setb state_change_signal
0F3D D210      1971            setb state_change_signal_TC
0F3F D212      1972       setb state_change_beep_signal
0F41 22        1973            ret
0F42           1974   Control_FSM_state7:
0F42 B40708    1975       cjne a, #7, Control_FSM_done
0F45           1976       ; Let's assume you meant the physical button P1.0 like State 0
0F45 101502    1977       jbc PB0_flag, Control_FSM_state7_pressed
0F48 8003      1978            sjmp Control_FSM_done
0F4A           1979   Control_FSM_state7_pressed:
0F4A 020E77    1980       ljmp Control_FSM_state0_a
0F4D           1981   
0F4D           1982   Control_FSM_done:
0F4D 22        1983       ret
0F4E           1984   
0F4E           1985   ; ================================================================
0F4E           1986   ; UI & HELPER SUBROUTINES
0F4E           1987   ; ================================================================
0F4E           1988   
0F4E           1989   ; ----------------------------------------------------------------
0F4E           1990   ; MODULE: BRIDGE (Text to Integer Conversion)
0F4E           1991   ; ----------------------------------------------------------------
0F4E           1992   
0F4E           1993   ;--------------------------
0F4E           1994   ;keep updating varaibles
0F4E           1995   Update_FSM_Variables:
0F4E C0E0      1996            push ACC
0F50 C006      1997            push AR6
0F52 C007      1998            push AR7
0F54 E560      1999            mov a, Control_FSM_state
0F56 B40132    2000            cjne a, #1, Update_FSM_Variables_done
0F59           2001   
0F59           2002       ; --- 1. SOAK TEMP ---
0F59 7880      2003       mov R0, #Buf_Soak_Temp
0F5B 120F92    2004       lcall Parse_Temp_String
0F5E 8F4B      2005       mov soak_temp+0, R7
0F60 754C00    2006       mov soak_temp+1, #0
0F63 754D00    2007       mov soak_temp+2, #0
0F66 754E00    2008       mov soak_temp+3, #0
0F69           2009   
0F69           2010       ; --- 2. REFLOW TEMP ---
0F69 7889      2011       mov R0, #Buf_Refl_Temp
0F6B 120F92    2012       lcall Parse_Temp_String
0F6E 8F4F      2013       mov reflow_temp+0, R7
0F70 755000    2014       mov reflow_temp+1, #0
0F73 755100    2015       mov reflow_temp+2, #0
0F76 755200    2016       mov reflow_temp+3, #0
0F79           2017   
0F79           2018       ; --- 3. SOAK TIME ---
0F79 7884      2019       mov R0, #Buf_Soak_Time
0F7B 120FA6    2020       lcall Parse_Time_String
0F7E 8F33      2021       mov soak_time_minute, R7
0F80 8E32      2022       mov soak_time_sec, R6
0F82           2023   
0F82           2024       ; --- 4. REFLOW TIME ---
0F82 788D      2025       mov R0, #Buf_Refl_Time
0F84 120FA6    2026       lcall Parse_Time_String
0F87 8F35      2027       mov reflow_time_minute, R7
0F89 8E34      2028       mov reflow_time_sec, R6
0F8B           2029   
0F8B           2030   Update_FSM_Variables_done:
0F8B D007      2031            pop AR7
0F8D D006      2032            pop AR6
0F8F D0E0      2033            pop ACC
0F91 22        2034       ret
0F92           2035   ;--------------------------
0F92           2036   
0F92           2037   ; --- Helper: Parse "123" to Integer ---
0F92           2038   Parse_Temp_String:
0F92 7F00      2039       mov R7, #0              ; Clear Result
0F94           2040   Parse_Temp_Loop:
0F94 E6        2041       mov A, @R0
0F95 600E      2042       jz Parse_Temp_Done      ; If Null, we are done
0F97           2043       
0F97           2044       ; Convert ASCII to Digit
0F97 C3        2045       clr C
0F98 9430      2046       subb A, #0x30
0F9A FD        2047       mov R5, A               ; R5 = New Digit
0F9B           2048       
0F9B           2049       ; Result = (Result * 10) + New Digit
0F9B EF        2050       mov A, R7
0F9C 75F00A    2051       mov B, #10
0F9F A4        2052       mul AB
0FA0 2D        2053       add A, R5
0FA1 FF        2054       mov R7, A
0FA2           2055       
0FA2 08        2056       inc R0
0FA3 80EF      2057       sjmp Parse_Temp_Loop
0FA5           2058   Parse_Temp_Done:
0FA5 22        2059       ret
0FA6           2060   
0FA6           2061   ; --- Helper: Parse "MMSS" to Seconds ---
0FA6           2062   Parse_Time_String:
0FA6           2063       ; Minutes tens
0FA6 E6        2064       mov A, @R0
0FA7 C3        2065       clr C
0FA8 9430      2066       subb A, #0x30
0FAA 75F00A    2067       mov B, #10
0FAD A4        2068       mul AB
0FAE FD        2069       mov R5, A
0FAF 08        2070       inc R0
0FB0           2071   
0FB0           2072       ; Minutes ones
0FB0 E6        2073       mov A, @R0
0FB1 C3        2074       clr C
0FB2 9430      2075       subb A, #0x30
0FB4 2D        2076       add A, R5
0FB5 FD        2077       mov R5, A
0FB6 08        2078       inc R0
0FB7           2079   
0FB7           2080       ; Seconds tens
0FB7 E6        2081       mov A, @R0
0FB8 C3        2082       clr C
0FB9 9430      2083       subb A, #0x30
0FBB 75F00A    2084       mov B, #10
0FBE A4        2085       mul AB
0FBF FC        2086       mov R4, A
0FC0 08        2087       inc R0
0FC1           2088   
0FC1           2089       ; Seconds ones
0FC1 E6        2090       mov A, @R0
0FC2 C3        2091       clr C
0FC3 9430      2092       subb A, #0x30
0FC5 2C        2093       add A, R4
0FC6 FC        2094       mov R4, A
0FC7           2095   
0FC7           2096       ; Return minutes/seconds
0FC7 ED        2097            mov a, R5
0FC8 FF        2098       mov R7, a     ; minutes
0FC9 EC        2099            mov a, R4
0FCA FE        2100       mov R6, a     ; seconds
0FCB 22        2101       ret
0FCC           2102   
0FCC           2103   ; ----------------------------------------------------------------
0FCC           2104   ; MODULE: BUTTON HANDLER (Mode Selection)
0FCC           2105   ; ----------------------------------------------------------------
0FCC           2106   ; Blocking wrapper for LCD clear (keeps old behavior just for this)
0FCC           2107   Wait_25ms_BLOCKING:
0FCC 1211AA    2108       lcall Wait_25ms
0FCF 50FB      2109       jnc Wait_25ms_BLOCKING ; Keep jumping back until Done (C=1)
0FD1 22        2110       ret
0FD2           2111   
0FD2           2112   ; ----------------------------------------------------------------
0FD2           2113   ; MODULE: BUTTON HANDLER (Non-Blocking Debounce)
0FD2           2114   ; ----------------------------------------------------------------
0FD2           2115   ; Variables needed:
0FD2           2116   ;   BTN_DEB_state   - state machine state (0-3)
0FD2           2117   ;   BTN_DEB_timer   - debounce timer (incremented by ISR every 1ms)
0FD2           2118   ;   BTN_DEB_id      - which button was pressed (1-4)
0FD2           2119   ; ----------------------------------------------------------------
0FD2           2120   
0FD2           2121   Check_Buttons:
0FD2 C0E0      2122       push ACC
0FD4 C0D0      2123       push PSW
0FD6           2124       
0FD6           2125       ; Only process in Control_FSM_state 1
0FD6 E560      2126       mov a, Control_FSM_state
0FD8 B40107    2127       cjne a, #1, Check_Buttons_Done_bridge
0FDB           2128       
0FDB           2129       ; --- FORCE INPUT MODE ---
0FDB 438055    2130       orl P0, #055H   ; Sets P0.0, P0.2, P0.4, P0.6 to '1' (Input Mode)
0FDE           2131       
0FDE E57A      2132       mov a, BTN_DEB_state
0FE0 8003      2133       sjmp BTN_DEB_state0
0FE2           2134   
0FE2           2135   Check_Buttons_Done_bridge:
0FE2 02108C    2136       ljmp Check_Buttons_Done
0FE5           2137   
0FE5           2138   ; ============================================================
0FE5           2139   ; State 0: Wait for any button press
0FE5           2140   ; ============================================================
0FE5           2141   BTN_DEB_state0:
0FE5 B4002A    2142       cjne a, #0, BTN_DEB_state1
0FE8           2143       
0FE8           2144       ; Check each button, record which one was pressed
0FE8 30800C    2145       jnb BTN_SOAK_TEMP, BTN_Detect_SoakTemp
0FEB 30820E    2146       jnb BTN_SOAK_TIME, BTN_Detect_SoakTime
0FEE 308410    2147       jnb BTN_REFL_TEMP, BTN_Detect_ReflTemp
0FF1 308612    2148       jnb BTN_REFL_TIME, BTN_Detect_ReflTime
0FF4 02108C    2149       ljmp Check_Buttons_Done     ; No button pressed
0FF7           2150   
0FF7           2151   BTN_Detect_SoakTemp:
0FF7 757C01    2152       mov BTN_DEB_id, #1
0FFA 800F      2153       sjmp BTN_Start_Debounce
0FFC           2154   BTN_Detect_SoakTime:
0FFC 757C02    2155       mov BTN_DEB_id, #2
0FFF 800A      2156       sjmp BTN_Start_Debounce
1001           2157   BTN_Detect_ReflTemp:
1001 757C03    2158       mov BTN_DEB_id, #3
1004 8005      2159       sjmp BTN_Start_Debounce
1006           2160   BTN_Detect_ReflTime:
1006 757C04    2161       mov BTN_DEB_id, #4
1009 8000      2162       sjmp BTN_Start_Debounce
100B           2163   
100B           2164   BTN_Start_Debounce:
100B 757B00    2165       mov BTN_DEB_timer, #0
100E 057A      2166       inc BTN_DEB_state
1010 807A      2167       sjmp Check_Buttons_Done
1012           2168   
1012           2169   ; ============================================================
1012           2170   ; State 1: Debounce delay (wait 50ms)
1012           2171   ; ============================================================
1012           2172   BTN_DEB_state1:
1012 B40109    2173       cjne a, #1, BTN_DEB_state2
1015 E57B      2174       mov a, BTN_DEB_timer
1017 B43272    2175       cjne a, #50, Check_Buttons_Done   ; Wait 50ms
101A 057A      2176       inc BTN_DEB_state
101C 806E      2177       sjmp Check_Buttons_Done
101E           2178   
101E           2179   ; ============================================================
101E           2180   ; State 2: Verify button still pressed
101E           2181   ; ============================================================
101E           2182   BTN_DEB_state2:
101E B40226    2183       cjne a, #2, BTN_DEB_state3
1021           2184       
1021           2185       ; Check if the same button is still pressed
1021 E57C      2186       mov a, BTN_DEB_id
1023 B40105    2187       cjne a, #1, BTN_Verify_Check2
1026 30801A    2188       jnb BTN_SOAK_TEMP, BTN_Verify_OK
1029 8013      2189       sjmp BTN_Verify_Fail
102B           2190   BTN_Verify_Check2:
102B B40205    2191       cjne a, #2, BTN_Verify_Check3
102E 308212    2192       jnb BTN_SOAK_TIME, BTN_Verify_OK
1031 800B      2193       sjmp BTN_Verify_Fail
1033           2194   BTN_Verify_Check3:
1033 B40305    2195       cjne a, #3, BTN_Verify_Check4
1036 30840A    2196       jnb BTN_REFL_TEMP, BTN_Verify_OK
1039 8003      2197       sjmp BTN_Verify_Fail
103B           2198   BTN_Verify_Check4:
103B 308605    2199       jnb BTN_REFL_TIME, BTN_Verify_OK
103E           2200       ; Fall through to fail
103E           2201   
103E           2202   BTN_Verify_Fail:
103E 757A00    2203       mov BTN_DEB_state, #0           ; Was noise, reset
1041 8049      2204       sjmp Check_Buttons_Done
1043           2205   
1043           2206   BTN_Verify_OK:
1043 057A      2207       inc BTN_DEB_state               ; Confirmed, wait for release
1045 8045      2208       sjmp Check_Buttons_Done
1047           2209   
1047           2210   ; ============================================================
1047           2211   ; State 3: Wait for button release, then trigger action
1047           2212   ; ============================================================
1047           2213   BTN_DEB_state3:
1047 B40342    2214       cjne a, #3, Check_Buttons_Done
104A           2215       
104A           2216       ; Check if the button is released
104A E57C      2217       mov a, BTN_DEB_id
104C B40105    2218       cjne a, #1, BTN_Release_Check2
104F 30803A    2219       jnb BTN_SOAK_TEMP, Check_Buttons_Done   ; Still pressed, wait
1052 8013      2220       sjmp BTN_Do_Action
1054           2221   BTN_Release_Check2:
1054 B40205    2222       cjne a, #2, BTN_Release_Check3
1057 308232    2223       jnb BTN_SOAK_TIME, Check_Buttons_Done
105A 800B      2224       sjmp BTN_Do_Action
105C           2225   BTN_Release_Check3:
105C B40305    2226       cjne a, #3, BTN_Release_Check4
105F 30842A    2227       jnb BTN_REFL_TEMP, Check_Buttons_Done
1062 8003      2228       sjmp BTN_Do_Action
1064           2229   BTN_Release_Check4:
1064 308625    2230       jnb BTN_REFL_TIME, Check_Buttons_Done
1067           2231       ; Fall through to action
1067           2232   
1067           2233   ; ============================================================
1067           2234   ; Button Released - Execute Action
1067           2235   ; ============================================================
1067           2236   BTN_Do_Action:
1067 E57C      2237       mov a, BTN_DEB_id
1069           2238       
1069 B40105    2239       cjne a, #1, BTN_Action_2
106C 756101    2240       mov Current_State, #1           ; Soak Temp
106F 8013      2241       sjmp BTN_Action_Complete
1071           2242   BTN_Action_2:
1071 B40205    2243       cjne a, #2, BTN_Action_3
1074 756102    2244       mov Current_State, #2           ; Soak Time
1077 800B      2245       sjmp BTN_Action_Complete
1079           2246   BTN_Action_3:
1079 B40305    2247       cjne a, #3, BTN_Action_4
107C 756103    2248       mov Current_State, #3           ; Refl Temp
107F 8003      2249       sjmp BTN_Action_Complete
1081           2250   BTN_Action_4:
1081 756104    2251       mov Current_State, #4           ; Refl Time
1084           2252   
1084           2253   BTN_Action_Complete:
1084 756A00    2254       mov Cursor_Idx, #0
1087 D224      2255       setb fullscreen_update_signal   ; Trigger screen redraw
1089 757A00    2256       mov BTN_DEB_state, #0           ; Reset state machine
108C           2257   
108C           2258   Check_Buttons_Done:
108C D0D0      2259       pop PSW
108E D0E0      2260       pop ACC
1090 22        2261       ret
1091           2262   
1091           2263   ; ----------------------------------------------------------------
1091           2264   ; MODULE: KEYPAD HANDLER (Input Logic)
1091           2265   ; ----------------------------------------------------------------
1091           2266   Check_Keypad:
1091 E560      2267       mov a, Control_FSM_state
1093 B40152    2268       cjne a, #1, Keypad_Exit
1096           2269   
1096           2270       ; If State is 0 (Home), ignore keypad
1096 E561      2271       mov A, Current_State
1098 604E      2272       jz Keypad_Exit
109A           2273       
109A 1210E9    2274       lcall Keypad_Scan
109D 5049      2275       jnc Keypad_Exit         ; Carry = 0 means no key pressed
109F           2276   
109F           2277       ; --- Check Special Keys ---
109F EF        2278       mov A, R7
10A0 B40E09    2279       cjne A, #14, Check_Hash ; 14 is Star (*)
10A3           2280       
10A3           2281       ; Star Key Pressed: Reset Buffer
10A3 1211ED    2282       lcall Reset_Current_Buffer
10A6 D224      2283       setb fullscreen_update_signal
10A8 756A00    2284       mov Cursor_Idx, #0
10AB 22        2285       ret
10AC           2286   
10AC           2287   Check_Hash:
10AC EF        2288       mov A, R7
10AD B40C01    2289       cjne A, #12, Check_Numeric ; 12 is Hash (#)
10B0 22        2290       ret                     ; Ignore Hash key
10B1           2291   
10B1           2292   Check_Numeric:
10B1           2293       ; Ensure key is 0-9
10B1 EF        2294       mov A, R7
10B2 C3        2295       clr C
10B3 940A      2296       subb A, #10
10B5 5030      2297       jnc Symbol_Key_Ignored
10B7           2298       
10B7           2299       ; Convert to ASCII
10B7 EF        2300       mov A, R7
10B8 2430      2301       add A, #0x30
10BA FD        2302       mov R5, A
10BB           2303   
10BB           2304       ; Save to Buffer
10BB 120B25    2305       lcall Get_Current_Buffer_Addr
10BE E56A      2306       mov A, Cursor_Idx
10C0 28        2307       add A, R0
10C1 F8        2308       mov R0, A
10C2 ED        2309       mov A, R5
10C3 F6        2310       mov @R0, A
10C4 056A      2311       inc Cursor_Idx
10C6           2312   
10C6           2313       ; --- Check Cursor Limits ---
10C6 E561      2314       mov A, Current_State
10C8 B40102    2315       cjne A, #1, Check_Limit_Time_1
10CB 8005      2316       sjmp Limit_Temp_3
10CD           2317   
10CD           2318   Check_Limit_Time_1:
10CD B4030B    2319       cjne A, #3, Limit_Time_4
10D0 8000      2320       sjmp Limit_Temp_3
10D2           2321   
10D2           2322   Limit_Temp_3:
10D2 E56A      2323       mov A, Cursor_Idx
10D4 B4030D    2324       cjne A, #3, Do_Refresh
10D7 156A      2325       dec Cursor_Idx          ; Stay at last digit
10D9 8009      2326       sjmp Do_Refresh
10DB           2327   
10DB           2328   Limit_Time_4:
10DB E56A      2329       mov A, Cursor_Idx
10DD B40404    2330       cjne A, #4, Do_Refresh
10E0 156A      2331       dec Cursor_Idx          ; Stay at last digit
10E2 8000      2332       sjmp Do_Refresh
10E4           2333   
10E4           2334   Do_Refresh:
10E4 D224      2335       setb fullscreen_update_signal
10E6 22        2336       ret
10E7           2337   
10E7           2338   Symbol_Key_Ignored:
10E7 22        2339       ret
10E8           2340   Keypad_Exit:
10E8 22        2341       ret
10E9           2342   
10E9           2343   ; ----------------------------------------------------------------
10E9           2344   ; MODULE: HARDWARE SCANNER (Matrix Logic)
10E9           2345   ; ----------------------------------------------------------------
10E9           2346   Keypad_Scan:
10E9           2347       ; Step 1: Check if ANY key is pressed (All Rows Low)
10E9 C292      2348       clr ROW1
10EB C294      2349       clr ROW2
10ED C296      2350       clr ROW3
10EF C2A0      2351       clr ROW4
10F1 A2A2      2352       mov C, COL1
10F3 82A4      2353       anl C, COL2
10F5 82A6      2354       anl C, COL3
10F7 82B0      2355       anl C, COL4
10F9 5002      2356       jnc Keypad_Debounce
10FB C3        2357       clr C
10FC 22        2358       ret
10FD           2359   
10FD           2360   Keypad_Debounce:
10FD 120FCC    2361       lcall Wait_25ms_BLOCKING
1100 A2A2      2362       mov C, COL1
1102 82A4      2363       anl C, COL2
1104 82A6      2364       anl C, COL3
1106 82B0      2365       anl C, COL4
1108 5002      2366       jnc Keypad_Find_Row
110A C3        2367       clr C
110B 22        2368       ret
110C           2369   
110C           2370   Keypad_Find_Row:
110C D292      2371       setb ROW1
110E D294      2372       setb ROW2
1110 D296      2373       setb ROW3
1112 D2A0      2374       setb ROW4
1114           2375   
1114           2376       ; Row 1
1114 C292      2377       clr ROW1
1116 30A23D    2378       jnb COL1, Keypad_Key_1
1119 30A43E    2379       jnb COL2, Keypad_Key_2
111C 30A63F    2380       jnb COL3, Keypad_Key_3
111F 30B040    2381       jnb COL4, Keypad_Key_A
1122 D292      2382       setb ROW1
1124           2383   
1124           2384       ; Row 2
1124 C294      2385       clr ROW2
1126 30A23D    2386       jnb COL1, Keypad_Key_4
1129 30A43E    2387       jnb COL2, Keypad_Key_5
112C 30A63F    2388       jnb COL3, Keypad_Key_6
112F 30B040    2389       jnb COL4, Keypad_Key_B
1132 D294      2390       setb ROW2
1134           2391   
1134           2392       ; Row 3
1134 C296      2393       clr ROW3
1136 30A23D    2394       jnb COL1, Keypad_Key_7
1139 30A43E    2395       jnb COL2, Keypad_Key_8
113C 30A63F    2396       jnb COL3, Keypad_Key_9
113F 30B040    2397       jnb COL4, Keypad_Key_C
1142 D296      2398       setb ROW3
1144           2399   
1144           2400       ; Row 4
1144 C2A0      2401       clr ROW4
1146 30A23D    2402       jnb COL1, Keypad_Key_Star
1149 30A43E    2403       jnb COL2, Keypad_Key_0
114C 30A63F    2404       jnb COL3, Keypad_Key_Hash
114F 30B040    2405       jnb COL4, Keypad_Key_D
1152 D2A0      2406       setb ROW4
1154 C3        2407       clr C
1155 22        2408       ret
1156           2409   
1156           2410   ; Key Mapping (Renamed to avoid conflicts)
1156 7F01      2411   Keypad_Key_1: mov R7, #1
1158 803C      2412          sjmp Wait_Release
115A 7F02      2413   Keypad_Key_2: mov R7, #2
115C 8038      2414          sjmp Wait_Release
115E 7F03      2415   Keypad_Key_3: mov R7, #3
1160 8034      2416          sjmp Wait_Release
1162 7F0A      2417   Keypad_Key_A: mov R7, #10
1164 8030      2418          sjmp Wait_Release
1166 7F04      2419   Keypad_Key_4: mov R7, #4
1168 802C      2420          sjmp Wait_Release
116A 7F05      2421   Keypad_Key_5: mov R7, #5
116C 8028      2422          sjmp Wait_Release
116E 7F06      2423   Keypad_Key_6: mov R7, #6
1170 8024      2424          sjmp Wait_Release
1172 7F0B      2425   Keypad_Key_B: mov R7, #11
1174 8020      2426          sjmp Wait_Release
1176 7F07      2427   Keypad_Key_7: mov R7, #7
1178 801C      2428          sjmp Wait_Release
117A 7F08      2429   Keypad_Key_8: mov R7, #8
117C 8018      2430          sjmp Wait_Release
117E 7F09      2431   Keypad_Key_9: mov R7, #9
1180 8014      2432          sjmp Wait_Release
1182 7F0D      2433   Keypad_Key_C: mov R7, #13
1184 8010      2434          sjmp Wait_Release
1186 7F0E      2435   Keypad_Key_Star: mov R7, #14
1188 800C      2436          sjmp Wait_Release
118A 7F00      2437   Keypad_Key_0: mov R7, #0
118C 8008      2438          sjmp Wait_Release
118E 7F0C      2439   Keypad_Key_Hash: mov R7, #12
1190 8004      2440          sjmp Wait_Release
1192 7F0F      2441   Keypad_Key_D: mov R7, #15
1194 8000      2442          sjmp Wait_Release
1196           2443   
1196           2444   Wait_Release:
1196 A2A2      2445       mov C, COL1
1198 82A4      2446       anl C, COL2
119A 82A6      2447       anl C, COL3
119C 82B0      2448       anl C, COL4
119E 50F6      2449       jnc Wait_Release
11A0 D3        2450       setb C
11A1 D292      2451       setb ROW1
11A3 D294      2452       setb ROW2
11A5 D296      2453       setb ROW3
11A7 D2A0      2454       setb ROW4
11A9 22        2455       ret
11AA           2456   
11AA           2457   Wait_25ms:
11AA           2458       ; 1. Check if we are already waiting
11AA 201A0E    2459       jb wait25_active, Check_Timer_Status
11AD           2460       
11AD           2461       ; 2. Check if we just finished
11AD 301B04    2462       jnb wait25_done, Start_New_Timer
11B0           2463       
11B0           2464       ; 3. Timer is DONE! Reset flags and return True
11B0 C21B      2465       clr wait25_done
11B2 D3        2466       setb C          ; Carry = 1 means "Done"
11B3 22        2467       ret
11B4           2468   
11B4           2469   Start_New_Timer:
11B4           2470       ; 4. Start a new 25ms wait
11B4 755700    2471       mov wait25_count, #0
11B7 D21A      2472       setb wait25_active
11B9 C3        2473       clr C           ; Carry = 0 means "Not Done Yet"
11BA 22        2474       ret
11BB           2475   
11BB           2476   Check_Timer_Status:
11BB           2477       ; 5. Still waiting... return False immediately
11BB C3        2478       clr C           ; Carry = 0 means "Not Done Yet"
11BC 22        2479       ret
11BD           2480   
11BD           2481   ; ----------------------------------------------------------------
11BD           2482   ; MODULE: BUFFER INIT (Reset Logic)
11BD           2483   ; ----------------------------------------------------------------
11BD           2484   Init_All_Buffers:
11BD 7880      2485       mov R0, #Buf_Soak_Temp
11BF 1211D2    2486       lcall Init_Temp_Template
11C2 7889      2487       mov R0, #Buf_Refl_Temp
11C4 1211D2    2488       lcall Init_Temp_Template
11C7 7884      2489       mov R0, #Buf_Soak_Time
11C9 1211DE    2490       lcall Init_Time_Template
11CC 788D      2491       mov R0, #Buf_Refl_Time
11CE 1211DE    2492       lcall Init_Time_Template
11D1 22        2493       ret
11D2           2494   
11D2           2495   Init_Temp_Template:
11D2 7630      2496       mov @R0, #'0'
11D4 08        2497       inc R0
11D5 7630      2498       mov @R0, #'0'
11D7 08        2499       inc R0
11D8 7630      2500       mov @R0, #'0'
11DA 08        2501       inc R0
11DB 7600      2502       mov @R0, #0
11DD 22        2503       ret
11DE           2504   
11DE           2505   Init_Time_Template:
11DE 7630      2506       mov @R0, #'0'
11E0 08        2507       inc R0
11E1 7630      2508       mov @R0, #'0'
11E3 08        2509       inc R0
11E4 7630      2510       mov @R0, #'0'
11E6 08        2511       inc R0
11E7 7630      2512       mov @R0, #'0'
11E9 08        2513       inc R0
11EA 7600      2514       mov @R0, #0
11EC 22        2515       ret
11ED           2516   
11ED           2517   Reset_Current_Buffer:
11ED E561      2518       mov A, Current_State
11EF B40106    2519       cjne A, #1, Reset_Chk_2
11F2 7880      2520       mov R0, #Buf_Soak_Temp
11F4 1211D2    2521       lcall Init_Temp_Template
11F7 22        2522       ret
11F8           2523   Reset_Chk_2:
11F8 B40206    2524       cjne A, #2, Reset_Chk_3
11FB 7884      2525       mov R0, #Buf_Soak_Time
11FD 1211DE    2526       lcall Init_Time_Template
1200 22        2527       ret
1201           2528   Reset_Chk_3:
1201 B40306    2529       cjne A, #3, Reset_Chk_4
1204 7889      2530       mov R0, #Buf_Refl_Temp
1206 1211D2    2531       lcall Init_Temp_Template
1209 22        2532       ret
120A           2533   Reset_Chk_4:
120A 788D      2534       mov R0, #Buf_Refl_Time
120C 1211DE    2535       lcall Init_Time_Template
120F 22        2536       ret 
1210           2537       
1210           2538   ; ================================================================
1210           2539   ; MODULE: THERMOCOUPLE ADC DRIVER (WITH NOISE SUPPRESSION & JUMP FIX)
1210           2540   ; ================================================================
1210           2541   Read_Thermocouple:
1210           2542       ; 1. Check Non-Blocking Timer
1210 1211AA    2543       lcall Wait_25ms
1213           2544       
1213           2545       ; [FIX] TRAMPOLINE JUMP
1213           2546       ; "jnc" cannot jump to the end because the code is too long.
1213           2547       ; We invert logic: If Carry=1 (Time is up), Jump NEARBY.
1213 4001      2548       jc Proceed_Reading
1215 22        2549       ret  ; If Carry=0, Return immediately.
1216           2550   
1216           2551   Proceed_Reading:
1216           2552       ; --- 25ms Passed! Time to Read ---
1216           2553   
1216           2554       ; [FIX] SILENCE THE BUZZER (Noise Suppression)
1216           2555       ; Save buzzer state and force it OFF during the sensitive read
1216 E588      2556       mov A, TCON      
1218 5410      2557       anl A, #0x10     ; Isolate TR0 bit
121A C0E0      2558       push acc         ; Save it
121C C28C      2559       clr TR0          ; STOP NOISE
121E           2560   
121E           2561       ; 2. Initialize / Trigger ADC
121E 75A180    2562       mov ADC_C, #0x80    ; Reset
1221 00        2563       nop
1222 00        2564       nop
1223 75A101    2565       mov ADC_C, #0x01    ; Start Channel 0
1226           2566       
1226           2567       ; 3. Settle Delay
1226 7DFA      2568       mov R5, #250
1228           2569   ADC_Settle_Loop:
1228 00        2570       nop
1229 00        2571       nop
122A DDFC      2572       djnz R5, ADC_Settle_Loop
122C           2573       
122C           2574       ; 4. Read Raw Data
122C 85A23A    2575       mov x+0, ADC_L
122F 85A33B    2576       mov x+1, ADC_H
1232 753C00    2577       mov x+2, #0
1235 753D00    2578       mov x+3, #0
1238           2579       
1238           2580       ; 5. Mask Data
1238 E53B      2581       mov a, x+1
123A 540F      2582       anl a, #0x0F
123C F53B      2583       mov x+1, a
123E           2584       
123E           2585       ; [FIX] RESTORE THE BUZZER
123E D0E0      2586       pop acc          ; Get previous state
1240 6002      2587       jz Skip_Restore  ; If it was OFF, keep it OFF
1242 D28C      2588       setb TR0         ; If it was ON, turn it back ON
1244           2589   Skip_Restore:
1244           2590   
1244           2591       ; 6. Math Conversions
1244 753E16    2592            mov y+0, #low (4118 % 0x10000) 
1247 753F10    2592            mov y+1, #high(4118 % 0x10000) 
124A 754000    2592            mov y+2, #low (4118 / 0x10000) 
124D 754100    2592            mov y+3, #high(4118 / 0x10000) 
1250 12018C    2593       lcall mul32       
1253           2594   
1253 75A104    2595       mov ADC_C, #0x04    ; Read LM4040
1256 85A23E    2596       mov y+0, ADC_L      
1259 85A33F    2597       mov y+1, ADC_H      
125C 754000    2598       mov y+2, #0
125F 754100    2599       mov y+3, #0
1262 75A100    2600       mov ADC_C, #0x00    ; Reset
1265           2601       
1265 120280    2602       lcall div32         
1268 753E64    2603            mov y+0, #low (100 % 0x10000) 
126B 753F00    2603            mov y+1, #high(100 % 0x10000) 
126E 754000    2603            mov y+2, #low (100 / 0x10000) 
1271 754100    2603            mov y+3, #high(100 / 0x10000) 
1274 12018C    2604       lcall mul32
1277 753E2B    2605            mov y+0, #low (1323 % 0x10000) 
127A 753F05    2605            mov y+1, #high(1323 % 0x10000) 
127D 754000    2605            mov y+2, #low (1323 / 0x10000) 
1280 754100    2605            mov y+3, #high(1323 / 0x10000)         
1283 120280    2606       lcall div32    
1286 753E14    2607            mov y+0, #low (COLD_JUNCTION_TEMP % 0x10000) 
1289 753F00    2607            mov y+1, #high(COLD_JUNCTION_TEMP % 0x10000) 
128C 754000    2607            mov y+2, #low (COLD_JUNCTION_TEMP / 0x10000) 
128F 754100    2607            mov y+3, #high(COLD_JUNCTION_TEMP / 0x10000) 
1292 1200D3    2608       lcall add32     
1295           2609       
1295           2610       ; 8. Store Result
1295 853A47    2611       mov current_temp+0, x+0
1298 853B48    2612       mov current_temp+1, x+1
129B 853C49    2613       mov current_temp+2, x+2
129E 853D4A    2614       mov current_temp+3, x+3
12A1           2615   
12A1 22        2616       ret
12A2           2617       
12A2           2618   ; ================================================================
12A2           2619   ; MODULE: POWER CONTROLLER (The Brain)
12A2           2620   ; ================================================================
12A2           2621   Power_Control:
12A2           2622       ; Default: Turn Heat OFF (Safety)
12A2 755800    2623       mov power_output+0, #0
12A5 755900    2624       mov power_output+1, #0
12A8 755A00    2625       mov power_output+2, #0
12AB 755B00    2626       mov power_output+3, #0
12AE           2627   
12AE E560      2628       mov a, Control_FSM_state
12B0           2629   
12B0           2630       ; --- State 2: RAMP TO SOAK ---
12B0 B40202    2631       cjne a, #2, PC_Check_Soak
12B3           2632       ; Mode: Full Speed Ahead
12B3 8016      2633       sjmp Set_Max_Power
12B5           2634   
12B5           2635   PC_Check_Soak:
12B5           2636       ; --- State 3: SOAK PHASE ---
12B5 B40305    2637       cjne a, #3, PC_Check_Ramp_Reflow
12B8           2638       ; Mode: Maintenance (Low Power)
12B8           2639       ; If Temp > Target, OFF. If Temp < Target, 20% Power.
12B8 20050F    2640       jb soak_temp_reached, PC_Done ; If hot enough, stay OFF
12BB 801B      2641       sjmp Set_20_Percent_Power     ; If cold, use 20%
12BD           2642   
12BD           2643   PC_Check_Ramp_Reflow:
12BD           2644       ; --- State 4: RAMP TO REFLOW ---
12BD B40402    2645       cjne a, #4, PC_Check_Reflow
12C0           2646       ; Mode: Full Speed Ahead
12C0 8009      2647       sjmp Set_Max_Power
12C2           2648   
12C2           2649   PC_Check_Reflow:
12C2           2650       ; --- State 5: REFLOW PHASE ---
12C2 B40505    2651       cjne a, #5, PC_Done
12C5           2652       ; Mode: Maintenance (Low Power)
12C5 200602    2653       jb reflow_temp_reached, PC_Done
12C8 800E      2654       sjmp Set_20_Percent_Power
12CA           2655   
12CA           2656   PC_Done:
12CA 22        2657       ret
12CB           2658   
12CB           2659   ; --- Power Helpers ---
12CB           2660   
12CB           2661   Set_Max_Power:
12CB           2662       ; Load 1500 (0x05DC) = 100% Duty Cycle
12CB 7558DC    2663       mov power_output+0, #0xDC
12CE 755905    2664       mov power_output+1, #0x05
12D1 755A00    2665       mov power_output+2, #0
12D4 755B00    2666       mov power_output+3, #0
12D7 22        2667       ret
12D8           2668   
12D8           2669   Set_20_Percent_Power:
12D8           2670       ; Load 300 (0x012C) = 20% Duty Cycle
12D8 75582C    2671       mov power_output+0, #0x2C
12DB 755901    2672       mov power_output+1, #0x01
12DE 755A00    2673       mov power_output+2, #0
12E1 755B00    2674       mov power_output+3, #0
12E4 22        2675       ret
12E5           2676   
12E5           2677   ;--------------------------------------------------------------
12E5           2678   ; set servo angle according to the state
12E5           2679   ; call servo control function every 1ms
12E5           2680   ;--------------------------------------------------------------
12E5           2681   call_servo_control:
12E5           2682            ; check current state and change servo angle
12E5 E560      2683            mov a, Control_FSM_state
12E7           2684            
12E7           2685            ; handle state 0
12E7 B40004    2686            cjne a, #0, servo_state1
12EA C227      2687            clr servo_angle_zero ; close door at state 0
12EC 802C      2688            sjmp check_servo_flag
12EE           2689   
12EE           2690            ; handle state 1
12EE           2691            servo_state1:
12EE B40104    2692            cjne a, #1, servo_state2
12F1 D227      2693            setb servo_angle_zero ; open door at state 1
12F3 8025      2694            sjmp check_servo_flag
12F5           2695   
12F5           2696            ; handle state 2
12F5           2697            servo_state2:
12F5 B40204    2698            cjne a, #2, servo_state3
12F8 C227      2699            clr servo_angle_zero ; close door at state 2
12FA 801E      2700            sjmp check_servo_flag
12FC           2701   
12FC           2702            ; handle state 3
12FC           2703            servo_state3:
12FC B40304    2704            cjne a, #3, servo_state4
12FF C227      2705            clr servo_angle_zero ; close door at state 3
1301 8017      2706            sjmp check_servo_flag
1303           2707   
1303           2708            ; handle state 4
1303           2709            servo_state4:
1303 B40404    2710            cjne a, #4, servo_state5
1306 C227      2711            clr servo_angle_zero ; close door at state 4
1308 8010      2712            sjmp check_servo_flag
130A           2713   
130A           2714            ; handle state 5
130A           2715            servo_state5:
130A B40504    2716            cjne a, #5, servo_state6
130D C227      2717            clr servo_angle_zero ; close door at state 5
130F 8009      2718            sjmp check_servo_flag
1311           2719   
1311           2720            ; handle state 6
1311           2721            servo_state6:
1311 B40604    2722            cjne a, #6, servo_state7
1314 C227      2723            clr servo_angle_zero ; close door at state 6
1316 8002      2724            sjmp check_servo_flag
1318           2725   
1318           2726            ; handle state 7
1318           2727            servo_state7:
1318 D227      2728            setb servo_angle_zero ; open door at state 7
131A           2729   
131A           2730   check_servo_flag:
131A           2731            ; check 1 ms flag
131A 102601    2732            jbc one_millisecond_flag_servo, run_servo_control
131D 22        2733            ret
131E           2734   
131E           2735   run_servo_control:
131E 121322    2736            lcall servo_control
1321 22        2737            ret
1322           2738   
1322           2739   
1322           2740   ;---------------------------------------------------------------
1322           2741   ; servo control
1322           2742   ; generate a 20 ms period pwm signal to control the servo motor
1322           2743   ; able to make the servo motor stay at 0 degree and 180 degree
1322           2744   ;---------------------------------------------------------------
1322           2745   servo_control:
1322 D2ED      2746       setb LEDRA.5
1324 C0E0      2747            push acc
1326 C0D0      2748            push psw
1328 E579      2749            mov a, servo_pwm_counter ; move servo counter to accumulator
132A 04        2750            inc A ; a += 1
132B B41402    2751            cjne a, #SERVO_PERIOD, servo_pwm_angle_compare ; jump if wrapup not needed
132E 7400      2752            mov a, #0
1330           2753   
1330           2754   servo_pwm_angle_compare: ; read target angle
1330 F579      2755            mov servo_pwm_counter, A
1332 202709    2756            jb servo_angle_zero, set_zero_degree ; set servo motor to 0 degree
1335           2757            ; set servo motor to 180 degrees
1335 E579      2758            mov a, servo_pwm_counter
1337 C3        2759            clr c
1338 9402      2760            subb a, #SERVO_180
133A 400B      2761            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 180 degrees duty cycle
133C 800D      2762            sjmp servo_pwm_set_low ; set low if greater
133E           2763   
133E           2764   set_zero_degree:
133E           2765            ; set servo motor to 0 degree
133E E579      2766            mov a, servo_pwm_counter
1340 C3        2767            clr c
1341 9401      2768            subb a, #SERVO_0
1343 4002      2769            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 0 degrees duty cycle
1345 8004      2770            sjmp servo_pwm_set_low ; set low if greater
1347           2771   
1347           2772   servo_pwm_set_high:
1347           2773            ; set pwm pin high
1347 D2B6      2774            setb SERVO_OUT
1349 8002      2775            sjmp servo_control_done
134B           2776   
134B           2777   servo_pwm_set_low:
134B           2778            ; set pwm pin low
134B C2B6      2779            clr SERVO_OUT
134D           2780   
134D           2781   servo_control_done:
134D D0D0      2782            pop psw
134F D0E0      2783            pop acc
1351 22        2784            ret
1352           2785   
1352           2786   ;-------------------------------------------------------------------------------
1352           2787   ; power_control
1352           2788   ;-------------------------------------------------------------------------------
1352           2789   ; Determine the power output based on current state and current temperature 
1352           2790   ; input parameter: Control_FSM_state
1352           2791   ;-------------------------------------------------------------------------------
1352           2792   
1352           2793   proportional_power_control:
1352 E560      2794            mov a, Control_FSM_state
1354           2795   
1354           2796   state0_power_control:
1354           2797            ; idle
1354           2798            ; 0% power
1354 B4000F    2799            cjne a, #0, state1_power_control
1357 755800    2800            mov power_output, #low(NO_POWER)
135A 755900    2801            mov power_output+1, #low(NO_POWER)
135D 755A00    2802            mov power_output+2, #0
1360 755B00    2803            mov power_output+3, #0
1363 0214FE    2804            ljmp power_control_done
1366           2805   
1366           2806   state1_power_control:
1366           2807            ; idle
1366           2808            ; 0% power
1366 B4010F    2809            cjne a, #1, state2_power_control
1369 755800    2810            mov power_output, #low(NO_POWER)
136C 755900    2811            mov power_output+1, #low(NO_POWER)
136F 755A00    2812            mov power_output+2, #0
1372 755B00    2813            mov power_output+3, #0
1375 0214FE    2814            ljmp power_control_done
1378           2815            
1378           2816   state2_power_control:
1378           2817            ; ramp to soak, ramp to ~150C
1378           2818            ; 100% power
1378 B4020F    2819            cjne a, #2, state3_power_control
137B 7558DC    2820            mov power_output, #low(MAX_POWER)
137E 755905    2821            mov power_output+1, #high(MAX_POWER)
1381 755A00    2822            mov power_output+2, #0
1384 755B00    2823            mov power_output+3, #0
1387 0214FE    2824            ljmp power_control_done
138A           2825   
138A           2826   state3_power_control:
138A           2827            ; soak period, hold at 150C
138A           2828            ; 20% base power + proportional calculated power
138A B40302    2829            cjne a, #3, jump_state4_power_control
138D 8003      2830            sjmp state3_power_control_calculation
138F           2831   
138F           2832   jump_state4_power_control:
138F 0214BC    2833            ljmp state4_power_control
1392           2834   
1392           2835   state3_power_control_calculation:
1392           2836            ; move soak_temp to x
1392 854B3A    2837            mov x, soak_temp
1395 854C3B    2838            mov x+1, soak_temp+1
1398 854D3C    2839            mov x+2, soak_temp+2
139B 854E3D    2840            mov x+3, soak_temp+3
139E           2841            ; move current_temp to y
139E 85473E    2842            mov y, current_temp
13A1 85483F    2843            mov y+1, current_temp+1
13A4 854940    2844            mov y+2, current_temp+2
13A7 854A41    2845            mov y+3, current_temp+3
13AA           2846   
13AA           2847            ; compare between soak_temp and current_temp
13AA C200      2848            clr mf
13AC 120178    2849            lcall x_gteq_y
13AF 10002B    2850            jbc mf, st_sub_ct
13B2           2851            ; current_temp - soak_temp if st < ct
13B2 C228      2852            clr soak_temp_greater
13B4           2853            ; move current_temp to y
13B4 854B3E    2854            mov y, soak_temp
13B7 854C3F    2855            mov y+1, soak_temp+1
13BA 854D40    2856            mov y+2, soak_temp+2
13BD 854E41    2857            mov y+3, soak_temp+3
13C0           2858            ; move current_temp to x
13C0 85473A    2859            mov x, current_temp
13C3 85483B    2860            mov x+1, current_temp+1
13C6 85493C    2861            mov x+2, current_temp+2
13C9 854A3D    2862            mov x+3, current_temp+3
13CC 1200F6    2863            lcall sub32
13CF 853A62    2864            mov soak_temp_diff, x
13D2 853B63    2865            mov soak_temp_diff+1, x+1
13D5 853C64    2866            mov soak_temp_diff+2, x+2
13D8 853D65    2867            mov soak_temp_diff+3, x+3
13DB 8011      2868            sjmp proportional_input_soak
13DD           2869   
13DD           2870   st_sub_ct:
13DD           2871            ; soak_temp - current_temp
13DD D228      2872            setb soak_temp_greater
13DF 1200F6    2873            lcall sub32
13E2 853A62    2874            mov soak_temp_diff, x
13E5 853B63    2875            mov soak_temp_diff+1, x+1
13E8 853C64    2876            mov soak_temp_diff+2, x+2
13EB 853D65    2877            mov soak_temp_diff+3, x+3
13EE           2878   
13EE           2879   proportional_input_soak:
13EE           2880            ; proportaional block calculation       
13EE           2881            ; move soak_temp_diff to x
13EE 85623A    2882            mov x, soak_temp_diff
13F1 85633B    2883            mov x+1, soak_temp_diff+1
13F4 85643C    2884            mov x+2, soak_temp_diff+2
13F7 85653D    2885            mov x+3, soak_temp_diff+3
13FA           2886            ; move proportional gain to y
13FA 753E05    2887            mov y+0, #low (KP % 0x10000) 
13FD 753F00    2887            mov y+1, #high(KP % 0x10000) 
1400 754000    2887            mov y+2, #low (KP / 0x10000) 
1403 754100    2887            mov y+3, #high(KP / 0x10000) 
1406 12018C    2888            lcall mul32 ; proportional_output = proportional_gain * difference
1409           2889            
1409 853A66    2890            mov proportional_gain_var, x
140C 853B67    2891            mov proportional_gain_var+1, x+1
140F 853C68    2892            mov proportional_gain_var+2, x+2
1412 853D69    2893            mov proportional_gain_var+3, x+3
1415           2894   
1415           2895            ; base_power + soak_power when soak_temp > current_temp
1415 302829    2896            jnb soak_temp_greater, sub_proportional_soak
1418 85663A    2897            mov x, proportional_gain_var
141B 85673B    2898            mov x+1, proportional_gain_var+1
141E 85683C    2899            mov x+2, proportional_gain_var+2
1421 85693D    2900            mov x+3, proportional_gain_var+3
1424 753E2C    2901            mov y+0, #low (BASE_POWER % 0x10000) 
1427 753F01    2901            mov y+1, #high(BASE_POWER % 0x10000) 
142A 754000    2901            mov y+2, #low (BASE_POWER / 0x10000) 
142D 754100    2901            mov y+3, #high(BASE_POWER / 0x10000) 
1430 1200D3    2902            lcall add32
1433           2903            ; x now holds the power output before the saturator
1433 853A66    2904            mov proportional_gain_var, x
1436 853B67    2905            mov proportional_gain_var+1, x+1
1439 853C68    2906            mov proportional_gain_var+2, x+2
143C 853D69    2907            mov proportional_gain_var+3, x+3
143F 803D      2908            sjmp saturator_soak
1441           2909   
1441           2910   sub_proportional_soak:
1441           2911            ; base_power - soak_power when soak_temp <= current_temp
1441 753A2C    2912            mov x+0, #low (BASE_POWER % 0x10000) 
1444 753B01    2912            mov x+1, #high(BASE_POWER % 0x10000) 
1447 753C00    2912            mov x+2, #low (BASE_POWER / 0x10000) 
144A 753D00    2912            mov x+3, #high(BASE_POWER / 0x10000) 
144D 85663E    2913            mov y, proportional_gain_var
1450 85673F    2914            mov y+1, proportional_gain_var+1
1453 856840    2915            mov y+2, proportional_gain_var+2
1456 856941    2916            mov y+3, proportional_gain_var+3
1459           2917   
1459           2918            ; compare whether base_power < proportional_gain_var
1459 C200      2919            clr mf
145B 12011A    2920            lcall x_lt_y ; set mf to 1 if base_power < proportional_gain_var, clamp output to 0
145E 30000E    2921            jnb mf, bp_gteq_pgv
1461 756600    2922            mov proportional_gain_var, #low(NO_POWER)
1464 756700    2923            mov proportional_gain_var+1, #high(NO_POWER)
1467 756800    2924            mov proportional_gain_var+2, #0
146A 756900    2925            mov proportional_gain_var+3, #0
146D 800F      2926            sjmp saturator_soak
146F           2927   
146F           2928   bp_gteq_pgv:
146F           2929            ; calculate subtracted gain
146F 1200F6    2930            lcall sub32
1472           2931            ; x now holds the power output before the saturator
1472 853A66    2932            mov proportional_gain_var, x
1475 853B67    2933            mov proportional_gain_var+1, x+1
1478 853C68    2934            mov proportional_gain_var+2, x+2
147B 853D69    2935            mov proportional_gain_var+3, x+3
147E           2936   
147E           2937   saturator_soak:
147E           2938            ; proportional_gain_var now holds the power output before the saturator
147E           2939            ; saturate power output to max power
147E 85663A    2940            mov x, proportional_gain_var
1481 85673B    2941            mov x+1, proportional_gain_var+1
1484 85683C    2942            mov x+2, proportional_gain_var+2
1487 85693D    2943            mov x+3, proportional_gain_var+3
148A           2944   
148A 753EDC    2945            mov y+0, #low (MAX_POWER % 0x10000) 
148D 753F05    2945            mov y+1, #high(MAX_POWER % 0x10000) 
1490 754000    2945            mov y+2, #low (MAX_POWER / 0x10000) 
1493 754100    2945            mov y+3, #high(MAX_POWER / 0x10000) 
1496           2946   
1496 C200      2947            clr mf
1498 120136    2948            lcall x_gt_y ; set mf to 1 if calculated power output greater than max power
149B 20000F    2949            jb mf, saturated_soak
149E           2950            ; set power_output to calculated power if not saturated
149E 856658    2951            mov power_output, proportional_gain_var
14A1 856759    2952            mov power_output+1, proportional_gain_var+1
14A4 85685A    2953            mov power_output+2, proportional_gain_var+2
14A7 85695B    2954            mov power_output+3, proportional_gain_var+3
14AA 0214FE    2955            ljmp power_control_done
14AD           2956   
14AD           2957   saturated_soak:
14AD 7558DC    2958            mov power_output, #low(MAX_POWER)
14B0 755905    2959            mov power_output+1, #high(MAX_POWER)
14B3 755A00    2960            mov power_output+2, #0
14B6 755B00    2961            mov power_output+3, #0
14B9 0214FE    2962            ljmp power_control_done
14BC           2963   
14BC           2964   
14BC           2965   state4_power_control:
14BC           2966            ; ramp to reflow, max power
14BC B4040F    2967            cjne a, #4, state5_power_control
14BF 7558DC    2968            mov power_output, #low(MAX_POWER)
14C2 755905    2969            mov power_output+1, #high(MAX_POWER)
14C5 755A00    2970            mov power_output+2, #0
14C8 755B00    2971            mov power_output+3, #0
14CB 0214FE    2972            ljmp power_control_done
14CE           2973   
14CE           2974   state5_power_control:
14CE           2975            ; reflow 20% base power
14CE B4050F    2976            cjne a, #5, state6_power_control
14D1 75582C    2977            mov power_output, #low(BASE_POWER)  
14D4 755901    2978            mov power_output+1, #high(BASE_POWER)
14D7 755A00    2979            mov power_output+2, #0
14DA 755B00    2980            mov power_output+3, #0
14DD 0214FE    2981            ljmp power_control_done
14E0           2982   
14E0           2983   state6_power_control:
14E0           2984            ; cooling 0% power
14E0 B4060F    2985            cjne a, #6, state_7_power_control
14E3 755800    2986            mov power_output, #low(NO_POWER)
14E6 755900    2987            mov power_output+1, #high(NO_POWER)
14E9 755A00    2988            mov power_output+2, #0
14EC 755B00    2989            mov power_output+3, #0
14EF 0214FE    2990            ljmp power_control_done
14F2           2991   
14F2           2992   state_7_power_control:
14F2           2993            ; idle 0% power
14F2 755800    2994            mov power_output, #low(NO_POWER)
14F5 755900    2995            mov power_output+1, #high(NO_POWER)
14F8 755A00    2996            mov power_output+2, #0
14FB 755B00    2997            mov power_output+3, #0
14FE           2998   
14FE           2999   power_control_done:
14FE 22        3000            ret
14FF           3001   
14FF           3002   ;-------------------------------------------------------------------------------;
14FF           3003   ;         Main program.          
14FF           3004   ;-------------------------------------------------------------------------------;
14FF           3005   main:
14FF           3006   
14FF           3007       ; --------------------------------------------------------
14FF           3008       ; 1. SAFETY SHUTDOWN
14FF           3009       ; --------------------------------------------------------
14FF C2AF      3010       clr EA              ; FORCE Interrupts OFF immediately
1501 7581C0    3011       mov SP, #0xC0       ; Reset Stack Pointer to safe location
1504           3012       
1504           3013       ; --------------------------------------------------------
1504           3014       ; THE "DIRTY DELAY" (Fixes Reset Garbage)
1504           3015       ; We burn ~100ms here using a raw loop. 
1504           3016       ; We cannot use timers yet because they aren't initialized.
1504           3017       ; --------------------------------------------------------
1504 78FA      3018       mov R0, #250
1506           3019   Reset_Delay_Outer:
1506 79FF      3020       mov R1, #255
1508           3021   Reset_Delay_Inner:
1508 D9FE      3022       djnz R1, Reset_Delay_Inner
150A D8FA      3023       djnz R0, Reset_Delay_Outer
150C           3024       
150C           3025       ; --- PORT CONFIGURATION ---
150C 759AAA    3026       mov P0MOD, #0xAA
150F           3027       ; P1: Mixed usage 
150F           3028       ; P1.7(LCD_RS), P1.6(Row3), P1.5(Sound), P1.4(Row2)
150F           3029       ; P1.3(PWM), P1.2(Row1), P1.1(LCD_E) -> All Outputs
150F           3030       ; P1.0 (Unused/RX) -> Input
150F           3031       ; Binary: 11111110 -> Hex: 0xFE
150F 759BFE    3032       mov P1MOD, #0xFE
1512           3033   
1512           3034       ; P2: Row4(Out), Cols(In)
1512           3035       ; P2.0 (Row4) is Out (1). P2.2, P2.4, P2.6 (Cols) are In (0).
1512           3036       ; Binary: 00000001 -> Hex: 0x01
1512 759C01    3037       mov P2MOD, #0x01
1515           3038   
1515           3039       ; P3: Col4(In)
1515           3040       ; P3.0 (Col4) is In (0).
1515 759D00    3041       mov P3MOD, #0x00
1518           3042       ; Turn off all the LEDs
1518 75E800    3043       mov LEDRA, #0 ; LEDRA is bit addressable
151B 759500    3044       mov LEDRB, #0 ; LEDRB is NOT bit addresable
151E           3045   
151E           3046       ; Enable Global interrupts
151E D2AF      3047       setb EA  
1520           3048   
1520           3049            ; FSM initial states
1520 757000    3050            mov SEC_FSM_state, #0
1523 756000    3051            mov Control_FSM_state, #0
1526 756100    3052            mov Current_State, #0
1529           3053            ; FSM timers initialization
1529 756F00    3054            mov SEC_FSM_timer, #0
152C           3055            ; time counters initialization
152C 753000    3056            mov current_time_sec, #0
152F 753100    3057            mov current_time_minute, #0
1532 753200    3058            mov soak_time_sec, #0
1535 753300    3059            mov soak_time_minute, #0
1538 753400    3060            mov reflow_time_sec, #0
153B 753500    3061            mov reflow_time_minute, #0
153E 753600    3062            mov soak_end_time_sec, #0
1541 753700    3063            mov soak_end_time_minute, #0
1544 753800    3064            mov reflow_end_time_sec, #0
1547 753900    3065            mov reflow_end_time_minute, #0
154A           3066       ; Initialize counter to zero
154A 755C00    3067       mov pwm_counter, #0
154D 755D00    3068       mov pwm_counter+1, #0
1550 755E00    3069       mov pwm_counter+2, #0
1553 755F00    3070       mov pwm_counter+3, #0
1556           3071       ; Initialize power output
1556 755B00    3072       mov power_output+3, #0
1559 755A00    3073       mov power_output+2, #0
155C 755902    3074       mov power_output+1, #02H
155F 7558EE    3075       mov power_output, #0EEH ; (initilize to 750 for testing)
1562           3076            ; FSM Buttons push button init
1562 757200    3077            mov     PB0_DEB_state, #0
1565 757400    3078            mov     PB2_DEB_state, #0
1568 757100    3079            mov     PB0_DEB_timer, #0
156B 757300    3080            mov     PB2_DEB_timer, #0
156E           3081       ; [FIX] ADD THIS BLOCK TO STOP STARTUP BEEP
156E 757600    3082       mov beep_state, #0
1571 757500    3083       mov beep_count, #0
1574 757700    3084       mov beep_tmr, #0
1577 757800    3085       mov beep_tmr+1, #0
157A           3086       ; Buttons 
157A 757A00    3087       mov BTN_DEB_state, #0
157D 757B00    3088       mov BTN_DEB_timer, #0
1580 757C00    3089       mov BTN_DEB_id, #0
1583 757900    3090       mov servo_pwm_counter, #0
1586 757D00    3091       mov rx_idx, #0
1589 757E00    3092       mov rx_ready, #0
158C C218      3093       clr one_ms_beep_flag
158E C28C      3094       clr TR0 ; Force buzzer hardware OFF
1590           3095   
1590           3096            ; Clear all the flags
1590 C295      3097            clr SOUND_OUT
1592 C219      3098       clr beep_error_done
1594 C213      3099            clr tc_missing_abort
1596 C20B      3100            clr stop_signal
1598 C215      3101            clr PB0_flag
159A C216      3102            clr PB1_flag
159C C217      3103            clr PB2_flag
159E C201      3104            clr one_second_flag
15A0 C204      3105            clr one_second_lcd_flag
15A2 C20E      3106            clr config_finish_signal
15A4 C20D      3107       clr time_count_doing_signal
15A6 C224      3108       clr fullscreen_update_signal
15A8 C205      3109            clr soak_temp_reached
15AA C208      3110            clr soak_time_reached
15AC C206      3111            clr reflow_temp_reached
15AE C209      3112            clr reflow_time_reached
15B0 C207      3113            clr cooling_temp_reached
15B2 C210      3114       clr state_change_signal_TC
15B4 C211      3115            clr state_change_signal_Count
15B6 C212      3116       clr state_change_beep_signal
15B8 C226      3117       clr one_millisecond_flag_servo
15BA C229      3118       clr remote_config_mode
15BC           3119       ; Set bit
15BC D20F      3120            setb state_change_signal
15BE D214      3121       setb tc_startup_window
15C0           3122   
15C0 12045D    3123       lcall Timer0_Init
15C3 1206A6    3124       lcall Timer2_Init
15C6 120779    3125       lcall ELCD_4BIT
15C9           3126       ;----- Two new lines I added to initialize the UI
15C9 1211BD    3127       lcall Init_All_Buffers
15CC 120477    3128       lcall Initialize_Serial_Port
15CF           3129   ;-------------------------------------------------------------------------------;
15CF           3130   ; while(1) loop
15CF           3131   ;-------------------------------------------------------------------------------;
15CF           3132   loop:
15CF           3133   
15CF 120BC4    3134            lcall SEC_FSM
15D2           3135   
15D2           3136            ; Check the FSM for the overall control flow of the reflow process
15D2 120E73    3137       lcall Control_FSM
15D5           3138   
15D5           3139       ; Check the FSM for PB01 debounce
15D5 120B56    3140       lcall PB0_DEB
15D8 120B8E    3141            lcall PB2_DEB
15DB           3142       
15DB           3143       ; Added to take temp readings
15DB 121210    3144       lcall Read_Thermocouple
15DE           3145       
15DE           3146       ; 1. Check if we reached temp (Observer)
15DE 120CAF    3147       lcall Temp_Compare
15E1           3148       
15E1           3149       ; 2. Decide heater power based on flags (Driver)
15E1           3150       ;lcall Power_Control
15E1 121352    3151       lcall proportional_power_control
15E4           3152       
15E4 120DA0    3153       lcall Safety_Check_TC
15E7           3154   
15E7 120C20    3155            lcall Time_Counter
15EA           3156   
15EA           3157            ; Update Variables (times and temp)
15EA 120F4E    3158            lcall Update_FSM_Variables
15ED           3159   
15ED           3160       ; GUI Interface polling uart port
15ED 1204AC    3161       lcall Serial_RX_Pump
15F0 120505    3162       lcall Serial_Process_Line
15F3           3163   
15F3           3164            ; Update while at state 1
15F3           3165            ; LCD
15F3 120A02    3166            lcall Update_Screen_Full 
15F6           3167            ; Buttons
15F6 120FD2    3168            lcall Check_Buttons 
15F9           3169            ; PB0pad
15F9 121091    3170       lcall Check_Keypad
15FC           3171   
15FC           3172       ; Update the LCD display based on the current state
15FC 12083E    3173       lcall LCD_Display_Update_func
15FF           3174   
15FF 120C42    3175            lcall Time_Compare_MMSS
1602           3176   
1602           3177       ; Update the pwm output for the ssr
1602 120D29    3178       lcall PWM_Wave 
1605           3179            ; Update the Buzzer 
1605 120E3A    3180            lcall Beep_Task
1608           3181       ; Update the pwm output for the servo
1608 1212E5    3182       lcall call_servo_control
160B           3183   
160B 120DF1    3184       lcall Beep_Judge
160E           3185   
160E           3186       ; After initialization the program stays in this 'forever' loop
160E 0215CF    3187       ljmp loop
1611           3188   ;-------------------------------------------------------------------------------;
1611           3189   EN
