0000              1   ; Project 1
0000              2   ; CV-8052 microcontroller in DE10-Lite board
0000              3   ;-------------------------------------------------------------------------------
0000              4   ; Reset vector
0000              5   org 0x0000
0000 020BC1       6       ljmp main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9       reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 02046E      12       ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15       reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18       reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 32          21       reti
0024             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
002B 02052E      24       ljmp Timer2_ISR
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 32   $LIST
0320             34   ; ----------------------------------------------------------------------------------------------;
0320             35   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             36   dseg at 0x30
0030             37   current_time_sec:     ds 1
0031             38   current_time_minute:  ds 1
0032             39   ; math32 buffer variables
0032             40   x:      ds  4
0036             41   y:      ds  4
003A             42   bcd:    ds  5
003F             43   
003F             44   current_temp: ds 4 ;
0043             45   soak_temp:    ds 4 ;
0047             46   reflow_temp:  ds 4 ;
004B             47   
004B             48   wait25_btn_cnt:    ds 1
004C             49   wait25_keypad_cnt: ds 1
004D             50   wait25_adc_cnt:    ds 1
004E             51   wait25_lcd_cnt:    ds 1
004F             52   wait25_count: ds 1  
0050             53   
0050             54   current_time: ds 4 ;
0054             55   soak_time:    ds 4 ;
0058             56   reflow_time:  ds 4 ;
005C             57   
005C             58   power_output:  ds 4 ;
0060             59   pwm_counter: ds 4 ; counter for pwm (0-1500)
0064             60   
0064             61   KEY1_DEB_timer: ds 1
0065             62   SEC_FSM_timer:  ds 1
0066             63   KEY1_DEB_state:    ds 1
0067             64   SEC_FSM_state:     ds 1
0068             65   Control_FSM_state: ds 1 
0069             66   
0069             67   Current_State:     ds 1
006A             68   
006A             69   
006A             70   ;-- UI buffers I added (ayaan)
006A             71   Cursor_Idx: ds 1
006B             72   
006B             73   ; These hold the TEXT (ASCII) safely
006B             74   ; Digits Only + Null Terminator, got rid of C,:, and s 
006B             75   
006B             76   ; Buzzer state
006B             77   beep_count:  ds 1      ; remaining beeps
006C             78   beep_state:  ds 1      ; 0=idle, 1=ON, 2=OFF
006D             79   beep_tmr:    ds 2      ; 16-bit ms timer (needs to reach 500)
006F             80   
006F             81   servo_pwm_counter: ds 1 ; counter for the servo pwm signal
0070             82   
0080             83   iseg at 0x80
0080             84   Buf_Soak_Temp: ds 4   
0084             85   Buf_Soak_Time: ds 5   
0089             86   Buf_Refl_Temp: ds 4   
008D             87   Buf_Refl_Time: ds 5
0092             88   
0092             89   
0092             90   
0092             91   ; 46d bytes used
0092             92   
0092             93   ;-------------------------------------------------------------------------------
0092             94   ; bit operation setb, clr, jb, and jnb
0000             95   bseg
0000             96   mf:     dbit 1 ; math32 sign
0001             97   one_second_flag: dbit 1
0002             98   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003             99   
0003            100   soak_temp_reached: dbit 1
0004            101   reflow_temp_reached: dbit 1
0005            102   cooling_temp_reached: dbit 1
0006            103   
0006            104   soak_time_reached: dbit 1
0007            105   reflow_time_reached: dbit 1
0008            106   
0008            107   reset_signal: dbit 1
0009            108   stop_signal: dbit 1
000A            109   start_signal: dbit 1
000B            110   config_finish_signal: dbit 1
000C            111   
000C            112   state_change_signal: dbit 1
000D            113   
000D            114   Key1_flag: dbit 1
000E            115   
000E            116   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
000F            117   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0010            118   PB0_flag: dbit 1 ; start entire program
0011            119   PB1_flag: dbit 1 ; start soak
0012            120   PB2_flag: dbit 1 ; pause process
0013            121   
0013            122   ;buzzer beep
0013            123   one_ms_beep_flag: dbit 1
0014            124   
0014            125   ; BSEG (Bit Segment)
0014            126   wait25_active: dbit 1 ; 1 = We are currently waiting
0015            127   wait25_done:   dbit 1 ; 1 = The 25ms has finished
0016            128   wait25_btn_active:    dbit 1
0017            129   wait25_btn_done:      dbit 1
0018            130   wait25_keypad_active: dbit 1
0019            131   wait25_keypad_done:   dbit 1
001A            132   wait25_adc_active:    dbit 1
001B            133   wait25_adc_done:      dbit 1
001C            134   wait25_lcd_active:    dbit 1
001D            135   wait25_lcd_done:      dbit 1
001E            136   
001E            137   one_millisecond_flag_servo: dbit 1 ; set the one millsiecond flag for servo pwm signal generation
001F            138   servo_angle_zero: dbit 1 ; flag for indicating whether the servo angle should be at 0 or not: 1 -> 0; 0 -> 180
0020            139   ; 11 bits used
0020            140   
0020            141   ;-------------------------------------------------------------------------------
0320            142   cseg
0320            143   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            144   BAUD           EQU 57600
0320            145   
0320            146   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            147   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            148   ; is always 12 unlike the N76E003 where is selectable.
0320            149   
0320            150   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            151   
0320            152   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            153   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            154   
0320            155   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            156   
0320            157   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            158   
0320            159   PWM_OUT        EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            160   
0320            161   ; These 'equ' must match the wiring between the DE10Lite board and the LCD!
0320            162   ; P0 is in connector JPIO.
0320            163   
0320            164   ;Added correct I/O definitions
0320            165   ;-- LCD Pins ---
0320            166   ELCD_RS equ P1.7
0320            167   ELCD_E  equ P1.1
0320            168   ELCD_D4 equ P0.7
0320            169   ELCD_D5 equ P0.5
0320            170   ELCD_D6 equ P0.3
0320            171   ELCD_D7 equ P0.1
0320            172   
0320            173   ; -- Buttons --
0320            174   BTN_SOAK_TEMP equ P0.0
0320            175   BTN_SOAK_TIME equ P0.2
0320            176   BTN_REFL_TEMP equ P0.4
0320            177   BTN_REFL_TIME equ P0.6
0320            178   
0320            179   ; --- KEYPAD ---
0320            180   ROW1 equ P1.2
0320            181   ROW2 equ P1.4
0320            182   ROW3 equ P1.6
0320            183   ROW4 equ P2.0
0320            184   COL1 equ P2.2
0320            185   COL2 equ P2.4
0320            186   COL3 equ P2.6
0320            187   COL4 equ P3.0
0320            188   
0320            189   SERVO_OUT      EQU p3.6 ; servo pin
0320            190   
0320            191   SERVO_PERIOD   EQU 20 ; pwm signal period for the servo motor (20 ms)
0320            192   SERVO_0        EQU 1 ; pwm high time for the servo motor to stay at 0 degree
0320            193   SERVO_180      EQU 2 ; pwm high time for the servo motor to stay at 180 degrees
0320            194   
0320            195   COLD_JUNCTION_TEMP equ 20
0320            196   
0320            197   ;                     1234567890123456 <-- 16 characters per line LCD
0320 696E6974   198   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   199   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   200   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            201   
0350            202   ; --- UI STRINGS (REQUIRED FOR KEYPAD LOGIC), <- I can fix if duplicates
0350 53656C65   203   Txt_Home:     db 'Select Mode:    ', 0
     6374204D
     6F64653A
     20202020
     00
0361 53657420   204   Txt_SoakT:    db 'Set Soak Temp   ', 0
     536F616B
     2054656D
     70202020
     00
0372 53657420   205   Txt_SoakTime: db 'Set Soak Time   ', 0
     536F616B
     2054696D
     65202020
     00
0383 53657420   206   Txt_ReflT:    db 'Set Reflow Temp ', 0
     5265666C
     6F772054
     656D7020
     00
0394 53657420   207   Txt_ReflTime: db 'Set Reflow Time ', 0
     5265666C
     6F772054
     696D6520
     00
03A5            208   
03A5            209   ;                       1234567890123456
03A5 53657420   210   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
03B5 536F616B   211   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
03C0 5265666C   212   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
03CD 536F616B   213   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
03D8 5265666C   214   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03E5            215   
03E5 54656D70   216   String_temp_line:  db 'Temp: ', 0
     3A2000
03EC            217   
03EC            218   ;                     1234567890123456
03EC 52616D70   219   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03FC 536F616B   220   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
040C 52616D70   221   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
041C 5265666C   222   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
042C 436F6F6C   223   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
043C 50726F63   224   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
044C            225   
044C 20202020   226   String_Blank:    db '                ', 0
     20202020
     20202020
     20202020
     00
045D            227   
045D            228   ;-------------------------------------------------------------------------------
045D            229   ; Timers Setting:
045D            230   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
045D            231   ;   Timer 1: Serial port baud rate 57600 generator
045D            232   ;   Timer 2: 1ms interrupt for BCD counter increment/decrement
045D            233   ;-------------------------------------------------------------------------------
045D            234   ; Routine to initialize the ISR for Timer 0 ;
045D            235   Timer0_Init:
045D E589       236       mov a, TMOD
045F 54F0       237       anl a, #0xf0 ; Clear the bits for timer 0
0461 4401       238       orl a, #0x01 ; Configure timer 0 as 16-timer
0463 F589       239       mov TMOD, a
0465 758CFD     240       mov TH0, #high(TIMER0_RELOAD)
0468 758A5A     241       mov TL0, #low(TIMER0_RELOAD)
046B            242       ; Enable the timer and interrupts
046B D2A9       243       setb ET0  ; Enable timer 0 interrupt
046D            244       ; setb TR0  (no need to open at first)
046D 22         245       ret
046E            246   ; ISR for timer 0.  Set to execute every 1/4096Hz 
046E            247   ; to generate a 2048 Hz square wave at pin P1.5 
046E            248   Timer0_ISR:
046E            249       ;clr TF0  ; According to the data sheet this is done for us already.
046E 758CFD     250       mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
0471 758A5A     251       mov TL0, #low(TIMER0_RELOAD)
0474 B295       252       cpl SOUND_OUT ; Connect speaker to P1.5
0476 32         253       reti
0477            254   ; -----------------------------------------------------------------------------------------------;
0477            255   
0477            256   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
0477            257   Initialize_Serial_Port:
0477            258       ; Configure serial port and baud rate
0477 C28E       259       clr TR1 ; Disable timer 1
0479 53890F     260       anl TMOD, #0x0f ; Mask the bits for timer 1
047C 438920     261       orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
047F 438780     262       orl PCON, #80H ; Set SMOD to 1
0482 758DFD     263       mov TH1, #low(TIMER_1_RELOAD)
0485 758BFD     264       mov TL1, #low(TIMER_1_RELOAD) 
0488 D28E       265       setb TR1 ; Enable timer 1
048A 759852     266       mov SCON, #52H
048D 22         267       ret
048E            268   
048E            269   ; uart sending functions
048E            270   putchar:
048E 109902     271       jbc TI, putchar_L1
0491 80FB       272       sjmp putchar
0493            273   putchar_L1:
0493 F599       274       mov SBUF,a
0495 22         275       ret
0496            276   
0496            277   SendString:
0496 E4         278       clr a
0497 93         279       movc a, @a+dptr
0498 6006       280       jz SendString_L1
049A 12048E     281       lcall putchar
049D A3         282       inc dptr
049E 80F6       283       sjmp SendString  
04A0            284   SendString_L1:
04A0 22         285       ret
04A1            286   
04A1            287   ;-------------------------------------------------------------------------------
04A1            288   ; serial debugging
04A1            289   ; send a four byte number via serial to laptop
04A1            290   ; need to be used with python script
04A1            291   ; content needed to be sent should be stored in the varaible x
04A1            292   ;-------------------------------------------------------------------------------
04A1            293   Send32:
04A1            294       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
04A1 74AA       295       mov A, #0AAH
04A3 12048E     296       lcall putchar
04A6 7455       297       mov A, #055H
04A8 12048E     298       lcall putchar
04AB            299   
04AB E535       300       mov A, x+3
04AD 12048E     301       lcall putchar
04B0 E534       302       mov A, x+2
04B2 12048E     303       lcall putchar
04B5 E533       304       mov A, x+1
04B7 12048E     305       lcall putchar
04BA E532       306       mov A, x+0
04BC 12048E     307       lcall putchar
04BF            308   
04BF 740A       309       mov A, #0AH
04C1 12048E     310       lcall putchar
04C4 22         311       ret
04C5            312   ; -----------------------------------------------------------------------------------------------;
04C5            313   
04C5            314   ;-------------------------------------------------------------------------------
04C5            315   ; Serial temperature line for PuTTY/screen
04C5            316   ; Outputs: "Temp: XXXC\r\n"
04C5            317   ;-------------------------------------------------------------------------------
04C5            318   Serial_Send_Temp_Line:
04C5 9003E5     319       mov dptr, #String_temp_line
04C8 120496     320       lcall SendString
04CB            321   
04CB            322       ; Convert current_temp to BCD (same as LCD)
04CB 853F32     323       mov x, current_temp
04CE 854033     324       mov x+1, current_temp+1
04D1 854134     325       mov x+2, current_temp+2
04D4 854235     326       mov x+3, current_temp+3
04D7 12002E     327       lcall hex2bcd
04DA            328   
04DA 7F00       329       mov R7, #0          ; printed_flag = 0
04DC            330   
04DC            331       ; Print Hundreds (if non-zero)
04DC E53B       332       mov a, bcd+1
04DE 540F       333       anl a, #0x0F
04E0 6007       334       jz Serial_Skip_Hundreds
04E2 2430       335       add a, #0x30
04E4 12048E     336       lcall putchar
04E7 7F01       337       mov R7, #1
04E9            338   Serial_Skip_Hundreds:
04E9            339   
04E9            340       ; Print Tens (if non-zero or if hundreds already printed)
04E9 E53A       341       mov a, bcd+0
04EB C4         342       swap a
04EC 540F       343       anl a, #0x0F
04EE 7003       344       jnz Serial_Print_Tens
04F0 EF         345       mov a, R7
04F1 600C       346       jz Serial_Skip_Tens
04F3            347   Serial_Print_Tens:
04F3 E53A       348       mov a, bcd+0
04F5 C4         349       swap a
04F6 540F       350       anl a, #0x0F
04F8 2430       351       add a, #0x30
04FA 12048E     352       lcall putchar
04FD 7F01       353       mov R7, #1
04FF            354   Serial_Skip_Tens:
04FF            355   
04FF            356       ; Print Ones (always)
04FF E53A       357       mov a, bcd+0
0501 540F       358       anl a, #0x0F
0503 2430       359       add a, #0x30
0505 12048E     360       lcall putchar
0508            361   
0508            362       ; Print 'C' and newline
0508 7443       363       mov a, #'C'
050A 12048E     364       lcall putchar
050D 740D       365       mov a, #0DH     ; CR
050F 12048E     366       lcall putchar
0512 740A       367       mov a, #0AH     ; LF
0514 12048E     368       lcall putchar
0517 22         369       ret
0518            370   
0518            371   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
0518              1   ;-------------------------------------------------------------------------------
0518              2   ; Timer2_ISR.inc
0518              3   ; Contains Initialization and ISR for the 1ms System Timer
0518              4   ;-------------------------------------------------------------------------------
0518              5   
0518              6   ;-------------------------------------------------------------------------------
0518              7   ; Routine to initialize the ISR for timer 2
0518              8   ;-------------------------------------------------------------------------------
0518              9   Timer2_Init:
0518 75C800      10       mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
051B 75CDF5      11       mov TH2, #high(TIMER2_RELOAD)
051E 75CC27      12       mov TL2, #low(TIMER2_RELOAD)
0521             13       ; Set the reload value
0521 75CBF5      14       mov RCAP2H, #high(TIMER2_RELOAD)
0524 75CA27      15       mov RCAP2L, #low(TIMER2_RELOAD)
0527             16       
0527 C2CF        17       clr TF2       ; Clear flag just in case
0529             18       ; Enable the timer and interrupts
0529 D2AD        19       setb ET2      ; Enable timer 2 interrupt
052B D2CA        20       setb TR2      ; Enable timer 2
052D 22          21       ret
052E             22   
052E             23   ;-------------------------------------------------------------------------------
052E             24   ; ISR for timer 2.  Runs every 1 ms
052E             25   ;-------------------------------------------------------------------------------
052E             26   Timer2_ISR:
052E C0E0        27       push acc
0530 C0D0        28       push psw
0532             29       
0532 C2CF        30       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
0534             31   
0534             32       ; --- 1. Existing FSM Timers ---
0534 0564        33       inc KEY1_DEB_timer
0536 0565        34       inc SEC_FSM_timer
0538 D202        35       setb one_ms_pwm_flag 
053A D213        36       setb one_ms_beep_flag
053C D21E        37       setb one_millisecond_flag_servo
053E             38   
053E             39       ; --- 2. NEW: Non-Blocking Delay Counters ---
053E             40       
053E             41       ; A. BUTTON DELAY
053E 30160B      42       jnb wait25_btn_active, T2_Check_Keypad
0541 054B        43       inc wait25_btn_cnt
0543 E54B        44       mov a, wait25_btn_cnt
0545 B41904      45       cjne a, #25, T2_Check_Keypad
0548 D217        46       setb wait25_btn_done
054A C216        47       clr wait25_btn_active
054C             48       
054C             49       ; B. KEYPAD DELAY
054C             50   T2_Check_Keypad:
054C 30180B      51       jnb wait25_keypad_active, T2_Check_ADC
054F 054C        52       inc wait25_keypad_cnt
0551 E54C        53       mov a, wait25_keypad_cnt
0553 B41904      54       cjne a, #25, T2_Check_ADC
0556 D219        55       setb wait25_keypad_done
0558 C218        56       clr wait25_keypad_active
055A             57   
055A             58       ; C. ADC DELAY (Thermocouple)
055A             59   T2_Check_ADC:
055A 301A0B      60       jnb wait25_adc_active, T2_Check_LCD
055D 054D        61       inc wait25_adc_cnt
055F E54D        62       mov a, wait25_adc_cnt
0561 B41904      63       cjne a, #25, T2_Check_LCD
0564 D21B        64       setb wait25_adc_done
0566 C21A        65       clr wait25_adc_active
0568             66   
0568             67       ; D. LCD DELAY
0568             68   T2_Check_LCD:
0568 301C0B      69       jnb wait25_lcd_active, T2_Check_Generic
056B 054E        70       inc wait25_lcd_cnt
056D E54E        71       mov a, wait25_lcd_cnt
056F B41904      72       cjne a, #25, T2_Check_Generic
0572 D21D        73       setb wait25_lcd_done
0574 C21C        74       clr wait25_lcd_active
0576             75   
0576             76       ; E. GENERIC DELAY (Used by Wait_25ms in Main)
0576             77   T2_Check_Generic:
0576 30140B      78       jnb wait25_active, Timer2_ISR_done
0579 054F        79       inc wait25_count
057B E54F        80       mov a, wait25_count
057D B41904      81       cjne a, #25, Timer2_ISR_done
0580 D215        82       setb wait25_done      ; Tells Wait_25ms that we are finished
0582 C214        83       clr wait25_active     ; Stop counting
0584             84   
0584             85   Timer2_ISR_done:
0584 D0D0        86       pop psw
0586 D0E0        87       pop acc
0588 32          88       reti
0589             89            
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
0589              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
0589              2   cseg
0589              3   
0589              4   ; When using a 33.333333MHz crystal clock
0589              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
0589              6   
0589              7   ;---------------------------------;
0589              8   ; Wait 40 microseconds            ;
0589              9   ;---------------------------------;
0589             10   Wait40uSec:
0589 C000        11            push AR0
058B 78BE        12            mov R0, #190
058D             13   L0: 
058D 00          14            nop
058E 00          15            nop
058F 00          16            nop
0590 00          17            nop
0591 D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
0593 D000        19            pop AR0
0595 22          20       ret
0596             21   
0596             22   ;---------------------------------;
0596             23   ; Wait 'R2' milliseconds          ;
0596             24   ;---------------------------------;
                 25   Wait_Milli_Seconds mac
                 26   	push AR2
                 27   	mov R2, %0
                 28   	lcall ?Wait_Milli_Seconds
                 29   	pop AR2
                 30   endmac
0596             31   
0596             32   ?Wait_Milli_Seconds:
0596 C000        33            push AR0
0598 C001        34            push AR1
059A 7932        35   L3: mov R1, #50
059C 78DF        36   L2: mov R0, #223
059E D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
05A0 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
05A2 DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
05A4 D001        40       pop AR1
05A6 D000        41       pop AR0
05A8 22          42       ret
05A9             43            
05A9             44   ;---------------------------------;
05A9             45   ; Toggles the 'E' pin in the LCD  ;
05A9             46   ;---------------------------------;
05A9             47   ELCD_pulse:
05A9 D291        48            setb ELCD_E
05AB 120589      49            lcall Wait40uSec
05AE C291        50            clr ELCD_E
05B0 120589      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
05B3 22          52       ret
05B4             53   
05B4             54   ;---------------------------------;
05B4             55   ; Writes acc to LCD in 4-bit mode ;
05B4             56   ;---------------------------------;
05B4             57   ELCD_byte:
05B4             58            ; Write high 4 bits first
05B4 A2E7        59            mov c, ACC.7
05B6 9281        60            mov ELCD_D7, c
05B8 A2E6        61            mov c, ACC.6
05BA 9283        62            mov ELCD_D6, c
05BC A2E5        63            mov c, ACC.5
05BE 9285        64            mov ELCD_D5, c
05C0 A2E4        65            mov c, ACC.4
05C2 9287        66            mov ELCD_D4, c
05C4 1205A9      67       lcall ELCD_pulse
05C7             68            ; Write low 4 bits next
05C7 A2E3        69            mov c, ACC.3
05C9 9281        70            mov ELCD_D7, c
05CB A2E2        71            mov c, ACC.2
05CD 9283        72            mov ELCD_D6, c
05CF A2E1        73            mov c, ACC.1
05D1 9285        74            mov ELCD_D5, c
05D3 A2E0        75            mov c, ACC.0
05D5 9287        76            mov ELCD_D4, c
05D7 1205A9      77       lcall ELCD_pulse
05DA 22          78            ret
05DB             79   
05DB             80   ;---------------------------------;
05DB             81   ; Write data to LCD               ;
05DB             82   ;---------------------------------;
                 83   WriteData mac
                 84   	mov a, %0
                 85   	lcall ?WriteData
                 86   endmac
05DB             87            
05DB             88   ?WriteData:
05DB D297        89            setb ELCD_RS
05DD 0205B4      90            ljmp ELCD_byte
05E0             91   
05E0             92   ;---------------------------------;
05E0             93   ; Write command to LCD            ;
05E0             94   ;---------------------------------;
                 95   WriteCommand mac
                 96   	mov a, %0
                 97   	lcall ?WriteCommand
                 98   endmac
05E0             99   
05E0            100   ?WriteCommand:
05E0 C297       101            clr ELCD_RS
05E2 0205B4     102            ljmp ELCD_byte
05E5            103   
05E5            104   ;---------------------------------;
05E5            105   ; Configure LCD in 4-bit mode     ;
05E5            106   ;---------------------------------;
05E5            107   ELCD_4BIT:
05E5 C291       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
05E7            109            ;clr ELCD_RW  ; RW forced to zero
05E7            110            
05E7            111            ; After power on, let the LCD start up before initializing
05E7 C002       112            push AR2
05E9 7A28       112            mov R2, #40
05EB 120596     112            lcall ?Wait_Milli_Seconds
05EE D002       112            pop AR2
05F0            113            
05F0            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
05F0 7433       115            mov a, #0x33
05F2 1205E0     115            lcall ?WriteCommand
05F5 7433       116            mov a, #0x33
05F7 1205E0     116            lcall ?WriteCommand
05FA 7432       117            mov a, #0x32
05FC 1205E0     117            lcall ?WriteCommand ; change to 4-bit mode
05FF            118   
05FF            119            ; Configure the LCD
05FF 7428       120            mov a, #0x28
0601 1205E0     120            lcall ?WriteCommand
0604 740C       121            mov a, #0x0c
0606 1205E0     121            lcall ?WriteCommand
0609 7401       122            mov a, #0x01
060B 1205E0     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
060E            123   
060E            124       ;Wait for the clear screen command to finish.
060E C002       125            push AR2
0610 7A02       125            mov R2, #2
0612 120596     125            lcall ?Wait_Milli_Seconds
0615 D002       125            pop AR2
0617 22         126       ret
0618            127   
0618            128   ;---------------------------------;
0618            129   ; Send a constant string to LCD   ;
0618            130   ;---------------------------------;
                131   Send_Constant_String mac
                132   	push dph
                133   	push dpl
                134   	push acc
                135   	mov dptr, %0
                136   	lcall ?Send_Constant_String
                137   	pop acc
                138   	pop dpl
                139   	pop dph
                140   endmac
0618            141   
0618            142   ?Send_Constant_String:
0618 E4         143       clr a
0619 93         144       movc a, @a+dptr
061A 6006       145       jz ?Send_Constant_String_Done
061C 1205DB     146       lcall ?WriteData
061F A3         147       inc dptr
0620 80F6       148       sjmp ?Send_Constant_String
0622            149   ?Send_Constant_String_Done:
0622 22         150       ret  
0623            151   
0623            152   ;---------------------------------;
0623            153   ; Set LCD cursor at row, column   ;
0623            154   ;---------------------------------;
                155   Set_Cursor mac
                156   	push acc
                157   	mov a, #%1
                158   	dec a
                159   	lcall ?Set_Cursor_%0 ; Select column and row
                160   	pop acc
                161   endmac
0623            162   
0623            163   ?Set_Cursor_2:
0623 4440       164            orl a, #01000000B
0625            165   ?Set_Cursor_1:
0625 4480       166            orl a, #10000000B
0627 0205E0     167            ljmp ?WriteCommand ; Select column and row
062A            168   
062A            169   ;---------------------------------;
062A            170   ; Display a BCD number in the LCD ;
062A            171   ;---------------------------------;
                172   Display_BCD mac
                173   	push ar0
                174   	mov r0, %0
                175   	lcall ?Display_BCD
                176   	pop ar0
                177   endmac
062A            178   
062A            179   ?Display_BCD:
062A C0E0       180            push acc
062C            181            ; Write most significant digit
062C E8         182            mov a, r0
062D C4         183            swap a
062E 540F       184            anl a, #0fh
0630 4430       185            orl a, #30h
0632 1205DB     186            lcall ?WriteData
0635            187            ; write least significant digit
0635 E8         188            mov a, r0
0636 540F       189            anl a, #0fh
0638 4430       190            orl a, #30h
063A 1205DB     191            lcall ?WriteData
063D D0E0       192            pop acc
063F 22         193            ret
0640            194   
0640            195   ;------------------------------------;
0640            196   ; Display a char in the LCD          ;
0640            197   ;------------------------------------;
                198   Display_char mac
                199   	push acc
                200   	mov a, %0
                201   	lcall ?WriteData
                202   	pop acc
                203   endmac
0640            204   
0640            374            ;-----------------------------------------------------------------------------------------------;
0640            375   
0640            376   ;-------------------------------------------------------------------------------
0640            377   ; Display Function for 7-segment displays       
0640            378   ;-------------------------------------------------------------------------------
0640            379   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
0640            380   T_7seg:
0640 C0F9A4B0   381       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
0645 9282F880   382       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
064A 8883C6A1   383       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
0650            384   
0650            385   ; Displays a BCD number pased in R0 in HEX5-HEX0
0650            386   Display_BCD_7_Seg_HEX10:
0650 900640     387       mov dptr, #T_7seg
0653 E8         388       mov a, R0
0654 C4         389       swap a
0655 540F       390       anl a, #0FH
0657 93         391       movc a, @a+dptr
0658 F592       392       mov HEX1, a
065A E8         393       mov a, R0
065B 540F       394       anl a, #0FH
065D 93         395       movc a, @a+dptr
065E F591       396       mov HEX0, a
0660 22         397       ret
0661            398   
0661            399   Display_BCD_7_Seg_HEX32:
0661 900640     400       mov dptr, #T_7seg
0664 E8         401       mov a, R0
0665 C4         402       swap a
0666 540F       403       anl a, #0FH
0668 93         404       movc a, @a+dptr
0669 F594       405       mov HEX3, a
066B E8         406       mov a, R0
066C 540F       407       anl a, #0FH
066E 93         408       movc a, @a+dptr
066F F593       409       mov HEX2, a
0671 22         410       ret
0672            411   
0672            412   Display_BCD_7_Seg_HEX54:
0672 900640     413       mov dptr, #T_7seg
0675 E8         414       mov a, R0
0676 C4         415       swap a
0677 540F       416       anl a, #0FH
0679 93         417       movc a, @a+dptr
067A F58F       418       mov HEX5, a
067C E8         419       mov a, R0
067D 540F       420       anl a, #0FH
067F 93         421       movc a, @a+dptr
0680 F58E       422       mov HEX4, a
0682 22         423       ret
0683            424   
0683            425   ; The 8-bit hex number passed in the accumulator is converted to
0683            426   ; BCD and stored in [R1, R0]
0683            427   Hex_to_bcd_8bit:
0683 75F064     428       mov b, #100
0686 84         429       div ab
0687 F9         430       mov R1, a   ; After dividing, a has the 100s
0688 E5F0       431       mov a, b    ; Remainder is in register b
068A 75F00A     432       mov b, #10
068D 84         433       div ab ; The tens are stored in a, the units are stored in b 
068E C4         434       swap a
068F 54F0       435       anl a, #0xf0
0691 45F0       436       orl a, b
0693 F8         437       mov R0, a
0694 22         438       ret
0695            439   ;-------------------------------------------------------------------------------
0695            440   ; Display Function for LCD                      
0695            441   ;-------------------------------------------------------------------------------
0695            442   LCD_Print_2Digits:
0695 120683     443       lcall Hex_to_bcd_8bit
0698 E8         444       mov a, R0
0699 C4         445       swap a
069A 540F       446       anl a, #0x0F
069C 2430       447       add a, #0x30
069E 1205DB     448       lcall ?WriteData
06A1 E8         449       mov a, R0
06A2 540F       450       anl a, #0x0F
06A4 2430       451       add a, #0x30
06A6 1205DB     452       lcall ?WriteData
06A9 22         453       ret
06AA            454   
06AA            455   LCD_Display_Update_func:
06AA C0E0       456       push acc
06AC            457       
06AC            458       ; ==========================================
06AC            459       ; PART 1: STATIC TEXT (Title)
06AC            460       ; Runs ONLY when the state changes
06AC            461       ; ==========================================
06AC            462       
06AC            463       ; [FIX] "Trampoline" logic for long distance jump
06AC            464       ; If signal is SET (1), we stay here and update.
06AC            465       ; If signal is CLEAR (0), we Long Jump to the Live Update section.
06AC 200C03     466       jb state_change_signal, Do_Static_Update
06AF 0207E8     467       ljmp Check_Live_Update
06B2            468   
06B2            469   Do_Static_Update:
06B2 C20C       470       clr state_change_signal
06B4            471       
06B4            472       ; State Changed: Clear Screen and Write Title
06B4 120FFA     473       lcall Clear_Screen_Func
06B7 E568       474       mov a, Control_FSM_state
06B9            475       
06B9            476       ; State 0: Welcome
06B9 B4003B     477       cjne a, #0, LCD_Check_1
06BC C0E0       478            push acc
06BE 7401       478            mov a, #1
06C0 14         478            dec a
06C1 120625     478            lcall ?Set_Cursor_1 ; Select column and row
06C4 D0E0       478            pop acc
06C6 C083       479            push dph
06C8 C082       479            push dpl
06CA C0E0       479            push acc
06CC 900330     479            mov dptr, #String_state0_1
06CF 120618     479            lcall ?Send_Constant_String
06D2 D0E0       479            pop acc
06D4 D082       479            pop dpl
06D6 D083       479            pop dph
06D8 C0E0       480            push acc
06DA 7401       480            mov a, #1
06DC 14         480            dec a
06DD 120623     480            lcall ?Set_Cursor_2 ; Select column and row
06E0 D0E0       480            pop acc
06E2 C083       481            push dph
06E4 C082       481            push dpl
06E6 C0E0       481            push acc
06E8 900340     481            mov dptr, #String_state0_2
06EB 120618     481            lcall ?Send_Constant_String
06EE D0E0       481            pop acc
06F0 D082       481            pop dpl
06F2 D083       481            pop dph
06F4 0207E5     482       ljmp LCD_Done_Bridge ; Exit
06F7            483   
06F7            484   LCD_Check_1: ; Setup
06F7 B4011F     485       cjne a, #1, LCD_Check_2
06FA C0E0       486            push acc
06FC 7401       486            mov a, #1
06FE 14         486            dec a
06FF 120625     486            lcall ?Set_Cursor_1 ; Select column and row
0702 D0E0       486            pop acc
0704 C083       487            push dph
0706 C082       487            push dpl
0708 C0E0       487            push acc
070A 9003A5     487            mov dptr, #String_state1
070D 120618     487            lcall ?Send_Constant_String
0710 D0E0       487            pop acc
0712 D082       487            pop dpl
0714 D083       487            pop dph
0716 0207E5     488       ljmp LCD_Done_Bridge
0719            489   
0719            490   LCD_Check_2: ; Ramp to Soak
0719 B4021F     491       cjne a, #2, LCD_Check_3
071C C0E0       492            push acc
071E 7401       492            mov a, #1
0720 14         492            dec a
0721 120625     492            lcall ?Set_Cursor_1 ; Select column and row
0724 D0E0       492            pop acc
0726 C083       493            push dph
0728 C082       493            push dpl
072A C0E0       493            push acc
072C 9003EC     493            mov dptr, #String_state2
072F 120618     493            lcall ?Send_Constant_String
0732 D0E0       493            pop acc
0734 D082       493            pop dpl
0736 D083       493            pop dph
0738 020808     494       ljmp LCD_Update_Temp_Value ; Draw Temp immediately!
073B            495   
073B            496   LCD_Check_3: ; Soak
073B B4031F     497       cjne a, #3, LCD_Check_4
073E C0E0       498            push acc
0740 7401       498            mov a, #1
0742 14         498            dec a
0743 120625     498            lcall ?Set_Cursor_1 ; Select column and row
0746 D0E0       498            pop acc
0748 C083       499            push dph
074A C082       499            push dpl
074C C0E0       499            push acc
074E 9003FC     499            mov dptr, #String_state3
0751 120618     499            lcall ?Send_Constant_String
0754 D0E0       499            pop acc
0756 D082       499            pop dpl
0758 D083       499            pop dph
075A 020808     500       ljmp LCD_Update_Temp_Value
075D            501   
075D            502   LCD_Check_4: ; Ramp to Peak
075D B4041F     503       cjne a, #4, LCD_Check_5
0760 C0E0       504            push acc
0762 7401       504            mov a, #1
0764 14         504            dec a
0765 120625     504            lcall ?Set_Cursor_1 ; Select column and row
0768 D0E0       504            pop acc
076A C083       505            push dph
076C C082       505            push dpl
076E C0E0       505            push acc
0770 90040C     505            mov dptr, #String_state4
0773 120618     505            lcall ?Send_Constant_String
0776 D0E0       505            pop acc
0778 D082       505            pop dpl
077A D083       505            pop dph
077C 020808     506       ljmp LCD_Update_Temp_Value
077F            507   
077F            508   LCD_Check_5: ; Reflow
077F B4051F     509       cjne a, #5, LCD_Check_6
0782 C0E0       510            push acc
0784 7401       510            mov a, #1
0786 14         510            dec a
0787 120625     510            lcall ?Set_Cursor_1 ; Select column and row
078A D0E0       510            pop acc
078C C083       511            push dph
078E C082       511            push dpl
0790 C0E0       511            push acc
0792 90041C     511            mov dptr, #String_state5
0795 120618     511            lcall ?Send_Constant_String
0798 D0E0       511            pop acc
079A D082       511            pop dpl
079C D083       511            pop dph
079E 020808     512       ljmp LCD_Update_Temp_Value
07A1            513   
07A1            514   LCD_Check_6: ; Cooling
07A1 B4061F     515       cjne a, #6, LCD_Check_7
07A4 C0E0       516            push acc
07A6 7401       516            mov a, #1
07A8 14         516            dec a
07A9 120625     516            lcall ?Set_Cursor_1 ; Select column and row
07AC D0E0       516            pop acc
07AE C083       517            push dph
07B0 C082       517            push dpl
07B2 C0E0       517            push acc
07B4 90042C     517            mov dptr, #String_state6
07B7 120618     517            lcall ?Send_Constant_String
07BA D0E0       517            pop acc
07BC D082       517            pop dpl
07BE D083       517            pop dph
07C0 020808     518       ljmp LCD_Update_Temp_Value
07C3            519   
07C3            520   LCD_Check_7: ; Done
07C3            521       ; [FIX] Check distance safe logic for State 7
07C3 B4071F     522       cjne a, #7, LCD_Done_Bridge ; If not 7, we are done
07C6 C0E0       523            push acc
07C8 7401       523            mov a, #1
07CA 14         523            dec a
07CB 120625     523            lcall ?Set_Cursor_1 ; Select column and row
07CE D0E0       523            pop acc
07D0 C083       524            push dph
07D2 C082       524            push dpl
07D4 C0E0       524            push acc
07D6 90043C     524            mov dptr, #String_state7
07D9 120618     524            lcall ?Send_Constant_String
07DC D0E0       524            pop acc
07DE D082       524            pop dpl
07E0 D083       524            pop dph
07E2 0207E5     525       ljmp LCD_Done_Bridge
07E5            526   
07E5            527   ; Local bridge to reach the far-away LCD_Done
07E5            528   LCD_Done_Bridge:
07E5 020869     529       ljmp LCD_Done
07E8            530   
07E8            531   ; ==========================================
07E8            532   ; PART 2: DYNAMIC VALUES (Temperature)
07E8            533   ; Runs every time 'one_second_flag' is set
07E8            534   ; ==========================================
07E8            535   Check_Live_Update:
07E8 3001FA     536       jnb one_second_flag, LCD_Done_Bridge
07EB C201       537       clr one_second_flag
07ED            538       
07ED            539       ; Only update temp for States 2, 3, 4, 5, 6
07ED E568       540       mov a, Control_FSM_state
07EF B40202     541       cjne a, #2, Check_St3
07F2 8014       542       sjmp LCD_Update_Temp_Value
07F4            543   Check_St3:
07F4 B40302     544       cjne a, #3, Check_St4
07F7 800F       545       sjmp LCD_Update_Temp_Value
07F9            546   Check_St4:
07F9 B40402     547       cjne a, #4, Check_St5
07FC 800A       548       sjmp LCD_Update_Temp_Value
07FE            549   Check_St5:
07FE B40502     550       cjne a, #5, Check_St6
0801 8005       551       sjmp LCD_Update_Temp_Value
0803            552   Check_St6:
0803 B40663     553       cjne a, #6, LCD_Done
0806 8000       554       sjmp LCD_Update_Temp_Value
0808            555   
0808            556   ; --- HELPER: Prints "XXX C" on Line 2 ---
0808            557   LCD_Update_Temp_Value:
0808 C0E0       558            push acc
080A 7401       558            mov a, #1
080C 14         558            dec a
080D 120623     558            lcall ?Set_Cursor_2 ; Select column and row
0810 D0E0       558            pop acc
0812            559       
0812            560       ; Convert current_temp to BCD
0812 853F32     561       mov x, current_temp
0815 854033     562       mov x+1, current_temp+1
0818 854134     563       mov x+2, current_temp+2
081B 854235     564       mov x+3, current_temp+3
081E 12002E     565       lcall hex2bcd
0821            566   
0821            567       ; Update HEX2-HEX0 with temperature
0821 12086C     568       lcall Update_HEX_Temp
0824            569       
0824            570       ; Print Hundreds
0824 E53B       571       mov a, bcd+1
0826 540F       572       anl a, #0x0F
0828 2430       573       add a, #0x30
082A 1205DB     574       lcall ?WriteData
082D            575       
082D            576       ; Print Tens
082D E53A       577       mov a, bcd+0
082F C4         578       swap a
0830 540F       579       anl a, #0x0F
0832 2430       580       add a, #0x30
0834 1205DB     581       lcall ?WriteData
0837            582       
0837            583       ; Print Ones
0837 E53A       584       mov a, bcd+0
0839 540F       585       anl a, #0x0F
083B 2430       586       add a, #0x30
083D 1205DB     587       lcall ?WriteData
0840            588       
0840            589       ; Print 'C'
0840 7443       590       mov a, #'C'
0842 1205DB     591       lcall ?WriteData
0845            592       
0845            593       ; Clear remaining line space (prevents garbage)
0845 7420       594       mov a, #' '
0847 1205DB     595       lcall ?WriteData
084A 1205DB     596       lcall ?WriteData
084D            597   
084D            598       ; Print time MM:SS at bottom right
084D C0E0       599            push acc
084F 740C       599            mov a, #12
0851 14         599            dec a
0852 120623     599            lcall ?Set_Cursor_2 ; Select column and row
0855 D0E0       599            pop acc
0857 E531       600       mov a, current_time_minute
0859 120695     601       lcall LCD_Print_2Digits
085C 743A       602       mov a, #':'
085E 1205DB     603       lcall ?WriteData
0861 E530       604       mov a, current_time_sec
0863 120695     605       lcall LCD_Print_2Digits
0866            606   
0866            607       ; Mirror temp to serial (PuTTY/screen)
0866 1204C5     608       lcall Serial_Send_Temp_Line
0869            609   
0869            610   LCD_Done:
0869 D0E0       611       pop acc
086B 22         612       ret
086C            613   ;---------------------------------------------------------
086C            614   
086C            615   ;-------------------------------------------------------------------------------
086C            616   ; Update HEX2-HEX0 with temperature (3 digits)
086C            617   ;-------------------------------------------------------------------------------
086C            618   Update_HEX_Temp:
086C 900640     619       mov dptr, #T_7seg
086F            620       ; Hundreds -> HEX2
086F E53B       621       mov a, bcd+1
0871 540F       622       anl a, #0x0F
0873 93         623       movc a, @a+dptr
0874 F593       624       mov HEX2, a
0876            625       ; Tens -> HEX1
0876 E53A       626       mov a, bcd+0
0878 C4         627       swap a
0879 540F       628       anl a, #0x0F
087B 93         629       movc a, @a+dptr
087C F592       630       mov HEX1, a
087E            631       ; Ones -> HEX0
087E E53A       632       mov a, bcd+0
0880 540F       633       anl a, #0x0F
0882 93         634       movc a, @a+dptr
0883 F591       635       mov HEX0, a
0885 22         636       ret
0886            637   
0886            638   KEY1_DEB:
0886            639   ;non-blocking state machine for KEY1 debounce
0886 E566       640       mov a, KEY1_DEB_state
0888            641   KEY1_DEB_state0:
0888 B4000A     642       cjne a, #0, KEY1_DEB_state1
088B 20F92D     643       jb KEY.1, KEY1_DEB_done
088E 756400     644       mov KEY1_DEB_timer, #0
0891 0566       645       inc KEY1_DEB_state
0893 8026       646       sjmp KEY1_DEB_done
0895            647   KEY1_DEB_state1:
0895 B40109     648       cjne a, #1, KEY1_DEB_state2
0898            649       ; this is the debounce state
0898 E564       650       mov a, KEY1_DEB_timer
089A B4321E     651       cjne a, #50, KEY1_DEB_done ; 50 ms passed?
089D 0566       652       inc KEY1_DEB_state
089F 801A       653       sjmp KEY1_DEB_done  
08A1            654   KEY1_DEB_state2:
08A1 B4020C     655       cjne a, #2, KEY1_DEB_state3
08A4 20F904     656       jb KEY.1, KEY1_DEB_state2b
08A7 0566       657       inc KEY1_DEB_state
08A9 8010       658       sjmp KEY1_DEB_done  
08AB            659   KEY1_DEB_state2b:
08AB 756600     660       mov KEY1_DEB_state, #0
08AE 800B       661       sjmp KEY1_DEB_done
08B0            662   KEY1_DEB_state3:
08B0 B40308     663       cjne a, #3, KEY1_DEB_done
08B3 30F905     664       jnb KEY.1, KEY1_DEB_done
08B6 D20D       665       setb Key1_flag ; Suscesfully detected a valid KEY1 press/release
08B8 756600     666       mov KEY1_DEB_state, #0  
08BB            667   KEY1_DEB_done:
08BB 22         668       ret
08BC            669   ; ------------------------------------------------------------------------------
08BC            670   ; Non-blocking FSM for the one second counter
08BC            671   ;-------------------------------------------------------------------------------
08BC            672   SEC_FSM:
08BC E567       673       mov a, SEC_FSM_state
08BE            674   SEC_FSM_state0:
08BE B4000C     675       cjne a, #0, SEC_FSM_state1
08C1 E565       676       mov a, SEC_FSM_timer
08C3 B4FA4B     677       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08C6 756500     678       mov SEC_FSM_timer, #0
08C9 0567       679       inc SEC_FSM_state
08CB 8044       680       sjmp SEC_FSM_done
08CD            681   SEC_FSM_state1: 
08CD B4010E     682       cjne a, #1, SEC_FSM_state2
08D0 D2E9       683       setb LEDRA.1
08D2 E565       684       mov a, SEC_FSM_timer
08D4 B4FA3A     685       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08D7 756500     686       mov SEC_FSM_timer, #0
08DA 0567       687       inc SEC_FSM_state
08DC 8033       688       sjmp SEC_FSM_done
08DE            689   SEC_FSM_state2: 
08DE B4020E     690       cjne a, #2, SEC_FSM_state3
08E1 D2EA       691       setb LEDRA.2
08E3 E565       692       mov a, SEC_FSM_timer
08E5 B4FA29     693       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08E8 756500     694       mov SEC_FSM_timer, #0
08EB 0567       695       inc SEC_FSM_state
08ED 8022       696       sjmp SEC_FSM_done
08EF            697   SEC_FSM_state3: 
08EF B4031F     698       cjne a, #3, SEC_FSM_done
08F2 D2EB       699       setb LEDRA.3
08F4 E565       700       mov a, SEC_FSM_timer
08F6 B4FA18     701       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08F9 756500     702       mov SEC_FSM_timer, #0
08FC 756700     703       mov SEC_FSM_state, #0
08FF            704       
08FF            705       ; --- 1 Second has passed! ---
08FF D201       706       setb one_second_flag
0901            707       
0901 E530       708       mov a, current_time_sec
0903 B43B07     709       cjne a, #59, IncCurrentTimeSec 
0906            710       
0906            711       ; --- FIX: 59s -> 0s AND Increment Minute ---
0906 753000     712       mov current_time_sec, #0
0909 0531       713       inc current_time_minute    ; <--- YOU WERE MISSING THIS!
090B            714       ; -------------------------------------------
090B            715       
090B 8004       716       sjmp SEC_FSM_done
090D            717   
090D            718   IncCurrentTimeSec:
090D 0530       719       inc current_time_sec
090F B2E8       720       cpl LEDRA.0 
0911            721   SEC_FSM_done:
0911 22         722       ret
0912            723   ;-------------------------------------------------------------------------------
0912            724   ; PWM
0912            725   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0912            726   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0912            727   ; ------------------------------------------------------------------------------
0912            728   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0912 100202     729       jbc one_ms_pwm_flag, pwm_wave_generator
0915 8071       730       sjmp end_pwm_generator
0917            731   
0917            732   pwm_wave_generator:
0917 C200       733       clr mf
0919            734       ; move pwm counter value into x for comparison purpose
0919 856032     735       mov x, pwm_counter
091C 856133     736       mov x+1, pwm_counter+1
091F 856234     737       mov x+2, pwm_counter+2
0922 856335     738       mov x+3, pwm_counter+3
0925            739   
0925 7536DB     740            mov y+0, #low (PWM_PERIOD % 0x10000) 
0928 753705     740            mov y+1, #high(PWM_PERIOD % 0x10000) 
092B 753800     740            mov y+2, #low (PWM_PERIOD / 0x10000) 
092E 753900     740            mov y+3, #high(PWM_PERIOD / 0x10000) 
0931            741   
0931            742       ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
0931            743       ; increase x by 1
0931 120152     744       lcall x_eq_y 
0934 20001D     745       jb mf, wrap_pwm_counter
0937            746       ; x not equal 1499, increment by 1
0937 753601     747            mov y+0, #low (1 % 0x10000) 
093A 753700     747            mov y+1, #high(1 % 0x10000) 
093D 753800     747            mov y+2, #low (1 / 0x10000) 
0940 753900     747            mov y+3, #high(1 / 0x10000) 
0943 1200D3     748       lcall add32
0946            749       ; update pwm_counter
0946 853260     750       mov pwm_counter, x
0949 853361     751       mov pwm_counter+1, x+1
094C 853462     752       mov pwm_counter+2, x+2
094F 853563     753       mov pwm_counter+3, x+3
0952 8018       754       sjmp set_pwm
0954            755   
0954            756   wrap_pwm_counter:
0954            757       ; x equal 1499, wrap to 0
0954 753200     758            mov x+0, #low (0 % 0x10000) 
0957 753300     758            mov x+1, #high(0 % 0x10000) 
095A 753400     758            mov x+2, #low (0 / 0x10000) 
095D 753500     758            mov x+3, #high(0 / 0x10000) 
0960 853260     759       mov pwm_counter, x
0963 853361     760       mov pwm_counter+1, x+1
0966 853462     761       mov pwm_counter+2, x+2
0969 853563     762       mov pwm_counter+3, x+3
096C            763   
096C            764   set_pwm:
096C            765       ; compare with power_output, if pwm counter smaller than power_output, 
096C            766       ; set pwm pin high; else set pwm pin low load y with power output value
096C 855C36     767       mov y, power_output
096F 855D37     768       mov y+1, power_output+1
0972 855E38     769       mov y+2, power_output+2
0975 855F39     770       mov y+3, power_output+3
0978            771   
0978            772       ; compare x(pwm counter) with y(power output)
0978 12011A     773       lcall x_lt_y
097B 200006     774       jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
097E            775       ;output set pwm pin low if pwm counter greater than power output
097E C293       776       clr PWM_OUT
0980 C2EC       777       clr LEDRA.4
0982 8004       778       sjmp end_pwm_generator
0984            779   
0984            780   set_pwm_high:
0984 D293       781       setb PWM_OUT
0986 D2EC       782       setb LEDRA.4
0988            783   
0988            784   end_pwm_generator:
0988 22         785       ret
0989            786   
0989            787   ;-------------------------------------------------------------------------------;
0989            788   ; Temp_Compare
0989            789   ; Checks if we have reached the user's target temperatures.
0989            790   ; Sets 'soak_temp_reached' if current_temp >= soak_temp
0989            791   ; Sets 'reflow_temp_reached' if current_temp >= reflow_temp
0989            792   ;-------------------------------------------------------------------------------;
0989            793   Temp_Compare:
0989            794       ; Reset flags initially
0989 C203       795       clr soak_temp_reached
098B C204       796       clr reflow_temp_reached
098D            797   
098D C0E0       798       push acc
098F C0D0       799       push psw
0991 C000       800       push AR0
0993 C001       801       push AR1
0995 C002       802       push AR2
0997            803       
0997            804       ; --- 1. CHECK SOAK TEMP ---
0997            805       ; Copy current_temp to X
0997 783F       806       mov R0, #current_temp
0999 7932       807       mov R1, #x
099B 120A0F     808       lcall Copy4_Bytes_R0_to_R1
099E            809   
099E            810       ; Copy soak_temp to Y
099E 7843       811       mov R0, #soak_temp
09A0 7936       812       mov R1, #y
09A2 120A0F     813       lcall Copy4_Bytes_R0_to_R1
09A5            814   
09A5            815       ; Compare: Is X (Current) < Y (Target)?
09A5 12011A     816       lcall x_lt_y
09A8 200002     817       jb mf, Check_Reflow_Threshold ; If Current < Target, jump (Flag stays 0)
09AB            818       
09AB            819       ; If we are here, Current >= Target
09AB D203       820       setb soak_temp_reached
09AD            821   
09AD            822   Check_Reflow_Threshold:
09AD            823       ; --- 2. CHECK REFLOW TEMP ---
09AD            824       ; Copy current_temp to X (Need to reload X because math32 destroys it)
09AD 783F       825       mov R0, #current_temp
09AF 7932       826       mov R1, #x
09B1 120A0F     827       lcall Copy4_Bytes_R0_to_R1
09B4            828   
09B4            829       ; Copy reflow_temp to Y
09B4 7847       830       mov R0, #reflow_temp
09B6 7936       831       mov R1, #y
09B8 120A0F     832       lcall Copy4_Bytes_R0_to_R1
09BB            833   
09BB            834       ; Compare
09BB 12011A     835       lcall x_lt_y
09BE 200002     836       jb mf, Temp_Compare_Done
09C1            837       
09C1            838       ; If Current >= Target
09C1 D204       839       setb reflow_temp_reached
09C3            840   
09C3            841   Temp_Compare_Done:
09C3 D002       842       pop AR2
09C5 D001       843       pop AR1
09C7 D000       844       pop AR0
09C9 D0D0       845       pop psw
09CB D0E0       846       pop acc
09CD 22         847       ret
09CE            848   ;-------------------------------------------------------------------------------;
09CE            849   ; Time_Compare
09CE            850   ;
09CE            851   ; PURPOSE:
09CE            852   ;   Compare the elapsed time against soak and reflow
09CE            853   ;   time limits.
09CE            854   ;
09CE            855   ; BEHAVIOR:
09CE            856   ;   - If current_time >= soak_time   if soak_time_reached    = 1
09CE            857   ;   - If current_time >= reflow_time if reflow_time_reached = 1
09CE            858   ;
09CE            859   ; NOTES:
09CE            860   ;   - Time values are treated as 32-bit UNSIGNED numbers
09CE            861   ;     (e.g., milliseconds or seconds).
09CE            862   ;   - Uses the SAME compare logic as Temp_Compare.
09CE            863   ;   - This routine ONLY SETS flags.
09CE            864   ;
09CE            865   ; EXPECTED VARIABLES:
09CE            866   ;   current_time[4], soak_time[4], reflow_time[4]
09CE            867   ;   x[4], y[4]
09CE            868   ;   mf, soak_time_reached, reflow_time_reached
09CE            869   ;-------------------------------------------------------------------------------;
09CE            870   Time_Compare:
09CE C0E0       871       push acc
09D0 C0D0       872       push psw
09D2 C000       873       push AR0
09D4 C001       874       push AR1
09D6 C002       875       push AR2
09D8            876   
09D8            877   ; Check: current_time >= soak_time ?
09D8            878       ; Copy current_time of x
09D8 7850       879       mov  R0, #current_time
09DA 7932       880       mov  R1, #x
09DC 120A0F     881       lcall Copy4_Bytes_R0_to_R1
09DF            882   
09DF            883       ; Copy soak_time of y
09DF 7854       884       mov  R0, #soak_time
09E1 7936       885       mov  R1, #y
09E3 120A0F     886       lcall Copy4_Bytes_R0_to_R1
09E6            887   
09E6            888       ; Compare elapsed time vs soak time
09E6 12011A     889       lcall x_lt_y
09E9 200002     890       jb   mf, Time_Soak_NotReached
09EC D206       891       setb soak_time_reached
09EE            892   
09EE            893   ; Check: current_time >= reflow_time ?
09EE            894   Time_Soak_NotReached:
09EE            895       ; Copy current_time of x
09EE 7850       896       mov  R0, #current_time
09F0 7932       897       mov  R1, #x
09F2 120A0F     898       lcall Copy4_Bytes_R0_to_R1
09F5            899   
09F5            900       ; Copy reflow_time of y
09F5 7858       901       mov  R0, #reflow_time
09F7 7936       902       mov  R1, #y
09F9 120A0F     903       lcall Copy4_Bytes_R0_to_R1
09FC            904   
09FC            905       ; Compare elapsed time vs reflow time
09FC 12011A     906       lcall x_lt_y
09FF 200002     907       jb   mf, Time_Reflow_NotReached
0A02 D207       908       setb reflow_time_reached
0A04            909   
0A04            910   Time_Reflow_NotReached:
0A04 D002       911       pop  AR2
0A06 D001       912       pop  AR1
0A08 D000       913       pop  AR0
0A0A D0D0       914       pop  psw
0A0C D0E0       915       pop  acc
0A0E 22         916       ret
0A0F            917   
0A0F            918   ;-------------------------------------------------------------------------------;
0A0F            919   ; Copy4_Bytes_R0_to_R1
0A0F            920   ;
0A0F            921   ; PURPOSE:
0A0F            922   ;   Utility routine to copy a 32-bit value (4 bytes)
0A0F            923   ;   from one memory location to another.
0A0F            924   ;
0A0F            925   ; INPUTS:
0A0F            926   ;   R0 st source address
0A0F            927   ;   R1 at destination address
0A0F            928   ;
0A0F            929   ; USES:
0A0F            930   ;   R2 as loop counter
0A0F            931   ;
0A0F            932   ; EXAMPLE:
0A0F            933   ;   mov R0, #current_temp
0A0F            934   ;   mov R1, #x
0A0F            935   ;   lcall Copy4_Bytes_R0_to_R1
0A0F            936   ;-------------------------------------------------------------------------------;
0A0F            937   Copy4_Bytes_R0_to_R1:
0A0F 7A04       938       mov  R2, #4
0A11            939   Copy4_Loop:
0A11 E6         940       mov  a, @R0
0A12 F7         941       mov  @R1, a
0A13 08         942       inc  R0
0A14 09         943       inc  R1
0A15 DAFA       944       djnz R2, Copy4_Loop
0A17 22         945       ret
0A18            946   
0A18            947   ;-------------------------------------------------------------------------------;
0A18            948   ; Abort condition safety check Temperature time
0A18            949   ;
0A18            950   ; PURPOSE:
0A18            951   ;   Automatic cycle termination on error:
0A18            952   ;   Abort if oven fails to reach at least 50C in first 60s.
0A18            953   ;
0A18            954   ; TRIP CONDITION:
0A18            955   ;   if (current_time >= 60s) AND (current_temp < 50C)
0A18            956   ;       -> set tc_missing_abort
0A18            957   ;       -> set stop_signal
0A18            958   ;
0A18            959   ; ASSUMPTIONS:
0A18            960   ;   - current_time is in SECONDS (32-bit, little-endian)
0A18            961   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
0A18            962   ;
0A18            963   ;   the Load_Y constants accordingly.
0A18            964   ;-------------------------------------------------------------------------------;
0A18            965   Safety_Check_TC:
0A18 C0E0       966       push acc
0A1A C0D0       967       push psw
0A1C C000       968       push AR0
0A1E C001       969       push AR1
0A20 C002       970       push AR2
0A22            971   
0A22            972       ; ---------------------------------------------------------
0A22            973       ; [FIX] GATEKEEPER: IGNORE UNLESS IN STATE 2 (RAMP TO SOAK)
0A22            974       ; ---------------------------------------------------------
0A22 E568       975       mov a, Control_FSM_state
0A24 B40202     976       cjne a, #2, Safety_TC_Exit_Bridge ; If State != 2, skip everything
0A27 8003       977       sjmp Safety_Logic_Proceed         ; If State == 2, do the check
0A29            978   
0A29            979       Safety_TC_Exit_Bridge:
0A29 020A77     980           ljmp Safety_TC_Done               ; Jump to the end
0A2C            981   
0A2C            982       Safety_Logic_Proceed:
0A2C            983           ; If already aborted or startup window closed, do nothing
0A2C 200E48     984           jb   tc_missing_abort, Safety_TC_Done
0A2F 300F45     985           jnb  tc_startup_window, Safety_TC_Done
0A32            986   
0A32            987       ; Check: current_time >= 60 ?
0A32 7850       988       mov  R0, #current_time
0A34 7932       989       mov  R1, #x
0A36 120A0F     990       lcall Copy4_Bytes_R0_to_R1
0A39            991   
0A39 75363C     992            mov y+0, #low (60 % 0x10000) 
0A3C 753700     992            mov y+1, #high(60 % 0x10000) 
0A3F 753800     992            mov y+2, #low (60 / 0x10000) 
0A42 753900     992            mov y+3, #high(60 / 0x10000) 
0A45 12011A     993       lcall x_lt_y
0A48 2000DE     994       jb   mf, Safety_TC_Exit_Bridge        ; still < 60s  keep waiting
0A4B            995   
0A4B            996       ; We reached 60s: close the startup window so it won't re-check later
0A4B C20F       997       clr  tc_startup_window
0A4D            998   
0A4D            999       ; Now check: current_temp < 50 ?
0A4D 783F      1000       mov  R0, #current_temp
0A4F 7932      1001       mov  R1, #x
0A51 120A0F    1002       lcall Copy4_Bytes_R0_to_R1
0A54           1003   
0A54 753632    1004            mov y+0, #low (50 % 0x10000) 
0A57 753700    1004            mov y+1, #high(50 % 0x10000) 
0A5A 753800    1004            mov y+2, #low (50 / 0x10000) 
0A5D 753900    1004            mov y+3, #high(50 / 0x10000) 
0A60 12011A    1005       lcall x_lt_y
0A63 3000C3    1006       jnb  mf, Safety_TC_Exit_Bridge        ; temp >= 50  pass
0A66           1007   
0A66           1008       ; FAIL: at 60s, still below 50C  abort
0A66 C293      1009       clr  PWM_OUT
0A68 D20E      1010       setb tc_missing_abort
0A6A D209      1011       setb stop_signal
0A6C 120A8C    1012            lcall Beep_Ten
0A6F           1013       ; 3. Force FSM to State 0 (Welcome)
0A6F 756800    1014       mov Control_FSM_state, #0
0A72           1015       
0A72           1016       ; 4. Force UI to State 0 (Home Screen)
0A72 756900    1017       mov Current_State, #0
0A75           1018       
0A75           1019       ; 5. Trigger Screen Refresh
0A75 D20C      1020       setb state_change_signal ; Tell loop to redraw "Welcome"
0A77           1021   
0A77           1022   Safety_TC_Done:
0A77 D002      1023       pop  AR2
0A79 D001      1024       pop  AR1
0A7B D000      1025       pop  AR0
0A7D D0D0      1026       pop  psw
0A7F D0E0      1027       pop  acc
0A81 22        1028       ret
0A82           1029   
0A82           1030   ; ============================================================
0A82           1031   ; BUZZER STARTUP FUNCTIONS
0A82           1032   ; ============================================================
0A82           1033   
0A82           1034   Beep_Once:
0A82 756B01    1035       mov beep_count, #1
0A85 800A      1036       sjmp Beep_Start
0A87           1037   
0A87           1038   Beep_Five:
0A87 756B05    1039       mov beep_count, #5
0A8A 8005      1040       sjmp Beep_Start
0A8C           1041   
0A8C           1042   Beep_Ten:
0A8C 756B0A    1043       mov beep_count, #10
0A8F 8000      1044       sjmp Beep_Start      ; [FIX] Added explicit jump for safety
0A91           1045   
0A91           1046   Beep_Start:
0A91 C28C      1047       clr TR0              ; [FIX] Stop timer briefly to reset cleanly
0A93 756C01    1048       mov beep_state, #1   ; Set State to ON
0A96 756D00    1049       mov beep_tmr, #0     ; Reset Timer High Byte
0A99 756E00    1050       mov beep_tmr+1, #0   ; Reset Timer Low Byte
0A9C D2A9      1051       setb ET0             ; [FIX] Ensure Interrupt is enabled
0A9E D28C      1052       setb TR0             ; START the 2kHz tone
0AA0 22        1053       ret
0AA1           1054   ;============================================================
0AA1           1055   
0AA1           1056   ;============================================================
0AA1           1057   ; Buzzer beep Task 
0AA1           1058   ; Purpose: beeps, holds, stop
0AA1           1059   ; Buzzer task:
0AA1           1060   ; Beep once when state changes
0AA1           1061   ; Beep five times if finished
0AA1           1062   ; Beep ten times if meets error
0AA1           1063   ;============================================================
0AA1           1064   
0AA1           1065   Beep_Task:
0AA1 301335    1066       jnb one_ms_beep_flag, Beep_Done
0AA4 C213      1067       clr one_ms_beep_flag
0AA6           1068   
0AA6 E56C      1069       mov a, beep_state
0AA8 602F      1070       jz Beep_Done
0AAA           1071   
0AAA           1072   ; ---- increment 16-bit timer ----
0AAA 056D      1073       inc beep_tmr
0AAC E56D      1074       mov a, beep_tmr
0AAE 7002      1075       jnz Beep_Check
0AB0 056E      1076       inc beep_tmr+1
0AB2           1077   
0AB2           1078   Beep_Check:
0AB2           1079       ; [FIX] FUZZY TIMER CHECK
0AB2           1080       ; Check if High Byte is non-zero (Time >= 256ms)
0AB2 E56E      1081       mov a, beep_tmr+1
0AB4 6023      1082       jz Beep_Done        ; If 0, keep beeping
0AB6           1083   
0AB6           1084       ; --- Time Limit Reached ---
0AB6 756D00    1085       mov beep_tmr, #0    ; Reset timer
0AB9 756E00    1086       mov beep_tmr+1, #0
0ABC           1087   
0ABC E56C      1088       mov a, beep_state
0ABE B40106    1089       cjne a, #1, Beep_Off_State
0AC1           1090   
0AC1           1091       ; State was 1 (ON) -> Turn OFF
0AC1 C28C      1092       clr TR0             ; Hardware Silence
0AC3 756C02    1093       mov beep_state, #2  ; Set State to OFF (Pause)
0AC6 22        1094       ret
0AC7           1095   
0AC7           1096   Beep_Off_State:
0AC7           1097   ; ---- OFF finished -> decrement count / next ON ----
0AC7 156B      1098       dec beep_count
0AC9 E56B      1099       mov a, beep_count
0ACB 6006      1100       jz  Beep_Stop
0ACD           1101   
0ACD 756C01    1102       mov beep_state, #1
0AD0 D28C      1103       setb TR0
0AD2 22        1104       ret
0AD3           1105   
0AD3           1106   Beep_Stop:
0AD3 C28C      1107       clr TR0
0AD5 756C00    1108       mov beep_state, #0
0AD8 22        1109       ret
0AD9           1110   
0AD9           1111   Beep_Done:
0AD9 22        1112       ret
0ADA           1113   ;==================================================================
0ADA           1114   
0ADA           1115   ;-------------------------------------------------------------------------------;
0ADA           1116   ; Main Control FSM for the entire process
0ADA           1117   ;-------------------------------------------------------------------------------;
0ADA           1118   ;-------------------------------------------------------------------------------;
0ADA           1119   ; FSM LOGIC (Button Logic Fixed)
0ADA           1120   ;-------------------------------------------------------------------------------;
0ADA           1121   Control_FSM:
0ADA E568      1122       mov a, Control_FSM_state
0ADC 8005      1123       sjmp Control_FSM_state0
0ADE           1124   
0ADE           1125   Control_FSM_state0_a:
0ADE 756800    1126       mov Control_FSM_state, #0
0AE1 D20C      1127       setb state_change_signal
0AE3           1128            
0AE3           1129   Control_FSM_state0:
0AE3 B40015    1130       cjne a, #0, Control_FSM_state1
0AE6 209005    1131       jb P1.0, Control_FSM_done_bridge ; If Button High (Not Pressed), Exit
0AE9 121024    1132       lcall Wait_For_P1_0_Release      ; If Low (Pressed), Wait & Proceed
0AEC 8001      1133       sjmp Control_FSM_state1_a  
0AEE           1134       
0AEE           1135   Control_FSM_done_bridge:
0AEE 22        1136       ret
0AEF           1137   
0AEF           1138   Control_FSM_state1_a:
0AEF 0568      1139       inc Control_FSM_state
0AF1 756900    1140       mov Current_State, #0
0AF4 120F02    1141       lcall Update_Screen_Full 
0AF7 D20C      1142       setb state_change_signal
0AF9 E568      1143       mov a, Control_FSM_state
0AFB           1144       
0AFB           1145   Control_FSM_state1:
0AFB B40127    1146       cjne a, #1, Control_FSM_state2
0AFE 120D3A    1147       lcall Check_Buttons 
0B01 120D86    1148       lcall Check_Keypad
0B04           1149       
0B04           1150       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
0B04 209008    1151       jb P1.0, Control_FSM_state1_ret
0B07           1152       
0B07           1153       ; If we get here, Button is LOW (Pressed)
0B07 121024    1154       lcall Wait_For_P1_0_Release
0B0A 120CBE    1155       lcall Update_FSM_Variables
0B0D 8001      1156       sjmp Control_FSM_state2_a
0B0F           1157   Control_FSM_state1_ret:
0B0F 22        1158       ret
0B10           1159   
0B10           1160   ; --- STATE 2: RAMP TO SOAK ---
0B10           1161   Control_FSM_state2_a:
0B10 0568      1162       inc Control_FSM_state
0B12 E568      1163       mov a, Control_FSM_state   ; [FIX] RELOAD 'A' so it matches the new state!
0B14 D20C      1164       setb state_change_signal
0B16 120A82    1165       lcall Beep_Once
0B19           1166   
0B19 D20F      1167       setb tc_startup_window    ; OPEN the safety window
0B1B C20E      1168       clr tc_missing_abort      ; Clear any previous aborts
0B1D 753000    1169       mov current_time_sec, #0  ; Reset Seconds to 0
0B20 753100    1170       mov current_time_minute, #0 ; Reset Minutes to 0
0B23           1171       
0B23           1172       ; [FIX] CLEAR FLAG ON ENTRY
0B23           1173       ; Force the system to wait for at least one fresh temp reading
0B23           1174       ; before deciding we are done.
0B23 C203      1175       clr soak_temp_reached      
0B25           1176   
0B25           1177   Control_FSM_state2:
0B25 B4021F    1178       cjne a, #2, Control_FSM_state3
0B28 301205    1179       jnb PB2_flag, State2_Check
0B2B C212      1180       clr PB2_flag
0B2D 020B98    1181       ljmp Control_FSM_state6_a ; Pause
0B30           1182   
0B30           1183   State2_Check:
0B30 300313    1184       jnb soak_temp_reached, State2_Ret
0B33           1185       
0B33           1186       ; --- We reached Temp! Move to State 3 ---
0B33 C203      1187       clr soak_temp_reached
0B35 0568      1188       inc Control_FSM_state
0B37           1189       
0B37           1190       ; [FIX] RELOAD 'A' (Good practice)
0B37 E568      1191       mov a, Control_FSM_state   
0B39           1192       
0B39 D20C      1193       setb state_change_signal
0B3B 120A82    1194       lcall Beep_Once
0B3E           1195       
0B3E 753000    1196       mov current_time_sec, #0
0B41 753100    1197       mov current_time_minute, #0
0B44           1198       
0B44           1199       ; Ensure we start State 3 fresh
0B44 C206      1200       clr soak_time_reached 
0B46           1201   
0B46           1202   State2_Ret:
0B46 22        1203       ret
0B47           1204   
0B47           1205   ; --- STATE 3: SOAK PHASE ---
0B47           1206   Control_FSM_state3:
0B47 B40315    1207       cjne a, #3, Control_FSM_state4
0B4A 301205    1208       jnb PB2_flag, State3_Check
0B4D C212      1209       clr PB2_flag
0B4F 020B98    1210       ljmp Control_FSM_state6_a
0B52           1211   State3_Check:
0B52 300609    1212       jnb soak_time_reached, State3_Ret
0B55 C206      1213       clr soak_time_reached
0B57 0568      1214       inc Control_FSM_state      
0B59 D20C      1215       setb state_change_signal 
0B5B 120A82    1216            lcall Beep_Once
0B5E           1217   State3_Ret:
0B5E 22        1218       ret
0B5F           1219   
0B5F           1220   ; --- STATE 4: RAMP TO PEAK ---
0B5F           1221   Control_FSM_state4:
0B5F B4041D    1222       cjne a, #4, Control_FSM_state5
0B62 301205    1223       jnb PB2_flag, State4_Check
0B65 C212      1224       clr PB2_flag
0B67 020B98    1225       ljmp Control_FSM_state6_a
0B6A           1226   State4_Check:
0B6A 300411    1227       jnb reflow_temp_reached, State4_Ret
0B6D C204      1228       clr reflow_temp_reached
0B6F 0568      1229       inc Control_FSM_state
0B71 D20C      1230       setb state_change_signal
0B73 120A82    1231            lcall Beep_Once
0B76 753000    1232       mov current_time_sec, #0
0B79 753100    1233       mov current_time_minute, #0
0B7C           1234       ; --- ADD THIS LINE ---
0B7C C207      1235       clr reflow_time_reached ; Kill the ghost flag
0B7E           1236       ; ---------------------
0B7E           1237   State4_Ret:
0B7E 22        1238       ret
0B7F           1239   
0B7F           1240   ; --- STATE 5: REFLOW PHASE ---
0B7F           1241   Control_FSM_state5:
0B7F B40502    1242       cjne a, #5, Control_FSM_state6_trampoline
0B82 8003      1243       sjmp State5_Logic
0B84           1244   Control_FSM_state6_trampoline:
0B84 020B9F    1245       ljmp Control_FSM_state6
0B87           1246   
0B87           1247   State5_Logic:
0B87 301205    1248       jnb PB2_flag, State5_Check
0B8A C212      1249       clr PB2_flag
0B8C 020B98    1250       ljmp Control_FSM_state6_a
0B8F           1251   State5_Check:
0B8F 300705    1252       jnb reflow_time_reached, State5_Ret
0B92 C207      1253       clr reflow_time_reached
0B94 020B98    1254       ljmp Control_FSM_state6_a
0B97           1255   State5_Ret:
0B97 22        1256       ret
0B98           1257   
0B98           1258   ; --- STATE 6: COOLING ---
0B98           1259   Control_FSM_state6_a:
0B98 0568      1260       inc Control_FSM_state
0B9A D20C      1261       setb state_change_signal
0B9C 120A87    1262            lcall Beep_Five
0B9F           1263   Control_FSM_state6:
0B9F B4060A    1264       cjne a, #6, Control_FSM_state7
0BA2           1265       ; Wait for Cooling Temp Reached
0BA2 300506    1266       jnb cooling_temp_reached, State6_Ret
0BA5 C205      1267       clr cooling_temp_reached
0BA7 0568      1268       inc Control_FSM_state
0BA9 D20C      1269       setb state_change_signal
0BAB           1270   State6_Ret:
0BAB 22        1271       ret
0BAC           1272   
0BAC           1273   ; --- STATE 7: DONE ---
0BAC           1274   Control_FSM_state7:
0BAC B40711    1275       cjne a, #7, Control_FSM_done
0BAF           1276       
0BAF           1277       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
0BAF 201009    1278       jb PB0_flag, Control_FSM_Reset_Logic ; Wait, PB0_flag is software flag?
0BB2           1279       
0BB2           1280       ; Let's assume you meant the physical button P1.0 like State 0
0BB2 20900B    1281       jb P1.0, Control_FSM_done
0BB5           1282       
0BB5 121024    1283       lcall Wait_For_P1_0_Release
0BB8 020ADE    1284       ljmp Control_FSM_state0_a
0BBB           1285   
0BBB           1286   Control_FSM_Reset_Logic:
0BBB           1287       ; If using PB0_flag from ISR, handle here
0BBB C210      1288       clr PB0_flag
0BBD 020ADE    1289       ljmp Control_FSM_state0_a
0BC0           1290   
0BC0           1291   Control_FSM_done:
0BC0 22        1292       ret
0BC1           1293   ;-------------------------------------------------------------------------------;
0BC1           1294   ;         Main program.          
0BC1           1295   ;-------------------------------------------------------------------------------;
0BC1           1296   main:
0BC1           1297   
0BC1           1298       ; --------------------------------------------------------
0BC1           1299       ; 1. SAFETY SHUTDOWN
0BC1           1300       ; --------------------------------------------------------
0BC1 C2AF      1301       clr EA              ; FORCE Interrupts OFF immediately
0BC3 7581C0    1302       mov SP, #0xC0       ; Reset Stack Pointer to safe location
0BC6           1303       
0BC6           1304       ; --------------------------------------------------------
0BC6           1305       ; 2. THE "DIRTY DELAY" (Fixes Reset Garbage)
0BC6           1306       ; We burn ~100ms here using a raw loop. 
0BC6           1307       ; We cannot use timers yet because they aren't initialized.
0BC6           1308       ; --------------------------------------------------------
0BC6 78FA      1309       mov R0, #250
0BC8           1310   Reset_Delay_Outer:
0BC8 79FF      1311       mov R1, #255
0BCA           1312   Reset_Delay_Inner:
0BCA D9FE      1313       djnz R1, Reset_Delay_Inner
0BCC D8FA      1314       djnz R0, Reset_Delay_Outer
0BCE           1315       ; --------------------------------------------------------
0BCE           1316   
0BCE           1317       ; ... NOW continue with your normal Port Configuration ...
0BCE           1318       
0BCE           1319       ; --- PORT CONFIGURATION ---
0BCE 759AAA    1320       mov P0MOD, #0xAA
0BD1           1321   
0BD1           1322       ; P1: Mixed usage 
0BD1           1323       ; P1.7(LCD_RS), P1.6(Row3), P1.5(Sound), P1.4(Row2)
0BD1           1324       ; P1.3(PWM), P1.2(Row1), P1.1(LCD_E) -> All Outputs
0BD1           1325       ; P1.0 (Unused/RX) -> Input
0BD1           1326       ; Binary: 11111110 -> Hex: 0xFE
0BD1 759BFE    1327       mov P1MOD, #0xFE
0BD4           1328   
0BD4           1329       ; P2: Row4(Out), Cols(In)
0BD4           1330       ; P2.0 (Row4) is Out (1). P2.2, P2.4, P2.6 (Cols) are In (0).
0BD4           1331       ; Binary: 00000001 -> Hex: 0x01
0BD4 759C01    1332       mov P2MOD, #0x01
0BD7           1333   
0BD7           1334       ; P3: Col4(In)
0BD7           1335       ; P3.0 (Col4) is In (0).
0BD7 759D40    1336       mov P3MOD, #01000000B
0BDA           1337       ; Turn off all the LEDs
0BDA 75E800    1338       mov LEDRA, #0 ; LEDRA is bit addressable
0BDD 759500    1339       mov LEDRB, #0 ; LEDRB is NOT bit addresable
0BE0           1340   
0BE0           1341       ; Enable Global interrupts
0BE0 D2AF      1342       setb EA  
0BE2           1343   
0BE2           1344       ; FSM initial states
0BE2 756600    1345       mov KEY1_DEB_state, #0
0BE5 756700    1346       mov SEC_FSM_state, #0
0BE8 756800    1347       mov Control_FSM_state, #0
0BEB 756900    1348       mov Current_State, #0
0BEE           1349       
0BEE           1350       ; FSM timers initialization
0BEE 756400    1351       mov KEY1_DEB_timer, #0
0BF1 756500    1352       mov SEC_FSM_timer, #0
0BF4           1353       ; time counters initialization
0BF4 753000    1354       mov current_time_sec, #0
0BF7 753100    1355       mov current_time_minute, #0
0BFA           1356       ; Initialize counter to zero
0BFA 756000    1357       mov pwm_counter, #0
0BFD 756100    1358       mov pwm_counter+1, #0
0C00 756200    1359       mov pwm_counter+2, #0
0C03 756300    1360       mov pwm_counter+3, #0
0C06           1361       ; Initialize power output
0C06 755F00    1362       mov power_output+3, #0
0C09 755E00    1363       mov power_output+2, #0
0C0C 755D02    1364       mov power_output+1, #02H
0C0F 755CEE    1365       mov power_output, #0EEH ; (initilize to 750 for testing)
0C12           1366   
0C12           1367       ; Clear all the flags
0C12 C20E      1368       clr  tc_missing_abort
0C14 C209      1369       clr  stop_signal
0C16 C210      1370       clr PB0_flag
0C18 C211      1371       clr PB1_flag
0C1A C212      1372       clr PB2_flag
0C1C C201      1373       clr one_second_flag
0C1E C20B      1374       clr config_finish_signal
0C20 C203      1375       clr soak_temp_reached
0C22 C206      1376       clr soak_time_reached
0C24 C204      1377       clr reflow_temp_reached
0C26 C207      1378       clr reflow_time_reached
0C28 C205      1379       clr cooling_temp_reached
0C2A C20C      1380       clr state_change_signal
0C2C C21E      1381       clr one_millisecond_flag_servo
0C2E           1382       
0C2E D20C      1383       setb state_change_signal
0C30           1384   
0C30           1385       ; Set bit
0C30 D20F      1386       setb tc_startup_window
0C32           1387   
0C32           1388       ; --------------------------------------
0C32           1389       ; [FIX] ADD THIS BLOCK TO STOP STARTUP BEEP
0C32           1390       ; --------------------------------------
0C32 756C00    1391       mov beep_state, #0
0C35 756B00    1392       mov beep_count, #0
0C38 756D00    1393       mov beep_tmr, #0
0C3B 756E00    1394       mov beep_tmr+1, #0
0C3E C213      1395       clr one_ms_beep_flag
0C40 C28C      1396       clr TR0              ; Force buzzer hardware OFF
0C42           1397       ; --------------------------------------
0C42           1398   
0C42           1399   
0C42 12045D    1400       lcall Timer0_Init
0C45 120518    1401       lcall Timer2_Init
0C48 1205E5    1402       lcall ELCD_4BIT
0C4B           1403       ;----- Two new lines I added to initialize the UI
0C4B 120EAF    1404       lcall Init_All_Buffers
0C4E 120F02    1405       lcall Update_Screen_Full
0C51           1406       ;-----
0C51 120477    1407       lcall Initialize_Serial_Port
0C54           1408   ;-------------------------------------------------------------------------------;
0C54           1409   ; while(1) loop
0C54           1410   ;-------------------------------------------------------------------------------;
0C54           1411   loop:
0C54           1412       ; Full reset button on P3.7 (active-low to GND)
0C54 30B702    1413        jnb P3_7, Full_Reset_Trig
0C57 8003      1414       sjmp Full_Reset_Check_Done
0C59           1415   
0C59           1416   Full_Reset_Trig:
0C59 02102C    1417       ljmp Full_Reset
0C5C           1418   
0C5C           1419   Full_Reset_Check_Done:
0C5C           1420       ; Check the FSM for KEY1 debounce
0C5C 120886    1421       lcall KEY1_DEB
0C5F           1422       
0C5F           1423       ; Added to take temp readings
0C5F 121032    1424       lcall Read_Thermocouple
0C62           1425       
0C62           1426       ; 1. Check if we reached temp (Observer)
0C62 120989    1427       lcall Temp_Compare
0C65           1428       
0C65           1429       ; 2. Decide heater power based on flags (Driver)
0C65 1210C4    1430       lcall Power_Control
0C68           1431       
0C68           1432       ; 3. [FIX] Calculate Total Seconds (Minutes * 60 + Seconds)
0C68           1433       ; ---------------------------------------------------------
0C68           1434       ; Load Minutes into X
0C68 853132    1435       mov x+0, current_time_minute
0C6B 753300    1436       mov x+1, #0
0C6E 753400    1437       mov x+2, #0
0C71 753500    1438       mov x+3, #0
0C74           1439       
0C74           1440       ; Multiply by 60 (Minutes -> Seconds)
0C74 75363C    1441            mov y+0, #low (60 % 0x10000) 
0C77 753700    1441            mov y+1, #high(60 % 0x10000) 
0C7A 753800    1441            mov y+2, #low (60 / 0x10000) 
0C7D 753900    1441            mov y+3, #high(60 / 0x10000) 
0C80 12018C    1442       lcall mul32
0C83           1443       
0C83           1444       ; Load Seconds into Y
0C83 853036    1445       mov y+0, current_time_sec
0C86 753700    1446       mov y+1, #0
0C89 753800    1447       mov y+2, #0
0C8C 753900    1448       mov y+3, #0
0C8F           1449       
0C8F           1450       ; Add them together (Total Seconds = X + Y)
0C8F 1200D3    1451       lcall add32
0C92           1452       
0C92           1453       ; Store Final Result into 'current_time'
0C92 853250    1454       mov current_time+0, x+0
0C95 853351    1455       mov current_time+1, x+1
0C98 853452    1456       mov current_time+2, x+2
0C9B 853553    1457       mov current_time+3, x+3
0C9E           1458       
0C9E 1209CE    1459       lcall Time_Compare
0CA1           1460       
0CA1 120A18    1461       lcall Safety_Check_TC
0CA4           1462   
0CA4           1463   
0CA4           1464       ; Check the FSM for one second counter
0CA4 1208BC    1465       lcall SEC_FSM
0CA7           1466   
0CA7           1467       ; Check the FSM for the overall control flow of the reflow process
0CA7 120ADA    1468       lcall Control_FSM
0CAA           1469   
0CAA           1470       ; Update the LCD display based on the current state
0CAA 1206AA    1471       lcall LCD_Display_Update_func
0CAD           1472   
0CAD 300202    1473       jnb one_ms_pwm_flag, Skip_Beep_Sync
0CB0 D213      1474       setb one_ms_beep_flag  ; Give the buzzer its own copy of the time tick
0CB2           1475   
0CB2           1476   Skip_Beep_Sync:
0CB2           1477       ; Update the pwm output for the ssr
0CB2 120912    1478       lcall PWM_Wave 
0CB5           1479            ; Update the Buzzer 
0CB5 120AA1    1480            lcall Beep_Task
0CB8           1481       ; Update the pwm output for the servo
0CB8 121107    1482       lcall call_servo_control
0CBB           1483       ; After initialization the program stays in this 'forever' loop
0CBB 020C54    1484       ljmp loop
0CBE           1485   ;-------------------------------------------------------------------------------;
0CBE           1486   
0CBE           1487   ; ================================================================
0CBE           1488   ; UI & HELPER SUBROUTINES
0CBE           1489   ; ================================================================
0CBE           1490   
0CBE           1491   ; ----------------------------------------------------------------
0CBE           1492   ; MODULE: BRIDGE (Text to Integer Conversion)
0CBE           1493   ; ----------------------------------------------------------------
0CBE           1494   Update_FSM_Variables:
0CBE           1495       ; --- 1. SOAK TEMP ---
0CBE 7880      1496       mov R0, #Buf_Soak_Temp
0CC0 120CFD    1497       lcall Parse_Temp_String
0CC3 8F43      1498       mov soak_temp+0, R7
0CC5 754400    1499       mov soak_temp+1, #0
0CC8 754500    1500       mov soak_temp+2, #0
0CCB 754600    1501       mov soak_temp+3, #0
0CCE           1502   
0CCE           1503       ; --- 2. REFLOW TEMP ---
0CCE 7889      1504       mov R0, #Buf_Refl_Temp
0CD0 120CFD    1505       lcall Parse_Temp_String
0CD3 8F47      1506       mov reflow_temp+0, R7
0CD5 754800    1507       mov reflow_temp+1, #0
0CD8 754900    1508       mov reflow_temp+2, #0
0CDB 754A00    1509       mov reflow_temp+3, #0
0CDE           1510   
0CDE           1511       ; --- 3. SOAK TIME ---
0CDE 7884      1512       mov R0, #Buf_Soak_Time
0CE0 120D11    1513       lcall Parse_Time_String
0CE3 8F54      1514       mov soak_time+0, R7
0CE5 8E55      1515       mov soak_time+1, R6
0CE7 755600    1516       mov soak_time+2, #0
0CEA 755700    1517       mov soak_time+3, #0
0CED           1518   
0CED           1519       ; --- 4. REFLOW TIME ---
0CED 788D      1520       mov R0, #Buf_Refl_Time
0CEF 120D11    1521       lcall Parse_Time_String
0CF2 8F58      1522       mov reflow_time+0, R7
0CF4 8E59      1523       mov reflow_time+1, R6
0CF6 755A00    1524       mov reflow_time+2, #0
0CF9 755B00    1525       mov reflow_time+3, #0
0CFC 22        1526       ret
0CFD           1527   
0CFD           1528   ; --- Helper: Parse "123" to Integer ---
0CFD           1529   Parse_Temp_String:
0CFD 7F00      1530       mov R7, #0              ; Clear Result
0CFF           1531   Parse_Temp_Loop:
0CFF E6        1532       mov A, @R0
0D00 600E      1533       jz Parse_Temp_Done      ; If Null, we are done
0D02           1534       
0D02           1535       ; Convert ASCII to Digit
0D02 C3        1536       clr C
0D03 9430      1537       subb A, #0x30
0D05 FD        1538       mov R5, A               ; R5 = New Digit
0D06           1539       
0D06           1540       ; Result = (Result * 10) + New Digit
0D06 EF        1541       mov A, R7
0D07 75F00A    1542       mov B, #10
0D0A A4        1543       mul AB
0D0B 2D        1544       add A, R5
0D0C FF        1545       mov R7, A
0D0D           1546       
0D0D 08        1547       inc R0
0D0E 80EF      1548       sjmp Parse_Temp_Loop
0D10           1549   Parse_Temp_Done:
0D10 22        1550       ret
0D11           1551   
0D11           1552   ; --- Helper: Parse "MMSS" to Seconds ---
0D11           1553   Parse_Time_String:
0D11           1554       ; 1. Minutes Tens
0D11 E6        1555       mov A, @R0
0D12 9430      1556       subb A, #0x30
0D14 75F00A    1557       mov B, #10
0D17 A4        1558       mul AB
0D18 FD        1559       mov R5, A
0D19 08        1560       inc R0
0D1A           1561       
0D1A           1562       ; 2. Minutes Ones
0D1A E6        1563       mov A, @R0
0D1B 9430      1564       subb A, #0x30
0D1D 2D        1565       add A, R5
0D1E FD        1566       mov R5, A               ; R5 = Total Minutes
0D1F 08        1567       inc R0
0D20           1568       
0D20           1569       ; 3. Seconds Tens
0D20 E6        1570       mov A, @R0
0D21 9430      1571       subb A, #0x30
0D23 75F00A    1572       mov B, #10
0D26 A4        1573       mul AB
0D27 FC        1574       mov R4, A
0D28 08        1575       inc R0
0D29           1576       
0D29           1577       ; 4. Seconds Ones
0D29 E6        1578       mov A, @R0
0D2A 9430      1579       subb A, #0x30
0D2C 2C        1580       add A, R4               ; R4 = Total Seconds
0D2D           1581       
0D2D           1582       ; 5. Calculate Total Seconds = (Mins * 60) + Secs
0D2D ED        1583       mov A, R5
0D2E 75F03C    1584       mov B, #60
0D31 A4        1585       mul AB
0D32 2C        1586       add A, R4
0D33 FF        1587       mov R7, A               ; Low Byte
0D34 E5F0      1588       mov A, B
0D36 3400      1589       addc A, #0
0D38 FE        1590       mov R6, A               ; High Byte
0D39 22        1591       ret
0D3A           1592   
0D3A           1593   ; ----------------------------------------------------------------
0D3A           1594   ; MODULE: BUTTON HANDLER (Mode Selection)
0D3A           1595   ; ----------------------------------------------------------------
0D3A           1596   Check_Buttons:
0D3A           1597       ; --- FORCE INPUT MODE ---
0D3A           1598       ; This clears any '0' the LCD library might have written to our buttons
0D3A 438055    1599       orl P0, #055H   ; Sets P0.0, P0.2, P0.4, and P0.6 to '1' (Input Mode)
0D3D           1600       ; ------------------------
0D3D           1601   
0D3D 30800A    1602       jnb BTN_SOAK_TEMP, Btn_Soak_Temp_Press
0D40 308212    1603       jnb BTN_SOAK_TIME, Btn_Soak_Time_Press
0D43 30841A    1604       jnb BTN_REFL_TEMP, Btn_Refl_Temp_Press
0D46 308622    1605       jnb BTN_REFL_TIME, Btn_Refl_Time_Press
0D49 22        1606       ret
0D4A           1607   
0D4A           1608   Btn_Soak_Temp_Press:
0D4A 120FF4    1609       lcall Wait_25ms_BLOCKING
0D4D 756901    1610       mov Current_State, #1
0D50 756A00    1611       mov Cursor_Idx, #0
0D53 8021      1612       sjmp Redraw_Screen
0D55           1613   
0D55           1614   Btn_Soak_Time_Press:
0D55 120FF4    1615       lcall Wait_25ms_BLOCKING
0D58 756902    1616       mov Current_State, #2
0D5B 756A00    1617       mov Cursor_Idx, #0
0D5E 8016      1618       sjmp Redraw_Screen
0D60           1619   
0D60           1620   Btn_Refl_Temp_Press:
0D60 120FF4    1621       lcall Wait_25ms_BLOCKING
0D63 756903    1622       mov Current_State, #3
0D66 756A00    1623       mov Cursor_Idx, #0
0D69 800B      1624       sjmp Redraw_Screen
0D6B           1625   
0D6B           1626   Btn_Refl_Time_Press:
0D6B 120FF4    1627       lcall Wait_25ms_BLOCKING 
0D6E 756904    1628       mov Current_State, #4
0D71 756A00    1629       mov Cursor_Idx, #0
0D74 8000      1630       sjmp Redraw_Screen
0D76           1631   
0D76           1632   Redraw_Screen:
0D76           1633       ; Wait for button release
0D76 3080FD    1634       jnb BTN_SOAK_TEMP, $
0D79 3082FD    1635       jnb BTN_SOAK_TIME, $
0D7C 3084FD    1636       jnb BTN_REFL_TEMP, $
0D7F 3086FD    1637       jnb BTN_REFL_TIME, $
0D82           1638   
0D82 120F02    1639       lcall Update_Screen_Full
0D85 22        1640       ret
0D86           1641   
0D86           1642   ; ----------------------------------------------------------------
0D86           1643   ; MODULE: KEYPAD HANDLER (Input Logic)
0D86           1644   ; ----------------------------------------------------------------
0D86           1645   Check_Keypad:
0D86           1646       ; If State is 0 (Home), ignore keypad
0D86 E569      1647       mov A, Current_State
0D88 6050      1648       jz Keypad_Exit
0D8A           1649       
0D8A 120DDB    1650       lcall Keypad_Scan
0D8D 504B      1651       jnc Keypad_Exit         ; Carry = 0 means no key pressed
0D8F           1652   
0D8F           1653       ; --- Check Special Keys ---
0D8F EF        1654       mov A, R7
0D90 B40E0A    1655       cjne A, #14, Check_Hash ; 14 is Star (*)
0D93           1656       
0D93           1657       ; Star Key Pressed: Reset Buffer
0D93 120EDF    1658       lcall Reset_Current_Buffer
0D96 120F02    1659       lcall Update_Screen_Full
0D99 756A00    1660       mov Cursor_Idx, #0
0D9C 22        1661       ret
0D9D           1662   
0D9D           1663   Check_Hash:
0D9D EF        1664       mov A, R7
0D9E B40C01    1665       cjne A, #12, Check_Numeric ; 12 is Hash (#)
0DA1 22        1666       ret                     ; Ignore Hash key
0DA2           1667   
0DA2           1668   Check_Numeric:
0DA2           1669       ; Ensure key is 0-9
0DA2 EF        1670       mov A, R7
0DA3 C3        1671       clr C
0DA4 940A      1672       subb A, #10
0DA6 5031      1673       jnc Symbol_Key_Ignored
0DA8           1674       
0DA8           1675       ; Convert to ASCII
0DA8 EF        1676       mov A, R7
0DA9 2430      1677       add A, #0x30
0DAB FD        1678       mov R5, A
0DAC           1679   
0DAC           1680       ; Save to Buffer
0DAC 12100D    1681       lcall Get_Current_Buffer_Addr
0DAF E56A      1682       mov A, Cursor_Idx
0DB1 28        1683       add A, R0
0DB2 F8        1684       mov R0, A
0DB3 ED        1685       mov A, R5
0DB4 F6        1686       mov @R0, A
0DB5 056A      1687       inc Cursor_Idx
0DB7           1688   
0DB7           1689       ; --- Check Cursor Limits ---
0DB7 E569      1690       mov A, Current_State
0DB9 B40102    1691       cjne A, #1, Check_Limit_Time_1
0DBC 8005      1692       sjmp Limit_Temp_3
0DBE           1693   
0DBE           1694   Check_Limit_Time_1:
0DBE B4030B    1695       cjne A, #3, Limit_Time_4
0DC1 8000      1696       sjmp Limit_Temp_3
0DC3           1697   
0DC3           1698   Limit_Temp_3:
0DC3 E56A      1699       mov A, Cursor_Idx
0DC5 B4030D    1700       cjne A, #3, Do_Refresh
0DC8 156A      1701       dec Cursor_Idx          ; Stay at last digit
0DCA 8009      1702       sjmp Do_Refresh
0DCC           1703   
0DCC           1704   Limit_Time_4:
0DCC E56A      1705       mov A, Cursor_Idx
0DCE B40404    1706       cjne A, #4, Do_Refresh
0DD1 156A      1707       dec Cursor_Idx          ; Stay at last digit
0DD3 8000      1708       sjmp Do_Refresh
0DD5           1709   
0DD5           1710   Do_Refresh:
0DD5 120F02    1711       lcall Update_Screen_Full
0DD8 22        1712       ret
0DD9           1713   
0DD9           1714   Symbol_Key_Ignored:
0DD9 22        1715       ret
0DDA           1716   Keypad_Exit:
0DDA 22        1717       ret
0DDB           1718   
0DDB           1719   ; ----------------------------------------------------------------
0DDB           1720   ; MODULE: HARDWARE SCANNER (Matrix Logic)
0DDB           1721   ; ----------------------------------------------------------------
0DDB           1722   Keypad_Scan:
0DDB           1723       ; Step 1: Check if ANY key is pressed (All Rows Low)
0DDB C292      1724       clr ROW1
0DDD C294      1725       clr ROW2
0DDF C296      1726       clr ROW3
0DE1 C2A0      1727       clr ROW4
0DE3 A2A2      1728       mov C, COL1
0DE5 82A4      1729       anl C, COL2
0DE7 82A6      1730       anl C, COL3
0DE9 82B0      1731       anl C, COL4
0DEB 5002      1732       jnc Keypad_Debounce
0DED C3        1733       clr C
0DEE 22        1734       ret
0DEF           1735   
0DEF           1736   Keypad_Debounce:
0DEF 120FF4    1737       lcall Wait_25ms_BLOCKING
0DF2 A2A2      1738       mov C, COL1
0DF4 82A4      1739       anl C, COL2
0DF6 82A6      1740       anl C, COL3
0DF8 82B0      1741       anl C, COL4
0DFA 5002      1742       jnc Keypad_Find_Row
0DFC C3        1743       clr C
0DFD 22        1744       ret
0DFE           1745   
0DFE           1746   Keypad_Find_Row:
0DFE D292      1747       setb ROW1
0E00 D294      1748       setb ROW2
0E02 D296      1749       setb ROW3
0E04 D2A0      1750       setb ROW4
0E06           1751   
0E06           1752       ; Row 1
0E06 C292      1753       clr ROW1
0E08 30A23D    1754       jnb COL1, Keypad_Key_1
0E0B 30A43E    1755       jnb COL2, Keypad_Key_2
0E0E 30A63F    1756       jnb COL3, Keypad_Key_3
0E11 30B040    1757       jnb COL4, Keypad_Key_A
0E14 D292      1758       setb ROW1
0E16           1759   
0E16           1760       ; Row 2
0E16 C294      1761       clr ROW2
0E18 30A23D    1762       jnb COL1, Keypad_Key_4
0E1B 30A43E    1763       jnb COL2, Keypad_Key_5
0E1E 30A63F    1764       jnb COL3, Keypad_Key_6
0E21 30B040    1765       jnb COL4, Keypad_Key_B
0E24 D294      1766       setb ROW2
0E26           1767   
0E26           1768       ; Row 3
0E26 C296      1769       clr ROW3
0E28 30A23D    1770       jnb COL1, Keypad_Key_7
0E2B 30A43E    1771       jnb COL2, Keypad_Key_8
0E2E 30A63F    1772       jnb COL3, Keypad_Key_9
0E31 30B040    1773       jnb COL4, Keypad_Key_C
0E34 D296      1774       setb ROW3
0E36           1775   
0E36           1776       ; Row 4
0E36 C2A0      1777       clr ROW4
0E38 30A23D    1778       jnb COL1, Keypad_Key_Star
0E3B 30A43E    1779       jnb COL2, Keypad_Key_0
0E3E 30A63F    1780       jnb COL3, Keypad_Key_Hash
0E41 30B040    1781       jnb COL4, Keypad_Key_D
0E44 D2A0      1782       setb ROW4
0E46 C3        1783       clr C
0E47 22        1784       ret
0E48           1785   
0E48           1786   ; Key Mapping (Renamed to avoid conflicts)
0E48 7F01      1787   Keypad_Key_1: mov R7, #1
0E4A 803C      1788          sjmp Wait_Release
0E4C 7F02      1789   Keypad_Key_2: mov R7, #2
0E4E 8038      1790          sjmp Wait_Release
0E50 7F03      1791   Keypad_Key_3: mov R7, #3
0E52 8034      1792          sjmp Wait_Release
0E54 7F0A      1793   Keypad_Key_A: mov R7, #10
0E56 8030      1794          sjmp Wait_Release
0E58 7F04      1795   Keypad_Key_4: mov R7, #4
0E5A 802C      1796          sjmp Wait_Release
0E5C 7F05      1797   Keypad_Key_5: mov R7, #5
0E5E 8028      1798          sjmp Wait_Release
0E60 7F06      1799   Keypad_Key_6: mov R7, #6
0E62 8024      1800          sjmp Wait_Release
0E64 7F0B      1801   Keypad_Key_B: mov R7, #11
0E66 8020      1802          sjmp Wait_Release
0E68 7F07      1803   Keypad_Key_7: mov R7, #7
0E6A 801C      1804          sjmp Wait_Release
0E6C 7F08      1805   Keypad_Key_8: mov R7, #8
0E6E 8018      1806          sjmp Wait_Release
0E70 7F09      1807   Keypad_Key_9: mov R7, #9
0E72 8014      1808          sjmp Wait_Release
0E74 7F0D      1809   Keypad_Key_C: mov R7, #13
0E76 8010      1810          sjmp Wait_Release
0E78 7F0E      1811   Keypad_Key_Star: mov R7, #14
0E7A 800C      1812          sjmp Wait_Release
0E7C 7F00      1813   Keypad_Key_0: mov R7, #0
0E7E 8008      1814          sjmp Wait_Release
0E80 7F0C      1815   Keypad_Key_Hash: mov R7, #12
0E82 8004      1816          sjmp Wait_Release
0E84 7F0F      1817   Keypad_Key_D: mov R7, #15
0E86 8000      1818          sjmp Wait_Release
0E88           1819   
0E88           1820   Wait_Release:
0E88 A2A2      1821       mov C, COL1
0E8A 82A4      1822       anl C, COL2
0E8C 82A6      1823       anl C, COL3
0E8E 82B0      1824       anl C, COL4
0E90 50F6      1825       jnc Wait_Release
0E92 D3        1826       setb C
0E93 D292      1827       setb ROW1
0E95 D294      1828       setb ROW2
0E97 D296      1829       setb ROW3
0E99 D2A0      1830       setb ROW4
0E9B 22        1831       ret
0E9C           1832   
0E9C           1833   Wait_25ms:
0E9C           1834       ; 1. Check if we are already waiting
0E9C 20140E    1835       jb wait25_active, Check_Timer_Status
0E9F           1836       
0E9F           1837       ; 2. Check if we just finished
0E9F 301504    1838       jnb wait25_done, Start_New_Timer
0EA2           1839       
0EA2           1840       ; 3. Timer is DONE! Reset flags and return True
0EA2 C215      1841       clr wait25_done
0EA4 D3        1842       setb C          ; Carry = 1 means "Done"
0EA5 22        1843       ret
0EA6           1844   
0EA6           1845   Start_New_Timer:
0EA6           1846       ; 4. Start a new 25ms wait
0EA6 754F00    1847       mov wait25_count, #0
0EA9 D214      1848       setb wait25_active
0EAB C3        1849       clr C           ; Carry = 0 means "Not Done Yet"
0EAC 22        1850       ret
0EAD           1851   
0EAD           1852   Check_Timer_Status:
0EAD           1853       ; 5. Still waiting... return False immediately
0EAD C3        1854       clr C           ; Carry = 0 means "Not Done Yet"
0EAE 22        1855       ret
0EAF           1856   
0EAF           1857   ; ----------------------------------------------------------------
0EAF           1858   ; MODULE: BUFFER INIT (Reset Logic)
0EAF           1859   ; ----------------------------------------------------------------
0EAF           1860   Init_All_Buffers:
0EAF 7880      1861       mov R0, #Buf_Soak_Temp
0EB1 120EC4    1862       lcall Init_Temp_Template
0EB4 7889      1863       mov R0, #Buf_Refl_Temp
0EB6 120EC4    1864       lcall Init_Temp_Template
0EB9 7884      1865       mov R0, #Buf_Soak_Time
0EBB 120ED0    1866       lcall Init_Time_Template
0EBE 788D      1867       mov R0, #Buf_Refl_Time
0EC0 120ED0    1868       lcall Init_Time_Template
0EC3 22        1869       ret
0EC4           1870   
0EC4           1871   Init_Temp_Template:
0EC4 7630      1872       mov @R0, #'0'
0EC6 08        1873       inc R0
0EC7 7630      1874       mov @R0, #'0'
0EC9 08        1875       inc R0
0ECA 7630      1876       mov @R0, #'0'
0ECC 08        1877       inc R0
0ECD 7600      1878       mov @R0, #0
0ECF 22        1879       ret
0ED0           1880   
0ED0           1881   Init_Time_Template:
0ED0 7630      1882       mov @R0, #'0'
0ED2 08        1883       inc R0
0ED3 7630      1884       mov @R0, #'0'
0ED5 08        1885       inc R0
0ED6 7630      1886       mov @R0, #'0'
0ED8 08        1887       inc R0
0ED9 7630      1888       mov @R0, #'0'
0EDB 08        1889       inc R0
0EDC 7600      1890       mov @R0, #0
0EDE 22        1891       ret
0EDF           1892   
0EDF           1893   Reset_Current_Buffer:
0EDF E569      1894       mov A, Current_State
0EE1 B40106    1895       cjne A, #1, Reset_Chk_2
0EE4 7880      1896       mov R0, #Buf_Soak_Temp
0EE6 120EC4    1897       lcall Init_Temp_Template
0EE9 22        1898       ret
0EEA           1899   Reset_Chk_2:
0EEA B40206    1900       cjne A, #2, Reset_Chk_3
0EED 7884      1901       mov R0, #Buf_Soak_Time
0EEF 120ED0    1902       lcall Init_Time_Template
0EF2 22        1903       ret
0EF3           1904   Reset_Chk_3:
0EF3 B40306    1905       cjne A, #3, Reset_Chk_4
0EF6 7889      1906       mov R0, #Buf_Refl_Temp
0EF8 120EC4    1907       lcall Init_Temp_Template
0EFB 22        1908       ret
0EFC           1909   Reset_Chk_4:
0EFC 788D      1910       mov R0, #Buf_Refl_Time
0EFE 120ED0    1911       lcall Init_Time_Template
0F01 22        1912       ret
0F02           1913   
0F02           1914   ; ----------------------------------------------------------------
0F02           1915   ; MODULE: SCREEN UPDATE (Visual Logic)
0F02           1916   ; ----------------------------------------------------------------
0F02           1917   Update_Screen_Full:
0F02 120FFA    1918       lcall Clear_Screen_Func
0F05 C0E0      1919            push acc
0F07 7401      1919            mov a, #1
0F09 14        1919            dec a
0F0A 120625    1919            lcall ?Set_Cursor_1 ; Select column and row
0F0D D0E0      1919            pop acc
0F0F           1920   
0F0F           1921       ; --- Draw Line 1 (Titles) ---
0F0F E569      1922       mov A, Current_State
0F11 B40013    1923       cjne A, #0, Update_State_1
0F14 C083      1924            push dph
0F16 C082      1924            push dpl
0F18 C0E0      1924            push acc
0F1A 900350    1924            mov dptr, #Txt_Home
0F1D 120618    1924            lcall ?Send_Constant_String
0F20 D0E0      1924            pop acc
0F22 D082      1924            pop dpl
0F24 D083      1924            pop dph
0F26 22        1925       ret 
0F27           1926   Update_State_1:
0F27 B40114    1927       cjne A, #1, Update_State_2
0F2A C083      1928            push dph
0F2C C082      1928            push dpl
0F2E C0E0      1928            push acc
0F30 900361    1928            mov dptr, #Txt_SoakT
0F33 120618    1928            lcall ?Send_Constant_String
0F36 D0E0      1928            pop acc
0F38 D082      1928            pop dpl
0F3A D083      1928            pop dph
0F3C 8042      1929       sjmp Draw_Temp_Format
0F3E           1930   Update_State_2:
0F3E B40214    1931       cjne A, #2, Update_State_3
0F41 C083      1932            push dph
0F43 C082      1932            push dpl
0F45 C0E0      1932            push acc
0F47 900372    1932            mov dptr, #Txt_SoakTime
0F4A 120618    1932            lcall ?Send_Constant_String
0F4D D0E0      1932            pop acc
0F4F D082      1932            pop dpl
0F51 D083      1932            pop dph
0F53 8042      1933       sjmp Draw_Time_Format
0F55           1934   Update_State_3:
0F55 B40314    1935       cjne A, #3, Update_State_4
0F58 C083      1936            push dph
0F5A C082      1936            push dpl
0F5C C0E0      1936            push acc
0F5E 900383    1936            mov dptr, #Txt_ReflT
0F61 120618    1936            lcall ?Send_Constant_String
0F64 D0E0      1936            pop acc
0F66 D082      1936            pop dpl
0F68 D083      1936            pop dph
0F6A 8014      1937       sjmp Draw_Temp_Format
0F6C           1938   Update_State_4:
0F6C C083      1939            push dph
0F6E C082      1939            push dpl
0F70 C0E0      1939            push acc
0F72 900394    1939            mov dptr, #Txt_ReflTime
0F75 120618    1939            lcall ?Send_Constant_String
0F78 D0E0      1939            pop acc
0F7A D082      1939            pop dpl
0F7C D083      1939            pop dph
0F7E 8017      1940       sjmp Draw_Time_Format
0F80           1941   
0F80           1942   ; --- Draw Line 2 (Values) ---
0F80           1943   Draw_Temp_Format:
0F80 C0E0      1944            push acc
0F82 7401      1944            mov a, #1
0F84 14        1944            dec a
0F85 120623    1944            lcall ?Set_Cursor_2 ; Select column and row
0F88 D0E0      1944            pop acc
0F8A 12100D    1945       lcall Get_Current_Buffer_Addr
0F8D 120FEA    1946       lcall Print_String_RAM
0F90 7443      1947       mov A, #'C'
0F92 1205DB    1948       lcall ?WriteData
0F95 8027      1949       sjmp Restore_Cursor
0F97           1950   
0F97           1951   Draw_Time_Format:
0F97 C0E0      1952            push acc
0F99 7401      1952            mov a, #1
0F9B 14        1952            dec a
0F9C 120623    1952            lcall ?Set_Cursor_2 ; Select column and row
0F9F D0E0      1952            pop acc
0FA1 12100D    1953       lcall Get_Current_Buffer_Addr
0FA4           1954       ; MM
0FA4 E6        1955       mov A, @R0
0FA5 1205DB    1956       lcall ?WriteData
0FA8 08        1957       inc R0
0FA9 E6        1958       mov A, @R0
0FAA 1205DB    1959       lcall ?WriteData
0FAD 08        1960       inc R0
0FAE           1961       ; Colon
0FAE 743A      1962       mov A, #':'
0FB0 1205DB    1963       lcall ?WriteData
0FB3           1964       ; SS
0FB3 E6        1965       mov A, @R0
0FB4 1205DB    1966       lcall ?WriteData
0FB7 08        1967       inc R0
0FB8 E6        1968       mov A, @R0
0FB9 1205DB    1969       lcall ?WriteData
0FBC           1970       ; Unit
0FBC           1971       ;got rid of the "s"
0FBC           1972       ;mov A, #'s'
0FBC           1973       ;lcall ?WriteData
0FBC 8000      1974       sjmp Restore_Cursor
0FBE           1975   
0FBE           1976   ; --- Restore Cursor Position ---
0FBE           1977   Restore_Cursor:
0FBE E569      1978       mov A, Current_State
0FC0 B40202    1979       cjne A, #2, RC_Check_State_4  
0FC3 800D      1980       sjmp Adjust_Cursor_Time
0FC5           1981   RC_Check_State_4:             
0FC5 B40402    1982       cjne A, #4, Normal_Cursor
0FC8 8008      1983       sjmp Adjust_Cursor_Time
0FCA           1984   
0FCA           1985   Normal_Cursor:
0FCA E56A      1986       mov A, Cursor_Idx
0FCC 24C0      1987       add A, #0xC0
0FCE 1205E0    1988       lcall ?WriteCommand
0FD1 22        1989       ret
0FD2           1990   
0FD2           1991   Adjust_Cursor_Time:
0FD2           1992       ; Skip the colon index (2)
0FD2 E56A      1993       mov A, Cursor_Idx
0FD4 B40201    1994       cjne A, #2, No_Skip
0FD7 04        1995       inc A 
0FD8           1996   No_Skip:
0FD8           1997       ; Add 1 if past the colon
0FD8 C3        1998       clr C
0FD9 9402      1999       subb A, #2
0FDB 4005      2000       jc No_Add
0FDD E56A      2001       mov A, Cursor_Idx
0FDF 04        2002       inc A
0FE0 8002      2003       sjmp Final_Cursor_Set
0FE2           2004   No_Add:
0FE2 E56A      2005       mov A, Cursor_Idx
0FE4           2006   Final_Cursor_Set:
0FE4 24C0      2007       add A, #0xC0
0FE6 1205E0    2008       lcall ?WriteCommand
0FE9 22        2009       ret
0FEA           2010   
0FEA           2011   Print_String_RAM:
0FEA E6        2012       mov A, @R0
0FEB 6006      2013       jz Print_String_Done
0FED 1205DB    2014       lcall ?WriteData
0FF0 08        2015       inc R0
0FF1 80F7      2016       sjmp Print_String_RAM
0FF3           2017   Print_String_Done:
0FF3 22        2018       ret
0FF4           2019   
0FF4           2020   ; Blocking wrapper for LCD clear (keeps old behavior just for this)
0FF4           2021   Wait_25ms_BLOCKING:
0FF4 120E9C    2022       lcall Wait_25ms
0FF7 50FB      2023       jnc Wait_25ms_BLOCKING ; Keep jumping back until Done (C=1)
0FF9 22        2024       ret
0FFA           2025   
0FFA           2026   Clear_Screen_Func:
0FFA 7401      2027       mov A, #0x01
0FFC 1205E0    2028       lcall ?WriteCommand
0FFF           2029       
0FFF           2030       ; --- FIX: HARDWARE DELAY LOOP (MAX STRENGTH) ---
0FFF           2031       ; The LCD needs ~2ms to clear. 
0FFF           2032       ; We use R0=255 to guarantee ~5ms+ delay.
0FFF           2033       ; This ensures the LCD is 100% ready before we send "Ramp to Soak".
0FFF 78FF      2034       mov R0, #255
1001           2035   Clear_Delay_Loop_Outer:
1001 79FF      2036       mov R1, #255
1003           2037   Clear_Delay_Loop_Inner:
1003 D9FE      2038       djnz R1, Clear_Delay_Loop_Inner
1005 D8FA      2039       djnz R0, Clear_Delay_Loop_Outer
1007           2040       ; -----------------------------------------------
1007           2041   
1007 740C      2042       mov A, #0x0C  ; Display ON, Cursor OFF
1009 1205E0    2043       lcall ?WriteCommand
100C 22        2044       ret
100D           2045   
100D           2046   Get_Current_Buffer_Addr:
100D E569      2047       mov A, Current_State
100F B40103    2048       cjne A, #1, Get_Buf_2
1012 7880      2049       mov R0, #Buf_Soak_Temp
1014 22        2050       ret
1015           2051   Get_Buf_2:
1015 B40203    2052       cjne A, #2, Get_Buf_3
1018 7884      2053       mov R0, #Buf_Soak_Time
101A 22        2054       ret
101B           2055   Get_Buf_3:
101B B40303    2056       cjne A, #3, Get_Buf_4
101E 7889      2057       mov R0, #Buf_Refl_Temp
1020 22        2058       ret
1021           2059   Get_Buf_4:
1021 788D      2060       mov R0, #Buf_Refl_Time
1023 22        2061       ret
1024           2062       
1024           2063   ; --- Helper to prevent "Machine Gun" button presses ---
1024           2064   Wait_For_P1_0_Release:
1024 3090FD    2065       jnb P1.0, $    ; Wait here while the button is still pressed (0)
1027 22        2066       ret
1028           2067   
1028           2068   ; --- Full reset helper for P3.7 (active-low) ---
1028           2069   Wait_For_P3_7_Release:
1028 30B7FD    2070       jnb P3_7, $    ; Wait here while the button is still pressed (0)
102B 22        2071       ret
102C           2072   
102C           2073   Full_Reset:
102C 121028    2074       lcall Wait_For_P3_7_Release
102F 020BC1    2075       ljmp main
1032           2076   
1032           2077   ; ================================================================
1032           2078   ; MODULE: THERMOCOUPLE ADC DRIVER (WITH NOISE SUPPRESSION & JUMP FIX)
1032           2079   ; ================================================================
1032           2080   Read_Thermocouple:
1032           2081       ; 1. Check Non-Blocking Timer
1032 120E9C    2082       lcall Wait_25ms
1035           2083       
1035           2084       ; [FIX] TRAMPOLINE JUMP
1035           2085       ; "jnc" cannot jump to the end because the code is too long.
1035           2086       ; We invert logic: If Carry=1 (Time is up), Jump NEARBY.
1035 4001      2087       jc Proceed_Reading
1037 22        2088       ret  ; If Carry=0, Return immediately.
1038           2089   
1038           2090   Proceed_Reading:
1038           2091       ; --- 25ms Passed! Time to Read ---
1038           2092   
1038           2093       ; [FIX] SILENCE THE BUZZER (Noise Suppression)
1038           2094       ; Save buzzer state and force it OFF during the sensitive read
1038 E588      2095       mov A, TCON      
103A 5410      2096       anl A, #0x10     ; Isolate TR0 bit
103C C0E0      2097       push acc         ; Save it
103E C28C      2098       clr TR0          ; STOP NOISE
1040           2099   
1040           2100       ; 2. Initialize / Trigger ADC
1040 75A180    2101       mov ADC_C, #0x80    ; Reset
1043 00        2102       nop
1044 00        2103       nop
1045 75A101    2104       mov ADC_C, #0x01    ; Start Channel 0
1048           2105       
1048           2106       ; 3. Settle Delay
1048 7DFA      2107       mov R5, #250
104A           2108   ADC_Settle_Loop:
104A 00        2109       nop
104B 00        2110       nop
104C DDFC      2111       djnz R5, ADC_Settle_Loop
104E           2112       
104E           2113       ; 4. Read Raw Data
104E 85A232    2114       mov x+0, ADC_L
1051 85A333    2115       mov x+1, ADC_H
1054 753400    2116       mov x+2, #0
1057 753500    2117       mov x+3, #0
105A           2118       
105A           2119       ; 5. Mask Data
105A E533      2120       mov a, x+1
105C 540F      2121       anl a, #0x0F
105E F533      2122       mov x+1, a
1060           2123       
1060           2124       ; [FIX] RESTORE THE BUZZER
1060 D0E0      2125       pop acc          ; Get previous state
1062 6002      2126       jz Skip_Restore  ; If it was OFF, keep it OFF
1064 D28C      2127       setb TR0         ; If it was ON, turn it back ON
1066           2128   Skip_Restore:
1066           2129   
1066           2130       ; 6. Math Conversions
1066 753616    2131            mov y+0, #low (4118 % 0x10000) 
1069 753710    2131            mov y+1, #high(4118 % 0x10000) 
106C 753800    2131            mov y+2, #low (4118 / 0x10000) 
106F 753900    2131            mov y+3, #high(4118 / 0x10000) 
1072 12018C    2132       lcall mul32       
1075           2133   
1075 75A104    2134       mov ADC_C, #0x04    ; Read LM4040
1078 85A236    2135       mov y+0, ADC_L      
107B 85A337    2136       mov y+1, ADC_H      
107E 753800    2137       mov y+2, #0
1081 753900    2138       mov y+3, #0
1084 75A100    2139       mov ADC_C, #0x00    ; Reset
1087           2140       
1087 120280    2141       lcall div32         
108A 753664    2142            mov y+0, #low (100 % 0x10000) 
108D 753700    2142            mov y+1, #high(100 % 0x10000) 
1090 753800    2142            mov y+2, #low (100 / 0x10000) 
1093 753900    2142            mov y+3, #high(100 / 0x10000) 
1096 12018C    2143       lcall mul32
1099 75362B    2144            mov y+0, #low (1323 % 0x10000) 
109C 753705    2144            mov y+1, #high(1323 % 0x10000) 
109F 753800    2144            mov y+2, #low (1323 / 0x10000) 
10A2 753900    2144            mov y+3, #high(1323 / 0x10000)         
10A5 120280    2145       lcall div32    
10A8 753614    2146            mov y+0, #low (COLD_JUNCTION_TEMP % 0x10000) 
10AB 753700    2146            mov y+1, #high(COLD_JUNCTION_TEMP % 0x10000) 
10AE 753800    2146            mov y+2, #low (COLD_JUNCTION_TEMP / 0x10000) 
10B1 753900    2146            mov y+3, #high(COLD_JUNCTION_TEMP / 0x10000) 
10B4 1200D3    2147       lcall add32     
10B7           2148       
10B7           2149       ; 8. Store Result
10B7 85323F    2150       mov current_temp+0, x+0
10BA 853340    2151       mov current_temp+1, x+1
10BD 853441    2152       mov current_temp+2, x+2
10C0 853542    2153       mov current_temp+3, x+3
10C3           2154   
10C3 22        2155       ret
10C4           2156       
10C4           2157   ; ================================================================
10C4           2158   ; MODULE: POWER CONTROLLER (The Brain)
10C4           2159   ; ================================================================
10C4           2160   Power_Control:
10C4           2161       ; Default: Turn Heat OFF (Safety)
10C4 755C00    2162       mov power_output+0, #0
10C7 755D00    2163       mov power_output+1, #0
10CA 755E00    2164       mov power_output+2, #0
10CD 755F00    2165       mov power_output+3, #0
10D0           2166   
10D0 E568      2167       mov a, Control_FSM_state
10D2           2168   
10D2           2169       ; --- State 2: RAMP TO SOAK ---
10D2 B40202    2170       cjne a, #2, PC_Check_Soak
10D5           2171       ; Mode: Full Speed Ahead
10D5 8016      2172       sjmp Set_Max_Power
10D7           2173   
10D7           2174   PC_Check_Soak:
10D7           2175       ; --- State 3: SOAK PHASE ---
10D7 B40305    2176       cjne a, #3, PC_Check_Ramp_Reflow
10DA           2177       ; Mode: Maintenance (Low Power)
10DA           2178       ; If Temp > Target, OFF. If Temp < Target, 20% Power.
10DA 20030F    2179       jb soak_temp_reached, PC_Done ; If hot enough, stay OFF
10DD 801B      2180       sjmp Set_20_Percent_Power     ; If cold, use 20%
10DF           2181   
10DF           2182   PC_Check_Ramp_Reflow:
10DF           2183       ; --- State 4: RAMP TO REFLOW ---
10DF B40402    2184       cjne a, #4, PC_Check_Reflow
10E2           2185       ; Mode: Full Speed Ahead
10E2 8009      2186       sjmp Set_Max_Power
10E4           2187   
10E4           2188   PC_Check_Reflow:
10E4           2189       ; --- State 5: REFLOW PHASE ---
10E4 B40505    2190       cjne a, #5, PC_Done
10E7           2191       ; Mode: Maintenance (Low Power)
10E7 200402    2192       jb reflow_temp_reached, PC_Done
10EA 800E      2193       sjmp Set_20_Percent_Power
10EC           2194   
10EC           2195   PC_Done:
10EC 22        2196       ret
10ED           2197   
10ED           2198   ; --- Power Helpers ---
10ED           2199   
10ED           2200   Set_Max_Power:
10ED           2201       ; Load 1500 (0x05DC) = 100% Duty Cycle
10ED 755CDC    2202       mov power_output+0, #0xDC
10F0 755D05    2203       mov power_output+1, #0x05
10F3 755E00    2204       mov power_output+2, #0
10F6 755F00    2205       mov power_output+3, #0
10F9 22        2206       ret
10FA           2207   
10FA           2208   Set_20_Percent_Power:
10FA           2209       ; Load 300 (0x012C) = 20% Duty Cycle
10FA 755C2C    2210       mov power_output+0, #0x2C
10FD 755D01    2211       mov power_output+1, #0x01
1100 755E00    2212       mov power_output+2, #0
1103 755F00    2213       mov power_output+3, #0
1106 22        2214       ret
1107           2215   
1107           2216   
1107           2217   ;--------------------------------------------------------------
1107           2218   ; set servo angle according to the state
1107           2219   ; call servo control function every 1ms
1107           2220   ;--------------------------------------------------------------
1107           2221   call_servo_control:
1107           2222            ; check current state and change servo angle
1107 E568      2223            mov a, Control_FSM_state
1109           2224            
1109           2225            ; handle state 0
1109 B40004    2226            cjne a, #0, servo_state1
110C C21F      2227            clr servo_angle_zero ; close door at state 0
110E 802C      2228            sjmp check_servo_flag
1110           2229   
1110           2230            ; handle state 1
1110           2231            servo_state1:
1110 B40104    2232            cjne a, #1, servo_state2
1113 D21F      2233            setb servo_angle_zero ; open door at state 1
1115 8025      2234            sjmp check_servo_flag
1117           2235   
1117           2236            ; handle state 2
1117           2237            servo_state2:
1117 B40204    2238            cjne a, #2, servo_state3
111A C21F      2239            clr servo_angle_zero ; close door at state 2
111C 801E      2240            sjmp check_servo_flag
111E           2241   
111E           2242            ; handle state 3
111E           2243            servo_state3:
111E B40304    2244            cjne a, #3, servo_state4
1121 C21F      2245            clr servo_angle_zero ; close door at state 3
1123 8017      2246            sjmp check_servo_flag
1125           2247   
1125           2248            ; handle state 4
1125           2249            servo_state4:
1125 B40404    2250            cjne a, #4, servo_state5
1128 C21F      2251            clr servo_angle_zero ; close door at state 4
112A 8010      2252            sjmp check_servo_flag
112C           2253   
112C           2254            ; handle state 5
112C           2255            servo_state5:
112C B40504    2256            cjne a, #5, servo_state6
112F C21F      2257            clr servo_angle_zero ; close door at state 5
1131 8009      2258            sjmp check_servo_flag
1133           2259   
1133           2260            ; handle state 6
1133           2261            servo_state6:
1133 B40604    2262            cjne a, #6, servo_state7
1136 C21F      2263            clr servo_angle_zero ; close door at state 6
1138 8002      2264            sjmp check_servo_flag
113A           2265   
113A           2266            ; handle state 7
113A           2267            servo_state7:
113A D21F      2268            setb servo_angle_zero ; open door at state 7
113C           2269   
113C           2270   check_servo_flag:
113C           2271            ; check 1 ms flag
113C 101E01    2272            jbc one_millisecond_flag_servo, run_servo_control
113F 22        2273            ret
1140           2274   
1140           2275   run_servo_control:
1140 121144    2276            lcall servo_control
1143 22        2277            ret
1144           2278   
1144           2279   
1144           2280   ;---------------------------------------------------------------
1144           2281   ; servo control
1144           2282   ; generate a 20 ms period pwm signal to control the servo motor
1144           2283   ; able to make the servo motor stay at 0 degree and 180 degree
1144           2284   ;---------------------------------------------------------------
1144           2285   servo_control:
1144 D2ED      2286       setb LEDRA.5
1146 C0E0      2287            push acc
1148 C0D0      2288            push psw
114A E56F      2289            mov a, servo_pwm_counter ; move servo counter to accumulator
114C 04        2290            inc A ; a += 1
114D B41402    2291            cjne a, #SERVO_PERIOD, servo_pwm_angle_compare ; jump if wrapup not needed
1150 7400      2292            mov a, #0
1152           2293   
1152           2294   servo_pwm_angle_compare: ; read target angle
1152 F56F      2295            mov servo_pwm_counter, A
1154 201F09    2296            jb servo_angle_zero, set_zero_degree ; set servo motor to 0 degree
1157           2297            ; set servo motor to 180 degrees
1157 E56F      2298            mov a, servo_pwm_counter
1159 C3        2299            clr c
115A 9402      2300            subb a, #SERVO_180
115C 400B      2301            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 180 degrees duty cycle
115E 800D      2302            sjmp servo_pwm_set_low ; set low if greater
1160           2303   
1160           2304   set_zero_degree:
1160           2305            ; set servo motor to 0 degree
1160 E56F      2306            mov a, servo_pwm_counter
1162 C3        2307            clr c
1163 9401      2308            subb a, #SERVO_0
1165 4002      2309            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 0 degrees duty cycle
1167 8004      2310            sjmp servo_pwm_set_low ; set low if greater
1169           2311   
1169           2312   servo_pwm_set_high:
1169           2313            ; set pwm pin high
1169 D2B6      2314            setb SERVO_OUT
116B 8002      2315            sjmp servo_control_done
116D           2316   
116D           2317   servo_pwm_set_low:
116D           2318            ; set pwm pin low
116D C2B6      2319            clr SERVO_OUT
116F           2320   
116F           2321   servo_control_done:
116F D0D0      2322            pop psw
1171 D0E0      2323            pop acc
1173 22        2324            ret
1174           2325   
1174           2326   END
