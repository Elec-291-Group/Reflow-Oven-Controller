0000              1   ; Project 1
0000              2   ; CV-8052 microcontroller in DE10-Lite board
<<<<<<< HEAD
0000              3   
0000              4   ; ----------------------------------------------------------------------------------------------;
0000              5   ; Reset vector
0000              6   org 0x0000
0000 0209E2       7       ljmp main
0003              8   ; External interrupt 0 vector
0003              9   org 0x0003
0003 32          10            reti
0004             11   ; Timer/Counter 0 overflow interrupt vector
000B             12   org 0x000B
000B 0204CB      13            ljmp Timer0_ISR
000E             14   ; External interrupt 1 vector
0013             15   org 0x0013
0013 32          16            reti
0014             17   ; Timer/Counter 1 overflow interrupt vector
001B             18   org 0x001B
001B 32          19            reti
001C             20   ; Serial port receive/transmit interrupt vector
0023             21   org 0x0023 
0023 32          22            reti
0024             23   ; Timer/Counter 2 overflow interrupt vector
002B             24   org 0x002B
002B 020536      25            ljmp Timer2_ISR
002E             26   ; ----------------------------------------------------------------------------------------------;
002E             27   
002E             28   ; ----------------------------------------------------------------------------------------------;
002E             29   ; includes
                614   $LIST
                 33   $LIST
03D7             35   ; ----------------------------------------------------------------------------------------------;
03D7             36   
03D7             37   ; ----------------------------------------------------------------------------------------------;
03D7             38   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             39   dseg at 0x30
0030             40   current_time_sec:     ds 1
0031             41   current_time_minute:  ds 1
0032             42   
0032             43   ; math32 buffer variables
0032             44   x:               ds      4
0036             45   y:               ds      4
003A             46   bcd:     ds      5
003F             47   
003F             48   current_temp: ds 4 ;
0043             49   soak_temp:    ds 4 ;
0047             50   reflow_temp:  ds 4 ;
004B             51   
004B             52   current_time: ds 4 ;
004F             53   soak_time:    ds 4 ;
0053             54   reflow_time:  ds 4 ;
0057             55   
0057             56   power_output:  ds 4 ;
005B             57   pwm_counter: ds 4 ; counter for pwm (0-1500)
005F             58   soak_temp_diff: ds 4 ; temperature difference between target soak temp and current oven temp 
0063             59   ; 47d bytes used
0063             60   
0063             61   KEY1_DEB_timer: ds 1
0064             62   SEC_FSM_timer:  ds 1
0065             63   KEY1_DEB_state:    ds 1
0066             64   SEC_FSM_state:      ds 1
0067             65   Control_FSM_state: ds 1
0068             66   
0068             67   proportional_gain_var: ds 4
006C             68   
006C             69   ; 46d bytes used
006C             70   ; ---------------------------------------------------------------------------------------------;
006C             71   
006C             72   ; ---------------------------------------------------------------------------------------------;
006C             73   ; bit operation setb, clr, jb, and jnb
0000             74   bseg
0000             75   mf:              dbit 1 ; math32 sign
0001             76   one_second_flag: dbit 1
0002             77   one_millisecond_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003             78   
0003             79   soak_temp_reached: dbit 1
0004             80   reflow_temp_reached: dbit 1
0005             81   cooling_temp_reached: dbit 1
0006             82   
0006             83   soak_time_reached: dbit 1
0007             84   reflow_time_reached: dbit 1
0008             85   
0008             86   reset_signal: dbit 1
0009             87   stop_signal: dbit 1
000A             88   start_signal: dbit 1
000B             89   config_finish_signal: dbit 1
000C             90   
000C             91   Key1_flag: dbit 1
000D             92   PB0_flag: dbit 1 ; start entire program
000E             93   PB1_flag: dbit 1 ; start soak
000F             94   PB2_flag: dbit 1 ; pause process
0010             95   
0010             96   soak_temp_greater: dbit 1 ; target soak_temp greater than current_temp
0011             97   ; 11 bits used
0011             98   ; ---------------------------------------------------------------------------------------------;
0011             99   
0011            100   ; ---------------------------------------------------------------------------------------------;
03D7            101   cseg
03D7            102   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
03D7            103   BAUD                EQU 57600
03D7            104   
03D7            105   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
03D7            106   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 is always 12 unlike the N76E003 where is selectable.
03D7            107   
03D7            108   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
03D7            109   
03D7            110   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
03D7            111   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
03D7            112   
03D7            113   PWM_PERIOD     EQU 1499 ; 1.5s period
03D7            114   
03D7            115   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
03D7            116   
03D7            117   PWM_OUT             EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
03D7            118   
03D7            119   MAX_POWER           EQU 1500 ; max oven power
03D7            120   NO_POWER            EQU 0    ; no power
03D7            121   BASE_POWER     EQU (MAX_POWER/5) ; 20% base power for state 2, 4
03D7            122   
03D7            123   KP                          EQU 5 ; proportional gain
03D7            124   
03D7            125   ; These 'equ' must match the wiring between the DE10Lite board and the LCD!
03D7            126   ; P0 is in connector JPIO.  Check "CV-8052 Soft Processor in the DE10Lite Board: Getting
03D7            127   ; Started Guide" for the details.
03D7            128   ELCD_RS equ P3.7
03D7            129   ELCD_RW equ P3.5
03D7            130   ELCD_E  equ P3.3
03D7            131   ELCD_D4 equ P3.1
03D7            132   ELCD_D5 equ P2.7
03D7            133   ELCD_D6 equ P2.5
03D7            134   ELCD_D7 equ P2.3
03D7            135   
03D7            136   ;                     1234567890123456 <-- 16 characters per line LCD
03D7 696E6974   137   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
03E7 57656C63   138   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
03F7 50726573   139   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0407            140   
0407            141   ;                       1234567890123456
0407 53657420   142   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
0417 536F616B   143   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
0422 5265666C   144   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
042F 536F616B   145   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
043A 5265666C   146   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
0447            147   
0447            148   ;                     1234567890123456
0447 52616D70   149   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
0457 536F616B   150   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
0467 52616D70   151   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
0477 5265666C   152   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
0487 436F6F6C   153   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
0497 50726F63   154   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
04A7            155   
04A7 20202020   156   String_Blank:    db '                ', 0
=======
0000              3   ;-------------------------------------------------------------------------------
0000              4   ; Reset vector
0000              5   org 0x0000
0000 02099A       6       ljmp main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9            reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 020414      12            ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15            reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18            reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 32          21            reti
0024             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
002B 02047F      24            ljmp Timer2_ISR
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 29   $LIST
0320             31   ; ----------------------------------------------------------------------------------------------;
0320             32   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             33   dseg at 0x30
0030             34   current_time_sec:     ds 1
0031             35   current_time_minute:  ds 1
0032             36   ; math32 buffer variables
0032             37   x:               ds      4
0036             38   y:               ds      4
003A             39   bcd:     ds      5
003F             40   
003F             41   current_temp: ds 4 ;
0043             42   soak_temp:    ds 4 ;
0047             43   reflow_temp:  ds 4 ;
004B             44   
004B             45   current_time: ds 4 ;
004F             46   soak_time:    ds 4 ;
0053             47   reflow_time:  ds 4 ;
0057             48   
0057             49   power_output:  ds 4 ;
005B             50   pwm_counter: ds 4 ; counter for pwm (0-1500)
005F             51   
005F             52   KEY1_DEB_timer: ds 1
0060             53   SEC_FSM_timer:  ds 1
0061             54   KEY1_DEB_state:    ds 1
0062             55   SEC_FSM_state:      ds 1
0063             56   Control_FSM_state: ds 1 
0064             57   
0064             58   servo_pwm_counter: ds 1 ; counter for the servo pwm signal
0065             59   ; 46d bytes used
0065             60   
0065             61   ;-------------------------------------------------------------------------------
0065             62   ; bit operation setb, clr, jb, and jnb
0000             63   bseg
0000             64   mf:              dbit 1 ; math32 sign
0001             65   one_second_flag: dbit 1
0002             66   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003             67   
0003             68   one_millisecond_flag_servo: dbit 1 ; one_millisecond_flag for servo motor control
0004             69   
0004             70   soak_temp_reached: dbit 1
0005             71   reflow_temp_reached: dbit 1
0006             72   cooling_temp_reached: dbit 1
0007             73   
0007             74   soak_time_reached: dbit 1
0008             75   reflow_time_reached: dbit 1
0009             76   
0009             77   reset_signal: dbit 1
000A             78   stop_signal: dbit 1
000B             79   start_signal: dbit 1
000C             80   config_finish_signal: dbit 1
000D             81   
000D             82   state_change_signal: dbit 1
000E             83   
000E             84   Key1_flag: dbit 1
000F             85   
000F             86   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
0010             87   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0011             88   PB0_flag: dbit 1 ; start entire program
0012             89   PB1_flag: dbit 1 ; start soak
0013             90   PB2_flag: dbit 1 ; pause process
0014             91   
0014             92   servo_angle_zero: dbit 1 ; flag for indicating whether the servo angle should be at 0 or not: 1 -> 0; 0 -> 180
0015             93   ; 0 degree as oven door open
0015             94   ; 180 degree as oven door close
0015             95   
0015             96   ; 11 bits used
0015             97   
0015             98   ;-------------------------------------------------------------------------------
0320             99   cseg
0320            100   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            101   BAUD                EQU 57600
0320            102   
0320            103   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            104   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            105   ; is always 12 unlike the N76E003 where is selectable.
0320            106   
0320            107   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            108   
0320            109   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            110   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            111   
0320            112   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            113   
0320            114   SERVO_OUT      EQU P1.4 ; x.x modify here to change pwm pin
0320            115   
0320            116   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            117   
0320            118   PWM_OUT             EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            119   
0320            120   SERVO_PERIOD   EQU 20 ; pwm signal period for the servo motor (20 ms)
0320            121   SERVO_0        EQU 1 ; pwm high time for the servo motor to stay at 0 degree
0320            122   SERVO_180      EQU 2 ; pwm high time for the servo motor to stay at 180 degrees
0320            123   
0320            124   ; These 'equ' must match the wiring between the DE10Lite board and the LCD!
0320            125   ; P0 is in connector JPIO.
0320            126   ELCD_RS equ P3.7
0320            127   ELCD_RW equ P3.5
0320            128   ELCD_E  equ P3.3
0320            129   ELCD_D4 equ P3.1
0320            130   ELCD_D5 equ P2.7
0320            131   ELCD_D6 equ P2.5
0320            132   ELCD_D7 equ P2.3
0320            133   
0320            134   ;                     1234567890123456 <-- 16 characters per line LCD
0320 696E6974   135   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   136   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   137   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            138   
0350            139   ;                       1234567890123456
0350 53657420   140   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
0360 536F616B   141   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
036B 5265666C   142   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
0378 536F616B   143   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
0383 5265666C   144   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
0390            145   
0390            146   ;                     1234567890123456
0390 52616D70   147   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03A0 536F616B   148   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
03B0 52616D70   149   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
03C0 5265666C   150   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
03D0 436F6F6C   151   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
03E0 50726F63   152   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
03F0            153   
03F0 20202020   154   String_Blank:    db '                ', 0
>>>>>>> main
     20202020
     20202020
     20202020
     00
<<<<<<< HEAD
04B8            157   
04B8            158   
04B8            159   ;----------------------------------------------------------------------------------------------;
04B8            160   ; Timers Setting:
04B8            161   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
04B8            162   ;        Timer 1: Serial port baud rate 57600 generator
04B8            163   ;        Timer 2: 1ms interrupt for BCD counter increment/decrement
04B8            164   ;----------------------------------------------------------------------------------------------;
04B8            165   
04B8            166   ; Routine to initialize the ISR for Timer 0 ;
04B8            167   Timer0_Init:
04B8 E589       168            mov a, TMOD
04BA 54F0       169            anl a, #0xf0 ; Clear the bits for timer 0
04BC 4401       170            orl a, #0x01 ; Configure timer 0 as 16-timer
04BE F589       171            mov TMOD, a
04C0 758CFD     172            mov TH0, #high(TIMER0_RELOAD)
04C3 758A5A     173            mov TL0, #low(TIMER0_RELOAD)
04C6            174            ; Enable the timer and interrupts
04C6 D2A9       175       setb ET0  ; Enable timer 0 interrupt
04C8 D28C       176       setb TR0  ; Start timer 0
04CA 22         177            ret
04CB            178   ; ISR for timer 0.  Set to execute every 1/4096Hz 
04CB            179   ; to generate a 2048 Hz square wave at pin P1.5 
04CB            180   Timer0_ISR:
04CB            181            ;clr TF0  ; According to the data sheet this is done for us already.
04CB 758CFD     182            mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
04CE 758A5A     183            mov TL0, #low(TIMER0_RELOAD)
04D1 B295       184            cpl SOUND_OUT ; Connect speaker to P1.5
04D3 32         185            reti
04D4            186   
04D4            187   ; -----------------------------------------------------------------------------------------------;
04D4            188   
04D4            189   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
04D4            190   Initialize_Serial_Port:
04D4            191            ; Configure serial port and baud rate
04D4 C28E       192            clr TR1 ; Disable timer 1
04D6 53890F     193            anl TMOD, #0x0f ; Mask the bits for timer 1
04D9 438920     194            orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
04DC 438780     195       orl PCON, #80H ; Set SMOD to 1
04DF 758DFD     196            mov TH1, #low(TIMER_1_RELOAD)
04E2 758BFD     197            mov TL1, #low(TIMER_1_RELOAD) 
04E5 D28E       198            setb TR1 ; Enable timer 1
04E7 759852     199            mov SCON, #52H
04EA 22         200            ret
04EB            201   
04EB            202   ; uart sending functions
04EB            203   putchar:
04EB 109902     204            jbc     TI, putchar_L1
04EE 80FB       205            sjmp putchar
04F0            206   putchar_L1:
04F0 F599       207            mov     SBUF,a
04F2 22         208            ret
04F3            209   
04F3            210   SendString:
04F3 E4         211       clr a
04F4 93         212       movc a, @a+dptr
04F5 6006       213       jz SendString_L1
04F7 1204EB     214       lcall putchar
04FA A3         215       inc dptr
04FB 80F6       216       sjmp SendString  
04FD            217   SendString_L1:
04FD 22         218            ret
04FE            219   
04FE            220   ; -----------------------------------------------------------------------------------------------;
04FE            221   
04FE            222   ; serial debugging
04FE            223   ; send a four byte number via serial to laptop
04FE            224   ; need to be used with python script
04FE            225   ; content needed to be sent should be stored in the varaible x
04FE            226   Send32:
04FE            227       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
04FE 74AA       228       mov A, #0AAH
0500 1204EB     229       lcall putchar
0503 7455       230       mov A, #055H
0505 1204EB     231       lcall putchar
0508            232   
0508 E535       233       mov A, x+3
050A 1204EB     234       lcall putchar
050D E534       235       mov A, x+2
050F 1204EB     236       lcall putchar
0512 E533       237       mov A, x+1
0514 1204EB     238       lcall putchar
0517 E532       239       mov A, x+0
0519 1204EB     240       lcall putchar
051C            241   
051C 740A       242       mov A, #0AH
051E 1204EB     243       lcall putchar
0521 22         244       ret
0522            245   
0522            246   ;------------------------------------------------------------------------------------------------;
0522            247   ; Routine to initialize the ISR for timer 2 
0522            248   Timer2_Init:
0522 75C800     249            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0525 75CDF5     250            mov TH2, #high(TIMER2_RELOAD)
0528 75CC27     251            mov TL2, #low(TIMER2_RELOAD)
052B            252            ; Set the reload value
052B 75CBF5     253            mov RCAP2H, #high(TIMER2_RELOAD)
052E 75CA27     254            mov RCAP2L, #low(TIMER2_RELOAD)
0531            255            ; Enable the timer and interrupts
0531 D2AD       256       setb ET2  ; Enable timer 2 interrupt
0533 D2CA       257       setb TR2  ; Enable timer 2
0535 22         258            ret
0536            259   
0536            260   ; ISR for timer 2.  Runs every 1 ms ;
0536            261   Timer2_ISR:
0536 C0E0       262            push acc
0538 C0D0       263            push psw
053A C2CF       264            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
053C            265            ; cpl P1.1 ; Optional debug pin toggle for scope (ensure it's not used elsewhere)
053C            266   
053C            267   ; FSM states timers
053C 0563       268            inc KEY1_DEB_timer
053E 0564       269            inc SEC_FSM_timer
0540            270   
0540 D202       271            setb one_millisecond_flag ; set the one millisecond flag
0542            272   
0542            273   Timer2_ISR_done:
0542 D0D0       274            pop psw
0544 D0E0       275            pop acc
0546 32         276            reti
0547            277   ;-----------------------------------------------------------------------------------------------;
0547            278   
0547            279   ;-----------------------------------------------------------------------------------------------;
0547            280   ; Display Function for 7-segment displays                
0547            281   
0547            282   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
0547            283   T_7seg:
0547 C0F9A4B0   284       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
054C 9282F880   285       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
0551 8883C6A1   286       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
0557            287   
0557            288   ; Displays a BCD number pased in R0 in HEX5-HEX0
0557            289   Display_BCD_7_Seg_HEX10:
0557 900547     290            mov dptr, #T_7seg
055A            291   
055A E8         292            mov a, R0
055B C4         293            swap a
055C 540F       294            anl a, #0FH
055E 93         295            movc a, @a+dptr
055F F592       296            mov HEX1, a
0561            297            
0561 E8         298            mov a, R0
0562 540F       299            anl a, #0FH
0564 93         300            movc a, @a+dptr
0565 F591       301            mov HEX0, a
0567            302            
0567 22         303            ret
0568            304   
0568            305   Display_BCD_7_Seg_HEX32:
0568 900547     306            mov dptr, #T_7seg
056B            307   
056B E8         308            mov a, R0
056C C4         309            swap a
056D 540F       310            anl a, #0FH
056F 93         311            movc a, @a+dptr
0570 F594       312            mov HEX3, a
0572            313            
0572 E8         314            mov a, R0
0573 540F       315            anl a, #0FH
0575 93         316            movc a, @a+dptr
0576 F593       317            mov HEX2, a
0578            318            
0578 22         319            ret
0579            320   
0579            321   Display_BCD_7_Seg_HEX54:
0579 900547     322            mov dptr, #T_7seg
057C            323   
057C E8         324            mov a, R0
057D C4         325            swap a
057E 540F       326            anl a, #0FH
0580 93         327            movc a, @a+dptr
0581 F58F       328            mov HEX5, a
0583            329            
0583 E8         330            mov a, R0
0584 540F       331            anl a, #0FH
0586 93         332            movc a, @a+dptr
0587 F58E       333            mov HEX4, a
0589            334            
0589 22         335            ret
058A            336   
058A            337   ; The 8-bit hex number passed in the accumulator is converted to
058A            338   ; BCD and stored in [R1, R0]
058A            339   Hex_to_bcd_8bit:
058A 75F064     340            mov b, #100
058D 84         341            div ab
058E F9         342            mov R1, a   ; After dividing, a has the 100s
058F E5F0       343            mov a, b    ; Remainder is in register b
0591 75F00A     344            mov b, #10
0594 84         345            div ab ; The tens are stored in a, the units are stored in b 
0595 C4         346            swap a
0596 54F0       347            anl a, #0xf0
0598 45F0       348            orl a, b
059A F8         349            mov R0, a
059B 22         350            ret
059C            351   
059C            352   ;------------------------------------------------------------------;
059C            353   ; Display Function for LCD                                               
059C            354   LCD_Display_Update_func:
059C C0E0       355            push acc
059E E567       356            mov a, Control_FSM_state
05A0            357   
05A0            358   LCD_Display_Update_0:
05A0 B4003B     359            cjne a, #0, LCD_Display_Update_1
05A3 C0E0       360            push acc
05A5 7401       360            mov a, #1
05A7 14         360            dec a
05A8 1200CA     360            lcall ?Set_Cursor_1 ; Select column and row
05AB D0E0       360            pop acc
05AD C083       361            push dph
05AF C082       361            push dpl
05B1 C0E0       361            push acc
05B3 9003E7     361            mov dptr, #String_state0_1
05B6 1200BD     361            lcall ?Send_Constant_String
05B9 D0E0       361            pop acc
05BB D082       361            pop dpl
05BD D083       361            pop dph
05BF C0E0       362            push acc
05C1 7401       362            mov a, #1
05C3 14         362            dec a
05C4 1200C8     362            lcall ?Set_Cursor_2 ; Select column and row
05C7 D0E0       362            pop acc
05C9 C083       363            push dph
05CB C082       363            push dpl
05CD C0E0       363            push acc
05CF 9003F7     363            mov dptr, #String_state0_2
05D2 1200BD     363            lcall ?Send_Constant_String
05D5 D0E0       363            pop acc
05D7 D082       363            pop dpl
05D9 D083       363            pop dph
05DB 0206CC     364            ljmp LCD_Display_Update_done
05DE            365   
05DE            366   LCD_Display_Update_1:
05DE B4011F     367            cjne a, #1, LCD_Display_Update_2
05E1 C0E0       368            push acc
05E3 7401       368            mov a, #1
05E5 14         368            dec a
05E6 1200CA     368            lcall ?Set_Cursor_1 ; Select column and row
05E9 D0E0       368            pop acc
05EB C083       369            push dph
05ED C082       369            push dpl
05EF C0E0       369            push acc
05F1 900407     369            mov dptr, #String_state1
05F4 1200BD     369            lcall ?Send_Constant_String
05F7 D0E0       369            pop acc
05F9 D082       369            pop dpl
05FB D083       369            pop dph
05FD 0206CC     370            ljmp LCD_Display_Update_done
0600            371   
0600            372   LCD_Display_Update_2:
0600 B4021F     373            cjne a, #2, LCD_Display_Update_3
0603 C0E0       374            push acc
0605 7401       374            mov a, #1
0607 14         374            dec a
0608 1200CA     374            lcall ?Set_Cursor_1 ; Select column and row
060B D0E0       374            pop acc
060D C083       375            push dph
060F C082       375            push dpl
0611 C0E0       375            push acc
0613 900447     375            mov dptr, #String_state2
0616 1200BD     375            lcall ?Send_Constant_String
0619 D0E0       375            pop acc
061B D082       375            pop dpl
061D D083       375            pop dph
061F 0206CC     376            ljmp LCD_Display_Update_done
0622            377   
0622            378   LCD_Display_Update_3:
0622 B4031F     379            cjne a, #3, LCD_Display_Update_4
0625 C0E0       380            push acc
0627 7401       380            mov a, #1
0629 14         380            dec a
062A 1200CA     380            lcall ?Set_Cursor_1 ; Select column and row
062D D0E0       380            pop acc
062F C083       381            push dph
0631 C082       381            push dpl
0633 C0E0       381            push acc
0635 900457     381            mov dptr, #String_state3
0638 1200BD     381            lcall ?Send_Constant_String
063B D0E0       381            pop acc
063D D082       381            pop dpl
063F D083       381            pop dph
0641 0206CC     382            ljmp LCD_Display_Update_done
0644            383   
0644            384   LCD_Display_Update_4:
0644 B4041F     385            cjne a, #4, LCD_Display_Update_5
0647 C0E0       386            push acc
0649 7401       386            mov a, #1
064B 14         386            dec a
064C 1200CA     386            lcall ?Set_Cursor_1 ; Select column and row
064F D0E0       386            pop acc
0651 C083       387            push dph
0653 C082       387            push dpl
0655 C0E0       387            push acc
0657 900467     387            mov dptr, #String_state4
065A 1200BD     387            lcall ?Send_Constant_String
065D D0E0       387            pop acc
065F D082       387            pop dpl
0661 D083       387            pop dph
0663 0206CC     388            ljmp LCD_Display_Update_done
0666            389   
0666            390   LCD_Display_Update_5:
0666 B4051F     391            cjne a, #5, LCD_Display_Update_6
0669 C0E0       392            push acc
066B 7401       392            mov a, #1
066D 14         392            dec a
066E 1200CA     392            lcall ?Set_Cursor_1 ; Select column and row
0671 D0E0       392            pop acc
0673 C083       393            push dph
0675 C082       393            push dpl
0677 C0E0       393            push acc
0679 900477     393            mov dptr, #String_state5
067C 1200BD     393            lcall ?Send_Constant_String
067F D0E0       393            pop acc
0681 D082       393            pop dpl
0683 D083       393            pop dph
0685 0206CC     394            ljmp LCD_Display_Update_done
0688            395   
0688            396   LCD_Display_Update_6:
0688 B4061F     397            cjne a, #6, LCD_Display_Update_7
068B C0E0       398            push acc
068D 7401       398            mov a, #1
068F 14         398            dec a
0690 1200CA     398            lcall ?Set_Cursor_1 ; Select column and row
0693 D0E0       398            pop acc
0695 C083       399            push dph
0697 C082       399            push dpl
0699 C0E0       399            push acc
069B 900487     399            mov dptr, #String_state6
069E 1200BD     399            lcall ?Send_Constant_String
06A1 D0E0       399            pop acc
06A3 D082       399            pop dpl
06A5 D083       399            pop dph
06A7 0206CC     400            ljmp LCD_Display_Update_done
06AA            401   
06AA            402   LCD_Display_Update_7:
06AA B4071F     403            cjne a, #7, LCD_Display_Update_done
06AD C0E0       404            push acc
06AF 7401       404            mov a, #1
06B1 14         404            dec a
06B2 1200CA     404            lcall ?Set_Cursor_1 ; Select column and row
06B5 D0E0       404            pop acc
06B7 C083       405            push dph
06B9 C082       405            push dpl
06BB C0E0       405            push acc
06BD 900497     405            mov dptr, #String_state7
06C0 1200BD     405            lcall ?Send_Constant_String
06C3 D0E0       405            pop acc
06C5 D082       405            pop dpl
06C7 D083       405            pop dph
06C9 0206CC     406            ljmp LCD_Display_Update_done
06CC            407   
06CC            408   LCD_Display_Update_done:
06CC D0E0       409            pop acc
06CE 22         410            ret
06CF            411   
06CF            412   ;-------------------------------------------------------------------------------
06CF            413   ; non-blocking state machine for KEY1 debounce
06CF            414   KEY1_DEB:
06CF E565       415            mov a, KEY1_DEB_state
06D1            416   KEY1_DEB_state0:
06D1 B4000A     417            cjne a, #0, KEY1_DEB_state1
06D4 20F92D     418            jb KEY.1, KEY1_DEB_done
06D7 756300     419            mov KEY1_DEB_timer, #0
06DA 0565       420            inc KEY1_DEB_state
06DC 8026       421            sjmp KEY1_DEB_done
06DE            422   KEY1_DEB_state1:
06DE B40109     423            cjne a, #1, KEY1_DEB_state2
06E1            424            ; this is the debounce state
06E1 E563       425            mov a, KEY1_DEB_timer
06E3 B4321E     426            cjne a, #50, KEY1_DEB_done ; 50 ms passed?
06E6 0565       427            inc KEY1_DEB_state
06E8 801A       428            sjmp KEY1_DEB_done      
06EA            429   KEY1_DEB_state2:
06EA B4020C     430            cjne a, #2, KEY1_DEB_state3
06ED 20F904     431            jb KEY.1, KEY1_DEB_state2b
06F0 0565       432            inc KEY1_DEB_state
06F2 8010       433            sjmp KEY1_DEB_done      
06F4            434   KEY1_DEB_state2b:
06F4 756500     435            mov KEY1_DEB_state, #0
06F7 800B       436            sjmp KEY1_DEB_done
06F9            437   KEY1_DEB_state3:
06F9 B40308     438            cjne a, #3, KEY1_DEB_done
06FC 30F905     439            jnb KEY.1, KEY1_DEB_done
06FF D20C       440            setb Key1_flag ; Suscesfully detected a valid KEY1 press/release
0701 756500     441            mov KEY1_DEB_state, #0  
0704            442   KEY1_DEB_done:
0704 22         443            ret
0705            444   ; ------------------------------------------------------------------------------
0705            445   
0705            446   ;-------------------------------------------------------------------------------
0705            447   ; non-blocking FSM for the one second counter
0705            448   SEC_FSM:
0705 E566       449            mov a, SEC_FSM_state
0707            450   SEC_FSM_state0:
0707 B4000C     451            cjne a, #0, SEC_FSM_state1
070A E564       452            mov a, SEC_FSM_timer
070C B4FA47     453            cjne a, #250, SEC_FSM_done ; 250 ms passed?
070F 756400     454            mov SEC_FSM_timer, #0
0712 0566       455            inc SEC_FSM_state
0714 8040       456            sjmp SEC_FSM_done
0716            457   SEC_FSM_state1:  
0716 B4010E     458            cjne a, #1, SEC_FSM_state2
0719 D2E9       459            setb LEDRA.1
071B E564       460            mov a, SEC_FSM_timer
071D B4FA36     461            cjne a, #250, SEC_FSM_done ; 250 ms passed?
0720 756400     462            mov SEC_FSM_timer, #0
0723 0566       463            inc SEC_FSM_state
0725 802F       464            sjmp SEC_FSM_done
0727            465   SEC_FSM_state2:  
0727 B4020E     466            cjne a, #2, SEC_FSM_state3
072A D2EA       467            setb LEDRA.2
072C E564       468            mov a, SEC_FSM_timer
072E B4FA25     469            cjne a, #250, SEC_FSM_done ; 250 ms passed?
0731 756400     470            mov SEC_FSM_timer, #0
0734 0566       471            inc SEC_FSM_state
0736 801E       472            sjmp SEC_FSM_done
0738            473   SEC_FSM_state3:  
0738 B4031B     474            cjne a, #3, SEC_FSM_done
073B D2EB       475            setb LEDRA.3
073D E564       476            mov a, SEC_FSM_timer
073F B4FA14     477            cjne a, #250, SEC_FSM_done ; 250 ms passed?
0742 756400     478            mov SEC_FSM_timer, #0
0745 756600     479            mov SEC_FSM_state, #0
0748 E530       480            mov a, current_time_sec
074A B43B05     481            cjne a, #59, IncCurrentTimeSec ; Don't let the seconds counter pass 59
074D 753000     482            mov current_time_sec, #0
0750 8004       483            sjmp SEC_FSM_done
0752            484   IncCurrentTimeSec:
0752 0530       485            inc current_time_sec
0754 B2E8       486            cpl LEDRA.0 ; 1 Hz heartbeat LED
0756            487   SEC_FSM_done:
0756 22         488            ret
0757            489   
0757            490   
0757            491   ;-------------------------------------------------------------------------------
0757            492   ; power_control
0757            493   ;-------------------------------------------------------------------------------
0757            494   ; Determine the power output based on current state and current temperature 
0757            495   ; input parameter: Control_FSM_state
0757            496   ;-------------------------------------------------------------------------------
0757            497   
0757            498   power_control:
0757 E567       499            mov a, Control_FSM_state
0759            500   
0759            501   state0_power_control:
0759            502            ; idle
0759            503            ; 0% power
0759 B4000F     504            cjne a, #0, state1_power_control
075C 755700     505            mov power_output, #low(NO_POWER)
075F 755800     506            mov power_output+1, #low(NO_POWER)
0762 755900     507            mov power_output+2, #0
0765 755A00     508            mov power_output+3, #0
0768 020903     509            ljmp power_control_done
076B            510   
076B            511   state1_power_control:
076B            512            ; idle
076B            513            ; 0% power
076B B4010F     514            cjne a, #1, state2_power_control
076E 755700     515            mov power_output, #low(NO_POWER)
0771 755800     516            mov power_output+1, #low(NO_POWER)
0774 755900     517            mov power_output+2, #0
0777 755A00     518            mov power_output+3, #0
077A 020903     519            ljmp power_control_done
077D            520            
077D            521   state2_power_control:
077D            522            ; ramp to soak, ramp to ~150C
077D            523            ; 100% power
077D B4020F     524            cjne a, #2, state3_power_control
0780 7557DC     525            mov power_output, #low(MAX_POWER)
0783 755805     526            mov power_output+1, #high(MAX_POWER)
0786 755900     527            mov power_output+2, #0
0789 755A00     528            mov power_output+3, #0
078C 020903     529            ljmp power_control_done
078F            530   
078F            531   state3_power_control:
078F            532            ; soak period, hold at 150C
078F            533            ; 20% base power + proportional calculated power
078F B40302     534            cjne a, #3, jump_state4_power_control
0792 8003       535            sjmp state3_power_control_calculation
0794            536   
0794            537   jump_state4_power_control:
0794 0208C1     538            ljmp state4_power_control
0797            539   
0797            540   state3_power_control_calculation:
0797            541            ; move soak_temp to x
0797 854332     542            mov x, soak_temp
079A 854433     543            mov x+1, soak_temp+1
079D 854534     544            mov x+2, soak_temp+2
07A0 854635     545            mov x+3, soak_temp+3
07A3            546            ; move current_temp to y
07A3 853F36     547            mov y, current_temp
07A6 854037     548            mov y+1, current_temp+1
07A9 854138     549            mov y+2, current_temp+2
07AC 854239     550            mov y+3, current_temp+3
07AF            551   
07AF            552            ; compare between soak_temp and current_temp
07AF C200       553            clr mf
07B1 12022F     554            lcall x_gteq_y
07B4 10002B     555            jbc mf, st_sub_ct
07B7            556            ; current_temp - soak_temp if st < ct
07B7 C210       557            clr soak_temp_greater
07B9            558            ; move current_temp to y
07B9 854336     559            mov y, soak_temp
07BC 854437     560            mov y+1, soak_temp+1
07BF 854538     561            mov y+2, soak_temp+2
07C2 854639     562            mov y+3, soak_temp+3
07C5            563            ; move current_temp to x
07C5 853F32     564            mov x, current_temp
07C8 854033     565            mov x+1, current_temp+1
07CB 854134     566            mov x+2, current_temp+2
07CE 854235     567            mov x+3, current_temp+3
07D1 1201AD     568            lcall sub32
07D4 85325F     569            mov soak_temp_diff, x
07D7 853360     570            mov soak_temp_diff+1, x+1
07DA 853461     571            mov soak_temp_diff+2, x+2
07DD 853562     572            mov soak_temp_diff+3, x+3
07E0 8011       573            sjmp proportional_input_soak
07E2            574   
07E2            575   st_sub_ct:
07E2            576            ; soak_temp - current_temp
07E2 D210       577            setb soak_temp_greater
07E4 1201AD     578            lcall sub32
07E7 85325F     579            mov soak_temp_diff, x
07EA 853360     580            mov soak_temp_diff+1, x+1
07ED 853461     581            mov soak_temp_diff+2, x+2
07F0 853562     582            mov soak_temp_diff+3, x+3
07F3            583   
07F3            584   proportional_input_soak:
07F3            585            ; proportaional block calculation       
07F3            586            ; move soak_temp_diff to x
07F3 855F32     587            mov x, soak_temp_diff
07F6 856033     588            mov x+1, soak_temp_diff+1
07F9 856134     589            mov x+2, soak_temp_diff+2
07FC 856235     590            mov x+3, soak_temp_diff+3
07FF            591            ; move proportional gain to y
07FF 753605     592            mov y+0, #low (KP % 0x10000) 
0802 753700     592            mov y+1, #high(KP % 0x10000) 
0805 753800     592            mov y+2, #low (KP / 0x10000) 
0808 753900     592            mov y+3, #high(KP / 0x10000) 
080B 120243     593            lcall mul32 ; proportional_output = proportional_gain * difference
080E            594            
080E 853268     595            mov proportional_gain_var, x
0811 853369     596            mov proportional_gain_var+1, x+1
0814 85346A     597            mov proportional_gain_var+2, x+2
0817 85356B     598            mov proportional_gain_var+3, x+3
081A            599   
081A            600            ; base_power + soak_power when soak_temp > current_temp
081A 301029     601            jnb soak_temp_greater, sub_proportional_soak
081D 856832     602            mov x, proportional_gain_var
0820 856933     603            mov x+1, proportional_gain_var+1
0823 856A34     604            mov x+2, proportional_gain_var+2
0826 856B35     605            mov x+3, proportional_gain_var+3
0829 75362C     606            mov y+0, #low (BASE_POWER % 0x10000) 
082C 753701     606            mov y+1, #high(BASE_POWER % 0x10000) 
082F 753800     606            mov y+2, #low (BASE_POWER / 0x10000) 
0832 753900     606            mov y+3, #high(BASE_POWER / 0x10000) 
0835 12018A     607            lcall add32
0838            608            ; x now holds the power output before the saturator
0838 853268     609            mov proportional_gain_var, x
083B 853369     610            mov proportional_gain_var+1, x+1
083E 85346A     611            mov proportional_gain_var+2, x+2
0841 85356B     612            mov proportional_gain_var+3, x+3
0844 803D       613            sjmp saturator_soak
0846            614   
0846            615   sub_proportional_soak:
0846            616            ; base_power - soak_power when soak_temp <= current_temp
0846 75322C     617            mov x+0, #low (BASE_POWER % 0x10000) 
0849 753301     617            mov x+1, #high(BASE_POWER % 0x10000) 
084C 753400     617            mov x+2, #low (BASE_POWER / 0x10000) 
084F 753500     617            mov x+3, #high(BASE_POWER / 0x10000) 
0852 856836     618            mov y, proportional_gain_var
0855 856937     619            mov y+1, proportional_gain_var+1
0858 856A38     620            mov y+2, proportional_gain_var+2
085B 856B39     621            mov y+3, proportional_gain_var+3
085E            622   
085E            623            ; compare whether base_power < proportional_gain_var
085E C200       624            clr mf
0860 1201D1     625            lcall x_lt_y ; set mf to 1 if base_power < proportional_gain_var, clamp output to 0
0863 30000E     626            jnb mf, bp_gteq_pgv
0866 756800     627            mov proportional_gain_var, #low(NO_POWER)
0869 756900     628            mov proportional_gain_var+1, #high(NO_POWER)
086C 756A00     629            mov proportional_gain_var+2, #0
086F 756B00     630            mov proportional_gain_var+3, #0
0872 800F       631            sjmp saturator_soak
0874            632   
0874            633   bp_gteq_pgv:
0874            634            ; calculate subtracted gain
0874 1201AD     635            lcall sub32
0877            636            ; x now holds the power output before the saturator
0877 853268     637            mov proportional_gain_var, x
087A 853369     638            mov proportional_gain_var+1, x+1
087D 85346A     639            mov proportional_gain_var+2, x+2
0880 85356B     640            mov proportional_gain_var+3, x+3
0883            641   
0883            642   saturator_soak:
0883            643            ; proportional_gain_var now holds the power output before the saturator
0883            644            ; saturate power output to max power
0883 856832     645            mov x, proportional_gain_var
0886 856933     646            mov x+1, proportional_gain_var+1
0889 856A34     647            mov x+2, proportional_gain_var+2
088C 856B35     648            mov x+3, proportional_gain_var+3
088F            649   
088F 7536DC     650            mov y+0, #low (MAX_POWER % 0x10000) 
0892 753705     650            mov y+1, #high(MAX_POWER % 0x10000) 
0895 753800     650            mov y+2, #low (MAX_POWER / 0x10000) 
0898 753900     650            mov y+3, #high(MAX_POWER / 0x10000) 
089B            651   
089B C200       652            clr mf
089D 1201ED     653            lcall x_gt_y ; set mf to 1 if calculated power output greater than max power
08A0 20000F     654            jb mf, saturated_soak
08A3            655            ; set power_output to calculated power if not saturated
08A3 856857     656            mov power_output, proportional_gain_var
08A6 856958     657            mov power_output+1, proportional_gain_var+1
08A9 856A59     658            mov power_output+2, proportional_gain_var+2
08AC 856B5A     659            mov power_output+3, proportional_gain_var+3
08AF 020903     660            ljmp power_control_done
08B2            661   
08B2            662   saturated_soak:
08B2 7557DC     663            mov power_output, #low(MAX_POWER)
08B5 755805     664            mov power_output+1, #high(MAX_POWER)
08B8 755900     665            mov power_output+2, #0
08BB 755A00     666            mov power_output+3, #0
08BE 020903     667            ljmp power_control_done
08C1            668   
08C1            669   
08C1            670   state4_power_control:
08C1            671            ; ramp to reflow, max power
08C1 B4040F     672            cjne a, #4, state5_power_control
08C4 7557DC     673            mov power_output, #low(MAX_POWER)
08C7 755805     674            mov power_output+1, #high(MAX_POWER)
08CA 755900     675            mov power_output+2, #0
08CD 755A00     676            mov power_output+3, #0
08D0 020903     677            ljmp power_control_done
08D3            678   
08D3            679   state5_power_control:
08D3            680            ; reflow 20% base power
08D3 B4050F     681            cjne a, #5, state6_power_control
08D6 75572C     682            mov power_output, #low(BASE_POWER)  
08D9 755801     683            mov power_output+1, #high(BASE_POWER)
08DC 755900     684            mov power_output+2, #0
08DF 755A00     685            mov power_output+3, #0
08E2 020903     686            ljmp power_control_done
08E5            687   
08E5            688   state6_power_control:
08E5            689            ; cooling 0% power
08E5 B4060F     690            cjne a, #6, state_7_power_control
08E8 755700     691            mov power_output, #low(NO_POWER)
08EB 755800     692            mov power_output+1, #high(NO_POWER)
08EE 755900     693            mov power_output+2, #0
08F1 755A00     694            mov power_output+3, #0
08F4 020903     695            ljmp power_control_done
08F7            696   
08F7            697   state_7_power_control:
08F7            698            ; idle 0% power
08F7 755700     699            mov power_output, #low(NO_POWER)
08FA 755800     700            mov power_output+1, #high(NO_POWER)
08FD 755900     701            mov power_output+2, #0
0900 755A00     702            mov power_output+3, #0
0903            703   
0903            704   power_control_done:
0903 22         705            ret
0904            706   
0904            707   
0904            708   
0904            709   ;-------------------------------------------------------------------------------
0904            710   ; PWM
0904            711   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0904            712   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0904            713   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0904 100202     714            jbc one_millisecond_flag, pwm_wave_generator
0907 8071       715            sjmp end_pwm_generator
0909            716   
0909            717   pwm_wave_generator:
0909 C200       718            clr mf
090B            719            ; move pwm counter value into x for comparison purpose
090B 855B32     720            mov x, pwm_counter
090E 855C33     721            mov x+1, pwm_counter+1
0911 855D34     722            mov x+2, pwm_counter+2
0914 855E35     723            mov x+3, pwm_counter+3
0917            724   
0917 7536DB     725            mov y+0, #low (PWM_PERIOD % 0x10000) 
091A 753705     725            mov y+1, #high(PWM_PERIOD % 0x10000) 
091D 753800     725            mov y+2, #low (PWM_PERIOD / 0x10000) 
0920 753900     725            mov y+3, #high(PWM_PERIOD / 0x10000) 
0923            726   
0923            727            ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else increase x by 1
0923 120209     728            lcall x_eq_y 
0926 20001D     729            jb mf, wrap_pwm_counter
0929            730            ; x not equal 1499, increment by 1
0929 753601     731            mov y+0, #low (1 % 0x10000) 
092C 753700     731            mov y+1, #high(1 % 0x10000) 
092F 753800     731            mov y+2, #low (1 / 0x10000) 
0932 753900     731            mov y+3, #high(1 / 0x10000) 
0935 12018A     732            lcall add32
0938            733            ; update pwm_counter
0938 85325B     734            mov pwm_counter, x
093B 85335C     735            mov pwm_counter+1, x+1
093E 85345D     736            mov pwm_counter+2, x+2
0941 85355E     737            mov pwm_counter+3, x+3
0944 8018       738            sjmp set_pwm
0946            739   
0946            740   wrap_pwm_counter:
0946            741            ; x equal 1499, wrap to 0
0946 753200     742            mov x+0, #low (0 % 0x10000) 
0949 753300     742            mov x+1, #high(0 % 0x10000) 
094C 753400     742            mov x+2, #low (0 / 0x10000) 
094F 753500     742            mov x+3, #high(0 / 0x10000) 
0952 85325B     743            mov pwm_counter, x
0955 85335C     744            mov pwm_counter+1, x+1
0958 85345D     745            mov pwm_counter+2, x+2
095B 85355E     746            mov pwm_counter+3, x+3
095E            747   
095E            748   set_pwm:
095E            749            ; compare with power_output, if pwm counter smaller than power_output, set pwm pin high; else set pwm pin low
095E            750            ; load y with power output value
095E 855736     751            mov y, power_output
0961 855837     752            mov y+1, power_output+1
0964 855938     753            mov y+2, power_output+2
0967 855A39     754            mov y+3, power_output+3
096A            755   
096A            756            ; compare x(pwm counter) with y(power output)
096A 1201D1     757            lcall x_lt_y
096D 200006     758            jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power output
0970            759            ; set pwm pin low if pwm counter greater than power output
0970 C293       760            clr PWM_OUT
0972 C2EC       761            clr LEDRA.4
0974 8004       762            sjmp end_pwm_generator
0976            763   
0976            764   set_pwm_high:
0976 D293       765            setb PWM_OUT
0978 D2EC       766            setb LEDRA.4
097A            767   
097A            768   end_pwm_generator:
097A 22         769            ret
097B            770   ;-------------------------------------------------------------------------------;
097B            771   
097B            772   ;-------------------------------------------------------------------------------;
097B            773   ; main control fsm for the entire process
097B            774   Control_FSM:
097B E567       775            mov a, Control_FSM_state
097D 8003       776            sjmp Control_FSM_state0
097F            777   
097F            778   Control_FSM_state0_a:
097F 756700     779            mov Control_FSM_state, #0
0982            780   Control_FSM_state0:
0982 B40007     781            cjne a, #0, Control_FSM_state1
0985 100D02     782            jbc PB0_flag, Control_FSM_state1_a
0988 8057       783            sjmp Control_FSM_done
098A            784   
098A            785   Control_FSM_state1_a:
098A 0567       786            inc Control_FSM_state
098C            787   Control_FSM_state1:
098C B4010C     788            cjne a, #1, Control_FSM_state2
098F 100E02     789            jbc PB1_flag, Control_FSM_state1_b
0992 804D       790            sjmp Control_FSM_done
0994            791   Control_FSM_state1_b:
0994 100B02     792            jbc config_finish_signal, Control_FSM_state2_a
0997 8048       793            sjmp Control_FSM_done
0999            794   
0999            795   Control_FSM_state2_a:
0999 0567       796            inc Control_FSM_state
099B            797   Control_FSM_state2:
099B B4020A     798            cjne a, #2, Control_FSM_state3
099E 100F2C     799            jbc PB2_flag, Control_FSM_state6_a
09A1 100302     800            jbc soak_temp_reached, Control_FSM_state3_a
09A4 803B       801            sjmp Control_FSM_done
09A6            802   
09A6            803   Control_FSM_state3_a:
09A6 0567       804            inc Control_FSM_state
09A8            805   Control_FSM_state3:
09A8 B4030A     806            cjne a, #3, Control_FSM_state4
09AB 100F1F     807            jbc PB2_flag, Control_FSM_state6_a
09AE 100602     808            jbc soak_time_reached, Control_FSM_state4_a
09B1 802E       809            sjmp Control_FSM_done
09B3            810   
09B3            811   Control_FSM_state4_a:
09B3 0567       812            inc Control_FSM_state   
09B5            813   Control_FSM_state4:
09B5 B4040A     814            cjne a, #4, Control_FSM_state5
09B8 100F12     815            jbc PB2_flag, Control_FSM_state6_a
09BB 100402     816            jbc reflow_temp_reached, Control_FSM_state5_a
09BE 8021       817            sjmp Control_FSM_done
09C0            818   
09C0            819   Control_FSM_state5_a:
09C0 0567       820            inc Control_FSM_state
09C2            821   Control_FSM_state5:
09C2 B4050A     822            cjne a, #5, Control_FSM_state6
09C5 100F05     823            jbc PB2_flag, Control_FSM_state6_a
09C8 100702     824            jbc reflow_time_reached, Control_FSM_state6_a
09CB 8014       825            sjmp Control_FSM_done
09CD            826   
09CD            827   Control_FSM_state6_a:
09CD 0567       828            inc Control_FSM_state
09CF            829   Control_FSM_state6:
09CF B4060F     830            cjne a, #6, Control_FSM_done
09D2 100502     831            jbc cooling_temp_reached, Control_FSM_state7_a
09D5 800A       832            sjmp Control_FSM_done
09D7            833   
09D7            834   Control_FSM_state7_a:
09D7 0567       835            inc Control_FSM_state
09D9            836   Control_FSM_state7:
09D9 B40705     837            cjne a, #7, Control_FSM_done
09DC 100DA0     838            jbc PB0_flag, Control_FSM_state0_a
09DF 8000       839            sjmp Control_FSM_done
09E1            840   
09E1            841   Control_FSM_done:
09E1 22         842            ret
09E2            843   ;-------------------------------------------------------------------------------;
09E2            844   
09E2            845   
09E2            846   ;---------------------------------;
09E2            847   ;         Main program.           ;
09E2            848   ;---------------------------------;
09E2            849   main:
09E2            850            ; -------------------------------------------------------------------;
09E2            851            ; Initialization
09E2 75817F     852       mov SP, #0x7F
09E5            853   
09E5            854            ; We use the pins of P0 to control the LCD.  Configure as outputs.
09E5 759A7F     855       mov P0MOD, #01111111b ; P0.0 to P0.6 are outputs.  ('1' makes the pin output)
09E8            856       ; We use pins P1.5 and P1.1 as outputs also.  Configure accordingly.
09E8 759B22     857       mov P1MOD, #00100010b ; P1.5 and P1.1 are outputs
09EB 759CFF     858       mov P2MOD, #0xff
09EE 759DFF     859       mov P3MOD, #0xff
09F1            860       ; Turn off all the LEDs
09F1 75E800     861       mov LEDRA, #0 ; LEDRA is bit addressable
09F4 759500     862       mov LEDRB, #0 ; LEDRB is NOT bit addresable
09F7            863   
09F7            864            ; Enable Global interrupts
09F7 D2AF       865       setb EA  
09F9            866   
09F9            867            ; FSM initial states
09F9 756500     868            mov KEY1_DEB_state, #0
09FC 756600     869            mov SEC_FSM_state, #0
09FF 756700     870            mov Control_FSM_state, #0
0A02            871            ; FSM timers initialization
0A02 756300     872            mov KEY1_DEB_timer, #0
0A05 756400     873            mov SEC_FSM_timer, #0
0A08            874            ; time counters initialization
0A08 753000     875            mov current_time_sec, #0
0A0B 753100     876            mov current_time_minute, #0
0A0E            877            ; Initialize counter to zero
0A0E 755B00     878       mov pwm_counter, #0
0A11 755C00     879            mov pwm_counter+1, #0
0A14 755D00     880            mov pwm_counter+2, #0
0A17 755E00     881            mov pwm_counter+3, #0
0A1A            882            ; Initialize power output
0A1A 755A00     883            mov power_output+3, #0
0A1D 755900     884            mov power_output+2, #0
0A20 755802     885            mov power_output+1, #02H
0A23 7557EE     886            mov power_output, #0EEH ; (initilize to 750 for testing)
0A26            887   
0A26            888            ; Clear all the flags
0A26 C20D       889            clr PB0_flag
0A28 C20E       890            clr PB1_flag
0A2A C20F       891            clr PB2_flag
0A2C C201       892            clr one_second_flag
0A2E C20B       893            clr config_finish_signal
0A30 C203       894            clr soak_temp_reached
0A32 C206       895            clr soak_time_reached
0A34 C204       896            clr reflow_temp_reached
0A36 C207       897            clr reflow_time_reached
0A38 C205       898            clr cooling_temp_reached
0A3A            899   
0A3A 1204B8     900            lcall Timer0_Init
0A3D 120522     901       lcall Timer2_Init
0A40 12008A     902            lcall ELCD_4BIT
0A43 1204D4     903            lcall Initialize_Serial_Port
0A46            904   
0A46            905   loop:
0A46            906            ; Check the FSM for KEY1 debounce
0A46 1206CF     907            lcall KEY1_DEB
0A49            908   
0A49            909            ; Check the FSM for one second counter
0A49 120705     910            lcall SEC_FSM
0A4C            911   
0A4C            912            ; Check the FSM for the overall control flow of the reflow process
0A4C 12097B     913            lcall Control_FSM
0A4F            914   
0A4F            915            ; Update the LCD display based on the current state
0A4F            916            ;lcall LCD_Display_Update_func
0A4F            917   
0A4F            918            ; Update the pwm output for the ssr
0A4F 120904     919            lcall PWM_Wave 
0A52            920   
0A52            921            ; After initialization the program stays in this 'forever' loop
0A52 020A46     922            ljmp loop
0A55            923   
0A55            924   END
=======
0401            155   
0401            156   ;-------------------------------------------------------------------------------
0401            157   ; Timers Setting:
0401            158   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
0401            159   ;        Timer 1: Serial port baud rate 57600 generator
0401            160   ;        Timer 2: 1ms interrupt for BCD counter increment/decrement
0401            161   ;-------------------------------------------------------------------------------
0401            162   ; Routine to initialize the ISR for Timer 0 ;
0401            163   Timer0_Init:
0401 E589       164            mov a, TMOD
0403 54F0       165            anl a, #0xf0 ; Clear the bits for timer 0
0405 4401       166            orl a, #0x01 ; Configure timer 0 as 16-timer
0407 F589       167            mov TMOD, a
0409 758CFD     168            mov TH0, #high(TIMER0_RELOAD)
040C 758A5A     169            mov TL0, #low(TIMER0_RELOAD)
040F            170            ; Enable the timer and interrupts
040F D2A9       171       setb ET0  ; Enable timer 0 interrupt
0411 D28C       172       setb TR0  ; Start timer 0
0413 22         173            ret
0414            174   ; ISR for timer 0.  Set to execute every 1/4096Hz 
0414            175   ; to generate a 2048 Hz square wave at pin P1.5 
0414            176   Timer0_ISR:
0414            177            ;clr TF0  ; According to the data sheet this is done for us already.
0414 758CFD     178            mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
0417 758A5A     179            mov TL0, #low(TIMER0_RELOAD)
041A B295       180            cpl SOUND_OUT ; Connect speaker to P1.5
041C 32         181            reti
041D            182   ; -----------------------------------------------------------------------------------------------;
041D            183   
041D            184   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
041D            185   Initialize_Serial_Port:
041D            186            ; Configure serial port and baud rate
041D C28E       187            clr TR1 ; Disable timer 1
041F 53890F     188            anl TMOD, #0x0f ; Mask the bits for timer 1
0422 438920     189            orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
0425 438780     190       orl PCON, #80H ; Set SMOD to 1
0428 758DFD     191            mov TH1, #low(TIMER_1_RELOAD)
042B 758BFD     192            mov TL1, #low(TIMER_1_RELOAD) 
042E D28E       193            setb TR1 ; Enable timer 1
0430 759852     194            mov SCON, #52H
0433 22         195            ret
0434            196   
0434            197   ; uart sending functions
0434            198   putchar:
0434 109902     199            jbc     TI, putchar_L1
0437 80FB       200            sjmp putchar
0439            201   putchar_L1:
0439 F599       202            mov     SBUF,a
043B 22         203            ret
043C            204   
043C            205   SendString:
043C E4         206       clr a
043D 93         207       movc a, @a+dptr
043E 6006       208       jz SendString_L1
0440 120434     209       lcall putchar
0443 A3         210       inc dptr
0444 80F6       211       sjmp SendString  
0446            212   SendString_L1:
0446 22         213            ret
0447            214   
0447            215   ;-------------------------------------------------------------------------------
0447            216   ; serial debugging
0447            217   ; send a four byte number via serial to laptop
0447            218   ; need to be used with python script
0447            219   ; content needed to be sent should be stored in the varaible x
0447            220   ;-------------------------------------------------------------------------------
0447            221   Send32:
0447            222       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
0447 74AA       223       mov A, #0AAH
0449 120434     224       lcall putchar
044C 7455       225       mov A, #055H
044E 120434     226       lcall putchar
0451            227   
0451 E535       228       mov A, x+3
0453 120434     229       lcall putchar
0456 E534       230       mov A, x+2
0458 120434     231       lcall putchar
045B E533       232       mov A, x+1
045D 120434     233       lcall putchar
0460 E532       234       mov A, x+0
0462 120434     235       lcall putchar
0465            236   
0465 740A       237       mov A, #0AH
0467 120434     238       lcall putchar
046A 22         239       ret
046B            240   ; -----------------------------------------------------------------------------------------------;
046B            241   
046B            242   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
046B              1   ;------------------------------------------------------------------------------------------------;
046B              2   ; Routine to initialize the ISR for timer 2 
046B              3   Timer2_Init:
046B 75C800       4            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
046E 75CDF5       5            mov TH2, #high(TIMER2_RELOAD)
0471 75CC27       6            mov TL2, #low(TIMER2_RELOAD)
0474              7            ; Set the reload value
0474 75CBF5       8            mov RCAP2H, #high(TIMER2_RELOAD)
0477 75CA27       9            mov RCAP2L, #low(TIMER2_RELOAD)
047A             10            ; Enable the timer and interrupts
047A D2AD        11       setb ET2  ; Enable timer 2 interrupt
047C D2CA        12       setb TR2  ; Enable timer 2
047E 22          13            ret
047F             14   
047F             15   ; ISR for timer 2.  Runs every 1 ms ;
047F             16   Timer2_ISR:
047F C0E0        17            push acc
0481 C0D0        18            push psw
0483 C2CF        19            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
0485             20            ; cpl P1.1 ; Optional debug pin toggle for scope (ensure it's not used elsewhere)
0485             21   
0485             22   ; FSM states timers
0485 055F        23            inc KEY1_DEB_timer
0487 0560        24            inc SEC_FSM_timer
0489             25   
0489 D202        26            setb one_ms_pwm_flag ; set the one millisecond flag for pwm signal generation
048B D203        27            setb one_millisecond_flag_servo ; set the one millsiecond flag for servo pwm signal generation
048D             28   
048D             29   Timer2_ISR_done:
048D D0D0        30            pop psw
048F D0E0        31            pop acc
0491 32          32            reti
0492             33   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
0492              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
0492              2   cseg
0492              3   
0492              4   ; When using a 33.333333MHz crystal clock
0492              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
0492              6   
0492              7   ;---------------------------------;
0492              8   ; Wait 40 microseconds            ;
0492              9   ;---------------------------------;
0492             10   Wait40uSec:
0492 C000        11            push AR0
0494 78BE        12            mov R0, #190
0496             13   L0: 
0496 00          14            nop
0497 00          15            nop
0498 00          16            nop
0499 00          17            nop
049A D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
049C D000        19            pop AR0
049E 22          20       ret
049F             21   
049F             22   ;---------------------------------;
049F             23   ; Wait 'R2' milliseconds          ;
049F             24   ;---------------------------------;
                 25   Wait_Milli_Seconds mac
                 26   	push AR2
                 27   	mov R2, %0
                 28   	lcall ?Wait_Milli_Seconds
                 29   	pop AR2
                 30   endmac
049F             31   
049F             32   ?Wait_Milli_Seconds:
049F C000        33            push AR0
04A1 C001        34            push AR1
04A3 7932        35   L3: mov R1, #50
04A5 78DF        36   L2: mov R0, #223
04A7 D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
04A9 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
04AB DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
04AD D001        40       pop AR1
04AF D000        41       pop AR0
04B1 22          42       ret
04B2             43            
04B2             44   ;---------------------------------;
04B2             45   ; Toggles the 'E' pin in the LCD  ;
04B2             46   ;---------------------------------;
04B2             47   ELCD_pulse:
04B2 D2B3        48            setb ELCD_E
04B4 120492      49            lcall Wait40uSec
04B7 C2B3        50            clr ELCD_E
04B9 120492      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
04BC 22          52       ret
04BD             53   
04BD             54   ;---------------------------------;
04BD             55   ; Writes acc to LCD in 4-bit mode ;
04BD             56   ;---------------------------------;
04BD             57   ELCD_byte:
04BD             58            ; Write high 4 bits first
04BD A2E7        59            mov c, ACC.7
04BF 92A3        60            mov ELCD_D7, c
04C1 A2E6        61            mov c, ACC.6
04C3 92A5        62            mov ELCD_D6, c
04C5 A2E5        63            mov c, ACC.5
04C7 92A7        64            mov ELCD_D5, c
04C9 A2E4        65            mov c, ACC.4
04CB 92B1        66            mov ELCD_D4, c
04CD 1204B2      67       lcall ELCD_pulse
04D0             68            ; Write low 4 bits next
04D0 A2E3        69            mov c, ACC.3
04D2 92A3        70            mov ELCD_D7, c
04D4 A2E2        71            mov c, ACC.2
04D6 92A5        72            mov ELCD_D6, c
04D8 A2E1        73            mov c, ACC.1
04DA 92A7        74            mov ELCD_D5, c
04DC A2E0        75            mov c, ACC.0
04DE 92B1        76            mov ELCD_D4, c
04E0 1204B2      77       lcall ELCD_pulse
04E3 22          78            ret
04E4             79   
04E4             80   ;---------------------------------;
04E4             81   ; Write data to LCD               ;
04E4             82   ;---------------------------------;
                 83   WriteData mac
                 84   	mov a, %0
                 85   	lcall ?WriteData
                 86   endmac
04E4             87            
04E4             88   ?WriteData:
04E4 D2B7        89            setb ELCD_RS
04E6 0204BD      90            ljmp ELCD_byte
04E9             91   
04E9             92   ;---------------------------------;
04E9             93   ; Write command to LCD            ;
04E9             94   ;---------------------------------;
                 95   WriteCommand mac
                 96   	mov a, %0
                 97   	lcall ?WriteCommand
                 98   endmac
04E9             99   
04E9            100   ?WriteCommand:
04E9 C2B7       101            clr ELCD_RS
04EB 0204BD     102            ljmp ELCD_byte
04EE            103   
04EE            104   ;---------------------------------;
04EE            105   ; Configure LCD in 4-bit mode     ;
04EE            106   ;---------------------------------;
04EE            107   ELCD_4BIT:
04EE C2B3       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
04F0            109            ;clr ELCD_RW  ; RW forced to zero
04F0            110            
04F0            111            ; After power on, let the LCD start up before initializing
04F0 C002       112            push AR2
04F2 7A28       112            mov R2, #40
04F4 12049F     112            lcall ?Wait_Milli_Seconds
04F7 D002       112            pop AR2
04F9            112   
04F9            113            
04F9            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
04F9 7433       115            mov a, #0x33
04FB 1204E9     115            lcall ?WriteCommand
04FE 7433       116            mov a, #0x33
0500 1204E9     116            lcall ?WriteCommand
0503 7432       117            mov a, #0x32
0505 1204E9     117            lcall ?WriteCommand ; change to 4-bit mode
0508            118   
0508            119            ; Configure the LCD
0508 7428       120            mov a, #0x28
050A 1204E9     120            lcall ?WriteCommand
050D 740C       121            mov a, #0x0c
050F 1204E9     121            lcall ?WriteCommand
0512 7401       122            mov a, #0x01
0514 1204E9     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
0517            123   
0517            124       ;Wait for the clear screen command to finish.
0517 C002       125            push AR2
0519 7A02       125            mov R2, #2
051B 12049F     125            lcall ?Wait_Milli_Seconds
051E D002       125            pop AR2
0520            125   
0520 22         126       ret
0521            127   
0521            128   ;---------------------------------;
0521            129   ; Send a constant string to LCD   ;
0521            130   ;---------------------------------;
                131   Send_Constant_String mac
                132   	push dph
                133   	push dpl
                134   	push acc
                135   	mov dptr, %0
                136   	lcall ?Send_Constant_String
                137   	pop acc
                138   	pop dpl
                139   	pop dph
                140   endmac
0521            141   
0521            142   ?Send_Constant_String:
0521 E4         143       clr a
0522 93         144       movc a, @a+dptr
0523 6006       145       jz ?Send_Constant_String_Done
0525 1204E4     146       lcall ?WriteData
0528 A3         147       inc dptr
0529 80F6       148       sjmp ?Send_Constant_String
052B            149   ?Send_Constant_String_Done:
052B 22         150       ret  
052C            151   
052C            152   ;---------------------------------;
052C            153   ; Set LCD cursor at row, column   ;
052C            154   ;---------------------------------;
                155   Set_Cursor mac
                156   	push acc
                157   	mov a, #%1
                158   	dec a
                159   	lcall ?Set_Cursor_%0 ; Select column and row
                160   	pop acc
                161   endmac
052C            162   
052C            163   ?Set_Cursor_2:
052C 4440       164            orl a, #01000000B
052E            165   ?Set_Cursor_1:
052E 4480       166            orl a, #10000000B
0530 0204E9     167            ljmp ?WriteCommand ; Select column and row
0533            168   
0533            169   ;---------------------------------;
0533            170   ; Display a BCD number in the LCD ;
0533            171   ;---------------------------------;
                172   Display_BCD mac
                173   	push ar0
                174   	mov r0, %0
                175   	lcall ?Display_BCD
                176   	pop ar0
                177   endmac
0533            178   
0533            179   ?Display_BCD:
0533 C0E0       180            push acc
0535            181            ; Write most significant digit
0535 E8         182            mov a, r0
0536 C4         183            swap a
0537 540F       184            anl a, #0fh
0539 4430       185            orl a, #30h
053B 1204E4     186            lcall ?WriteData
053E            187            ; write least significant digit
053E E8         188            mov a, r0
053F 540F       189            anl a, #0fh
0541 4430       190            orl a, #30h
0543 1204E4     191            lcall ?WriteData
0546 D0E0       192            pop acc
0548 22         193            ret
0549            194   
0549            195   ;------------------------------------;
0549            196   ; Display a char in the LCD          ;
0549            197   ;------------------------------------;
                198   Display_char mac
                199   	push acc
                200   	mov a, %0
                201   	lcall ?WriteData
                202   	pop acc
                203   endmac
0549            204   
0549            245            ;-----------------------------------------------------------------------------------------------;
0549            246   
0549            247   ;-------------------------------------------------------------------------------
0549            248   ; Display Function for 7-segment displays                
0549            249   ;-------------------------------------------------------------------------------
0549            250   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
0549            251   T_7seg:
0549 C0F9A4B0   252       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
054E 9282F880   253       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
0553 8883C6A1   254       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
0559            255   
0559            256   ; Displays a BCD number pased in R0 in HEX5-HEX0
0559            257   Display_BCD_7_Seg_HEX10:
0559 900549     258            mov dptr, #T_7seg
055C E8         259            mov a, R0
055D C4         260            swap a
055E 540F       261            anl a, #0FH
0560 93         262            movc a, @a+dptr
0561 F592       263            mov HEX1, a
0563 E8         264            mov a, R0
0564 540F       265            anl a, #0FH
0566 93         266            movc a, @a+dptr
0567 F591       267            mov HEX0, a
0569 22         268            ret
056A            269   
056A            270   Display_BCD_7_Seg_HEX32:
056A 900549     271            mov dptr, #T_7seg
056D E8         272            mov a, R0
056E C4         273            swap a
056F 540F       274            anl a, #0FH
0571 93         275            movc a, @a+dptr
0572 F594       276            mov HEX3, a
0574 E8         277            mov a, R0
0575 540F       278            anl a, #0FH
0577 93         279            movc a, @a+dptr
0578 F593       280            mov HEX2, a
057A 22         281            ret
057B            282   
057B            283   Display_BCD_7_Seg_HEX54:
057B 900549     284            mov dptr, #T_7seg
057E E8         285            mov a, R0
057F C4         286            swap a
0580 540F       287            anl a, #0FH
0582 93         288            movc a, @a+dptr
0583 F58F       289            mov HEX5, a
0585 E8         290            mov a, R0
0586 540F       291            anl a, #0FH
0588 93         292            movc a, @a+dptr
0589 F58E       293            mov HEX4, a
058B 22         294            ret
058C            295   
058C            296   ; The 8-bit hex number passed in the accumulator is converted to
058C            297   ; BCD and stored in [R1, R0]
058C            298   Hex_to_bcd_8bit:
058C 75F064     299            mov b, #100
058F 84         300            div ab
0590 F9         301            mov R1, a   ; After dividing, a has the 100s
0591 E5F0       302            mov a, b    ; Remainder is in register b
0593 75F00A     303            mov b, #10
0596 84         304            div ab ; The tens are stored in a, the units are stored in b 
0597 C4         305            swap a
0598 54F0       306            anl a, #0xf0
059A 45F0       307            orl a, b
059C F8         308            mov R0, a
059D 22         309            ret
059E            310   
059E            311   ;-------------------------------------------------------------------------------
059E            312   ; Display Function for LCD                                               
059E            313   ;-------------------------------------------------------------------------------
059E            314   LCD_Display_Update_func:
059E C0E0       315            push acc
05A0 100D03     316            jbc state_change_signal, LCD_Display_Update_Do
05A3 0206D4     317            ljmp LCD_Display_Update_done
05A6            318   
05A6            319   LCD_Display_Update_Do:
05A6 E563       320            mov a, Control_FSM_state
05A8            321   
05A8            322   LCD_Display_Update_0:
05A8 B4003B     323            cjne a, #0, LCD_Display_Update_1
05AB C0E0       324            push acc
05AD 7401       324            mov a, #1
05AF 14         324            dec a
05B0 12052E     324            lcall ?Set_Cursor_1 ; Select column and row
05B3 D0E0       324            pop acc
05B5 C083       325            push dph
05B7 C082       325            push dpl
05B9 C0E0       325            push acc
05BB 900330     325            mov dptr, #String_state0_1
05BE 120521     325            lcall ?Send_Constant_String
05C1 D0E0       325            pop acc
05C3 D082       325            pop dpl
05C5 D083       325            pop dph
05C7 C0E0       326            push acc
05C9 7401       326            mov a, #1
05CB 14         326            dec a
05CC 12052C     326            lcall ?Set_Cursor_2 ; Select column and row
05CF D0E0       326            pop acc
05D1 C083       327            push dph
05D3 C082       327            push dpl
05D5 C0E0       327            push acc
05D7 900340     327            mov dptr, #String_state0_2
05DA 120521     327            lcall ?Send_Constant_String
05DD D0E0       327            pop acc
05DF D082       327            pop dpl
05E1 D083       327            pop dph
05E3 0206D4     328            ljmp LCD_Display_Update_done
05E6            329   
05E6            330   LCD_Display_Update_1:
05E6 B4011F     331            cjne a, #1, LCD_Display_Update_2
05E9 C0E0       332            push acc
05EB 7401       332            mov a, #1
05ED 14         332            dec a
05EE 12052E     332            lcall ?Set_Cursor_1 ; Select column and row
05F1 D0E0       332            pop acc
05F3 C083       333            push dph
05F5 C082       333            push dpl
05F7 C0E0       333            push acc
05F9 900350     333            mov dptr, #String_state1
05FC 120521     333            lcall ?Send_Constant_String
05FF D0E0       333            pop acc
0601 D082       333            pop dpl
0603 D083       333            pop dph
0605 0206D4     334            ljmp LCD_Display_Update_done
0608            335   
0608            336   LCD_Display_Update_2:
0608 B4021F     337            cjne a, #2, LCD_Display_Update_3
060B C0E0       338            push acc
060D 7401       338            mov a, #1
060F 14         338            dec a
0610 12052E     338            lcall ?Set_Cursor_1 ; Select column and row
0613 D0E0       338            pop acc
0615 C083       339            push dph
0617 C082       339            push dpl
0619 C0E0       339            push acc
061B 900390     339            mov dptr, #String_state2
061E 120521     339            lcall ?Send_Constant_String
0621 D0E0       339            pop acc
0623 D082       339            pop dpl
0625 D083       339            pop dph
0627 0206D4     340            ljmp LCD_Display_Update_done
062A            341   
062A            342   LCD_Display_Update_3:
062A B4031F     343            cjne a, #3, LCD_Display_Update_4
062D C0E0       344            push acc
062F 7401       344            mov a, #1
0631 14         344            dec a
0632 12052E     344            lcall ?Set_Cursor_1 ; Select column and row
0635 D0E0       344            pop acc
0637 C083       345            push dph
0639 C082       345            push dpl
063B C0E0       345            push acc
063D 9003A0     345            mov dptr, #String_state3
0640 120521     345            lcall ?Send_Constant_String
0643 D0E0       345            pop acc
0645 D082       345            pop dpl
0647 D083       345            pop dph
0649 0206D4     346            ljmp LCD_Display_Update_done
064C            347   
064C            348   LCD_Display_Update_4:
064C B4041F     349            cjne a, #4, LCD_Display_Update_5
064F C0E0       350            push acc
0651 7401       350            mov a, #1
0653 14         350            dec a
0654 12052E     350            lcall ?Set_Cursor_1 ; Select column and row
0657 D0E0       350            pop acc
0659 C083       351            push dph
065B C082       351            push dpl
065D C0E0       351            push acc
065F 9003B0     351            mov dptr, #String_state4
0662 120521     351            lcall ?Send_Constant_String
0665 D0E0       351            pop acc
0667 D082       351            pop dpl
0669 D083       351            pop dph
066B 0206D4     352            ljmp LCD_Display_Update_done
066E            353   
066E            354   LCD_Display_Update_5:
066E B4051F     355            cjne a, #5, LCD_Display_Update_6
0671 C0E0       356            push acc
0673 7401       356            mov a, #1
0675 14         356            dec a
0676 12052E     356            lcall ?Set_Cursor_1 ; Select column and row
0679 D0E0       356            pop acc
067B C083       357            push dph
067D C082       357            push dpl
067F C0E0       357            push acc
0681 9003C0     357            mov dptr, #String_state5
0684 120521     357            lcall ?Send_Constant_String
0687 D0E0       357            pop acc
0689 D082       357            pop dpl
068B D083       357            pop dph
068D 0206D4     358            ljmp LCD_Display_Update_done
0690            359   
0690            360   LCD_Display_Update_6:
0690 B4061F     361            cjne a, #6, LCD_Display_Update_7
0693 C0E0       362            push acc
0695 7401       362            mov a, #1
0697 14         362            dec a
0698 12052E     362            lcall ?Set_Cursor_1 ; Select column and row
069B D0E0       362            pop acc
069D C083       363            push dph
069F C082       363            push dpl
06A1 C0E0       363            push acc
06A3 9003D0     363            mov dptr, #String_state6
06A6 120521     363            lcall ?Send_Constant_String
06A9 D0E0       363            pop acc
06AB D082       363            pop dpl
06AD D083       363            pop dph
06AF 0206D4     364            ljmp LCD_Display_Update_done
06B2            365   
06B2            366   LCD_Display_Update_7:
06B2 B4071F     367            cjne a, #7, LCD_Display_Update_done
06B5 C0E0       368            push acc
06B7 7401       368            mov a, #1
06B9 14         368            dec a
06BA 12052E     368            lcall ?Set_Cursor_1 ; Select column and row
06BD D0E0       368            pop acc
06BF C083       369            push dph
06C1 C082       369            push dpl
06C3 C0E0       369            push acc
06C5 9003E0     369            mov dptr, #String_state7
06C8 120521     369            lcall ?Send_Constant_String
06CB D0E0       369            pop acc
06CD D082       369            pop dpl
06CF D083       369            pop dph
06D1 0206D4     370            ljmp LCD_Display_Update_done
06D4            371   
06D4            372   LCD_Display_Update_done:
06D4 D0E0       373            pop acc
06D6 22         374            ret
06D7            375   
06D7            376   LCD_Display_Update_Temp:
06D7            377            
06D7            378   ;---------------------------------------------------------
06D7            379   
06D7            380   KEY1_DEB:
06D7            381   ;non-blocking state machine for KEY1 debounce
06D7 E561       382            mov a, KEY1_DEB_state
06D9            383   KEY1_DEB_state0:
06D9 B4000A     384            cjne a, #0, KEY1_DEB_state1
06DC 20F92D     385            jb KEY.1, KEY1_DEB_done
06DF 755F00     386            mov KEY1_DEB_timer, #0
06E2 0561       387            inc KEY1_DEB_state
06E4 8026       388            sjmp KEY1_DEB_done
06E6            389   KEY1_DEB_state1:
06E6 B40109     390            cjne a, #1, KEY1_DEB_state2
06E9            391            ; this is the debounce state
06E9 E55F       392            mov a, KEY1_DEB_timer
06EB B4321E     393            cjne a, #50, KEY1_DEB_done ; 50 ms passed?
06EE 0561       394            inc KEY1_DEB_state
06F0 801A       395            sjmp KEY1_DEB_done      
06F2            396   KEY1_DEB_state2:
06F2 B4020C     397            cjne a, #2, KEY1_DEB_state3
06F5 20F904     398            jb KEY.1, KEY1_DEB_state2b
06F8 0561       399            inc KEY1_DEB_state
06FA 8010       400            sjmp KEY1_DEB_done      
06FC            401   KEY1_DEB_state2b:
06FC 756100     402            mov KEY1_DEB_state, #0
06FF 800B       403            sjmp KEY1_DEB_done
0701            404   KEY1_DEB_state3:
0701 B40308     405            cjne a, #3, KEY1_DEB_done
0704 30F905     406            jnb KEY.1, KEY1_DEB_done
0707 D20E       407            setb Key1_flag ; Suscesfully detected a valid KEY1 press/release
0709 756100     408            mov KEY1_DEB_state, #0  
070C            409   KEY1_DEB_done:
070C 22         410            ret
070D            411   
070D            412   ; ------------------------------------------------------------------------------
070D            413   ; Non-blocking FSM for the one second counter
070D            414   ;-------------------------------------------------------------------------------
070D            415   SEC_FSM:
070D E562       416            mov a, SEC_FSM_state
070F            417   SEC_FSM_state0:
070F B4000C     418            cjne a, #0, SEC_FSM_state1
0712 E560       419            mov a, SEC_FSM_timer
0714 B4FA47     420            cjne a, #250, SEC_FSM_done ; 250 ms passed?
0717 756000     421            mov SEC_FSM_timer, #0
071A 0562       422            inc SEC_FSM_state
071C 8040       423            sjmp SEC_FSM_done
071E            424   SEC_FSM_state1:  
071E B4010E     425            cjne a, #1, SEC_FSM_state2
0721 D2E9       426            setb LEDRA.1
0723 E560       427            mov a, SEC_FSM_timer
0725 B4FA36     428            cjne a, #250, SEC_FSM_done ; 250 ms passed?
0728 756000     429            mov SEC_FSM_timer, #0
072B 0562       430            inc SEC_FSM_state
072D 802F       431            sjmp SEC_FSM_done
072F            432   SEC_FSM_state2:  
072F B4020E     433            cjne a, #2, SEC_FSM_state3
0732 D2EA       434            setb LEDRA.2
0734 E560       435            mov a, SEC_FSM_timer
0736 B4FA25     436            cjne a, #250, SEC_FSM_done ; 250 ms passed?
0739 756000     437            mov SEC_FSM_timer, #0
073C 0562       438            inc SEC_FSM_state
073E 801E       439            sjmp SEC_FSM_done
0740            440   SEC_FSM_state3:  
0740 B4031B     441            cjne a, #3, SEC_FSM_done
0743 D2EB       442            setb LEDRA.3
0745 E560       443            mov a, SEC_FSM_timer
0747 B4FA14     444            cjne a, #250, SEC_FSM_done ; 250 ms passed?
074A 756000     445            mov SEC_FSM_timer, #0
074D 756200     446            mov SEC_FSM_state, #0
0750 E530       447            mov a, current_time_sec
0752 B43B05     448            cjne a, #59, IncCurrentTimeSec ; Don't let the seconds counter pass 59
0755 753000     449            mov current_time_sec, #0
0758 8004       450            sjmp SEC_FSM_done
075A            451   IncCurrentTimeSec:
075A 0530       452            inc current_time_sec
075C B2E8       453            cpl LEDRA.0 ; 1 Hz heartbeat LED
075E            454   SEC_FSM_done:
075E 22         455            ret
075F            456   
075F            457   ;-------------------------------------------------------------------------------
075F            458   ; PWM
075F            459   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
075F            460   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
075F            461   ; ------------------------------------------------------------------------------
075F            462   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
075F 100202     463            jbc one_ms_pwm_flag, pwm_wave_generator
0762 8071       464            sjmp end_pwm_generator
0764            465   
0764            466   pwm_wave_generator:
0764 C200       467            clr mf
0766            468            ; move pwm counter value into x for comparison purpose
0766 855B32     469            mov x, pwm_counter
0769 855C33     470            mov x+1, pwm_counter+1
076C 855D34     471            mov x+2, pwm_counter+2
076F 855E35     472            mov x+3, pwm_counter+3
0772            473   
0772 7536DB     474            mov y+0, #low (PWM_PERIOD % 0x10000) 
0775 753705     474            mov y+1, #high(PWM_PERIOD % 0x10000) 
0778 753800     474            mov y+2, #low (PWM_PERIOD / 0x10000) 
077B 753900     474            mov y+3, #high(PWM_PERIOD / 0x10000) 
077E            475   
077E            476            ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
077E            477            ; increase x by 1
077E 120152     478            lcall x_eq_y 
0781 20001D     479            jb mf, wrap_pwm_counter
0784            480            ; x not equal 1499, increment by 1
0784 753601     481            mov y+0, #low (1 % 0x10000) 
0787 753700     481            mov y+1, #high(1 % 0x10000) 
078A 753800     481            mov y+2, #low (1 / 0x10000) 
078D 753900     481            mov y+3, #high(1 / 0x10000) 
0790 1200D3     482            lcall add32
0793            483            ; update pwm_counter
0793 85325B     484            mov pwm_counter, x
0796 85335C     485            mov pwm_counter+1, x+1
0799 85345D     486            mov pwm_counter+2, x+2
079C 85355E     487            mov pwm_counter+3, x+3
079F 8018       488            sjmp set_pwm
07A1            489   
07A1            490   wrap_pwm_counter:
07A1            491            ; x equal 1499, wrap to 0
07A1 753200     492            mov x+0, #low (0 % 0x10000) 
07A4 753300     492            mov x+1, #high(0 % 0x10000) 
07A7 753400     492            mov x+2, #low (0 / 0x10000) 
07AA 753500     492            mov x+3, #high(0 / 0x10000) 
07AD 85325B     493            mov pwm_counter, x
07B0 85335C     494            mov pwm_counter+1, x+1
07B3 85345D     495            mov pwm_counter+2, x+2
07B6 85355E     496            mov pwm_counter+3, x+3
07B9            497   
07B9            498   set_pwm:
07B9            499            ; compare with power_output, if pwm counter smaller than power_output, 
07B9            500            ; set pwm pin high; else set pwm pin low load y with power output value
07B9 855736     501            mov y, power_output
07BC 855837     502            mov y+1, power_output+1
07BF 855938     503            mov y+2, power_output+2
07C2 855A39     504            mov y+3, power_output+3
07C5            505   
07C5            506            ; compare x(pwm counter) with y(power output)
07C5 12011A     507            lcall x_lt_y
07C8 200006     508            jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
07CB            509            ;output set pwm pin low if pwm counter greater than power output
07CB C293       510            clr PWM_OUT
07CD C2EC       511            clr LEDRA.4
07CF 8004       512            sjmp end_pwm_generator
07D1            513   
07D1            514   set_pwm_high:
07D1 D293       515            setb PWM_OUT
07D3 D2EC       516            setb LEDRA.4
07D5            517   
07D5            518   end_pwm_generator:
07D5 22         519            ret
07D6            520   
07D6            521   
07D6            522   ;--------------------------------------------------------------
07D6            523   ; set servo angle according to the state
07D6            524   ; call servo control function every 1ms
07D6            525   ;--------------------------------------------------------------
07D6            526   call_servo_control:
07D6            527            ; check current state and change servo angle
07D6 E563       528            mov a, Control_FSM_state
07D8            529            
07D8            530            ; handle state 0
07D8 B40004     531            cjne a, #0, servo_state1
07DB C214       532            clr servo_angle_zero ; close door at state 0
07DD 802C       533            sjmp check_servo_flag
07DF            534   
07DF            535            ; handle state 1
07DF            536            servo_state1:
07DF B40104     537            cjne a, #1, servo_state2
07E2 D214       538            setb servo_angle_zero ; open door at state 1
07E4 8025       539            sjmp check_servo_flag
07E6            540   
07E6            541            ; handle state 2
07E6            542            servo_state2:
07E6 B40204     543            cjne a, #2, servo_state3
07E9 C214       544            clr servo_angle_zero ; close door at state 2
07EB 801E       545            sjmp check_servo_flag
07ED            546   
07ED            547            ; handle state 3
07ED            548            servo_state3:
07ED B40304     549            cjne a, #3, servo_state4
07F0 C214       550            clr servo_angle_zero ; close door at state 3
07F2 8017       551            sjmp check_servo_flag
07F4            552   
07F4            553            ; handle state 4
07F4            554            servo_state4:
07F4 B40404     555            cjne a, #4, servo_state5
07F7 C214       556            clr servo_angle_zero ; close door at state 4
07F9 8010       557            sjmp check_servo_flag
07FB            558   
07FB            559            ; handle state 5
07FB            560            servo_state5:
07FB B40504     561            cjne a, #5, servo_state6
07FE C214       562            clr servo_angle_zero ; close door at state 5
0800 8009       563            sjmp check_servo_flag
0802            564   
0802            565            ; handle state 6
0802            566            servo_state6:
0802 B40604     567            cjne a, #6, servo_state7
0805 C214       568            clr servo_angle_zero ; close door at state 6
0807 8002       569            sjmp check_servo_flag
0809            570   
0809            571            ; handle state 7
0809            572            servo_state7:
0809 D214       573            setb servo_angle_zero ; open door at state 7
080B            574   
080B            575   check_servo_flag:
080B            576            ; check 1 ms flag
080B 100301     577            jbc one_millisecond_flag_servo, run_servo_control
080E 22         578            ret
080F            579   
080F            580   run_servo_control:
080F 120813     581            lcall servo_control
0812 22         582            ret
0813            583   
0813            584   ;---------------------------------------------------------------
0813            585   ; servo control
0813            586   ; generate a 20 ms period pwm signal to control the servo motor
0813            587   ; able to make the servo motor stay at 0 degree and 180 degree
0813            588   ;---------------------------------------------------------------
0813            589   servo_control:
0813 C0E0       590            push acc
0815 C0D0       591            push psw
0817 D2ED       592            setb LEDRA.5
0819 E564       593            mov a, servo_pwm_counter ; move servo counter to accumulator
081B 04         594            inc A ; a += 1
081C B41402     595            cjne a, #SERVO_PERIOD, servo_pwm_angle_compare ; jump if wrapup not needed
081F 7400       596            mov a, #0
0821            597   
0821            598   servo_pwm_angle_compare: ; read target angle
0821 F564       599            mov servo_pwm_counter, A
0823 201409     600            jb servo_angle_zero, set_zero_degree ; set servo motor to 0 degree
0826            601            ; set servo motor to 180 degrees
0826 E564       602            mov a, servo_pwm_counter
0828 C3         603            clr c
0829 9402       604            subb a, #SERVO_180
082B 400B       605            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 180 degrees duty cycle
082D 800D       606            sjmp servo_pwm_set_low ; set low if greater
082F            607   
082F            608   set_zero_degree:
082F            609            ; set servo motor to 0 degree
082F E564       610            mov a, servo_pwm_counter
0831 C3         611            clr c
0832 9401       612            subb a, #SERVO_0
0834 4002       613            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 0 degrees duty cycle
0836 8004       614            sjmp servo_pwm_set_low ; set low if greater
0838            615   
0838            616   servo_pwm_set_high:
0838            617            ; set pwm pin high
0838 D294       618            setb SERVO_OUT
083A 8002       619            sjmp servo_control_done
083C            620   
083C            621   servo_pwm_set_low:
083C            622            ; set pwm pin low
083C C294       623            clr SERVO_OUT
083E            624   
083E            625   servo_control_done:
083E D0D0       626            pop psw
0840 D0E0       627            pop acc
0842 22         628            ret
0843            629   
0843            630   
0843            631   ;-------------------------------------------------------------------------------;
0843            632   ; Temp_Compare
0843            633   ;
0843            634   ; PURPOSE:
0843            635   ;   Compare the current measured temperature against
0843            636   ;   the soak and reflow temperature setpoints.
0843            637   ;
0843            638   ; BEHAVIOR:
0843            639   ;   - If current_temp >= soak_temp   if soak_temp_reached   = 1
0843            640   ;   - If current_temp >= reflow_temp if reflow_temp_reached = 1
0843            641   ;
0843            642   ; NOTES:
0843            643   ;   - Uses 32-bit UNSIGNED comparison from math32.asm
0843            644   ;   - Comparison is done by:
0843            645   ;       x < y ?   (mf = 1)  if NOT reached
0843            646   ;       x >= y ?  (mf = 0)  if reached
0843            647   ;   - This routine ONLY SETS flags.
0843            648   ;     Clearing flags must be handled by the FSM.
0843            649   ;
0843            650   ; EXPECTED VARIABLES (DSEG / BSEG):
0843            651   ;   current_temp[4], soak_temp[4], reflow_temp[4]
0843            652   ;   x[4], y[4]
0843            653   ;   mf (math32 compare flag)
0843            654   ;   soak_temp_reached, reflow_temp_reached
0843            655   ;-------------------------------------------------------------------------------;
0843            656   Temp_Compare:
0843 C0E0       657       push acc
0845 C0D0       658       push psw
0847 C000       659       push AR0
0849 C001       660       push AR1
084B C002       661       push AR2
084D            662       
084D            663   ; Check: current_temp >= soak_temp ?
084D            664       ; Copy current_temp of x (math32 operand A)
084D 783F       665       mov  R0, #current_temp
084F 7932       666       mov  R1, #x
0851 1208C5     667       lcall Copy4_Bytes_R0_to_R1
0854            668   
0854            669       ; Copy soak_temp of y (math32 operand B)
0854 7843       670       mov  R0, #soak_temp
0856 7936       671       mov  R1, #y
0858 1208C5     672       lcall Copy4_Bytes_R0_to_R1
085B            673   
085B            674       ; Perform x < y comparison
085B            675       ; mf = 1 if current_temp < soak_temp  (NOT reached)
085B            676       ; mf = 0 if current_temp >= soak_temp (REACHED)
085B 12011A     677       lcall x_lt_y
085E 200002     678       jb   mf, Temp_Soak_NotReached
0861 D204       679       setb soak_temp_reached
0863            680   
0863            681   ; Check: current_temp >= reflow_temp ?
0863            682   Temp_Soak_NotReached:
0863            683       ; Copy current_temp of x
0863 783F       684       mov  R0, #current_temp
0865 7932       685       mov  R1, #x
0867 1208C5     686       lcall Copy4_Bytes_R0_to_R1
086A            687   
086A            688       ; Copy reflow_temp of y
086A 7847       689       mov  R0, #reflow_temp
086C 7936       690       mov  R1, #y
086E 1208C5     691       lcall Copy4_Bytes_R0_to_R1
0871            692   
0871            693       ; Compare x < y again
0871 12011A     694       lcall x_lt_y
0874 200002     695       jb   mf, Temp_Reflow_NotReached
0877 D205       696       setb reflow_temp_reached
0879            697   
0879            698   Temp_Reflow_NotReached:
0879 D002       699       pop  AR2
087B D001       700       pop  AR1
087D D000       701       pop  AR0
087F D0D0       702       pop  psw
0881 D0E0       703       pop  acc
0883 22         704       ret
0884            705   ;-------------------------------------------------------------------------------;
0884            706   ; Time_Compare
0884            707   ;
0884            708   ; PURPOSE:
0884            709   ;   Compare the elapsed time against soak and reflow
0884            710   ;   time limits.
0884            711   ;
0884            712   ; BEHAVIOR:
0884            713   ;   - If current_time >= soak_time   if soak_time_reached   = 1
0884            714   ;   - If current_time >= reflow_time if reflow_time_reached = 1
0884            715   ;
0884            716   ; NOTES:
0884            717   ;   - Time values are treated as 32-bit UNSIGNED numbers
0884            718   ;     (e.g., milliseconds or seconds).
0884            719   ;   - Uses the SAME compare logic as Temp_Compare.
0884            720   ;   - This routine ONLY SETS flags.
0884            721   ;
0884            722   ; EXPECTED VARIABLES:
0884            723   ;   current_time[4], soak_time[4], reflow_time[4]
0884            724   ;   x[4], y[4]
0884            725   ;   mf, soak_time_reached, reflow_time_reached
0884            726   ;-------------------------------------------------------------------------------;
0884            727   Time_Compare:
0884 C0E0       728       push acc
0886 C0D0       729       push psw
0888 C000       730       push AR0
088A C001       731       push AR1
088C C002       732       push AR2
088E            733   
088E            734   ; Check: current_time >= soak_time ?
088E            735       ; Copy current_time of x
088E 784B       736       mov  R0, #current_time
0890 7932       737       mov  R1, #x
0892 1208C5     738       lcall Copy4_Bytes_R0_to_R1
0895            739   
0895            740       ; Copy soak_time of y
0895 784F       741       mov  R0, #soak_time
0897 7936       742       mov  R1, #y
0899 1208C5     743       lcall Copy4_Bytes_R0_to_R1
089C            744   
089C            745       ; Compare elapsed time vs soak time
089C 12011A     746       lcall x_lt_y
089F 200002     747       jb   mf, Time_Soak_NotReached
08A2 D207       748       setb soak_time_reached
08A4            749   
08A4            750   ; Check: current_time >= reflow_time ?
08A4            751   Time_Soak_NotReached:
08A4            752       ; Copy current_time of x
08A4 784B       753       mov  R0, #current_time
08A6 7932       754       mov  R1, #x
08A8 1208C5     755       lcall Copy4_Bytes_R0_to_R1
08AB            756   
08AB            757       ; Copy reflow_time of y
08AB 7853       758       mov  R0, #reflow_time
08AD 7936       759       mov  R1, #y
08AF 1208C5     760       lcall Copy4_Bytes_R0_to_R1
08B2            761   
08B2            762       ; Compare elapsed time vs reflow time
08B2 12011A     763       lcall x_lt_y
08B5 200002     764       jb   mf, Time_Reflow_NotReached
08B8 D208       765       setb reflow_time_reached
08BA            766   
08BA            767   Time_Reflow_NotReached:
08BA D002       768       pop  AR2
08BC D001       769       pop  AR1
08BE D000       770       pop  AR0
08C0 D0D0       771       pop  psw
08C2 D0E0       772       pop  acc
08C4 22         773       ret
08C5            774   
08C5            775   ;-------------------------------------------------------------------------------;
08C5            776   ; Copy4_Bytes_R0_to_R1
08C5            777   ;
08C5            778   ; PURPOSE:
08C5            779   ;   Utility routine to copy a 32-bit value (4 bytes)
08C5            780   ;   from one memory location to another.
08C5            781   ;
08C5            782   ; INPUTS:
08C5            783   ;   R0 st source address
08C5            784   ;   R1 at destination address
08C5            785   ;
08C5            786   ; USES:
08C5            787   ;   R2 as loop counter
08C5            788   ;
08C5            789   ; EXAMPLE:
08C5            790   ;   mov R0, #current_temp
08C5            791   ;   mov R1, #x
08C5            792   ;   lcall Copy4_Bytes_R0_to_R1
08C5            793   ;-------------------------------------------------------------------------------;
08C5            794   Copy4_Bytes_R0_to_R1:
08C5 7A04       795       mov  R2, #4
08C7            796   Copy4_Loop:
08C7 E6         797       mov  a, @R0
08C8 F7         798       mov  @R1, a
08C9 08         799       inc  R0
08CA 09         800       inc  R1
08CB DAFA       801       djnz R2, Copy4_Loop
08CD 22         802       ret
08CE            803   
08CE            804   ;-------------------------------------------------------------------------------;
08CE            805   ; Abort condition safety check Temperature time
08CE            806   ;
08CE            807   ; PURPOSE:
08CE            808   ;   Automatic cycle termination on error:
08CE            809   ;   Abort if oven fails to reach at least 50C in first 60s.
08CE            810   ;
08CE            811   ; TRIP CONDITION:
08CE            812   ;   if (current_time >= 60s) AND (current_temp < 50C)
08CE            813   ;       -> set tc_missing_abort
08CE            814   ;       -> set stop_signal
08CE            815   ;
08CE            816   ; ASSUMPTIONS:
08CE            817   ;   - current_time is in SECONDS (32-bit, little-endian)
08CE            818   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
08CE            819   ;
08CE            820   ;   the Load_Y constants accordingly.
08CE            821   ;-------------------------------------------------------------------------------;
08CE            822   Safety_Check_TC:
08CE C0E0       823       push acc
08D0 C0D0       824       push psw
08D2 C000       825       push AR0
08D4 C001       826       push AR1
08D6 C002       827       push AR2
08D8            828   
08D8            829       ; If already aborted or startup window closed, do nothing
08D8 200F3D     830       jb   tc_missing_abort, Safety_TC_Done
08DB 30103A     831       jnb  tc_startup_window, Safety_TC_Done
08DE            832   
08DE            833       ; Check: current_time >= 60 ?
08DE 784B       834       mov  R0, #current_time
08E0 7932       835       mov  R1, #x
08E2 1208C5     836       lcall Copy4_Bytes_R0_to_R1
08E5            837   
08E5 75363C     838            mov y+0, #low (60 % 0x10000) 
08E8 753700     838            mov y+1, #high(60 % 0x10000) 
08EB 753800     838            mov y+2, #low (60 / 0x10000) 
08EE 753900     838            mov y+3, #high(60 / 0x10000) 
08F1 12011A     839       lcall x_lt_y
08F4 200021     840       jb   mf, Safety_TC_Done        ; still < 60s  keep waiting
08F7            841   
08F7            842       ; We reached 60s: close the startup window so it won't re-check later
08F7 C210       843       clr  tc_startup_window
08F9            844   
08F9            845       ; Now check: current_temp < 50 ?
08F9 783F       846       mov  R0, #current_temp
08FB 7932       847       mov  R1, #x
08FD 1208C5     848       lcall Copy4_Bytes_R0_to_R1
0900            849   
0900 753632     850            mov y+0, #low (50 % 0x10000) 
0903 753700     850            mov y+1, #high(50 % 0x10000) 
0906 753800     850            mov y+2, #low (50 / 0x10000) 
0909 753900     850            mov y+3, #high(50 / 0x10000) 
090C 12011A     851       lcall x_lt_y
090F 300006     852       jnb  mf, Safety_TC_Done        ; temp >= 50  pass
0912            853   
0912            854       ; FAIL: at 60s, still below 50C  abort
0912 D20F       855       setb tc_missing_abort
0914 D20A       856       setb stop_signal
0916 C293       857       clr  PWM_OUT
0918            858   
0918            859   Safety_TC_Done:
0918 D002       860       pop  AR2
091A D001       861       pop  AR1
091C D000       862       pop  AR0
091E D0D0       863       pop  psw
0920 D0E0       864       pop  acc
0922 22         865       ret
0923            866   
0923            867   ;-------------------------------------------------------------------------------;
0923            868   ; Main Control FSM for the entire process
0923            869   ;-------------------------------------------------------------------------------;
0923            870   Control_FSM:
0923 E563       871            mov a, Control_FSM_state
0925 8005       872            sjmp Control_FSM_state0
0927            873   
0927            874   Control_FSM_state0_a:
0927 756300     875            mov Control_FSM_state, #0
092A D20D       876            setb state_change_signal
092C            877   Control_FSM_state0:
092C B40009     878            cjne a, #0, Control_FSM_state1
092F 101102     879            jbc PB0_flag, Control_FSM_state1_a
0932 8065       880            sjmp Control_FSM_done
0934            881   
0934            882   Control_FSM_state1_a:
0934 0563       883            inc Control_FSM_state
0936 D20D       884            setb state_change_signal
0938            885   Control_FSM_state1:
0938 B4010E     886            cjne a, #1, Control_FSM_state2
093B 101202     887            jbc PB1_flag, Control_FSM_state1_b
093E 8059       888            sjmp Control_FSM_done
0940            889   Control_FSM_state1_b:
0940 100C02     890            jbc config_finish_signal, Control_FSM_state2_a
0943 8054       891            sjmp Control_FSM_done
0945            892   
0945            893   Control_FSM_state2_a:
0945 0563       894            inc Control_FSM_state
0947 D20D       895            setb state_change_signal
0949            896   Control_FSM_state2:
0949 B4020C     897            cjne a, #2, Control_FSM_state3
094C 101332     898            jbc PB2_flag, Control_FSM_state6_a
094F 100402     899            jbc soak_temp_reached, Control_FSM_state3_a
0952 8045       900            sjmp Control_FSM_done
0954            901   
0954            902   Control_FSM_state3_a:
0954 0563       903            inc Control_FSM_state
0956 D20D       904            setb state_change_signal
0958            905   Control_FSM_state3:
0958 B4030C     906            cjne a, #3, Control_FSM_state4
095B 101323     907            jbc PB2_flag, Control_FSM_state6_a
095E 100702     908            jbc soak_time_reached, Control_FSM_state4_a
0961 8036       909            sjmp Control_FSM_done
0963            910   
0963            911   Control_FSM_state4_a:
0963 0563       912            inc Control_FSM_state   
0965 D20D       913            setb state_change_signal
0967            914   Control_FSM_state4:
0967 B4040C     915            cjne a, #4, Control_FSM_state5
096A 101314     916            jbc PB2_flag, Control_FSM_state6_a
096D 100502     917            jbc reflow_temp_reached, Control_FSM_state5_a
0970 8027       918            sjmp Control_FSM_done
0972            919   
0972            920   Control_FSM_state5_a:
0972 0563       921            inc Control_FSM_state
0974 D20D       922            setb state_change_signal
0976            923   Control_FSM_state5:
0976 B4050C     924            cjne a, #5, Control_FSM_state6
0979 101305     925            jbc PB2_flag, Control_FSM_state6_a
097C 100802     926            jbc reflow_time_reached, Control_FSM_state6_a
097F 8018       927            sjmp Control_FSM_done
0981            928   
0981            929   Control_FSM_state6_a:
0981 0563       930            inc Control_FSM_state
0983 D20D       931            setb state_change_signal
0985            932   Control_FSM_state6:
0985 B40611     933            cjne a, #6, Control_FSM_done
0988 100602     934            jbc cooling_temp_reached, Control_FSM_state7_a
098B 800C       935            sjmp Control_FSM_done
098D            936   
098D            937   Control_FSM_state7_a:
098D 0563       938            inc Control_FSM_state
098F D20D       939            setb state_change_signal
0991            940   Control_FSM_state7:
0991 B40705     941            cjne a, #7, Control_FSM_done
0994 101190     942            jbc PB0_flag, Control_FSM_state0_a
0997 8000       943            sjmp Control_FSM_done
0999            944   
0999            945   Control_FSM_done:
0999 22         946            ret
099A            947   ;-------------------------------------------------------------------------------;
099A            948   ;         Main program.          
099A            949   ;-------------------------------------------------------------------------------;
099A            950   main:
099A            951            ; Initialization
099A 75817F     952       mov SP, #0x7F
099D            953   
099D            954            ; We use the pins of P0 to control the LCD.  Configure as outputs.
099D 759A7F     955       mov P0MOD, #01111111b ; P0.0 to P0.6 are outputs.  ('1' makes the pin output)
09A0            956       ; We use pins P1.5 and P1.1 as outputs also.  Configure accordingly.
09A0 759B3A     957       mov P1MOD, #00111010b ; P1.5 and P1.1 are outputs
09A3 759CFF     958       mov P2MOD, #0xff
09A6 759DFF     959       mov P3MOD, #0xff
09A9            960       ; Turn off all the LEDs
09A9 75E800     961       mov LEDRA, #0 ; LEDRA is bit addressable
09AC 759500     962       mov LEDRB, #0 ; LEDRB is NOT bit addresable
09AF            963   
09AF            964            ; Enable Global interrupts
09AF D2AF       965       setb EA  
09B1            966   
09B1            967            ; FSM initial states
09B1 756100     968            mov KEY1_DEB_state, #0
09B4 756200     969            mov SEC_FSM_state, #0
09B7 756300     970            mov Control_FSM_state, #0
09BA            971            ; FSM timers initialization
09BA 755F00     972            mov KEY1_DEB_timer, #0
09BD 756000     973            mov SEC_FSM_timer, #0
09C0            974            ; time counters initialization
09C0 753000     975            mov current_time_sec, #0
09C3 753100     976            mov current_time_minute, #0
09C6            977            ; Initialize counter to zero
09C6 755B00     978       mov pwm_counter, #0
09C9 755C00     979            mov pwm_counter+1, #0
09CC 755D00     980            mov pwm_counter+2, #0
09CF 755E00     981            mov pwm_counter+3, #0
09D2            982            ; Initialize power output
09D2 755A00     983            mov power_output+3, #0
09D5 755900     984            mov power_output+2, #0
09D8 755802     985            mov power_output+1, #02H
09DB 7557EE     986            mov power_output, #0EEH ; (initilize to 750 for testing)
09DE            987   
09DE            988            ; Clear all the flags
09DE C20F       989            clr  tc_missing_abort
09E0 C20A       990            clr  stop_signal
09E2 C211       991            clr PB0_flag
09E4 C212       992            clr PB1_flag
09E6 C213       993            clr PB2_flag
09E8 C201       994            clr one_second_flag
09EA C20C       995            clr config_finish_signal
09EC C204       996            clr soak_temp_reached
09EE C207       997            clr soak_time_reached
09F0 C205       998            clr reflow_temp_reached
09F2 C208       999            clr reflow_time_reached
09F4 C206      1000            clr cooling_temp_reached
09F6 C20D      1001            clr state_change_signal
09F8           1002   
09F8           1003            ; Set bit
09F8 D210      1004            setb tc_startup_window
09FA           1005   
09FA 120401    1006            lcall Timer0_Init
09FD 12046B    1007       lcall Timer2_Init
0A00 1204EE    1008            lcall ELCD_4BIT
0A03 12041D    1009            lcall Initialize_Serial_Port
0A06           1010   ;-------------------------------------------------------------------------------;
0A06           1011   ; while(1) loop
0A06           1012   ;-------------------------------------------------------------------------------;
0A06           1013   loop:
0A06           1014            ; Check the FSM for KEY1 debounce
0A06 1206D7    1015            lcall KEY1_DEB
0A09           1016   
0A09           1017            ; Check the FSM for one second counter
0A09 12070D    1018            lcall SEC_FSM
0A0C           1019   
0A0C           1020            ; Check the FSM for the overall control flow of the reflow process
0A0C 120923    1021            lcall Control_FSM
0A0F           1022   
0A0F           1023            ; Update the LCD display based on the current state
0A0F 12059E    1024            lcall LCD_Display_Update_func
0A12           1025   
0A12           1026            ; Update the pwm output for the ssr
0A12 12075F    1027            lcall PWM_Wave 
0A15           1028   
0A15           1029            ; Update the pwm output for the servo
0A15 1207D6    1030            lcall call_servo_control
0A18           1031   
0A18           1032            ; After initialization the program stays in this 'forever' loop
0A18 020A06    1033            ljmp loop
0A1B           1034   ;-------------------------------------------------------------------------------;
0A1B           1035   
0A1B           1036   END
>>>>>>> main
