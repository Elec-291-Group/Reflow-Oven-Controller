0000              1   ; Project 1
0000              2   ; CV-8052 microcontroller in DE10-Lite board
0000              3   ;-------------------------------------------------------------------------------
0000              4   ; Reset vector
0000              5   org 0x0000
0000 0216E0       6       ljmp main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9       reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 02046E      12       ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15       reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18       reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 32          21       reti
0024             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
002B 0206BC      24       ljmp Timer2_ISR
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 32   $LIST
0320             34   ; ----------------------------------------------------------------------------------------------;
0320             35   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             36   dseg at 0x30
0030             37   ; time buffer 
0030             38   current_time_sec:     ds 1
0031             39   current_time_minute:  ds 1
0032             40   soak_time_sec:        ds 1
0033             41   soak_time_minute:     ds 1
0034             42   reflow_time_sec:      ds 1
0035             43   reflow_time_minute:   ds 1
0036             44   soak_end_time_sec:      ds 1
0037             45   soak_end_time_minute:   ds 1
0038             46   reflow_end_time_sec:    ds 1
0039             47   reflow_end_time_minute: ds 1
003A             48   
003A             49   ; math32 buffer variables
003A             50   x:      ds  4
003E             51   y:      ds  4
0042             52   bcd:    ds  5
0047             53   
0047             54   current_temp: ds 4 ;
004B             55   soak_temp:    ds 4 ;
004F             56   reflow_temp:  ds 4 ;
0053             57   
0053             58   wait25_btn_cnt:    ds 1
0054             59   wait25_keypad_cnt: ds 1
0055             60   wait25_adc_cnt:    ds 1
0056             61   wait25_lcd_cnt:    ds 1
0057             62   wait25_count:      ds 1
0058             63   
0058             64   power_output:  ds 4 ;
005C             65   pwm_counter:   ds 4 ; counter for pwm (0-1500_timer: ds 1
0060             66   
0060             67   Control_FSM_state: ds 1 
0061             68   Current_State:     ds 1
0062             69   
0062             70   soak_temp_diff: ds 4 ; temperature difference between target soak temp and current oven temp 
0066             71   proportional_gain_var: ds 4 ; power gain calculated from the proportional block
006A             72   
006A             73   ;-- UI buffers I added (ayaan)
006A             74   Cursor_Idx: ds 1
006B             75   
006B             76   ; Buzzer module variables
006B             77   buzz_state:      ds 1   ; 0=IDLE, 1=ON, 2=OFF
006C             78   buzz_timer:      ds 1   ; counts ms within ON/OFF window
006D             79   buzz_beeps_left: ds 1   ; how many beeps remaining
006E             80   buzz_priority:   ds 1   ; 0 none, 1=state, 2=done, 3=error
006F             81   
006F             82   SEC_FSM_timer: ds 1
0070             83   SEC_FSM_state: ds 1
0071             84   ; Push buttons for globel interrupt 
0071             85   PB0_DEB_timer:  ds 1
0072             86   PB0_DEB_state:  ds 1
0073             87   PB2_DEB_timer:  ds 1
0074             88   PB2_DEB_state:  ds 1
0075             89   
0075             90   ; Buzzer state
0075             91   beep_count:  ds 1      ; remaining beeps
0076             92   beep_state:  ds 1      ; 0=idle, 1=ON, 2=OFF
0077             93   beep_tmr:    ds 2      ; 16-bit ms timer (needs to reach 500)
0079             94   
0079             95   servo_pwm_counter: ds 1 ; counter for the servo pwm signal
007A             96   ; In your data section
007A             97   BTN_DEB_state: ds 1
007B             98   BTN_DEB_timer: ds 1
007C             99   BTN_DEB_id:    ds 1
007D            100   
007D            101   ; UART RX state (polling)
007D            102   rx_idx:    ds 1
007E            103   rx_ready:  ds 1
007F            104   ; 79
007F            105   
0080            106   iseg at 0x80
0080            107   Buf_Soak_Temp: ds 4   
0084            108   Buf_Soak_Time: ds 5   
0089            109   Buf_Refl_Temp: ds 4   
008D            110   Buf_Refl_Time: ds 5
0092            111   
0092            112   ; UART RX line buffer (polling) in upper RAM
0092            113   rx_buf:        ds 40    ; null-terminated command line
00BA            114   ; 
00BA            115   ;-------------------------------------------------------------------------------
00BA            116   ; bit operation setb, clr, jb, and jnb
0000            117   bseg
0000            118   mf:     dbit 1 ; math32 sign
0001            119   one_second_flag: dbit 1
0002            120   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003            121   one_ms_buzz_flag: dbit 1 ; one_millisecond_flag for buzz
0004            122   one_second_lcd_flag: dbit 1
0005            123   
0005            124   soak_temp_reached: dbit 1
0006            125   reflow_temp_reached: dbit 1
0007            126   cooling_temp_reached: dbit 1
0008            127   
0008            128   soak_time_reached: dbit 1
0009            129   reflow_time_reached: dbit 1
000A            130   
000A            131   reset_signal: dbit 1
000B            132   stop_signal: dbit 1
000C            133   start_signal_count: dbit 1
000D            134   time_count_doing_signal: dbit 1
000E            135   config_finish_signal: dbit 1
000F            136   
000F            137   state_change_signal: dbit 1
0010            138   state_change_signal_TC: dbit 1
0011            139   state_change_signal_Count: dbit 1
0012            140   state_change_beep_signal: dbit 1
0013            141   
0013            142   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
0014            143   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0015            144   
0015            145   PB0_flag: dbit 1 ; start entire program
0016            146   PB1_flag: dbit 1 ; start soak
0017            147   PB2_flag: dbit 1 ; pause process
0018            148   
0018            149   ;buzzer beep
0018            150   one_ms_beep_flag: dbit 1
0019            151   beep_error_done: dbit 1
001A            152   
001A            153   ; BSEG (Bit Segment)
001A            154   wait25_active: dbit 1 ; 1 = We are currently waiting
001B            155   wait25_done:   dbit 1 ; 1 = The 25ms has finished
001C            156   wait25_btn_active:    dbit 1
001D            157   wait25_btn_done:      dbit 1
001E            158   wait25_keypad_active: dbit 1
001F            159   wait25_keypad_done:   dbit 1
0020            160   wait25_adc_active:    dbit 1
0021            161   wait25_adc_done:      dbit 1
0022            162   wait25_lcd_active:    dbit 1
0023            163   wait25_lcd_done:      dbit 1
0024            164   
0024            165   fullscreen_update_signal: dbit 1
0025            166   
0025            167   one_second_flag_test: dbit 1
0026            168   one_millisecond_flag_servo: dbit 1 ; set the one millsiecond flag for servo pwm signal generation
0027            169   
0027            170   servo_angle_zero: dbit 1 ; flag for indicating whether the servo angle should be at 0 or not: 1 -> 0; 0 -> 180
0028            171   soak_temp_greater: dbit 1 ; target soak_temp greater than current_temp
0029            172   
0029            173   remote_config_mode: dbit 1
002A            174   ; 40 bits used
002A            175   
002A            176   ;-------------------------------------------------------------------------------
0320            177   cseg
0320            178   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            179   BAUD           EQU 57600
0320            180   
0320            181   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            182   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            183   ; is always 12 unlike the N76E003 where is selectable.
0320            184   
0320            185   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            186   
0320            187   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            188   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            189   
0320            190   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            191   
0320            192   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            193   BEEP_ON_MS          EQU 100  ; 100ms
0320            194   BEEP_OFF_MS    EQU 100  ; 100ms
0320            195   
0320            196   PWM_OUT        EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            197   
0320            198   ; These 'equ' must match the wiring between the DE10Lite board and the LCD
0320            199   ; P0 is in connector JPIO.
0320            200   ;Added correct I/O definitions
0320            201   ;-- LCD Pins ---
0320            202   ELCD_RS equ P1.7
0320            203   ELCD_E  equ P1.1
0320            204   ELCD_D4 equ P0.7
0320            205   ELCD_D5 equ P0.5
0320            206   ELCD_D6 equ P0.3
0320            207   ELCD_D7 equ P0.1
0320            208   
0320            209   ; -- Buttons --
0320            210   BTN_SOAK_TEMP equ P0.0
0320            211   BTN_SOAK_TIME equ P0.2
0320            212   BTN_REFL_TEMP equ P0.4
0320            213   BTN_REFL_TIME equ P0.6
0320            214   PB0                equ P1.0
0320            215   PB2                equ P3.7
0320            216   
0320            217   ; --- PB0PAD ---
0320            218   ROW1 equ P1.2
0320            219   ROW2 equ P1.4
0320            220   ROW3 equ P1.6
0320            221   ROW4 equ P2.0
0320            222   COL1 equ P2.2
0320            223   COL2 equ P2.4
0320            224   COL3 equ P2.6
0320            225   COL4 equ P3.0
0320            226   
0320            227   DC_OUT         EQU P4.0
0320            228   SERVO_OUT      EQU p3.6 ; servo pin
0320            229   LED_LEFT       EQU P3.4 ; left LED (PB3.4)
0320            230   LED_MID        EQU P3.3 ; middle LED (PB3.3)
0320            231   LED_RIGHT      EQU P3.2 ; right LED (PB3.2)
0320            232   
0320            233   SERVO_PERIOD   EQU 20 ; pwm signal period for the servo motor (20 ms)
0320            234   SERVO_0        EQU 1 ; pwm high time for the servo motor to stay at 0 degree
0320            235   SERVO_180      EQU 2 ; pwm high time for the servo motor to stay at 180 degrees
0320            236   
0320            237   COLD_JUNCTION_TEMP equ 20
0320            238   MAX_POWER           EQU 1500 ; max oven power
0320            239   NO_POWER            EQU 0    ; no power
0320            240   BASE_POWER     EQU (MAX_POWER/5) ; 20% base power for state 2, 4
0320            241   HALF_POWER     EQU (MAX_POWER/2) ; 50% power indicator
0320            242   KP                          EQU 5 ; proportional gain
0320            243   
0320            244   ;1234567890123456 <-- 16 characters per line LCD
0320 696E6974   245   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   246   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   247   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            248   
0350            249   ; --- UI STRINGS (REQUIRED FOR PB0PAD LOGIC), <- I can fix if duplicates
0350 53656C65   250   Txt_Home:     db 'Select Mode:    ', 0
     6374204D
     6F64653A
     20202020
     00
0361 53657420   251   Txt_SoakT:    db 'Set Soak Temp   ', 0
     536F616B
     2054656D
     70202020
     00
0372 53657420   252   Txt_SoakTime: db 'Set Soak Time   ', 0
     536F616B
     2054696D
     65202020
     00
0383 53657420   253   Txt_ReflT:    db 'Set Reflow Temp ', 0
     5265666C
     6F772054
     656D7020
     00
0394 53657420   254   Txt_ReflTime: db 'Set Reflow Time ', 0
     5265666C
     6F772054
     696D6520
     00
03A5            255   
03A5            256   ; 1234567890123456
03A5 53657420   257   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
03B5 536F616B   258   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
03C0 5265666C   259   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
03CD 536F616B   260   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
03D8 5265666C   261   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03E5            262   
03E5 54656D70   263   String_temp_line:  db 'Temp: ', 0
     3A2000
03EC            264   
03EC            265   ; 1234567890123456
03EC 52616D70   266   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03FC 536F616B   267   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
040C 52616D70   268   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
041C 5265666C   269   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
042C 436F6F6C   270   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
043C 50726F63   271   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
044C            272   
044C 20202020   273   String_Blank:    db '                ', 0
     20202020
     20202020
     20202020
     00
045D            274   
045D            275   ;-------------------------------------------------------------------------------
045D            276   ; Timers Setting:
045D            277   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
045D            278   ;   Timer 1: Serial port baud rate 57600 generator
045D            279   ;   Timer 2: 1ms interrupt for BCD counter increment/decrement
045D            280   ;-------------------------------------------------------------------------------
045D            281   ; Routine to initialize the ISR for Timer 0 ;
045D            282   Timer0_Init:
045D E589       283       mov a, TMOD
045F 54F0       284       anl a, #0xf0 ; Clear the bits for timer 0
0461 4401       285       orl a, #0x01 ; Configure timer 0 as 16-timer
0463 F589       286       mov TMOD, a
0465 758CFD     287       mov TH0, #high(TIMER0_RELOAD)
0468 758A5A     288       mov TL0, #low(TIMER0_RELOAD)
046B            289       ; Enable the timer and interrupts
046B D2A9       290       setb ET0  ; Enable timer 0 interrupt
046D            291       ; setb TR0  (no need to open at first)
046D 22         292       ret
046E            293   ; ISR for timer 0.  Set to execute every 1/4096Hz 
046E            294   ; to generate a 2048 Hz square wave at pin P1.5 
046E            295   Timer0_ISR:
046E            296       ;clr TF0  ; According to the data sheet this is done for us already.
046E 758CFD     297       mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
0471 758A5A     298       mov TL0, #low(TIMER0_RELOAD)
0474 B295       299       cpl SOUND_OUT ; Connect speaker to P1.5
0476 32         300       reti
0477            301   ; -----------------------------------------------------------------------------------------------;
0477            302   
0477            303   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
0477            304   Initialize_Serial_Port:
0477            305       ; Configure serial port and baud rate
0477 C28E       306       clr TR1 ; Disable timer 1
0479 53890F     307       anl TMOD, #0x0f ; Mask the bits for timer 1
047C 438920     308       orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
047F 438780     309       orl PCON, #80H ; Set SMOD to 1
0482 758DFD     310       mov TH1, #low(TIMER_1_RELOAD)
0485 758BFD     311       mov TL1, #low(TIMER_1_RELOAD) 
0488 D28E       312       setb TR1 ; Enable timer 1
048A 759852     313       mov SCON, #52H
048D 22         314       ret
048E            315   
048E            316   ; uart sending functions
048E            317   putchar:
048E 109902     318       jbc TI, putchar_L1
0491 80FB       319       sjmp putchar
0493            320   putchar_L1:
0493 F599       321       mov SBUF,a
0495 22         322       ret
0496            323   
0496            324   SendString:
0496 E4         325       clr a
0497 93         326       movc a, @a+dptr
0498 6006       327       jz SendString_L1
049A 12048E     328       lcall putchar
049D A3         329       inc dptr
049E 80F6       330       sjmp SendString  
04A0            331   SendString_L1:
04A0 22         332       ret
04A1            333   
04A1            334   ;------------------------------------------------------------
04A1            335   ; getchar_nb (non-blocking)
04A1            336   ; OUT: C=1 if got byte, A=byte
04A1            337   ;      C=0 if none
04A1            338   ;------------------------------------------------------------
04A1            339   getchar_nb:
04A1 309806     340       jnb RI, rx_none
04A4 E599       341       mov A, SBUF
04A6 C298       342       clr RI
04A8 D3         343       setb C
04A9 22         344       ret
04AA            345   rx_none:
04AA C3         346       clr C
04AB 22         347       ret
04AC            348   ;------------------------------------------------------------
04AC            349   ; Serial_RX_Pump
04AC            350   ; Builds a null-terminated line in rx_buf.
04AC            351   ; Sets rx_ready=1 when a full line received.
04AC            352   ;------------------------------------------------------------
04AC            353   Serial_RX_Pump:
04AC E57E       354       mov A, rx_ready
04AE 7034       355       jnz rxp_done          ; don't overwrite unprocessed line
04B0            356   
04B0            357   rxp_more:
04B0 1204A1     358       lcall getchar_nb
04B3 502F       359       jnc rxp_done          ; no new byte
04B5 F5F0       360       mov B, A              ; save received byte
04B7            361   
04B7            362       ; ignore CR
04B7 B40D02     363       cjne A, #0DH, rxp_not_cr
04BA 80F4       364       sjmp rxp_more
04BC            365   
04BC            366   rxp_not_cr:
04BC            367       ; if LF -> finish line
04BC B40A0F     368       cjne A, #0AH, rxp_store
04BF            369   
04BF            370       ; terminate string
04BF E57D       371       mov A, rx_idx
04C1 2492       372       add A, #rx_buf
04C3 F8         373       mov R0, A
04C4 7600       374       mov @R0, #0
04C6 757E01     375       mov rx_ready, #1
04C9 757D00     376       mov rx_idx, #0
04CC 8016       377       sjmp rxp_done
04CE            378   
04CE            379   rxp_store:
04CE            380       ; store char if room (max 39 chars)
04CE E57D       381       mov A, rx_idx
04D0 B42705     382       cjne A, #39, rxp_ok
04D3 757D00     383       mov rx_idx, #0        ; overflow: reset
04D6 800C       384       sjmp rxp_done
04D8            385   
04D8            386   rxp_ok:
04D8 E57D       387       mov A, rx_idx
04DA 2492       388       add A, #rx_buf
04DC F8         389       mov R0, A
04DD E5F0       390       mov A, B
04DF F6         391       mov @R0, A
04E0 057D       392       inc rx_idx
04E2 80CC       393       sjmp rxp_more
04E4            394   
04E4            395   rxp_done:
04E4 22         396       ret
04E5            397   ; copies 3 ASCII digits to buffer at R1, null terminates
04E5            398   ; R0 = src (first digit), R1 = dst
04E5            399   Copy3DigitsToBuf:
04E5 E6         400       mov A, @R0
04E6 F7         401       mov @R1, A
04E7 08         402       inc R0
04E8 09         403       inc R1
04E9 E6         404       mov A, @R0
04EA F7         405       mov @R1, A
04EB 08         406       inc R0
04EC 09         407       inc R1
04ED E6         408       mov A, @R0
04EE F7         409       mov @R1, A
04EF 09         410       inc R1
04F0 7700       411       mov @R1, #0
04F2 22         412       ret
04F3            413   
04F3            414   ; copies 4 ASCII digits to buffer at R1, null terminates
04F3            415   Copy4DigitsToBuf:
04F3 E6         416       mov A, @R0
04F4 F7         417       mov @R1, A
04F5 08         418       inc R0
04F6 09         419       inc R1
04F7 E6         420       mov A, @R0
04F8 F7         421       mov @R1, A
04F9 08         422       inc R0
04FA 09         423       inc R1
04FB E6         424       mov A, @R0
04FC F7         425       mov @R1, A
04FD 08         426       inc R0
04FE 09         427       inc R1
04FF E6         428       mov A, @R0
0500 F7         429       mov @R1, A
0501 09         430       inc R1
0502 7700       431       mov @R1, #0
0504 22         432       ret
0505            433   
0505            434   ;------------------------------------------------------------
0505            435   ; Serial_Process_Line
0505            436   ; Handles: UI:REMOTE, RUN:0/1, S:TTT, K:MMSS, R:TTT, L:MMSS, 
0505            437   ;          CFG:APPLY, CFG {json}, SAVE:1
0505            438   ;------------------------------------------------------------
0505            439   Serial_Process_Line:
0505 E57E       440       mov A, rx_ready
0507 7001       441       jnz SPL_HAVE
0509 22         442       ret
050A            443   SPL_HAVE:
050A 757E00     444       mov rx_ready, #0
050D 7892       445       mov R0, #rx_buf
050F E6         446       mov A, @R0
0510            447   
0510            448       ; Branch by first character (with trampolines for distance)
0510 B45502     449       cjne A, #'U', SPL_not_U
0513 801C       450       sjmp do_chk_UI_REMOTE
0515            451   SPL_not_U:
0515 B45202     452       cjne A, #'R', SPL_not_R
0518 801A       453       sjmp do_chk_R_commands
051A            454   SPL_not_R:
051A B45302     455       cjne A, #'S', SPL_not_S
051D 8018       456       sjmp do_chk_S_commands
051F            457   SPL_not_S:
051F B44B02     458       cjne A, #'K', SPL_not_K
0522 8016       459       sjmp do_chk_K
0524            460   SPL_not_K:
0524 B44C02     461       cjne A, #'L', SPL_not_L
0527 8014       462       sjmp do_chk_L
0529            463   SPL_not_L:
0529 B44302     464       cjne A, #'C', SPL_not_C
052C 8012       465       sjmp do_chk_CFG_commands
052E            466   SPL_not_C:
052E 02062E     467       ljmp spl_done
0531            468   
0531            469   ; --- Trampolines ---
0531            470   do_chk_UI_REMOTE:
0531 020543     471       ljmp chk_UI_REMOTE
0534            472   do_chk_R_commands:
0534 02055D     473       ljmp chk_R_commands
0537            474   do_chk_S_commands:
0537 020597     475       ljmp chk_S_commands
053A            476   do_chk_K:
053A 0205CB     477       ljmp chk_K
053D            478   do_chk_L:
053D 0205DD     479       ljmp chk_L
0540            480   do_chk_CFG_commands:
0540 0205EF     481       ljmp chk_CFG_commands
0543            482   
0543            483   ;------------------------------------------------------------
0543            484   ; UI:REMOTE - Switch to remote control mode
0543            485   ;------------------------------------------------------------
0543            486   chk_UI_REMOTE:
0543 7892       487       mov R0, #rx_buf
0545 E6         488       mov A, @R0
0546 B45511     489       cjne A, #'U', spl_done_bridge1
0549 08         490       inc R0
054A E6         491       mov A, @R0
054B B4490C     492       cjne A, #'I', spl_done_bridge1
054E 08         493       inc R0
054F E6         494       mov A, @R0
0550 B43A07     495       cjne A, #':', spl_done_bridge1
0553 08         496       inc R0
0554 E6         497       mov A, @R0
0555 B45202     498       cjne A, #'R', spl_done_bridge1
0558            499       ; Good enough - it's UI:R...
0558 8000       500       sjmp spl_done_bridge1
055A            501   
055A            502   spl_done_bridge1:
055A 02062E     503       ljmp spl_done
055D            504   
055D            505   ;------------------------------------------------------------
055D            506   ; R commands: R:TTT (reflow temp) or RUN:0/1
055D            507   ;------------------------------------------------------------
055D            508   chk_R_commands:
055D 7892       509       mov R0, #rx_buf
055F 08         510       inc R0                     ; Point to second char
0560 E6         511       mov A, @R0
0561 B43A08     512       cjne A, #':', chk_RUN_jump ; If not ':', check for RUN
0564            513       ; It's "R:" - Reflow temperature
0564 08         514       inc R0
0565 7989       515       mov R1, #Buf_Refl_Temp
0567 1204E5     516       lcall Copy3DigitsToBuf
056A 8002       517       sjmp spl_done_bridge2
056C            518   
056C            519   chk_RUN_jump:
056C 8003       520       sjmp chk_RUN
056E            521   
056E            522   spl_done_bridge2:
056E 02062E     523       ljmp spl_done
0571            524   
0571            525   chk_RUN:
0571            526       ; Check for "RUN:"
0571 7892       527       mov R0, #rx_buf
0573 08         528       inc R0
0574 E6         529       mov A, @R0
0575 B4551C     530       cjne A, #'U', spl_done_bridge3
0578 08         531       inc R0
0579 E6         532       mov A, @R0
057A B44E17     533       cjne A, #'N', spl_done_bridge3
057D 08         534       inc R0
057E E6         535       mov A, @R0
057F B43A12     536       cjne A, #':', spl_done_bridge3
0582 08         537       inc R0
0583 E6         538       mov A, @R0
0584            539       
0584            540       ; Check for '1' or '0'
0584 B43105     541       cjne A, #'1', chk_RUN_zero
0587            542       
0587            543       ; RUN:1 - Start the process
0587 020EA4     544       ljmp Control_FSM_state2_a
058A 8008       545       sjmp spl_done_bridge3
058C            546   
058C            547   chk_RUN_zero:
058C B43005     548       cjne A, #'0', spl_done_bridge3
058F            549       ; RUN:0 - Stop the process
058F 020E77     550       ljmp Control_FSM_state0_a
0592 8000       551       sjmp spl_done_bridge3
0594            552   
0594            553   spl_done_bridge3:
0594 02062E     554       ljmp spl_done
0597            555   
0597            556   ;------------------------------------------------------------
0597            557   ; S commands: S:TTT (soak temp) or SAVE:1
0597            558   ;------------------------------------------------------------
0597            559   chk_S_commands:
0597 7892       560       mov R0, #rx_buf
0599 08         561       inc R0                     ; Point to second char
059A E6         562       mov A, @R0
059B B43A08     563       cjne A, #':', chk_SAVE_jump
059E            564       ; It's "S:" - Soak temperature
059E 08         565       inc R0
059F 7980       566       mov R1, #Buf_Soak_Temp
05A1 1204E5     567       lcall Copy3DigitsToBuf
05A4 8002       568       sjmp spl_done_bridge4
05A6            569   
05A6            570   chk_SAVE_jump:
05A6 8003       571       sjmp chk_SAVE
05A8            572   
05A8            573   spl_done_bridge4:
05A8 02062E     574       ljmp spl_done
05AB            575   
05AB            576   chk_SAVE:
05AB            577       ; Check for "SAVE:"
05AB 7892       578       mov R0, #rx_buf
05AD 08         579       inc R0
05AE E6         580       mov A, @R0
05AF B44116     581       cjne A, #'A', spl_done_bridge5
05B2 08         582       inc R0
05B3 E6         583       mov A, @R0
05B4 B45611     584       cjne A, #'V', spl_done_bridge5
05B7 08         585       inc R0
05B8 E6         586       mov A, @R0
05B9 B4450C     587       cjne A, #'E', spl_done_bridge5
05BC 08         588       inc R0
05BD E6         589       mov A, @R0
05BE B43A07     590       cjne A, #':', spl_done_bridge5
05C1 08         591       inc R0
05C2 E6         592       mov A, @R0
05C3 B43102     593       cjne A, #'1', spl_done_bridge5
05C6            594       
05C6            595       ; SAVE:1 - Save to non-volatile memory (stub)
05C6 8000       596       sjmp spl_done_bridge5
05C8            597   
05C8            598   spl_done_bridge5:
05C8 02062E     599       ljmp spl_done
05CB            600   
05CB            601   ;------------------------------------------------------------
05CB            602   ; K:MMSS - Soak time
05CB            603   ;------------------------------------------------------------
05CB            604   chk_K:
05CB 7892       605       mov R0, #rx_buf
05CD 08         606       inc R0
05CE E6         607       mov A, @R0
05CF B43A08     608       cjne A, #':', spl_done_bridge6
05D2 08         609       inc R0
05D3 7984       610       mov R1, #Buf_Soak_Time
05D5 1204F3     611       lcall Copy4DigitsToBuf
05D8 8000       612       sjmp spl_done_bridge6
05DA            613   
05DA            614   spl_done_bridge6:
05DA 02062E     615       ljmp spl_done
05DD            616   
05DD            617   ;------------------------------------------------------------
05DD            618   ; L:MMSS - Reflow time
05DD            619   ;------------------------------------------------------------
05DD            620   chk_L:
05DD 7892       621       mov R0, #rx_buf
05DF 08         622       inc R0
05E0 E6         623       mov A, @R0
05E1 B43A08     624       cjne A, #':', spl_done_bridge7
05E4 08         625       inc R0
05E5 798D       626       mov R1, #Buf_Refl_Time
05E7 1204F3     627       lcall Copy4DigitsToBuf
05EA 8000       628       sjmp spl_done_bridge7
05EC            629   
05EC            630   spl_done_bridge7:
05EC 02062E     631       ljmp spl_done
05EF            632   
05EF            633   ;------------------------------------------------------------
05EF            634   ; CFG commands: CFG:APPLY or CFG {json}
05EF            635   ;------------------------------------------------------------
05EF            636   chk_CFG_commands:
05EF 7892       637       mov R0, #rx_buf
05F1 E6         638       mov A, @R0
05F2 B44336     639       cjne A, #'C', spl_done_bridge8
05F5 08         640       inc R0
05F6 E6         641       mov A, @R0
05F7 B44631     642       cjne A, #'F', spl_done_bridge8
05FA 08         643       inc R0
05FB E6         644       mov A, @R0
05FC B4472C     645       cjne A, #'G', spl_done_bridge8
05FF 08         646       inc R0
0600 E6         647       mov A, @R0
0601            648       
0601            649       ; Check if ':' (CFG:APPLY) or ' ' (CFG {json})
0601 B43A22     650       cjne A, #':', chk_CFG_json
0604            651       
0604            652       ; It's "CFG:" - check for APPLY
0604 08         653       inc R0
0605 E6         654       mov A, @R0
0606 B44122     655       cjne A, #'A', spl_done_bridge8
0609 08         656       inc R0
060A E6         657       mov A, @R0
060B B4501D     658       cjne A, #'P', spl_done_bridge8
060E 08         659       inc R0
060F E6         660       mov A, @R0
0610 B45018     661       cjne A, #'P', spl_done_bridge8
0613 08         662       inc R0
0614 E6         663       mov A, @R0
0615 B44C13     664       cjne A, #'L', spl_done_bridge8
0618 08         665       inc R0
0619 E6         666       mov A, @R0
061A B4590E     667       cjne A, #'Y', spl_done_bridge8
061D            668       
061D            669       ; CFG:APPLY - Apply configuration
061D 120F4E     670       lcall Update_FSM_Variables
0620 D20F       671       setb state_change_signal
0622 D224       672       setb fullscreen_update_signal
0624 8005       673       sjmp spl_done_bridge8
0626            674   
0626            675   chk_CFG_json:
0626            676       ; Check for space (CFG {json})
0626 B42002     677       cjne A, #' ', spl_done_bridge8
0629            678       ; It's "CFG {...}" - JSON config (ignored)
0629 8000       679       sjmp spl_done_bridge8
062B            680   
062B            681   spl_done_bridge8:
062B 02062E     682       ljmp spl_done
062E            683   
062E            684   ;------------------------------------------------------------
062E            685   spl_done:
062E 22         686       ret
062F            687   
062F            688   
062F            689   ;-------------------------------------------------------------------------------
062F            690   ; serial debugging
062F            691   ; send a four byte number via serial to laptop
062F            692   ; need to be used with python script
062F            693   ; content needed to be sent should be stored in the varaible x
062F            694   ;-------------------------------------------------------------------------------
062F            695   Send32:
062F            696       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
062F 74AA       697       mov A, #0AAH
0631 12048E     698       lcall putchar
0634 7455       699       mov A, #055H
0636 12048E     700       lcall putchar
0639            701   
0639 E53D       702       mov A, x+3
063B 12048E     703       lcall putchar
063E E53C       704       mov A, x+2
0640 12048E     705       lcall putchar
0643 E53B       706       mov A, x+1
0645 12048E     707       lcall putchar
0648 E53A       708       mov A, x+0
064A 12048E     709       lcall putchar
064D            710   
064D 740A       711       mov A, #0AH
064F 12048E     712       lcall putchar
0652 22         713       ret
0653            714   ;-------------------------------------------------------------------------------
0653            715   ; Serial temperature line for PuTTY/screen
0653            716   ; Outputs: "Temp: XXXC\r\n"
0653            717   ;-------------------------------------------------------------------------------
0653            718   Serial_Send_Temp_Line:
0653 9003E5     719       mov dptr, #String_temp_line
0656 120496     720       lcall SendString
0659            721   
0659            722       ; Convert current_temp to BCD (same as LCD)
0659 85473A     723       mov x, current_temp
065C 85483B     724       mov x+1, current_temp+1
065F 85493C     725       mov x+2, current_temp+2
0662 854A3D     726       mov x+3, current_temp+3
0665 12002E     727       lcall hex2bcd
0668            728   
0668 7F00       729       mov R7, #0          ; printed_flag = 0
066A            730   
066A            731       ; Print Hundreds (if non-zero)
066A E543       732       mov a, bcd+1
066C 540F       733       anl a, #0x0F
066E 6007       734       jz Serial_Skip_Hundreds
0670 2430       735       add a, #0x30
0672 12048E     736       lcall putchar
0675 7F01       737       mov R7, #1
0677            738   Serial_Skip_Hundreds:
0677            739   
0677            740       ; Print Tens (if non-zero or if hundreds already printed)
0677 E542       741       mov a, bcd+0
0679 C4         742       swap a
067A 540F       743       anl a, #0x0F
067C 7003       744       jnz Serial_Print_Tens
067E EF         745       mov a, R7
067F 600C       746       jz Serial_Skip_Tens
0681            747   Serial_Print_Tens:
0681 E542       748       mov a, bcd+0
0683 C4         749       swap a
0684 540F       750       anl a, #0x0F
0686 2430       751       add a, #0x30
0688 12048E     752       lcall putchar
068B 7F01       753       mov R7, #1
068D            754   Serial_Skip_Tens:
068D            755   
068D            756       ; Print Ones (always)
068D E542       757       mov a, bcd+0
068F 540F       758       anl a, #0x0F
0691 2430       759       add a, #0x30
0693 12048E     760       lcall putchar
0696            761   
0696            762       ; Print 'C' and newline
0696 7443       763       mov a, #'C'
0698 12048E     764       lcall putchar
069B 740D       765       mov a, #0DH     ; CR
069D 12048E     766       lcall putchar
06A0 740A       767       mov a, #0AH     ; LF
06A2 12048E     768       lcall putchar
06A5 22         769       ret
06A6            770   ;-------------------------------------------------------------------------------
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
06A6              1   ;-------------------------------------------------------------------------------
06A6              2   ; Timer2_ISR.inc
06A6              3   ; Contains Initialization and ISR for the 1ms System Timer
06A6              4   ;-------------------------------------------------------------------------------
06A6              5   
06A6              6   ;-------------------------------------------------------------------------------
06A6              7   ; Routine to initialize the ISR for timer 2
06A6              8   ;-------------------------------------------------------------------------------
06A6              9   Timer2_Init:
06A6 75C800      10       mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
06A9 75CDF5      11       mov TH2, #high(TIMER2_RELOAD)
06AC 75CC27      12       mov TL2, #low(TIMER2_RELOAD)
06AF             13       ; Set the reload value
06AF 75CBF5      14       mov RCAP2H, #high(TIMER2_RELOAD)
06B2 75CA27      15       mov RCAP2L, #low(TIMER2_RELOAD)
06B5             16       
06B5 C2CF        17       clr TF2       ; Clear flag just in case
06B7             18       ; Enable the timer and interrupts
06B7 D2AD        19       setb ET2      ; Enable timer 2 interrupt
06B9 D2CA        20       setb TR2      ; Enable timer 2
06BB 22          21       ret
06BC             22   
06BC             23   ;-------------------------------------------------------------------------------
06BC             24   ; ISR for timer 2.  Runs every 1 ms
06BC             25   ;-------------------------------------------------------------------------------
06BC             26   Timer2_ISR:
06BC C0E0        27       push acc
06BE C0D0        28       push psw
06C0             29       
06C0 C2CF        30       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
06C2             31   
06C2             32       ; --- 1. Existing Non-Blocking Seconds Increment and Periphals Debounce Timers ---
06C2 056F        33       inc SEC_FSM_timer
06C4 D202        34       setb one_ms_pwm_flag 
06C6 D203        35            setb one_ms_buzz_flag
06C8 D218        36       setb one_ms_beep_flag
06CA D226        37       setb one_millisecond_flag_servo
06CC             38     
06CC 0571        39       inc PB0_DEB_timer
06CE 0573        40       inc PB2_DEB_timer
06D0 057B        41       inc BTN_DEB_timer
06D2             42   
06D2             43       ; --- 2. NEW: Non-Blocking Delay Counters ---
06D2             44       ; A. BUTTON DELAY
06D2 301C0B      45       jnb wait25_btn_active, T2_Check_Keypad
06D5 0553        46       inc wait25_btn_cnt
06D7 E553        47       mov a, wait25_btn_cnt
06D9 B41904      48       cjne a, #25, T2_Check_Keypad
06DC D21D        49       setb wait25_btn_done
06DE C21C        50       clr wait25_btn_active
06E0             51       
06E0             52       ; B. KEYPAD DELAY
06E0             53   T2_Check_Keypad:
06E0 301E0B      54       jnb wait25_keypad_active, T2_Check_ADC
06E3 0554        55       inc wait25_keypad_cnt
06E5 E554        56       mov a, wait25_keypad_cnt
06E7 B41904      57       cjne a, #25, T2_Check_ADC
06EA D21F        58       setb wait25_keypad_done
06EC C21E        59       clr wait25_keypad_active
06EE             60   
06EE             61       ; C. ADC DELAY (Thermocouple)
06EE             62   T2_Check_ADC:
06EE 30200B      63       jnb wait25_adc_active, T2_Check_LCD
06F1 0555        64       inc wait25_adc_cnt
06F3 E555        65       mov a, wait25_adc_cnt
06F5 B41904      66       cjne a, #25, T2_Check_LCD
06F8 D221        67       setb wait25_adc_done
06FA C220        68       clr wait25_adc_active
06FC             69   
06FC             70       ; D. LCD DELAY
06FC             71   T2_Check_LCD:
06FC 30220B      72       jnb wait25_lcd_active, T2_Check_Generic
06FF 0556        73       inc wait25_lcd_cnt
0701 E556        74       mov a, wait25_lcd_cnt
0703 B41904      75       cjne a, #25, T2_Check_Generic
0706 D223        76       setb wait25_lcd_done
0708 C222        77       clr wait25_lcd_active
070A             78   
070A             79       ; E. GENERIC DELAY (Used by Wait_25ms in Main)
070A             80   T2_Check_Generic:
070A 301A0B      81       jnb wait25_active, Timer2_ISR_done
070D 0557        82       inc wait25_count
070F E557        83       mov a, wait25_count
0711 B41904      84       cjne a, #25, Timer2_ISR_done
0714 D21B        85       setb wait25_done      ; Tells Wait_25ms that we are finished
0716 C21A        86       clr wait25_active     ; Stop counting
0718             87   
0718             88   Timer2_ISR_done:
0718 D0D0        89       pop psw
071A D0E0        90       pop acc
071C 32          91       reti
071D             92            
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
071D              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
071D              2   cseg
071D              3   
071D              4   ; When using a 33.333333MHz crystal clock
071D              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
071D              6   
071D              7   ;---------------------------------;
071D              8   ; Wait 40 microseconds            ;
071D              9   ;---------------------------------;
071D             10   Wait40uSec:
071D C000        11            push AR0
071F 78BE        12            mov R0, #190
0721             13   L0: 
0721 00          14            nop
0722 00          15            nop
0723 00          16            nop
0724 00          17            nop
0725 D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
0727 D000        19            pop AR0
0729 22          20       ret
072A             21   
072A             22   ;---------------------------------;
072A             23   ; Wait 'R2' milliseconds          ;
072A             24   ;---------------------------------;
                 25   Wait_Milli_Seconds mac
                 26   	push AR2
                 27   	mov R2, %0
                 28   	lcall ?Wait_Milli_Seconds
                 29   	pop AR2
                 30   endmac
072A             31   
072A             32   ?Wait_Milli_Seconds:
072A C000        33            push AR0
072C C001        34            push AR1
072E 7932        35   L3: mov R1, #50
0730 78DF        36   L2: mov R0, #223
0732 D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
0734 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
0736 DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
0738 D001        40       pop AR1
073A D000        41       pop AR0
073C 22          42       ret
073D             43            
073D             44   ;---------------------------------;
073D             45   ; Toggles the 'E' pin in the LCD  ;
073D             46   ;---------------------------------;
073D             47   ELCD_pulse:
073D D291        48            setb ELCD_E
073F 12071D      49            lcall Wait40uSec
0742 C291        50            clr ELCD_E
0744 12071D      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
0747 22          52       ret
0748             53   
0748             54   ;---------------------------------;
0748             55   ; Writes acc to LCD in 4-bit mode ;
0748             56   ;---------------------------------;
0748             57   ELCD_byte:
0748             58            ; Write high 4 bits first
0748 A2E7        59            mov c, ACC.7
074A 9281        60            mov ELCD_D7, c
074C A2E6        61            mov c, ACC.6
074E 9283        62            mov ELCD_D6, c
0750 A2E5        63            mov c, ACC.5
0752 9285        64            mov ELCD_D5, c
0754 A2E4        65            mov c, ACC.4
0756 9287        66            mov ELCD_D4, c
0758 12073D      67       lcall ELCD_pulse
075B             68            ; Write low 4 bits next
075B A2E3        69            mov c, ACC.3
075D 9281        70            mov ELCD_D7, c
075F A2E2        71            mov c, ACC.2
0761 9283        72            mov ELCD_D6, c
0763 A2E1        73            mov c, ACC.1
0765 9285        74            mov ELCD_D5, c
0767 A2E0        75            mov c, ACC.0
0769 9287        76            mov ELCD_D4, c
076B 12073D      77       lcall ELCD_pulse
076E 22          78            ret
076F             79   
076F             80   ;---------------------------------;
076F             81   ; Write data to LCD               ;
076F             82   ;---------------------------------;
                 83   WriteData mac
                 84   	mov a, %0
                 85   	lcall ?WriteData
                 86   endmac
076F             87            
076F             88   ?WriteData:
076F D297        89            setb ELCD_RS
0771 020748      90            ljmp ELCD_byte
0774             91   
0774             92   ;---------------------------------;
0774             93   ; Write command to LCD            ;
0774             94   ;---------------------------------;
                 95   WriteCommand mac
                 96   	mov a, %0
                 97   	lcall ?WriteCommand
                 98   endmac
0774             99   
0774            100   ?WriteCommand:
0774 C297       101            clr ELCD_RS
0776 020748     102            ljmp ELCD_byte
0779            103   
0779            104   ;---------------------------------;
0779            105   ; Configure LCD in 4-bit mode     ;
0779            106   ;---------------------------------;
0779            107   ELCD_4BIT:
0779 C291       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
077B            109            ;clr ELCD_RW  ; RW forced to zero
077B            110            
077B            111            ; After power on, let the LCD start up before initializing
077B C002       112            push AR2
077D 7A28       112            mov R2, #40
077F 12072A     112            lcall ?Wait_Milli_Seconds
0782 D002       112            pop AR2
0784            113            
0784            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
0784 7433       115            mov a, #0x33
0786 120774     115            lcall ?WriteCommand
0789 7433       116            mov a, #0x33
078B 120774     116            lcall ?WriteCommand
078E 7432       117            mov a, #0x32
0790 120774     117            lcall ?WriteCommand ; change to 4-bit mode
0793            118   
0793            119            ; Configure the LCD
0793 7428       120            mov a, #0x28
0795 120774     120            lcall ?WriteCommand
0798 740C       121            mov a, #0x0c
079A 120774     121            lcall ?WriteCommand
079D 7401       122            mov a, #0x01
079F 120774     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
07A2            123   
07A2            124       ;Wait for the clear screen command to finish.
07A2 C002       125            push AR2
07A4 7A02       125            mov R2, #2
07A6 12072A     125            lcall ?Wait_Milli_Seconds
07A9 D002       125            pop AR2
07AB 22         126       ret
07AC            127   
07AC            128   ;---------------------------------;
07AC            129   ; Send a constant string to LCD   ;
07AC            130   ;---------------------------------;
                131   Send_Constant_String mac
                132   	push dph
                133   	push dpl
                134   	push acc
                135   	mov dptr, %0
                136   	lcall ?Send_Constant_String
                137   	pop acc
                138   	pop dpl
                139   	pop dph
                140   endmac
07AC            141   
07AC            142   ?Send_Constant_String:
07AC E4         143       clr a
07AD 93         144       movc a, @a+dptr
07AE 6006       145       jz ?Send_Constant_String_Done
07B0 12076F     146       lcall ?WriteData
07B3 A3         147       inc dptr
07B4 80F6       148       sjmp ?Send_Constant_String
07B6            149   ?Send_Constant_String_Done:
07B6 22         150       ret  
07B7            151   
07B7            152   ;---------------------------------;
07B7            153   ; Set LCD cursor at row, column   ;
07B7            154   ;---------------------------------;
                155   Set_Cursor mac
                156   	push acc
                157   	mov a, #%1
                158   	dec a
                159   	lcall ?Set_Cursor_%0 ; Select column and row
                160   	pop acc
                161   endmac
07B7            162   
07B7            163   ?Set_Cursor_2:
07B7 4440       164            orl a, #01000000B
07B9            165   ?Set_Cursor_1:
07B9 4480       166            orl a, #10000000B
07BB 020774     167            ljmp ?WriteCommand ; Select column and row
07BE            168   
07BE            169   ;---------------------------------;
07BE            170   ; Display a BCD number in the LCD ;
07BE            171   ;---------------------------------;
                172   Display_BCD mac
                173   	push ar0
                174   	mov r0, %0
                175   	lcall ?Display_BCD
                176   	pop ar0
                177   endmac
07BE            178   
07BE            179   ?Display_BCD:
07BE C0E0       180            push acc
07C0            181            ; Write most significant digit
07C0 E8         182            mov a, r0
07C1 C4         183            swap a
07C2 540F       184            anl a, #0fh
07C4 4430       185            orl a, #30h
07C6 12076F     186            lcall ?WriteData
07C9            187            ; write least significant digit
07C9 E8         188            mov a, r0
07CA 540F       189            anl a, #0fh
07CC 4430       190            orl a, #30h
07CE 12076F     191            lcall ?WriteData
07D1 D0E0       192            pop acc
07D3 22         193            ret
07D4            194   
07D4            195   ;------------------------------------;
07D4            196   ; Display a char in the LCD          ;
07D4            197   ;------------------------------------;
                198   Display_char mac
                199   	push acc
                200   	mov a, %0
                201   	lcall ?WriteData
                202   	pop acc
                203   endmac
07D4            204   
07D4            773            ;-------------------------------------------------------------------------------
07D4            774   ; Display Function for 7-segment displays       
07D4            775   ;-------------------------------------------------------------------------------
07D4            776   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
07D4            777   T_7seg:
07D4 C0F9A4B0   778       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
07D9 9282F880   779       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
07DE 8883C6A1   780       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
07E4            781   
07E4            782   ; Displays a BCD number pased in R0 in HEX5-HEX0
07E4            783   Display_BCD_7_Seg_HEX10:
07E4 9007D4     784       mov dptr, #T_7seg
07E7 E8         785       mov a, R0
07E8 C4         786       swap a
07E9 540F       787       anl a, #0FH
07EB 93         788       movc a, @a+dptr
07EC F592       789       mov HEX1, a
07EE E8         790       mov a, R0
07EF 540F       791       anl a, #0FH
07F1 93         792       movc a, @a+dptr
07F2 F591       793       mov HEX0, a
07F4 22         794       ret
07F5            795   
07F5            796   Display_BCD_7_Seg_HEX32:
07F5 9007D4     797       mov dptr, #T_7seg
07F8 E8         798       mov a, R0
07F9 C4         799       swap a
07FA 540F       800       anl a, #0FH
07FC 93         801       movc a, @a+dptr
07FD F594       802       mov HEX3, a
07FF E8         803       mov a, R0
0800 540F       804       anl a, #0FH
0802 93         805       movc a, @a+dptr
0803 F593       806       mov HEX2, a
0805 22         807       ret
0806            808   
0806            809   Display_BCD_7_Seg_HEX54:
0806 9007D4     810       mov dptr, #T_7seg
0809 E8         811       mov a, R0
080A C4         812       swap a
080B 540F       813       anl a, #0FH
080D 93         814       movc a, @a+dptr
080E F58F       815       mov HEX5, a
0810 E8         816       mov a, R0
0811 540F       817       anl a, #0FH
0813 93         818       movc a, @a+dptr
0814 F58E       819       mov HEX4, a
0816 22         820       ret
0817            821   
0817            822   ; The 8-bit hex number passed in the accumulator is converted to
0817            823   ; BCD and stored in [R1, R0]
0817            824   Hex_to_bcd_8bit:
0817 75F064     825       mov b, #100
081A 84         826       div ab
081B F9         827       mov R1, a   ; After dividing, a has the 100s
081C E5F0       828       mov a, b    ; Remainder is in register b
081E 75F00A     829       mov b, #10
0821 84         830       div ab ; The tens are stored in a, the units are stored in b 
0822 C4         831       swap a
0823 54F0       832       anl a, #0xf0
0825 45F0       833       orl a, b
0827 F8         834       mov R0, a
0828 22         835       ret
0829            836   ;-------------------------------------------------------------------------------
0829            837   ; Display Function for LCD                      
0829            838   ;-------------------------------------------------------------------------------
0829            839   LCD_Print_2Digits:
0829 120817     840       lcall Hex_to_bcd_8bit
082C E8         841       mov a, R0
082D C4         842       swap a
082E 540F       843       anl a, #0x0F
0830 2430       844       add a, #0x30
0832 12076F     845       lcall ?WriteData
0835 E8         846       mov a, R0
0836 540F       847       anl a, #0x0F
0838 2430       848       add a, #0x30
083A 12076F     849       lcall ?WriteData
083D 22         850       ret
083E            851   
083E            852   LCD_Display_Update_func:
083E C0E0       853       push acc
0840            854       
0840            855       ; ==========================================
0840            856       ; PART 1: STATIC TEXT (Title)
0840            857       ; Runs ONLY when the state changes
0840            858       ; ==========================================
0840            859       
0840            860       ; [FIX] "Trampoline" logic for long distance jump
0840            861       ; If signal is SET (1), we stay here and update.
0840            862       ; If signal is CLEAR (0), we Long Jump to the Live Update section.
0840 300F04     863       jnb state_change_signal, Do_Dynamic_Update
0843 C20F       864            clr state_change_signal
0845 8003       865            sjmp Do_Static_Update
0847            866   Do_Dynamic_Update:
0847 02097E     867            ljmp Check_Live_Update
084A            868   
084A            869   Do_Static_Update:
084A            870       ; State Changed: Clear Screen and Write Title
084A 120B11     871       lcall Clear_Screen_Func
084D E560       872       mov a, Control_FSM_state
084F            873       
084F            874       ; State 0: Welcome
084F B4003B     875       cjne a, #0, LCD_Check_1
0852 C0E0       876            push acc
0854 7401       876            mov a, #1
0856 14         876            dec a
0857 1207B9     876            lcall ?Set_Cursor_1 ; Select column and row
085A D0E0       876            pop acc
085C C083       877            push dph
085E C082       877            push dpl
0860 C0E0       877            push acc
0862 900330     877            mov dptr, #String_state0_1
0865 1207AC     877            lcall ?Send_Constant_String
0868 D0E0       877            pop acc
086A D082       877            pop dpl
086C D083       877            pop dph
086E C0E0       878            push acc
0870 7401       878            mov a, #1
0872 14         878            dec a
0873 1207B7     878            lcall ?Set_Cursor_2 ; Select column and row
0876 D0E0       878            pop acc
0878 C083       879            push dph
087A C082       879            push dpl
087C C0E0       879            push acc
087E 900340     879            mov dptr, #String_state0_2
0881 1207AC     879            lcall ?Send_Constant_String
0884 D0E0       879            pop acc
0886 D082       879            pop dpl
0888 D083       879            pop dph
088A 02097B     880       ljmp LCD_Done_Bridge ; Exit
088D            881   
088D            882   LCD_Check_1: ; Setup
088D B4011F     883       cjne a, #1, LCD_Check_2
0890 C0E0       884            push acc
0892 7401       884            mov a, #1
0894 14         884            dec a
0895 1207B9     884            lcall ?Set_Cursor_1 ; Select column and row
0898 D0E0       884            pop acc
089A C083       885            push dph
089C C082       885            push dpl
089E C0E0       885            push acc
08A0 9003A5     885            mov dptr, #String_state1
08A3 1207AC     885            lcall ?Send_Constant_String
08A6 D0E0       885            pop acc
08A8 D082       885            pop dpl
08AA D083       885            pop dph
08AC 02097B     886       ljmp LCD_Done_Bridge
08AF            887   
08AF            888   LCD_Check_2: ; Ramp to Soak
08AF B4021F     889       cjne a, #2, LCD_Check_3
08B2 C0E0       890            push acc
08B4 7401       890            mov a, #1
08B6 14         890            dec a
08B7 1207B9     890            lcall ?Set_Cursor_1 ; Select column and row
08BA D0E0       890            pop acc
08BC C083       891            push dph
08BE C082       891            push dpl
08C0 C0E0       891            push acc
08C2 9003EC     891            mov dptr, #String_state2
08C5 1207AC     891            lcall ?Send_Constant_String
08C8 D0E0       891            pop acc
08CA D082       891            pop dpl
08CC D083       891            pop dph
08CE 02099E     892       ljmp LCD_Update_Temp_Value
08D1            893   
08D1            894   LCD_Check_3: ; Soak
08D1 B4031F     895       cjne a, #3, LCD_Check_4
08D4 C0E0       896            push acc
08D6 7401       896            mov a, #1
08D8 14         896            dec a
08D9 1207B9     896            lcall ?Set_Cursor_1 ; Select column and row
08DC D0E0       896            pop acc
08DE C083       897            push dph
08E0 C082       897            push dpl
08E2 C0E0       897            push acc
08E4 9003FC     897            mov dptr, #String_state3
08E7 1207AC     897            lcall ?Send_Constant_String
08EA D0E0       897            pop acc
08EC D082       897            pop dpl
08EE D083       897            pop dph
08F0 02099E     898       ljmp LCD_Update_Temp_Value
08F3            899   
08F3            900   LCD_Check_4: ; Ramp to Peak
08F3 B4041F     901       cjne a, #4, LCD_Check_5
08F6 C0E0       902            push acc
08F8 7401       902            mov a, #1
08FA 14         902            dec a
08FB 1207B9     902            lcall ?Set_Cursor_1 ; Select column and row
08FE D0E0       902            pop acc
0900 C083       903            push dph
0902 C082       903            push dpl
0904 C0E0       903            push acc
0906 90040C     903            mov dptr, #String_state4
0909 1207AC     903            lcall ?Send_Constant_String
090C D0E0       903            pop acc
090E D082       903            pop dpl
0910 D083       903            pop dph
0912 02099E     904       ljmp LCD_Update_Temp_Value
0915            905   
0915            906   LCD_Check_5: ; Reflow
0915 B4051F     907       cjne a, #5, LCD_Check_6
0918 C0E0       908            push acc
091A 7401       908            mov a, #1
091C 14         908            dec a
091D 1207B9     908            lcall ?Set_Cursor_1 ; Select column and row
0920 D0E0       908            pop acc
0922 C083       909            push dph
0924 C082       909            push dpl
0926 C0E0       909            push acc
0928 90041C     909            mov dptr, #String_state5
092B 1207AC     909            lcall ?Send_Constant_String
092E D0E0       909            pop acc
0930 D082       909            pop dpl
0932 D083       909            pop dph
0934 02099E     910       ljmp LCD_Update_Temp_Value
0937            911   
0937            912   LCD_Check_6: ; Cooling
0937 B4061F     913       cjne a, #6, LCD_Check_7
093A C0E0       914            push acc
093C 7401       914            mov a, #1
093E 14         914            dec a
093F 1207B9     914            lcall ?Set_Cursor_1 ; Select column and row
0942 D0E0       914            pop acc
0944 C083       915            push dph
0946 C082       915            push dpl
0948 C0E0       915            push acc
094A 90042C     915            mov dptr, #String_state6
094D 1207AC     915            lcall ?Send_Constant_String
0950 D0E0       915            pop acc
0952 D082       915            pop dpl
0954 D083       915            pop dph
0956 02099E     916       ljmp LCD_Update_Temp_Value
0959            917   
0959            918   LCD_Check_7: ; Done
0959 B4071F     919       cjne a, #7, LCD_Done_Bridge ; If not 7, we are done
095C C0E0       920            push acc
095E 7401       920            mov a, #1
0960 14         920            dec a
0961 1207B9     920            lcall ?Set_Cursor_1 ; Select column and row
0964 D0E0       920            pop acc
0966 C083       921            push dph
0968 C082       921            push dpl
096A C0E0       921            push acc
096C 90043C     921            mov dptr, #String_state7
096F 1207AC     921            lcall ?Send_Constant_String
0972 D0E0       921            pop acc
0974 D082       921            pop dpl
0976 D083       921            pop dph
0978 02097B     922       ljmp LCD_Done_Bridge
097B            923   
097B            924   ; Local bridge to reach the far-away LCD_Done
097B            925   LCD_Done_Bridge:
097B 0209FF     926       ljmp LCD_Done
097E            927   
097E            928   ;-------------------------------------------------------------------------------
097E            929   ; PART 2: dyanmic for temp
097E            930   ; runs every time 'one_second_flag' is set
097E            931   ;-------------------------------------------------------------------------------
097E            932   Check_Live_Update:
097E 3001FA     933       jnb one_second_flag, LCD_Done_Bridge
0981 C201       934       clr one_second_flag
0983            935       
0983            936       ; Only update temp for States 2, 3, 4, 5, 6
0983 E560       937       mov a, Control_FSM_state
0985 B40202     938       cjne a, #2, Check_St3
0988 8014       939       sjmp LCD_Update_Temp_Value
098A            940   Check_St3:
098A B40302     941       cjne a, #3, Check_St4
098D 800F       942       sjmp LCD_Update_Temp_Value
098F            943   Check_St4:
098F B40402     944       cjne a, #4, Check_St5
0992 800A       945       sjmp LCD_Update_Temp_Value
0994            946   Check_St5:
0994 B40502     947       cjne a, #5, Check_St6
0997 8005       948       sjmp LCD_Update_Temp_Value
0999            949   Check_St6:
0999 B40663     950       cjne a, #6, LCD_Done
099C 8000       951       sjmp LCD_Update_Temp_Value
099E            952   
099E            953   LCD_Update_Temp_Value:
099E C0E0       954            push acc
09A0 7401       954            mov a, #1
09A2 14         954            dec a
09A3 1207B7     954            lcall ?Set_Cursor_2 ; Select column and row
09A6 D0E0       954            pop acc
09A8 85473A     955       mov x, current_temp
09AB 85483B     956       mov x+1, current_temp+1
09AE 85493C     957       mov x+2, current_temp+2
09B1 854A3D     958       mov x+3, current_temp+3
09B4 12002E     959       lcall hex2bcd
09B7 120B3C     960       lcall Update_HEX_Temp 
09BA E543       961       mov a, bcd+1
09BC 540F       962       anl a, #0x0F
09BE 2430       963       add a, #0x30
09C0 12076F     964       lcall ?WriteData
09C3 E542       965       mov a, bcd+0
09C5 C4         966       swap a
09C6 540F       967       anl a, #0x0F
09C8 2430       968       add a, #0x30
09CA 12076F     969       lcall ?WriteData
09CD E542       970       mov a, bcd+0
09CF 540F       971       anl a, #0x0F
09D1 2430       972       add a, #0x30
09D3 12076F     973       lcall ?WriteData
09D6 7443       974       mov a, #'C'
09D8 12076F     975       lcall ?WriteData
09DB 7420       976       mov a, #' '
09DD 12076F     977       lcall ?WriteData
09E0 12076F     978       lcall ?WriteData
09E3 C0E0       979            push acc
09E5 740C       979            mov a, #12
09E7 14         979            dec a
09E8 1207B7     979            lcall ?Set_Cursor_2 ; Select column and row
09EB D0E0       979            pop acc
09ED E531       980       mov a, current_time_minute
09EF 120829     981       lcall LCD_Print_2Digits
09F2 743A       982       mov a, #':'
09F4 12076F     983       lcall ?WriteData
09F7 E530       984       mov a, current_time_sec
09F9 120829     985       lcall LCD_Print_2Digits
09FC 120653     986       lcall Serial_Send_Temp_Line
09FF            987   
09FF            988   LCD_Done:
09FF D0E0       989       pop acc
0A01 22         990       ret
0A02            991   
0A02            992   ; ----------------------------------------------------------------
0A02            993   ; MODULE: SCREEN UPDATE (Visual Logic)
0A02            994   ; ----------------------------------------------------------------
0A02            995   Update_Screen_Full:
0A02 E560       996            mov a, Control_FSM_state
0A04 B40102     997            cjne a, #1, Update_Screen_Full_ret
0A07 8001       998            sjmp Update_Screen_Full_do
0A09            999   Update_Screen_Full_ret:
0A09 22        1000            ret
0A0A           1001   Update_Screen_Full_do:
0A0A 3024FC    1002       jnb fullscreen_update_signal, Update_Screen_Full_ret
0A0D C224      1003       clr fullscreen_update_signal
0A0F           1004   
0A0F 120B11    1005       lcall Clear_Screen_Func
0A12 C0E0      1006            push acc
0A14 7401      1006            mov a, #1
0A16 14        1006            dec a
0A17 1207B9    1006            lcall ?Set_Cursor_1 ; Select column and row
0A1A D0E0      1006            pop acc
0A1C           1007       ; --- Draw Line 1 (Titles) ---
0A1C E561      1008       mov A, Current_State
0A1E B40013    1009       cjne A, #0, Update_State_1
0A21 C083      1010            push dph
0A23 C082      1010            push dpl
0A25 C0E0      1010            push acc
0A27 900350    1010            mov dptr, #Txt_Home
0A2A 1207AC    1010            lcall ?Send_Constant_String
0A2D D0E0      1010            pop acc
0A2F D082      1010            pop dpl
0A31 D083      1010            pop dph
0A33 22        1011       ret 
0A34           1012   Update_State_1:
0A34 B40114    1013       cjne A, #1, Update_State_2
0A37 C083      1014            push dph
0A39 C082      1014            push dpl
0A3B C0E0      1014            push acc
0A3D 900361    1014            mov dptr, #Txt_SoakT
0A40 1207AC    1014            lcall ?Send_Constant_String
0A43 D0E0      1014            pop acc
0A45 D082      1014            pop dpl
0A47 D083      1014            pop dph
0A49 8042      1015       sjmp Draw_Temp_Format
0A4B           1016   Update_State_2:
0A4B B40214    1017       cjne A, #2, Update_State_3
0A4E C083      1018            push dph
0A50 C082      1018            push dpl
0A52 C0E0      1018            push acc
0A54 900372    1018            mov dptr, #Txt_SoakTime
0A57 1207AC    1018            lcall ?Send_Constant_String
0A5A D0E0      1018            pop acc
0A5C D082      1018            pop dpl
0A5E D083      1018            pop dph
0A60 8046      1019       sjmp Draw_Time_Format
0A62           1020   Update_State_3:
0A62 B40314    1021       cjne A, #3, Update_State_4
0A65 C083      1022            push dph
0A67 C082      1022            push dpl
0A69 C0E0      1022            push acc
0A6B 900383    1022            mov dptr, #Txt_ReflT
0A6E 1207AC    1022            lcall ?Send_Constant_String
0A71 D0E0      1022            pop acc
0A73 D082      1022            pop dpl
0A75 D083      1022            pop dph
0A77 8014      1023       sjmp Draw_Temp_Format
0A79           1024   Update_State_4:
0A79 C083      1025            push dph
0A7B C082      1025            push dpl
0A7D C0E0      1025            push acc
0A7F 900394    1025            mov dptr, #Txt_ReflTime
0A82 1207AC    1025            lcall ?Send_Constant_String
0A85 D0E0      1025            pop acc
0A87 D082      1025            pop dpl
0A89 D083      1025            pop dph
0A8B 801B      1026       sjmp Draw_Time_Format
0A8D           1027   
0A8D           1028   ; --- Draw Line 2 (Values) ---
0A8D           1029   Draw_Temp_Format:
0A8D C0E0      1030            push acc
0A8F 7401      1030            mov a, #1
0A91 14        1030            dec a
0A92 1207B7    1030            lcall ?Set_Cursor_2 ; Select column and row
0A95 D0E0      1030            pop acc
0A97 120B25    1031       lcall Get_Current_Buffer_Addr
0A9A 120B07    1032       lcall Print_String_RAM
0A9D C0E0      1033            push acc
0A9F 7443      1033            mov a, #'C'
0AA1 12076F    1033            lcall ?WriteData
0AA4 D0E0      1033            pop acc
0AA6 8034      1034       sjmp Restore_Cursor
0AA8           1035   
0AA8           1036   Draw_Time_Format:
0AA8 C0E0      1037            push acc
0AAA 7401      1037            mov a, #1
0AAC 14        1037            dec a
0AAD 1207B7    1037            lcall ?Set_Cursor_2 ; Select column and row
0AB0 D0E0      1037            pop acc
0AB2 120B25    1038       lcall Get_Current_Buffer_Addr
0AB5           1039       ; MM
0AB5 E6        1040       mov A, @R0
0AB6 12076F    1041       lcall ?WriteData
0AB9 08        1042       inc R0
0ABA E6        1043       mov A, @R0
0ABB 12076F    1044       lcall ?WriteData
0ABE 08        1045       inc R0
0ABF           1046       ; Colon
0ABF C0E0      1047            push acc
0AC1 743A      1047            mov a, #':'
0AC3 12076F    1047            lcall ?WriteData
0AC6 D0E0      1047            pop acc
0AC8           1048       ; SS
0AC8 E6        1049       mov A, @R0
0AC9 12076F    1050       lcall ?WriteData
0ACC 08        1051       inc R0
0ACD E6        1052       mov A, @R0
0ACE 12076F    1053       lcall ?WriteData
0AD1           1054       ; Unit
0AD1 C0E0      1055            push acc
0AD3 7473      1055            mov a, #'s'
0AD5 12076F    1055            lcall ?WriteData
0AD8 D0E0      1055            pop acc
0ADA 8000      1056       sjmp Restore_Cursor
0ADC           1057   
0ADC           1058   ; --- Restore Cursor Position ---
0ADC           1059   Restore_Cursor:
0ADC E561      1060       mov A, Current_State
0ADE B40202    1061       cjne A, #2, RC_Check_State_4  
0AE1 800C      1062       sjmp Adjust_Cursor_Time
0AE3           1063   RC_Check_State_4:             
0AE3 B40402    1064       cjne A, #4, Normal_Cursor
0AE6 8007      1065       sjmp Adjust_Cursor_Time
0AE8           1066   
0AE8           1067   Normal_Cursor:
0AE8 E56A      1068       mov A, Cursor_Idx
0AEA 24C0      1069       add A, #0xC0
0AEC 120774    1070       lcall ?WriteCommand
0AEF           1071   
0AEF           1072   Adjust_Cursor_Time:
0AEF           1073       ; Skip the colon index (2)
0AEF E56A      1074       mov A, Cursor_Idx
0AF1 B40201    1075       cjne A, #2, No_Skip
0AF4 04        1076       inc A 
0AF5           1077   No_Skip:
0AF5           1078       ; Add 1 if past the colon
0AF5 C3        1079       clr C
0AF6 9402      1080       subb A, #2
0AF8 4005      1081       jc No_Add
0AFA E56A      1082       mov A, Cursor_Idx
0AFC 04        1083       inc A
0AFD 8002      1084       sjmp Final_Cursor_Set
0AFF           1085   No_Add:
0AFF E56A      1086       mov A, Cursor_Idx
0B01           1087   Final_Cursor_Set:
0B01 24C0      1088       add A, #0xC0
0B03 120774    1089       lcall ?WriteCommand
0B06 22        1090       ret
0B07           1091   
0B07           1092   Print_String_RAM:
0B07 E6        1093       mov A, @R0
0B08 6006      1094       jz Print_String_Done
0B0A 12076F    1095       lcall ?WriteData
0B0D 08        1096       inc R0
0B0E 80F7      1097       sjmp Print_String_RAM
0B10           1098   Print_String_Done:
0B10 22        1099       ret
0B11           1100   
0B11           1101   ; --- Clear Screen with hardware delay ---
0B11           1102   Clear_Screen_Func:
0B11 7401      1103            mov a, #0x01
0B13 120774    1103            lcall ?WriteCommand        ; Clear display command
0B16 C002      1104            push AR2
0B18 7A02      1104            mov R2, #2
0B1A 12072A    1104            lcall ?Wait_Milli_Seconds
0B1D D002      1104            pop AR2     ; LCD needs ~2ms to clear
0B1F 740C      1105            mov a, #0x0C
0B21 120774    1105            lcall ?WriteCommand        ; Display ON, Cursor OFF
0B24 22        1106       ret
0B25           1107   
0B25           1108   Get_Current_Buffer_Addr:
0B25 E561      1109       mov A, Current_State
0B27 B40103    1110       cjne A, #1, Get_Buf_2
0B2A 7880      1111       mov R0, #Buf_Soak_Temp
0B2C 22        1112       ret
0B2D           1113   Get_Buf_2:
0B2D B40203    1114       cjne A, #2, Get_Buf_3
0B30 7884      1115       mov R0, #Buf_Soak_Time
0B32 22        1116       ret
0B33           1117   Get_Buf_3:
0B33 B40303    1118       cjne A, #3, Get_Buf_4
0B36 7889      1119       mov R0, #Buf_Refl_Temp
0B38 22        1120       ret
0B39           1121   Get_Buf_4:
0B39 788D      1122       mov R0, #Buf_Refl_Time
0B3B 22        1123       ret
0B3C           1124   
0B3C           1125   ;-------------------------------------------------------------------------------
0B3C           1126   ; Update HEX2-HEX0 with temperature (3 digits)
0B3C           1127   ;-------------------------------------------------------------------------------
0B3C           1128   Update_HEX_Temp:
0B3C 9007D4    1129       mov dptr, #T_7seg
0B3F           1130       ; Hundreds -> HEX2
0B3F E543      1131       mov a, bcd+1
0B41 540F      1132       anl a, #0x0F
0B43 93        1133       movc a, @a+dptr
0B44 F593      1134       mov HEX2, a
0B46           1135       ; Tens -> HEX1
0B46 E542      1136       mov a, bcd+0
0B48 C4        1137       swap a
0B49 540F      1138       anl a, #0x0F
0B4B 93        1139       movc a, @a+dptr
0B4C F592      1140       mov HEX1, a
0B4E           1141       ; Ones -> HEX0
0B4E E542      1142       mov a, bcd+0
0B50 540F      1143       anl a, #0x0F
0B52 93        1144       movc a, @a+dptr
0B53 F591      1145       mov HEX0, a
0B55 22        1146       ret
0B56           1147       
0B56           1148   ;---------------------------------------------------------
0B56           1149   PB0_DEB:
0B56           1150   ;non-blocking state machine for PB0 debounce
0B56 E572      1151       mov a, PB0_DEB_state
0B58           1152   PB0_DEB_state0:
0B58 B4000A    1153       cjne a, #0, PB0_DEB_state1
0B5B 20902F    1154       jb PB0, PB0_DEB_done
0B5E 757100    1155       mov PB0_DEB_timer, #0
0B61 0572      1156       inc PB0_DEB_state
0B63 8028      1157       sjmp PB0_DEB_done
0B65           1158   PB0_DEB_state1:
0B65 B40109    1159       cjne a, #1, PB0_DEB_state2
0B68           1160       ; this is the debounce state
0B68 E571      1161       mov a, PB0_DEB_timer
0B6A B43220    1162       cjne a, #50, PB0_DEB_done ; 50 ms passed?
0B6D 0572      1163       inc PB0_DEB_state
0B6F 801C      1164       sjmp PB0_DEB_done  
0B71           1165   PB0_DEB_state2:
0B71 B4020C    1166       cjne a, #2, PB0_DEB_state3
0B74 209004    1167       jb PB0, PB0_DEB_state2b
0B77 0572      1168       inc PB0_DEB_state
0B79 8012      1169       sjmp PB0_DEB_done  
0B7B           1170   PB0_DEB_state2b:
0B7B 757200    1171       mov PB0_DEB_state, #0
0B7E 800D      1172       sjmp PB0_DEB_done
0B80           1173   PB0_DEB_state3:
0B80 B4030A    1174       cjne a, #3, PB0_DEB_done
0B83 309007    1175       jnb PB0, PB0_DEB_done
0B86 D215      1176       setb PB0_flag ; Suscesfully detected a valid PB0 press/release
0B88 B2ED      1177            cpl LEDRA.5
0B8A 757200    1178       mov PB0_DEB_state, #0  
0B8D           1179   PB0_DEB_done:
0B8D 22        1180       ret
0B8E           1181   
0B8E           1182   PB2_DEB:
0B8E           1183   ;non-blocking state machine for PB2 debounce
0B8E E574      1184       mov a, PB2_DEB_state
0B90           1185   PB2_DEB_state0:
0B90 B4000A    1186       cjne a, #0, PB2_DEB_state1
0B93 20B72D    1187       jb PB2, PB2_DEB_done
0B96 757300    1188       mov PB2_DEB_timer, #0
0B99 0574      1189       inc PB2_DEB_state
0B9B 8026      1190       sjmp PB2_DEB_done
0B9D           1191   PB2_DEB_state1:
0B9D B40109    1192       cjne a, #1, PB2_DEB_state2
0BA0           1193       ; this is the debounce state
0BA0 E573      1194       mov a, PB2_DEB_timer
0BA2 B4321E    1195       cjne a, #50, PB2_DEB_done ; 50 ms passed?
0BA5 0574      1196       inc PB2_DEB_state
0BA7 801A      1197       sjmp PB2_DEB_done  
0BA9           1198   PB2_DEB_state2:
0BA9 B4020C    1199       cjne a, #2, PB2_DEB_state3
0BAC 20B704    1200       jb PB2, PB2_DEB_state2b
0BAF 0574      1201       inc PB2_DEB_state
0BB1 8010      1202       sjmp PB2_DEB_done  
0BB3           1203   PB2_DEB_state2b:
0BB3 757400    1204       mov PB2_DEB_state, #0
0BB6 800B      1205       sjmp PB2_DEB_done
0BB8           1206   PB2_DEB_state3:
0BB8 B40308    1207       cjne a, #3, PB2_DEB_done
0BBB 30B705    1208       jnb PB2, PB2_DEB_done
0BBE D217      1209       setb PB2_flag ; Suscesfully detected a valid PB2 press/release
0BC0 757400    1210       mov PB2_DEB_state, #0  
0BC3           1211   PB2_DEB_done:
0BC3 22        1212       ret
0BC4           1213   
0BC4           1214   ; ------------------------------------------------------------------------------
0BC4           1215   ; Non-blocking FSM for the one second counter
0BC4           1216   ;-------------------------------------------------------------------------------
0BC4           1217   SEC_FSM:
0BC4 E570      1218       mov a, SEC_FSM_state
0BC6           1219   SEC_FSM_state0:
0BC6 B4000C    1220       cjne a, #0, SEC_FSM_state1
0BC9 E56F      1221       mov a, SEC_FSM_timer
0BCB B4FA51    1222       cjne a, #250, SEC_FSM_done
0BCE 756F00    1223       mov SEC_FSM_timer, #0
0BD1 0570      1224       inc SEC_FSM_state
0BD3 804A      1225       sjmp SEC_FSM_done
0BD5           1226   SEC_FSM_state1:  
0BD5 B4010E    1227       cjne a, #1, SEC_FSM_state2
0BD8 D2E9      1228       setb LEDRA.1
0BDA E56F      1229       mov a, SEC_FSM_timer
0BDC B4FA40    1230       cjne a, #250, SEC_FSM_done
0BDF 756F00    1231       mov SEC_FSM_timer, #0
0BE2 0570      1232       inc SEC_FSM_state
0BE4 8039      1233       sjmp SEC_FSM_done
0BE6           1234   SEC_FSM_state2:  
0BE6 B4020E    1235       cjne a, #2, SEC_FSM_state3
0BE9 D2EA      1236       setb LEDRA.2
0BEB E56F      1237       mov a, SEC_FSM_timer
0BED B4FA2F    1238       cjne a, #250, SEC_FSM_done
0BF0 756F00    1239       mov SEC_FSM_timer, #0
0BF3 0570      1240       inc SEC_FSM_state
0BF5 8028      1241       sjmp SEC_FSM_done
0BF7           1242   SEC_FSM_state3:  
0BF7 B40325    1243       cjne a, #3, SEC_FSM_done
0BFA D2EB      1244       setb LEDRA.3
0BFC E56F      1245       mov a, SEC_FSM_timer
0BFE B4FA1E    1246       cjne a, #250, SEC_FSM_done
0C01 756F00    1247       mov SEC_FSM_timer, #0
0C04 757000    1248       mov SEC_FSM_state, #0
0C07           1249       
0C07           1250       ; These flags are always set (global use)
0C07 D204      1251       setb one_second_lcd_flag
0C09 D201      1252       setb one_second_flag
0C0B           1253       
0C0B           1254       ; Heartbeat LED always toggles
0C0B B2E8      1255       cpl LEDRA.0
0C0D           1256       
0C0D           1257       ; Only update time if counting is enabled
0C0D 300D0F    1258       jnb time_count_doing_signal, SEC_FSM_done
0C10           1259       
0C10           1260       ; Update current time (only when counting)
0C10 E530      1261       mov a, current_time_sec
0C12 04        1262       inc a
0C13 B43C07    1263       cjne a, #60, SEC_NoMinuteCarry
0C16 753000    1264       mov current_time_sec, #0
0C19 0531      1265       inc current_time_minute
0C1B 8002      1266       sjmp SEC_FSM_done
0C1D           1267   SEC_NoMinuteCarry:
0C1D F530      1268       mov current_time_sec, a
0C1F           1269   SEC_FSM_done:
0C1F 22        1270       ret
0C20           1271   
0C20           1272   ; ------------------------------------------------------------------------------
0C20           1273   ; Counting the processing time 
0C20           1274   ;-------------------------------------------------------------------------------
0C20           1275   Time_Counter:
0C20 C0E0      1276       push ACC
0C22 C0D0      1277       push psw
0C24 E560      1278       mov a, Control_FSM_state
0C26           1279       
0C26           1280       ; State 2: Start counting
0C26 B4020F    1281       cjne a, #2, Time_Counter_Nstate2
0C29 101102    1282       jbc state_change_signal_Count, Time_Counter_Start
0C2C 800F      1283       sjmp Time_Counter_Done
0C2E           1284   
0C2E           1285   Time_Counter_Start:
0C2E 753000    1286       mov current_time_sec, #0
0C31 753100    1287       mov current_time_minute, #0
0C34 D20D      1288       setb time_count_doing_signal
0C36 8005      1289       sjmp Time_Counter_Done
0C38           1290   
0C38           1291   Time_Counter_Nstate2:
0C38           1292       ; State 6: Stop counting
0C38 B40602    1293       cjne a, #6, Time_Counter_Done
0C3B C20D      1294       clr time_count_doing_signal
0C3D           1295   
0C3D           1296   Time_Counter_Done:
0C3D D0D0      1297       pop psw
0C3F D0E0      1298       pop ACC
0C41 22        1299       ret
0C42           1300   
0C42           1301   
0C42           1302   ;-------------------------------------------------------------------------------
0C42           1303   ; Time_Compare_MMSS
0C42           1304   ;
0C42           1305   ; PURPOSE:
0C42           1306   ;   Compare elapsed time (current_time_minute:current_time_sec)
0C42           1307   ;   against soak and reflow setpoints (soak_time_*, reflow_time_*).
0C42           1308   ;
0C42           1309   ; BEHAVIOR:
0C42           1310   ;   - If current_time >= soak_end_time   then soak_time_reached = 1
0C42           1311   ;   - If current_time >= reflow_end_time then reflow_time_reached = 1
0C42           1312   ;
0C42           1313   ; NOTES:
0C42           1314   ;   Compare minutes first, then seconds.
0C42           1315   ;-------------------------------------------------------------------------------
0C42           1316   Time_Compare_MMSS:
0C42 C0E0      1317       push acc
0C44 C0D0      1318       push psw
0C46           1319   
0C46 E560      1320       mov a, Control_FSM_state
0C48 B4032E    1321       cjne a, #3, TC_Not_Soak
0C4B           1322   
0C4B           1323   ; ============================================================
0C4B           1324   ; STATE 3: SOAK TIME COMPARISON
0C4B           1325   ; ============================================================
0C4B 101002    1326       jbc state_change_signal_TC, TC_Soak_Start_Record
0C4E 8015      1327       sjmp TC_Soak_Comparing
0C50           1328   
0C50           1329   TC_Soak_Start_Record:
0C50           1330       ; Calculate end time = current_time + soak_time
0C50 E531      1331       mov a, current_time_minute
0C52 2533      1332       add a, soak_time_minute
0C54 F537      1333       mov soak_end_time_minute, a
0C56           1334   
0C56 E530      1335       mov a, current_time_sec
0C58 2532      1336       add a, soak_time_sec
0C5A F536      1337       mov soak_end_time_sec, a
0C5C           1338   
0C5C           1339       ; Check for seconds overflow (>= 60)
0C5C C3        1340       clr c
0C5D 943C      1341       subb a, #60
0C5F 4004      1342       jc TC_Soak_Comparing           ; No overflow, skip adjustment
0C61           1343   
0C61           1344       ; Overflow: adjust seconds and add 1 to minutes
0C61 F536      1345       mov soak_end_time_sec, a
0C63 0537      1346       inc soak_end_time_minute
0C65           1347   
0C65           1348   TC_Soak_Comparing:
0C65           1349       ; Compare minutes first
0C65 E531      1350       mov  a, current_time_minute
0C67 C3        1351       clr  c
0C68 9537      1352       subb a, soak_end_time_minute
0C6A 403E      1353       jc   TC_Done                   ; current_min < end_min -> not reached
0C6C 7007      1354       jnz  TC_Soak_Reached           ; current_min > end_min -> reached
0C6E           1355   
0C6E           1356       ; Minutes equal -> compare seconds
0C6E E530      1357       mov  a, current_time_sec
0C70 C3        1358       clr  c
0C71 9536      1359       subb a, soak_end_time_sec
0C73 4035      1360       jc   TC_Done                   ; current_sec < end_sec -> not reached
0C75           1361                                      ; current_sec >= end_sec -> fall through to reached
0C75           1362   
0C75           1363   TC_Soak_Reached:
0C75 D208      1364       setb soak_time_reached
0C77 8031      1365       sjmp TC_Done
0C79           1366   
0C79           1367   ; ============================================================
0C79           1368   ; STATE 5: REFLOW TIME COMPARISON
0C79           1369   ; ============================================================
0C79           1370   TC_Not_Soak:
0C79 E560      1371       mov a, Control_FSM_state
0C7B B4052C    1372       cjne a, #5, TC_Done
0C7E           1373   
0C7E 101002    1374       jbc state_change_signal_TC, TC_Reflow_Start_Record
0C81 8015      1375       sjmp TC_Reflow_Comparing
0C83           1376   
0C83           1377   TC_Reflow_Start_Record:
0C83           1378       ; Calculate end time = current_time + reflow_time
0C83 E531      1379       mov a, current_time_minute
0C85 2535      1380       add a, reflow_time_minute
0C87 F539      1381       mov reflow_end_time_minute, a
0C89           1382   
0C89 E530      1383       mov a, current_time_sec
0C8B 2534      1384       add a, reflow_time_sec
0C8D F538      1385       mov reflow_end_time_sec, a
0C8F           1386   
0C8F           1387       ; Check for seconds overflow (>= 60)
0C8F C3        1388       clr c
0C90 943C      1389       subb a, #60
0C92 4004      1390       jc TC_Reflow_Comparing         ; No overflow, skip adjustment
0C94           1391   
0C94           1392       ; Overflow: adjust seconds and add 1 to minutes
0C94 F538      1393       mov reflow_end_time_sec, a
0C96 0539      1394       inc reflow_end_time_minute
0C98           1395   
0C98           1396   TC_Reflow_Comparing:
0C98           1397       ; Compare minutes first
0C98 E531      1398       mov  a, current_time_minute
0C9A C3        1399       clr  c
0C9B 9539      1400       subb a, reflow_end_time_minute
0C9D 400B      1401       jc   TC_Done                   ; current_min < end_min -> not reached
0C9F 7007      1402       jnz  TC_Reflow_Reached         ; current_min > end_min -> reached
0CA1           1403   
0CA1           1404       ; Minutes equal -> compare seconds
0CA1 E530      1405       mov  a, current_time_sec
0CA3 C3        1406       clr  c
0CA4 9538      1407       subb a, reflow_end_time_sec
0CA6 4002      1408       jc   TC_Done                   ; current_sec < end_sec -> not reached
0CA8           1409                                      ; current_sec >= end_sec -> fall through to reached
0CA8           1410   
0CA8           1411   TC_Reflow_Reached:
0CA8 D209      1412       setb reflow_time_reached
0CAA           1413   
0CAA           1414   TC_Done:
0CAA D0D0      1415       pop  psw
0CAC D0E0      1416       pop  acc
0CAE 22        1417       ret
0CAF           1418   
0CAF           1419   ;-------------------------------------------------------------------------------;
0CAF           1420   ; Temp_Compare
0CAF           1421   ; Checks if we have reached the user's target temperatures.
0CAF           1422   ; Only compares relevant temperature based on current Control_FSM_state:
0CAF           1423   ;   State 2: Sets 'soak_temp_reached' if current_temp >= soak_temp
0CAF           1424   ;   State 4: Sets 'reflow_temp_reached' if current_temp >= reflow_temp
0CAF           1425   ;   State 6: Sets 'cooling_temp_reached' if current_temp < 100C
0CAF           1426   ;-------------------------------------------------------------------------------;
0CAF           1427   Temp_Compare:
0CAF C0E0      1428       push acc
0CB1 C0D0      1429       push psw
0CB3 C000      1430       push AR0
0CB5 C001      1431       push AR1
0CB7 C002      1432       push AR2
0CB9           1433       
0CB9 E560      1434       mov a, Control_FSM_state
0CBB           1435       
0CBB           1436       ; --- CHECK STATE 2: SOAK TEMP ---
0CBB B40202    1437       cjne a, #2, Temp_Compare_Check_State4
0CBE 800A      1438       sjmp Check_Soak_Threshold
0CC0           1439       
0CC0           1440   Temp_Compare_Check_State4:
0CC0           1441       ; --- CHECK STATE 4: REFLOW TEMP ---
0CC0 B40402    1442       cjne a, #4, Temp_Compare_Check_State6
0CC3 801D      1443       sjmp Check_Reflow_Threshold
0CC5           1444       
0CC5           1445   Temp_Compare_Check_State6:
0CC5           1446       ; --- CHECK STATE 6: COOLING TEMP ---
0CC5 B4064D    1447       cjne a, #6, Temp_Compare_Done
0CC8 8030      1448       sjmp Check_Cooling_Threshold
0CCA           1449   
0CCA           1450   Check_Soak_Threshold:
0CCA           1451       ; Copy current_temp to X
0CCA 7847      1452       mov R0, #current_temp
0CCC 793A      1453       mov R1, #x
0CCE 120D20    1454       lcall Copy4_Bytes_R0_to_R1
0CD1           1455   
0CD1           1456       ; Copy soak_temp to Y
0CD1 784B      1457       mov R0, #soak_temp
0CD3 793E      1458       mov R1, #y
0CD5 120D20    1459       lcall Copy4_Bytes_R0_to_R1
0CD8           1460   
0CD8           1461       ; Compare: Is X (Current) < Y (Target)?
0CD8 12011A    1462       lcall x_lt_y
0CDB 200037    1463       jb mf, Temp_Compare_Done          ; If Current < Target, not reached yet
0CDE           1464       
0CDE           1465       ; If Current >= Target
0CDE D205      1466       setb soak_temp_reached
0CE0 8033      1467       sjmp Temp_Compare_Done
0CE2           1468   
0CE2           1469   Check_Reflow_Threshold:
0CE2           1470       ; Copy current_temp to X
0CE2 7847      1471       mov R0, #current_temp
0CE4 793A      1472       mov R1, #x
0CE6 120D20    1473       lcall Copy4_Bytes_R0_to_R1
0CE9           1474   
0CE9           1475       ; Copy reflow_temp to Y
0CE9 784F      1476       mov R0, #reflow_temp
0CEB 793E      1477       mov R1, #y
0CED 120D20    1478       lcall Copy4_Bytes_R0_to_R1
0CF0           1479   
0CF0           1480       ; Compare
0CF0 12011A    1481       lcall x_lt_y
0CF3 20001F    1482       jb mf, Temp_Compare_Done          ; If Current < Target, not reached yet
0CF6           1483       
0CF6           1484       ; If Current >= Target
0CF6 D206      1485       setb reflow_temp_reached
0CF8 801B      1486       sjmp Temp_Compare_Done
0CFA           1487   
0CFA           1488   Check_Cooling_Threshold:
0CFA           1489       ; Copy current_temp to X
0CFA 7847      1490       mov R0, #current_temp
0CFC 793A      1491       mov R1, #x
0CFE 120D20    1492       lcall Copy4_Bytes_R0_to_R1
0D01           1493       
0D01 753E64    1494            mov y+0, #low (100 % 0x10000) 
0D04 753F00    1494            mov y+1, #high(100 % 0x10000) 
0D07 754000    1494            mov y+2, #low (100 / 0x10000) 
0D0A 754100    1494            mov y+3, #high(100 / 0x10000)                         ; Cooling target = 100C
0D0D 12011A    1495       lcall x_lt_y
0D10 300002    1496       jnb mf, Temp_Compare_Done         ; If temp >= 100, not cooled yet
0D13           1497       
0D13           1498       ; If Current < 100C
0D13 D207      1499       setb cooling_temp_reached
0D15           1500   
0D15           1501   ; ---------------------------------------------------------
0D15           1502   Temp_Compare_Done:
0D15 D002      1503       pop AR2
0D17 D001      1504       pop AR1
0D19 D000      1505       pop AR0
0D1B D0D0      1506       pop psw
0D1D D0E0      1507       pop acc
0D1F 22        1508       ret
0D20           1509   
0D20           1510   ;-------------------------------------------------------------------------------;
0D20           1511   ; Copy4_Bytes_R0_to_R1
0D20           1512   ;
0D20           1513   ; PURPOSE:
0D20           1514   ;   Utility routine to copy a 32-bit value (4 bytes)
0D20           1515   ;   from one memory location to another.
0D20           1516   ;
0D20           1517   ; INPUTS:
0D20           1518   ;   R0 st source address
0D20           1519   ;   R1 at destination address
0D20           1520   ;
0D20           1521   ; USES:
0D20           1522   ;   R2 as loop counter
0D20           1523   ;
0D20           1524   ; EXAMPLE:
0D20           1525   ;   mov R0, #current_temp
0D20           1526   ;   mov R1, #x
0D20           1527   ;   lcall Copy4_Bytes_R0_to_R1
0D20           1528   ;-------------------------------------------------------------------------------;
0D20           1529   Copy4_Bytes_R0_to_R1:
0D20 7A04      1530       mov  R2, #4
0D22           1531   Copy4_Loop:
0D22 E6        1532       mov  a, @R0
0D23 F7        1533       mov  @R1, a
0D24 08        1534       inc  R0
0D25 09        1535       inc  R1
0D26 DAFA      1536       djnz R2, Copy4_Loop
0D28 22        1537       ret
0D29           1538   
0D29           1539   ;-------------------------------------------------------------------------------
0D29           1540   ; PWM
0D29           1541   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0D29           1542   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0D29           1543   ; ------------------------------------------------------------------------------
0D29           1544   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0D29 100202    1545       jbc one_ms_pwm_flag, pwm_wave_generator
0D2C 8071      1546       sjmp end_pwm_generator
0D2E           1547   
0D2E           1548   pwm_wave_generator:
0D2E C200      1549       clr mf
0D30           1550       ; move pwm counter value into x for comparison purpose
0D30 855C3A    1551       mov x, pwm_counter
0D33 855D3B    1552       mov x+1, pwm_counter+1
0D36 855E3C    1553       mov x+2, pwm_counter+2
0D39 855F3D    1554       mov x+3, pwm_counter+3
0D3C           1555   
0D3C 753EDB    1556            mov y+0, #low (PWM_PERIOD % 0x10000) 
0D3F 753F05    1556            mov y+1, #high(PWM_PERIOD % 0x10000) 
0D42 754000    1556            mov y+2, #low (PWM_PERIOD / 0x10000) 
0D45 754100    1556            mov y+3, #high(PWM_PERIOD / 0x10000) 
0D48           1557   
0D48           1558       ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
0D48           1559       ; increase x by 1
0D48 120152    1560       lcall x_eq_y 
0D4B 20001D    1561       jb mf, wrap_pwm_counter
0D4E           1562       ; x not equal 1499, increment by 1
0D4E 753E01    1563            mov y+0, #low (1 % 0x10000) 
0D51 753F00    1563            mov y+1, #high(1 % 0x10000) 
0D54 754000    1563            mov y+2, #low (1 / 0x10000) 
0D57 754100    1563            mov y+3, #high(1 / 0x10000) 
0D5A 1200D3    1564       lcall add32
0D5D           1565       ; update pwm_counter
0D5D 853A5C    1566       mov pwm_counter, x
0D60 853B5D    1567       mov pwm_counter+1, x+1
0D63 853C5E    1568       mov pwm_counter+2, x+2
0D66 853D5F    1569       mov pwm_counter+3, x+3
0D69 8018      1570       sjmp set_pwm
0D6B           1571   
0D6B           1572   wrap_pwm_counter:
0D6B           1573       ; x equal 1499, wrap to 0
0D6B 753A00    1574            mov x+0, #low (0 % 0x10000) 
0D6E 753B00    1574            mov x+1, #high(0 % 0x10000) 
0D71 753C00    1574            mov x+2, #low (0 / 0x10000) 
0D74 753D00    1574            mov x+3, #high(0 / 0x10000) 
0D77 853A5C    1575       mov pwm_counter, x
0D7A 853B5D    1576       mov pwm_counter+1, x+1
0D7D 853C5E    1577       mov pwm_counter+2, x+2
0D80 853D5F    1578       mov pwm_counter+3, x+3
0D83           1579   
0D83           1580   set_pwm:
0D83           1581       ; compare with power_output, if pwm counter smaller than power_output, 
0D83           1582       ; set pwm pin high; else set pwm pin low load y with power output value
0D83 85583E    1583       mov y, power_output
0D86 85593F    1584       mov y+1, power_output+1
0D89 855A40    1585       mov y+2, power_output+2
0D8C 855B41    1586       mov y+3, power_output+3
0D8F           1587   
0D8F           1588       ; compare x(pwm counter) with y(power output)
0D8F 12011A    1589       lcall x_lt_y
0D92 200006    1590       jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
0D95           1591       ;output set pwm pin low if pwm counter greater than power output
0D95 C293      1592       clr PWM_OUT
0D97 C2EC      1593       clr LEDRA.4
0D99 8004      1594       sjmp end_pwm_generator
0D9B           1595   
0D9B           1596   set_pwm_high:
0D9B D293      1597       setb PWM_OUT
0D9D D2EC      1598       setb LEDRA.4
0D9F           1599   
0D9F           1600   end_pwm_generator:
0D9F 22        1601       ret
0DA0           1602   
0DA0           1603   ;-------------------------------------------------------------------------------
0DA0           1604   
0DA0           1605   ;-------------------------------------------------------------------------------;
0DA0           1606   ; Abort condition safety check Temperature time
0DA0           1607   ;
0DA0           1608   ; PURPOSE:
0DA0           1609   ;   Automatic cycle termination on error:
0DA0           1610   ;   Abort if oven fails to reach at least 50C in first 60s (1 minute).
0DA0           1611   ;
0DA0           1612   ; TRIP CONDITION:
0DA0           1613   ;   if (current_time_minute >= 1) AND (current_temp < 50C)
0DA0           1614   ;       -> set tc_missing_abort
0DA0           1615   ;       -> set stop_signal
0DA0           1616   ;
0DA0           1617   ; ASSUMPTIONS:
0DA0           1618   ;   - current_time_sec (byte): seconds 0-59
0DA0           1619   ;   - current_time_minute (byte): minutes counter
0DA0           1620   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
0DA0           1621   ;-------------------------------------------------------------------------------;
0DA0           1622   Safety_Check_TC:
0DA0 C0E0      1623       push acc
0DA2 C0D0      1624       push psw
0DA4 C000      1625       push AR0
0DA6 C001      1626       push AR1
0DA8           1627   
0DA8           1628       ; ---------------------------------------------------------
0DA8           1629       ; GATEKEEPER: IGNORE UNLESS IN STATE 2 (RAMP TO SOAK)
0DA8           1630       ; ---------------------------------------------------------
0DA8 E560      1631       mov a, Control_FSM_state
0DAA B40202    1632       cjne a, #2, Safety_TC_Exit_Bridge ; If State != 2, skip everything
0DAD 8003      1633       sjmp Safety_Logic_Proceed         ; If State == 2, do the check
0DAF           1634   
0DAF           1635   Safety_TC_Exit_Bridge:
0DAF 020DE8    1636       ljmp Safety_TC_Done               ; Jump to the end
0DB2           1637   
0DB2           1638   Safety_Logic_Proceed:
0DB2           1639       ; If already aborted or startup window closed, do nothing
0DB2 201333    1640       jb   tc_missing_abort, Safety_TC_Done
0DB5 301430    1641       jnb  tc_startup_window, Safety_TC_Done
0DB8           1642   
0DB8           1643       ; Check: current_time_minute >= 1 ? (has 1 minute passed?)
0DB8 E531      1644       mov  a, current_time_minute
0DBA 602C      1645       jz   Safety_TC_Done               ; minute == 0, still waiting
0DBC           1646   
0DBC           1647       ; We reached 1 minute: close the startup window so it won't re-check later
0DBC C214      1648       clr  tc_startup_window
0DBE           1649   
0DBE           1650       ; Now check: current_temp < 50 ?
0DBE 7847      1651       mov  R0, #current_temp
0DC0 793A      1652       mov  R1, #x
0DC2 120D20    1653       lcall Copy4_Bytes_R0_to_R1
0DC5           1654   
0DC5 753E32    1655            mov y+0, #low (50 % 0x10000) 
0DC8 753F00    1655            mov y+1, #high(50 % 0x10000) 
0DCB 754000    1655            mov y+2, #low (50 / 0x10000) 
0DCE 754100    1655            mov y+3, #high(50 / 0x10000) 
0DD1 12011A    1656       lcall x_lt_y
0DD4 300011    1657       jnb  mf, Safety_TC_Done           ; temp >= 50  pass
0DD7           1658   
0DD7           1659       ; FAIL: at 1 minute, still below 50C  abort
0DD7 C293      1660       clr  PWM_OUT
0DD9 D213      1661       setb tc_missing_abort
0DDB D20B      1662       setb stop_signal
0DDD 120E25    1663       lcall Beep_Ten
0DE0           1664       
0DE0           1665       ; Force FSM to State 0 (Welcome)
0DE0 756000    1666       mov Control_FSM_state, #0
0DE3           1667       
0DE3           1668       ; Force UI to State 0 (Home Screen)
0DE3 756100    1669       mov Current_State, #0
0DE6           1670       
0DE6           1671       ; Trigger Screen Refresh
0DE6 D20F      1672       setb state_change_signal          ; Tell loop to redraw "Welcome"
0DE8           1673   
0DE8           1674   Safety_TC_Done:
0DE8 D001      1675       pop  AR1
0DEA D000      1676       pop  AR0
0DEC D0D0      1677       pop  psw
0DEE D0E0      1678       pop  acc
0DF0 22        1679       ret
0DF1           1680   
0DF1           1681   ; ============================================================
0DF1           1682   ; BUZZER STARTUP FUNCTIONS
0DF1           1683   ; ============================================================
0DF1           1684   ;============================================================
0DF1           1685   ; Beep_Judge
0DF1           1686   ; Purpose: Trigger appropriate beep pattern based on events
0DF1           1687   ;   - Beep once when state changes
0DF1           1688   ;   - Beep five times when entering state 6 (cooling/finished)
0DF1           1689   ;   - Beep ten times if tc_missing_abort = 1 (error)
0DF1           1690   ;
0DF1           1691   ; Call this in main loop after Control_FSM
0DF1           1692   ;============================================================
0DF1           1693   Beep_Judge:
0DF1 C0E0      1694       push acc
0DF3 C0D0      1695       push psw
0DF5           1696   
0DF5           1697       ; --- Priority 1: Error condition (highest priority) ---
0DF5 30130A    1698       jnb tc_missing_abort, Beep_Judge_Check_State6
0DF8           1699       ; Error detected - beep 10 times (only once per error)
0DF8 20191B    1700       jb beep_error_done, Beep_Judge_Done   ; Already beeped for this error?
0DFB D219      1701       setb beep_error_done                   ; Mark as handled
0DFD 120E25    1702       lcall Beep_Ten
0E00 8014      1703       sjmp Beep_Judge_Done
0E02           1704   
0E02           1705   Beep_Judge_Check_State6:
0E02           1706       ; --- Priority 2: Entering State 6 (finished) ---
0E02 301211    1707       jnb state_change_beep_signal, Beep_Judge_Done  ; No state change? Exit
0E05           1708       
0E05 E560      1709       mov a, Control_FSM_state
0E07 B40607    1710       cjne a, #6, Beep_Judge_Normal_Change
0E0A           1711       ; Entering state 6 - beep 5 times
0E0A C212      1712       clr state_change_beep_signal               ; Consume the signal
0E0C 120E20    1713       lcall Beep_Five
0E0F 8005      1714       sjmp Beep_Judge_Done
0E11           1715   
0E11           1716   Beep_Judge_Normal_Change:
0E11           1717       ; --- Priority 3: Normal state change - beep once ---
0E11 C212      1718       clr state_change_beep_signal               ; Consume the signal
0E13 120E1B    1719       lcall Beep_Once
0E16           1720   
0E16           1721   Beep_Judge_Done:
0E16 D0D0      1722       pop psw
0E18 D0E0      1723       pop acc
0E1A 22        1724       ret
0E1B           1725   
0E1B           1726   Beep_Once:
0E1B 757501    1727       mov beep_count, #1
0E1E 800A      1728       sjmp Beep_Start
0E20           1729   
0E20           1730   Beep_Five:
0E20 757505    1731       mov beep_count, #5
0E23 8005      1732       sjmp Beep_Start
0E25           1733   
0E25           1734   Beep_Ten:
0E25 75750A    1735       mov beep_count, #10
0E28 8000      1736       sjmp Beep_Start      ; [FIX] Added explicit jump for safety
0E2A           1737   
0E2A           1738   Beep_Start:
0E2A C28C      1739       clr TR0              ; [FIX] Stop timer briefly to reset cleanly
0E2C 757601    1740       mov beep_state, #1   ; Set State to ON
0E2F 757700    1741       mov beep_tmr, #0     ; Reset Timer High Byte
0E32 757800    1742       mov beep_tmr+1, #0   ; Reset Timer Low Byte
0E35 D2A9      1743       setb ET0             ; [FIX] Ensure Interrupt is enabled
0E37 D28C      1744       setb TR0             ; START the 2kHz tone
0E39 22        1745       ret
0E3A           1746   ;-------------------------------------------------------------------------------
0E3A           1747   ; Buzzer beep Task 
0E3A           1748   ; Purpose: beeps, holds, stop
0E3A           1749   ; Buzzer task:
0E3A           1750   ; Beep once when state changes
0E3A           1751   ; Beep five times if finished
0E3A           1752   ; Beep ten times if meets error
0E3A           1753   ;============================================================
0E3A           1754   Beep_Task:
0E3A 301835    1755       jnb one_ms_beep_flag, Beep_Done
0E3D C218      1756       clr one_ms_beep_flag
0E3F           1757   
0E3F E576      1758       mov a, beep_state
0E41 602F      1759       jz Beep_Done
0E43           1760   
0E43           1761   ; ---- increment 16-bit timer ----
0E43 0577      1762       inc beep_tmr
0E45 E577      1763       mov a, beep_tmr
0E47 7002      1764       jnz Beep_Check
0E49 0578      1765       inc beep_tmr+1
0E4B           1766   
0E4B           1767   Beep_Check:
0E4B           1768       ; FUZZY TIMER CHECK
0E4B           1769       ; Check if High Byte is non-zero (Time >= 256ms)
0E4B E578      1770       mov a, beep_tmr+1
0E4D 6023      1771       jz Beep_Done        ; If 0, keep beeping
0E4F           1772   
0E4F           1773       ; --- Time Limit Reached ---
0E4F 757700    1774       mov beep_tmr, #0    ; Reset timer
0E52 757800    1775       mov beep_tmr+1, #0
0E55           1776   
0E55 E576      1777       mov a, beep_state
0E57 B40106    1778       cjne a, #1, Beep_Off_State
0E5A           1779   
0E5A           1780       ; State was 1 (ON) -> Turn OFF
0E5A C28C      1781       clr TR0             ; Hardware Silence
0E5C 757602    1782       mov beep_state, #2  ; Set State to OFF (Pause)
0E5F 22        1783       ret
0E60           1784   
0E60           1785   Beep_Off_State:
0E60           1786   ; ---- OFF finished -> decrement count / next ON ----
0E60 1575      1787       dec beep_count
0E62 E575      1788       mov a, beep_count
0E64 6006      1789       jz  Beep_Stop
0E66           1790   
0E66 757601    1791       mov beep_state, #1
0E69 D28C      1792       setb TR0
0E6B 22        1793       ret
0E6C           1794   
0E6C           1795   Beep_Stop:
0E6C C28C      1796       clr TR0
0E6E 757600    1797       mov beep_state, #0
0E71 22        1798       ret
0E72           1799   
0E72           1800   Beep_Done:
0E72 22        1801       ret
0E73           1802   ;-------------------------------------------------------------------------------;
0E73           1803   ; Main Control FSM for the entire process
0E73           1804   ;-------------------------------------------------------------------------------;
0E73           1805   Control_FSM:
0E73 E560      1806       mov a, Control_FSM_state
0E75 8008      1807       sjmp Control_FSM_state0
0E77           1808   
0E77           1809   Control_FSM_state0_a:
0E77 756000    1810            mov Control_FSM_state, #0
0E7A D20F      1811            setb state_change_signal
0E7C D210      1812            setb state_change_signal_TC
0E7E 22        1813            ret
0E7F           1814   Control_FSM_state0:
0E7F B40017    1815       cjne a, #0, Control_FSM_state1
0E82 C219      1816       clr beep_error_done
0E84 301504    1817       jnb PB0_flag, Control_FSM_state0_ret  ; Check flag
0E87 C215      1818       clr PB0_flag                 
0E89 8001      1819       sjmp Control_FSM_state1_a
0E8B           1820   Control_FSM_state0_ret:
0E8B 22        1821       ret
0E8C           1822   
0E8C           1823   Control_FSM_state1_a:
0E8C 756001    1824       mov Control_FSM_state, #1
0E8F 756100    1825       mov Current_State, #0
0E92 D20F      1826       setb state_change_signal
0E94 D210      1827            setb state_change_signal_TC
0E96 D212      1828       setb state_change_beep_signal
0E98 22        1829            ret
0E99           1830   Control_FSM_state1:
0E99 B40116    1831       cjne a, #1, Control_FSM_state2
0E9C 301504    1832       jnb PB0_flag, Control_FSM_state1_ret  ; Check flag
0E9F C215      1833       clr PB0_flag                    
0EA1 8001      1834       sjmp Control_FSM_state2_a
0EA3           1835   Control_FSM_state1_ret:
0EA3 22        1836       ret
0EA4           1837   
0EA4           1838   ; --- STATE 2: RAMP TO SOAK ---
0EA4           1839   Control_FSM_state2_a:
0EA4 756002    1840            mov Control_FSM_state, #2
0EA7 D20F      1841            setb state_change_signal
0EA9 D210      1842            setb state_change_signal_TC
0EAB D211      1843            setb state_change_signal_Count
0EAD D212      1844       setb state_change_beep_signal
0EAF C205      1845       clr soak_temp_reached
0EB1 22        1846            ret
0EB2           1847   Control_FSM_state2:
0EB2 B4021C    1848       cjne a, #2, Control_FSM_state3
0EB5 301705    1849       jnb PB2_flag, State2_Check
0EB8 C217      1850       clr PB2_flag
0EBA 020F1F    1851       ljmp Control_FSM_state6_a ; Pause
0EBD           1852   
0EBD           1853   State2_Check:
0EBD 300506    1854       jnb soak_temp_reached, State2_Ret
0EC0           1855       
0EC0           1856       ; --- Move to State 3 ---
0EC0 C205      1857       clr soak_temp_reached
0EC2 C208      1858       clr soak_time_reached
0EC4 8001      1859            sjmp Control_FSM_state3_a
0EC6           1860   State2_Ret:
0EC6 22        1861       ret
0EC7           1862   
0EC7           1863   ; --- STATE 3: SOAK PHASE ---
0EC7           1864   Control_FSM_state3_a:
0EC7 756003    1865            mov Control_FSM_state, #3
0ECA D20F      1866            setb state_change_signal
0ECC D210      1867            setb state_change_signal_TC
0ECE D212      1868       setb state_change_beep_signal
0ED0 22        1869            ret
0ED1           1870   Control_FSM_state3:
0ED1 B4031A    1871       cjne a, #3, Control_FSM_state4
0ED4 301705    1872       jnb PB2_flag, State3_Check
0ED7 C217      1873       clr PB2_flag
0ED9 020F1F    1874       ljmp Control_FSM_state6_a
0EDC           1875   State3_Check:
0EDC 300804    1876       jnb soak_time_reached, State3_Ret
0EDF C208      1877       clr soak_time_reached
0EE1 8001      1878       sjmp Control_FSM_state4_a
0EE3           1879   State3_Ret:
0EE3 22        1880       ret
0EE4           1881   
0EE4           1882   ; --- STATE 4: RAMP TO PEAK ---
0EE4           1883   Control_FSM_state4_a:
0EE4 756004    1884            mov Control_FSM_state, #4
0EE7 D20F      1885            setb state_change_signal
0EE9 D210      1886            setb state_change_signal_TC
0EEB D212      1887       setb state_change_beep_signal
0EED 22        1888            ret
0EEE           1889   Control_FSM_state4:
0EEE B4041C    1890       cjne a, #4, Control_FSM_state5
0EF1 301705    1891       jnb PB2_flag, State4_Check
0EF4 C217      1892       clr PB2_flag
0EF6 020F1F    1893       ljmp Control_FSM_state6_a
0EF9           1894   State4_Check:
0EF9 300606    1895       jnb reflow_temp_reached, State4_Ret
0EFC C206      1896       clr reflow_temp_reached
0EFE C209      1897       clr reflow_time_reached
0F00 8001      1898            sjmp Control_FSM_state5_a
0F02           1899   State4_Ret:
0F02 22        1900       ret
0F03           1901   
0F03           1902   ; --- STATE 5: REFLOW PHASE ---
0F03           1903   Control_FSM_state5_a:
0F03 756005    1904            mov Control_FSM_state, #5
0F06 D20F      1905            setb state_change_signal
0F08 D210      1906            setb state_change_signal_TC
0F0A D212      1907       setb state_change_beep_signal
0F0C 22        1908            ret
0F0D           1909   Control_FSM_state5:
0F0D B4051D    1910       cjne a, #5, Control_FSM_state6
0F10 301704    1911       jnb PB2_flag, State5_Check
0F13 C217      1912       clr PB2_flag
0F15 8008      1913       sjmp Control_FSM_state6_a
0F17           1914   State5_Check:
0F17 300904    1915       jnb reflow_time_reached, State5_Ret
0F1A C209      1916       clr reflow_time_reached
0F1C 8001      1917       sjmp Control_FSM_state6_a
0F1E           1918   State5_Ret:
0F1E 22        1919       ret
0F1F           1920   
0F1F           1921   ; --- STATE 6: COOLING ---
0F1F           1922   Control_FSM_state6_a:
0F1F 756006    1923            mov Control_FSM_state, #6
0F22 D20F      1924            setb state_change_signal
0F24 D210      1925            setb state_change_signal_TC
0F26 D211      1926            setb state_change_signal_Count
0F28 D212      1927       setb state_change_beep_signal
0F2A C207      1928       clr cooling_temp_reached
0F2C 22        1929            ret
0F2D           1930   Control_FSM_state6:
0F2D B40612    1931       cjne a, #6, Control_FSM_state7
0F30           1932       ; Wait for Cooling Temp Reached
0F30 300704    1933       jnb cooling_temp_reached, State6_Ret
0F33 C207      1934       clr cooling_temp_reached
0F35 8001      1935       sjmp Control_FSM_state7_a
0F37           1936   State6_Ret:
0F37 22        1937       ret
0F38           1938   
0F38           1939   ; --- STATE 7: DONE ---
0F38           1940   Control_FSM_state7_a:
0F38 756007    1941            mov Control_FSM_state, #7
0F3B D20F      1942            setb state_change_signal
0F3D D210      1943            setb state_change_signal_TC
0F3F D212      1944       setb state_change_beep_signal
0F41 22        1945            ret
0F42           1946   Control_FSM_state7:
0F42 B40708    1947       cjne a, #7, Control_FSM_done
0F45           1948       ; Let's assume you meant the physical button P1.0 like State 0
0F45 101502    1949       jbc PB0_flag, Control_FSM_state7_pressed
0F48 8003      1950            sjmp Control_FSM_done
0F4A           1951   Control_FSM_state7_pressed:
0F4A 020E77    1952       ljmp Control_FSM_state0_a
0F4D           1953   
0F4D           1954   Control_FSM_done:
0F4D 22        1955       ret
0F4E           1956   
0F4E           1957   ; ================================================================
0F4E           1958   ; UI & HELPER SUBROUTINES
0F4E           1959   ; ================================================================
0F4E           1960   
0F4E           1961   ; ----------------------------------------------------------------
0F4E           1962   ; MODULE: BRIDGE (Text to Integer Conversion)
0F4E           1963   ; ----------------------------------------------------------------
0F4E           1964   
0F4E           1965   ;--------------------------
0F4E           1966   ;keep updating varaibles
0F4E           1967   Update_FSM_Variables:
0F4E C0E0      1968            push ACC
0F50 C006      1969            push AR6
0F52 C007      1970            push AR7
0F54 E560      1971            mov a, Control_FSM_state
0F56 B40132    1972            cjne a, #1, Update_FSM_Variables_done
0F59           1973   
0F59           1974       ; --- 1. SOAK TEMP ---
0F59 7880      1975       mov R0, #Buf_Soak_Temp
0F5B 120F92    1976       lcall Parse_Temp_String
0F5E 8F4B      1977       mov soak_temp+0, R7
0F60 754C00    1978       mov soak_temp+1, #0
0F63 754D00    1979       mov soak_temp+2, #0
0F66 754E00    1980       mov soak_temp+3, #0
0F69           1981   
0F69           1982       ; --- 2. REFLOW TEMP ---
0F69 7889      1983       mov R0, #Buf_Refl_Temp
0F6B 120F92    1984       lcall Parse_Temp_String
0F6E 8F4F      1985       mov reflow_temp+0, R7
0F70 755000    1986       mov reflow_temp+1, #0
0F73 755100    1987       mov reflow_temp+2, #0
0F76 755200    1988       mov reflow_temp+3, #0
0F79           1989   
0F79           1990       ; --- 3. SOAK TIME ---
0F79 7884      1991       mov R0, #Buf_Soak_Time
0F7B 120FA6    1992       lcall Parse_Time_String
0F7E 8F33      1993       mov soak_time_minute, R7
0F80 8E32      1994       mov soak_time_sec, R6
0F82           1995   
0F82           1996       ; --- 4. REFLOW TIME ---
0F82 788D      1997       mov R0, #Buf_Refl_Time
0F84 120FA6    1998       lcall Parse_Time_String
0F87 8F35      1999       mov reflow_time_minute, R7
0F89 8E34      2000       mov reflow_time_sec, R6
0F8B           2001   
0F8B           2002   Update_FSM_Variables_done:
0F8B D007      2003            pop AR7
0F8D D006      2004            pop AR6
0F8F D0E0      2005            pop ACC
0F91 22        2006       ret
0F92           2007   ;--------------------------
0F92           2008   
0F92           2009   ; --- Helper: Parse "123" to Integer ---
0F92           2010   Parse_Temp_String:
0F92 7F00      2011       mov R7, #0              ; Clear Result
0F94           2012   Parse_Temp_Loop:
0F94 E6        2013       mov A, @R0
0F95 600E      2014       jz Parse_Temp_Done      ; If Null, we are done
0F97           2015       
0F97           2016       ; Convert ASCII to Digit
0F97 C3        2017       clr C
0F98 9430      2018       subb A, #0x30
0F9A FD        2019       mov R5, A               ; R5 = New Digit
0F9B           2020       
0F9B           2021       ; Result = (Result * 10) + New Digit
0F9B EF        2022       mov A, R7
0F9C 75F00A    2023       mov B, #10
0F9F A4        2024       mul AB
0FA0 2D        2025       add A, R5
0FA1 FF        2026       mov R7, A
0FA2           2027       
0FA2 08        2028       inc R0
0FA3 80EF      2029       sjmp Parse_Temp_Loop
0FA5           2030   Parse_Temp_Done:
0FA5 22        2031       ret
0FA6           2032   
0FA6           2033   ; --- Parse "MMSS" to ceconds ---
0FA6           2034   Parse_Time_String:
0FA6           2035       ; Minutes tens
0FA6 E6        2036       mov A, @R0
0FA7 C3        2037       clr C
0FA8 9430      2038       subb A, #0x30
0FAA 75F00A    2039       mov B, #10
0FAD A4        2040       mul AB
0FAE FD        2041       mov R5, A
0FAF 08        2042       inc R0
0FB0           2043   
0FB0           2044       ; Minutes ones
0FB0 E6        2045       mov A, @R0
0FB1 C3        2046       clr C
0FB2 9430      2047       subb A, #0x30
0FB4 2D        2048       add A, R5
0FB5 FD        2049       mov R5, A
0FB6 08        2050       inc R0
0FB7           2051   
0FB7           2052       ; Seconds tens
0FB7 E6        2053       mov A, @R0
0FB8 C3        2054       clr C
0FB9 9430      2055       subb A, #0x30
0FBB 75F00A    2056       mov B, #10
0FBE A4        2057       mul AB
0FBF FC        2058       mov R4, A
0FC0 08        2059       inc R0
0FC1           2060   
0FC1           2061       ; Seconds ones
0FC1 E6        2062       mov A, @R0
0FC2 C3        2063       clr C
0FC3 9430      2064       subb A, #0x30
0FC5 2C        2065       add A, R4
0FC6 FC        2066       mov R4, A
0FC7           2067   
0FC7           2068       ; Return minutes/seconds
0FC7 ED        2069            mov a, R5
0FC8 FF        2070       mov R7, a     ; minutes
0FC9 EC        2071            mov a, R4
0FCA FE        2072       mov R6, a     ; seconds
0FCB 22        2073       ret
0FCC           2074   
0FCC           2075   ; ----------------------------------------------------------------
0FCC           2076   ; MODULE: BUTTON HANDLER (Mode Selection)
0FCC           2077   ; ----------------------------------------------------------------
0FCC           2078   ; Blocking wrapper for LCD clear (keeps old behavior just for this)
0FCC           2079   Wait_25ms_BLOCKING:
0FCC 1211AA    2080       lcall Wait_25ms
0FCF 50FB      2081       jnc Wait_25ms_BLOCKING ; Keep jumping back until Done (C=1)
0FD1 22        2082       ret
0FD2           2083   
0FD2           2084   ; ----------------------------------------------------------------
0FD2           2085   ; MODULE: BUTTON HANDLER (Non-Blocking Debounce)
0FD2           2086   ; ----------------------------------------------------------------
0FD2           2087   ; Variables needed:
0FD2           2088   ;   BTN_DEB_state   - state machine state (0-3)
0FD2           2089   ;   BTN_DEB_timer   - debounce timer (incremented by ISR every 1ms)
0FD2           2090   ;   BTN_DEB_id      - which button was pressed (1-4)
0FD2           2091   ; ----------------------------------------------------------------
0FD2           2092   
0FD2           2093   Check_Buttons:
0FD2 C0E0      2094       push ACC
0FD4 C0D0      2095       push PSW
0FD6           2096       
0FD6           2097       ; Only process in Control_FSM_state 1
0FD6 E560      2098       mov a, Control_FSM_state
0FD8 B40107    2099       cjne a, #1, Check_Buttons_Done_bridge
0FDB           2100       
0FDB           2101       ; --- FORCE INPUT MODE ---
0FDB 438055    2102       orl P0, #055H   ; Sets P0.0, P0.2, P0.4, P0.6 to '1' (Input Mode)
0FDE           2103       
0FDE E57A      2104       mov a, BTN_DEB_state
0FE0 8003      2105       sjmp BTN_DEB_state0
0FE2           2106   
0FE2           2107   Check_Buttons_Done_bridge:
0FE2 02108C    2108       ljmp Check_Buttons_Done
0FE5           2109   
0FE5           2110   ; ============================================================
0FE5           2111   ; State 0: Wait for any button press
0FE5           2112   ; ============================================================
0FE5           2113   BTN_DEB_state0:
0FE5 B4002A    2114       cjne a, #0, BTN_DEB_state1
0FE8           2115       
0FE8           2116       ; Check each button, record which one was pressed
0FE8 30800C    2117       jnb BTN_SOAK_TEMP, BTN_Detect_SoakTemp
0FEB 30820E    2118       jnb BTN_SOAK_TIME, BTN_Detect_SoakTime
0FEE 308410    2119       jnb BTN_REFL_TEMP, BTN_Detect_ReflTemp
0FF1 308612    2120       jnb BTN_REFL_TIME, BTN_Detect_ReflTime
0FF4 02108C    2121       ljmp Check_Buttons_Done     ; No button pressed
0FF7           2122   
0FF7           2123   BTN_Detect_SoakTemp:
0FF7 757C01    2124       mov BTN_DEB_id, #1
0FFA 800F      2125       sjmp BTN_Start_Debounce
0FFC           2126   BTN_Detect_SoakTime:
0FFC 757C02    2127       mov BTN_DEB_id, #2
0FFF 800A      2128       sjmp BTN_Start_Debounce
1001           2129   BTN_Detect_ReflTemp:
1001 757C03    2130       mov BTN_DEB_id, #3
1004 8005      2131       sjmp BTN_Start_Debounce
1006           2132   BTN_Detect_ReflTime:
1006 757C04    2133       mov BTN_DEB_id, #4
1009 8000      2134       sjmp BTN_Start_Debounce
100B           2135   
100B           2136   BTN_Start_Debounce:
100B 757B00    2137       mov BTN_DEB_timer, #0
100E 057A      2138       inc BTN_DEB_state
1010 807A      2139       sjmp Check_Buttons_Done
1012           2140   
1012           2141   ; ============================================================
1012           2142   ; State 1: Debounce delay (wait 50ms)
1012           2143   ; ============================================================
1012           2144   BTN_DEB_state1:
1012 B40109    2145       cjne a, #1, BTN_DEB_state2
1015 E57B      2146       mov a, BTN_DEB_timer
1017 B43272    2147       cjne a, #50, Check_Buttons_Done   ; Wait 50ms
101A 057A      2148       inc BTN_DEB_state
101C 806E      2149       sjmp Check_Buttons_Done
101E           2150   
101E           2151   ; ============================================================
101E           2152   ; State 2: Verify button still pressed
101E           2153   ; ============================================================
101E           2154   BTN_DEB_state2:
101E B40226    2155       cjne a, #2, BTN_DEB_state3
1021           2156       
1021           2157       ; Check if the same button is still pressed
1021 E57C      2158       mov a, BTN_DEB_id
1023 B40105    2159       cjne a, #1, BTN_Verify_Check2
1026 30801A    2160       jnb BTN_SOAK_TEMP, BTN_Verify_OK
1029 8013      2161       sjmp BTN_Verify_Fail
102B           2162   BTN_Verify_Check2:
102B B40205    2163       cjne a, #2, BTN_Verify_Check3
102E 308212    2164       jnb BTN_SOAK_TIME, BTN_Verify_OK
1031 800B      2165       sjmp BTN_Verify_Fail
1033           2166   BTN_Verify_Check3:
1033 B40305    2167       cjne a, #3, BTN_Verify_Check4
1036 30840A    2168       jnb BTN_REFL_TEMP, BTN_Verify_OK
1039 8003      2169       sjmp BTN_Verify_Fail
103B           2170   BTN_Verify_Check4:
103B 308605    2171       jnb BTN_REFL_TIME, BTN_Verify_OK
103E           2172       ; Fall through to fail
103E           2173   
103E           2174   BTN_Verify_Fail:
103E 757A00    2175       mov BTN_DEB_state, #0           ; Was noise, reset
1041 8049      2176       sjmp Check_Buttons_Done
1043           2177   
1043           2178   BTN_Verify_OK:
1043 057A      2179       inc BTN_DEB_state               ; Confirmed, wait for release
1045 8045      2180       sjmp Check_Buttons_Done
1047           2181   
1047           2182   ; ============================================================
1047           2183   ; State 3: Wait for button release, then trigger action
1047           2184   ; ============================================================
1047           2185   BTN_DEB_state3:
1047 B40342    2186       cjne a, #3, Check_Buttons_Done
104A           2187       
104A           2188       ; Check if the button is released
104A E57C      2189       mov a, BTN_DEB_id
104C B40105    2190       cjne a, #1, BTN_Release_Check2
104F 30803A    2191       jnb BTN_SOAK_TEMP, Check_Buttons_Done   ; Still pressed, wait
1052 8013      2192       sjmp BTN_Do_Action
1054           2193   BTN_Release_Check2:
1054 B40205    2194       cjne a, #2, BTN_Release_Check3
1057 308232    2195       jnb BTN_SOAK_TIME, Check_Buttons_Done
105A 800B      2196       sjmp BTN_Do_Action
105C           2197   BTN_Release_Check3:
105C B40305    2198       cjne a, #3, BTN_Release_Check4
105F 30842A    2199       jnb BTN_REFL_TEMP, Check_Buttons_Done
1062 8003      2200       sjmp BTN_Do_Action
1064           2201   BTN_Release_Check4:
1064 308625    2202       jnb BTN_REFL_TIME, Check_Buttons_Done
1067           2203       ; Fall through to action
1067           2204   
1067           2205   ; ============================================================
1067           2206   ; Button Released - Execute Action
1067           2207   ; ============================================================
1067           2208   BTN_Do_Action:
1067 E57C      2209       mov a, BTN_DEB_id
1069           2210       
1069 B40105    2211       cjne a, #1, BTN_Action_2
106C 756101    2212       mov Current_State, #1           ; Soak Temp
106F 8013      2213       sjmp BTN_Action_Complete
1071           2214   BTN_Action_2:
1071 B40205    2215       cjne a, #2, BTN_Action_3
1074 756102    2216       mov Current_State, #2           ; Soak Time
1077 800B      2217       sjmp BTN_Action_Complete
1079           2218   BTN_Action_3:
1079 B40305    2219       cjne a, #3, BTN_Action_4
107C 756103    2220       mov Current_State, #3           ; Refl Temp
107F 8003      2221       sjmp BTN_Action_Complete
1081           2222   BTN_Action_4:
1081 756104    2223       mov Current_State, #4           ; Refl Time
1084           2224   
1084           2225   BTN_Action_Complete:
1084 756A00    2226       mov Cursor_Idx, #0
1087 D224      2227       setb fullscreen_update_signal   ; Trigger screen redraw
1089 757A00    2228       mov BTN_DEB_state, #0           ; Reset state machine
108C           2229   
108C           2230   Check_Buttons_Done:
108C D0D0      2231       pop PSW
108E D0E0      2232       pop ACC
1090 22        2233       ret
1091           2234   ; ----------------------------------------------------------------
1091           2235   ; MODULE: KEYPAD HANDLER (Input Logic)
1091           2236   ; ----------------------------------------------------------------
1091           2237   Check_Keypad:
1091 E560      2238       mov a, Control_FSM_state
1093 B40152    2239       cjne a, #1, Keypad_Exit
1096           2240   
1096           2241       ; If State is 0 (Home), ignore keypad
1096 E561      2242       mov A, Current_State
1098 604E      2243       jz Keypad_Exit
109A           2244       
109A 1210E9    2245       lcall Keypad_Scan
109D 5049      2246       jnc Keypad_Exit         ; Carry = 0 means no key pressed
109F           2247   
109F EF        2248       mov A, R7
10A0 B40E09    2249       cjne A, #14, Check_Hash ; 14 is Star (*)
10A3           2250       
10A3 1211ED    2251       lcall Reset_Current_Buffer
10A6 D224      2252       setb fullscreen_update_signal
10A8 756A00    2253       mov Cursor_Idx, #0
10AB 22        2254       ret
10AC           2255   
10AC           2256   Check_Hash:
10AC EF        2257       mov A, R7
10AD B40C01    2258       cjne A, #12, Check_Numeric 
10B0 22        2259       ret                
10B1           2260   
10B1           2261   Check_Numeric:
10B1           2262       ; Ensure key is 0-9
10B1 EF        2263       mov A, R7
10B2 C3        2264       clr C
10B3 940A      2265       subb A, #10
10B5 5030      2266       jnc Symbol_Key_Ignored
10B7           2267       
10B7           2268       ; Convert to ASCII
10B7 EF        2269       mov A, R7
10B8 2430      2270       add A, #0x30
10BA FD        2271       mov R5, A
10BB           2272   
10BB           2273       ;save to Buffer
10BB 120B25    2274       lcall Get_Current_Buffer_Addr
10BE E56A      2275       mov A, Cursor_Idx
10C0 28        2276       add A, R0
10C1 F8        2277       mov R0, A
10C2 ED        2278       mov A, R5
10C3 F6        2279       mov @R0, A
10C4 056A      2280       inc Cursor_Idx
10C6           2281   
10C6           2282       ;Check cursor limits ---
10C6 E561      2283       mov A, Current_State
10C8 B40102    2284       cjne A, #1, Check_Limit_Time_1
10CB 8005      2285       sjmp Limit_Temp_3
10CD           2286   
10CD           2287   Check_Limit_Time_1:
10CD B4030B    2288       cjne A, #3, Limit_Time_4
10D0 8000      2289       sjmp Limit_Temp_3
10D2           2290   
10D2           2291   Limit_Temp_3:
10D2 E56A      2292       mov A, Cursor_Idx
10D4 B4030D    2293       cjne A, #3, Do_Refresh
10D7 156A      2294       dec Cursor_Idx          
10D9 8009      2295       sjmp Do_Refresh
10DB           2296   
10DB           2297   Limit_Time_4:
10DB E56A      2298       mov A, Cursor_Idx
10DD B40404    2299       cjne A, #4, Do_Refresh
10E0 156A      2300       dec Cursor_Idx         
10E2 8000      2301       sjmp Do_Refresh
10E4           2302   
10E4           2303   Do_Refresh:
10E4 D224      2304       setb fullscreen_update_signal
10E6 22        2305       ret
10E7           2306   
10E7           2307   Symbol_Key_Ignored:
10E7 22        2308       ret
10E8           2309   Keypad_Exit:
10E8 22        2310       ret
10E9           2311   
10E9           2312   ;-------------------------------------------------------------------------------
10E9           2313   ; hardware
10E9           2314   ;-------------------------------------------------------------------------------
10E9           2315   Keypad_Scan:
10E9 C292      2316       clr ROW1
10EB C294      2317       clr ROW2
10ED C296      2318       clr ROW3
10EF C2A0      2319       clr ROW4
10F1 A2A2      2320       mov C, COL1
10F3 82A4      2321       anl C, COL2
10F5 82A6      2322       anl C, COL3
10F7 82B0      2323       anl C, COL4
10F9 5002      2324       jnc Keypad_Debounce
10FB C3        2325       clr C
10FC 22        2326       ret
10FD           2327   
10FD           2328   Keypad_Debounce:
10FD 120FCC    2329       lcall Wait_25ms_BLOCKING
1100 A2A2      2330       mov C, COL1
1102 82A4      2331       anl C, COL2
1104 82A6      2332       anl C, COL3
1106 82B0      2333       anl C, COL4
1108 5002      2334       jnc Keypad_Find_Row
110A C3        2335       clr C
110B 22        2336       ret
110C           2337   
110C           2338   Keypad_Find_Row:
110C D292      2339       setb ROW1
110E D294      2340       setb ROW2
1110 D296      2341       setb ROW3
1112 D2A0      2342       setb ROW4
1114           2343   
1114           2344       ; Row 1
1114 C292      2345       clr ROW1
1116 30A23D    2346       jnb COL1, Keypad_Key_1
1119 30A43E    2347       jnb COL2, Keypad_Key_2
111C 30A63F    2348       jnb COL3, Keypad_Key_3
111F 30B040    2349       jnb COL4, Keypad_Key_A
1122 D292      2350       setb ROW1
1124           2351   
1124           2352       ; Row 2
1124 C294      2353       clr ROW2
1126 30A23D    2354       jnb COL1, Keypad_Key_4
1129 30A43E    2355       jnb COL2, Keypad_Key_5
112C 30A63F    2356       jnb COL3, Keypad_Key_6
112F 30B040    2357       jnb COL4, Keypad_Key_B
1132 D294      2358       setb ROW2
1134           2359   
1134           2360       ; Row 3
1134 C296      2361       clr ROW3
1136 30A23D    2362       jnb COL1, Keypad_Key_7
1139 30A43E    2363       jnb COL2, Keypad_Key_8
113C 30A63F    2364       jnb COL3, Keypad_Key_9
113F 30B040    2365       jnb COL4, Keypad_Key_C
1142 D296      2366       setb ROW3
1144           2367   
1144           2368       ; Row 4
1144 C2A0      2369       clr ROW4
1146 30A23D    2370       jnb COL1, Keypad_Key_Star
1149 30A43E    2371       jnb COL2, Keypad_Key_0
114C 30A63F    2372       jnb COL3, Keypad_Key_Hash
114F 30B040    2373       jnb COL4, Keypad_Key_D
1152 D2A0      2374       setb ROW4
1154 C3        2375       clr C
1155 22        2376       ret
1156           2377   
1156           2378   ; Key Mapping
1156 7F01      2379   Keypad_Key_1: mov R7, #1
1158 803C      2380          sjmp Wait_Release
115A 7F02      2381   Keypad_Key_2: mov R7, #2
115C 8038      2382          sjmp Wait_Release
115E 7F03      2383   Keypad_Key_3: mov R7, #3
1160 8034      2384          sjmp Wait_Release
1162 7F0A      2385   Keypad_Key_A: mov R7, #10
1164 8030      2386          sjmp Wait_Release
1166 7F04      2387   Keypad_Key_4: mov R7, #4
1168 802C      2388          sjmp Wait_Release
116A 7F05      2389   Keypad_Key_5: mov R7, #5
116C 8028      2390          sjmp Wait_Release
116E 7F06      2391   Keypad_Key_6: mov R7, #6
1170 8024      2392          sjmp Wait_Release
1172 7F0B      2393   Keypad_Key_B: mov R7, #11
1174 8020      2394          sjmp Wait_Release
1176 7F07      2395   Keypad_Key_7: mov R7, #7
1178 801C      2396          sjmp Wait_Release
117A 7F08      2397   Keypad_Key_8: mov R7, #8
117C 8018      2398          sjmp Wait_Release
117E 7F09      2399   Keypad_Key_9: mov R7, #9
1180 8014      2400          sjmp Wait_Release
1182 7F0D      2401   Keypad_Key_C: mov R7, #13
1184 8010      2402          sjmp Wait_Release
1186 7F0E      2403   Keypad_Key_Star: mov R7, #14
1188 800C      2404          sjmp Wait_Release
118A 7F00      2405   Keypad_Key_0: mov R7, #0
118C 8008      2406          sjmp Wait_Release
118E 7F0C      2407   Keypad_Key_Hash: mov R7, #12
1190 8004      2408          sjmp Wait_Release
1192 7F0F      2409   Keypad_Key_D: mov R7, #15
1194 8000      2410          sjmp Wait_Release
1196           2411   
1196           2412   Wait_Release:
1196 A2A2      2413       mov C, COL1
1198 82A4      2414       anl C, COL2
119A 82A6      2415       anl C, COL3
119C 82B0      2416       anl C, COL4
119E 50F6      2417       jnc Wait_Release
11A0 D3        2418       setb C
11A1 D292      2419       setb ROW1
11A3 D294      2420       setb ROW2
11A5 D296      2421       setb ROW3
11A7 D2A0      2422       setb ROW4
11A9 22        2423       ret
11AA           2424   
11AA           2425   Wait_25ms:
11AA           2426       ; 1. Check if we are already waiting
11AA 201A0E    2427       jb wait25_active, Check_Timer_Status
11AD           2428       
11AD           2429       ; 2. Check if we just finished
11AD 301B04    2430       jnb wait25_done, Start_New_Timer
11B0           2431       
11B0           2432       ; 3. Timer is done
11B0 C21B      2433       clr wait25_done
11B2 D3        2434       setb C          ; Carry = 1 means done
11B3 22        2435       ret
11B4           2436   
11B4           2437   Start_New_Timer:
11B4           2438       ; 4. Start a new 25ms wait
11B4 755700    2439       mov wait25_count, #0
11B7 D21A      2440       setb wait25_active
11B9 C3        2441       clr C           ; Carry = 0 means not yet
11BA 22        2442       ret
11BB           2443   
11BB           2444   Check_Timer_Status:
11BB           2445       ; 5. Still waiting... return False immediately
11BB C3        2446       clr C           ; Carry = 0 means "Not Done Yet"
11BC 22        2447       ret
11BD           2448   
11BD           2449   ;-------------------------------------------------------------------------------
11BD           2450   ; reset logic
11BD           2451   ;-------------------------------------------------------------------------------
11BD           2452   Init_All_Buffers:
11BD 7880      2453       mov R0, #Buf_Soak_Temp
11BF 1211D2    2454       lcall Init_Temp_Template
11C2 7889      2455       mov R0, #Buf_Refl_Temp
11C4 1211D2    2456       lcall Init_Temp_Template
11C7 7884      2457       mov R0, #Buf_Soak_Time
11C9 1211DE    2458       lcall Init_Time_Template
11CC 788D      2459       mov R0, #Buf_Refl_Time
11CE 1211DE    2460       lcall Init_Time_Template
11D1 22        2461       ret
11D2           2462   
11D2           2463   Init_Temp_Template:
11D2 7630      2464       mov @R0, #'0'
11D4 08        2465       inc R0
11D5 7630      2466       mov @R0, #'0'
11D7 08        2467       inc R0
11D8 7630      2468       mov @R0, #'0'
11DA 08        2469       inc R0
11DB 7600      2470       mov @R0, #0
11DD 22        2471       ret
11DE           2472   
11DE           2473   Init_Time_Template:
11DE 7630      2474       mov @R0, #'0'
11E0 08        2475       inc R0
11E1 7630      2476       mov @R0, #'0'
11E3 08        2477       inc R0
11E4 7630      2478       mov @R0, #'0'
11E6 08        2479       inc R0
11E7 7630      2480       mov @R0, #'0'
11E9 08        2481       inc R0
11EA 7600      2482       mov @R0, #0
11EC 22        2483       ret
11ED           2484   
11ED           2485   Reset_Current_Buffer:
11ED E561      2486       mov A, Current_State
11EF B40106    2487       cjne A, #1, Reset_Chk_2
11F2 7880      2488       mov R0, #Buf_Soak_Temp
11F4 1211D2    2489       lcall Init_Temp_Template
11F7 22        2490       ret
11F8           2491   Reset_Chk_2:
11F8 B40206    2492       cjne A, #2, Reset_Chk_3
11FB 7884      2493       mov R0, #Buf_Soak_Time
11FD 1211DE    2494       lcall Init_Time_Template
1200 22        2495       ret
1201           2496   Reset_Chk_3:
1201 B40306    2497       cjne A, #3, Reset_Chk_4
1204 7889      2498       mov R0, #Buf_Refl_Temp
1206 1211D2    2499       lcall Init_Temp_Template
1209 22        2500       ret
120A           2501   Reset_Chk_4:
120A 788D      2502       mov R0, #Buf_Refl_Time
120C 1211DE    2503       lcall Init_Time_Template
120F 22        2504       ret 
1210           2505       
1210           2506   ; ================================================================
1210           2507   ; MODULE: THERMOCOUPLE ADC DRIVER (WITH NOISE SUPPRESSION & JUMP FIX)
1210           2508   ; ================================================================
1210           2509   Read_Thermocouple:
1210 1211AA    2510       lcall Wait_25ms
1213 4001      2511       jc Proceed_Reading
1215 22        2512       ret 
1216           2513   
1216           2514   Proceed_Reading:
1216 E588      2515       mov A, TCON      
1218 5410      2516       anl A, #0x10    
121A C0E0      2517       push acc         
121C C28C      2518       clr TR0         
121E           2519   
121E 75A180    2520       mov ADC_C, #0x80    
1221 00        2521       nop
1222 00        2522       nop
1223 75A101    2523       mov ADC_C, #0x01   
1226           2524       
1226 7DFA      2525       mov R5, #250
1228           2526   ADC_Settle_Loop:
1228 00        2527       nop
1229 00        2528       nop
122A DDFC      2529       djnz R5, ADC_Settle_Loop
122C           2530       
122C 85A23A    2531       mov x+0, ADC_L
122F 85A33B    2532       mov x+1, ADC_H
1232 753C00    2533       mov x+2, #0
1235 753D00    2534       mov x+3, #0
1238           2535       
1238 E53B      2536       mov a, x+1
123A 540F      2537       anl a, #0x0F
123C F53B      2538       mov x+1, a
123E           2539       
123E D0E0      2540       pop acc         
1240 6002      2541       jz Skip_Restore 
1242 D28C      2542       setb TR0       
1244           2543   Skip_Restore:
1244           2544   
1244           2545            ; as per our volatge reference (measured using the DMM)
1244 753E16    2546            mov y+0, #low (4118 % 0x10000) 
1247 753F10    2546            mov y+1, #high(4118 % 0x10000) 
124A 754000    2546            mov y+2, #low (4118 / 0x10000) 
124D 754100    2546            mov y+3, #high(4118 / 0x10000) 
1250 12018C    2547       lcall mul32       
1253           2548   
1253 75A104    2549       mov ADC_C, #0x04   
1256 85A23E    2550       mov y+0, ADC_L      
1259 85A33F    2551       mov y+1, ADC_H      
125C 754000    2552       mov y+2, #0
125F 754100    2553       mov y+3, #0
1262 75A100    2554       mov ADC_C, #0x00   
1265           2555       
1265 120280    2556       lcall div32         
1268 753E64    2557            mov y+0, #low (100 % 0x10000) 
126B 753F00    2557            mov y+1, #high(100 % 0x10000) 
126E 754000    2557            mov y+2, #low (100 / 0x10000) 
1271 754100    2557            mov y+3, #high(100 / 0x10000) 
1274 12018C    2558       lcall mul32
1277 753E2B    2559            mov y+0, #low (1323 % 0x10000) 
127A 753F05    2559            mov y+1, #high(1323 % 0x10000) 
127D 754000    2559            mov y+2, #low (1323 / 0x10000) 
1280 754100    2559            mov y+3, #high(1323 / 0x10000)  ;using our amplifiers resistance ratio and 41uV   
1283 120280    2560       lcall div32    
1286 753E14    2561            mov y+0, #low (COLD_JUNCTION_TEMP % 0x10000) 
1289 753F00    2561            mov y+1, #high(COLD_JUNCTION_TEMP % 0x10000) 
128C 754000    2561            mov y+2, #low (COLD_JUNCTION_TEMP / 0x10000) 
128F 754100    2561            mov y+3, #high(COLD_JUNCTION_TEMP / 0x10000) 
1292 1200D3    2562       lcall add32     
1295           2563       
1295 853A47    2564       mov current_temp+0, x+0
1298 853B48    2565       mov current_temp+1, x+1
129B 853C49    2566       mov current_temp+2, x+2
129E 853D4A    2567       mov current_temp+3, x+3
12A1           2568   
12A1 22        2569       ret
12A2           2570       
12A2           2571   ;-------------------------------------------------------------------------------
12A2           2572   ; power control
12A2           2573   ;-------------------------------------------------------------------------------
12A2           2574   Power_Control:
12A2 755800    2575       mov power_output+0, #0
12A5 755900    2576       mov power_output+1, #0
12A8 755A00    2577       mov power_output+2, #0
12AB 755B00    2578       mov power_output+3, #0
12AE           2579   
12AE E560      2580       mov a, Control_FSM_state
12B0           2581   
12B0           2582       ; --- State 2: RAMP TO SOAK ---
12B0 B40202    2583       cjne a, #2, PC_Check_Soak
12B3 8016      2584       sjmp Set_Max_Power
12B5           2585   
12B5           2586   PC_Check_Soak:
12B5           2587       ; --- State 3: SOAK PHASE ---
12B5 B40305    2588       cjne a, #3, PC_Check_Ramp_Reflow
12B8 20050F    2589       jb soak_temp_reached, PC_Done 
12BB 801B      2590       sjmp Set_20_Percent_Power     
12BD           2591   
12BD           2592   PC_Check_Ramp_Reflow:
12BD           2593       ; --- State 4: RAMP TO REFLOW ---
12BD B40402    2594       cjne a, #4, PC_Check_Reflow
12C0 8009      2595       sjmp Set_Max_Power
12C2           2596   
12C2           2597   PC_Check_Reflow:
12C2           2598       ; --- State 5: REFLOW PHASE ---
12C2 B40505    2599       cjne a, #5, PC_Done
12C5 200602    2600       jb reflow_temp_reached, PC_Done
12C8 800E      2601       sjmp Set_20_Percent_Power
12CA           2602   
12CA           2603   PC_Done:
12CA 22        2604       ret
12CB           2605   
12CB           2606   Set_Max_Power:
12CB           2607       ; Load 1500 (0x05DC) = 100% Duty Cycle
12CB 7558DC    2608       mov power_output+0, #0xDC
12CE 755905    2609       mov power_output+1, #0x05
12D1 755A00    2610       mov power_output+2, #0
12D4 755B00    2611       mov power_output+3, #0
12D7 22        2612       ret
12D8           2613   
12D8           2614   Set_20_Percent_Power:
12D8           2615       ; Load 300 (0x012C) = 20% Duty Cycle
12D8 75582C    2616       mov power_output+0, #0x2C
12DB 755901    2617       mov power_output+1, #0x01
12DE 755A00    2618       mov power_output+2, #0
12E1 755B00    2619       mov power_output+3, #0
12E4 22        2620       ret
12E5           2621   ;--------------------------------------------------------------
12E5           2622   ; set servo angle according to the state
12E5           2623   ; call servo control function every 1ms
12E5           2624   ;--------------------------------------------------------------
12E5           2625   call_servo_control:
12E5           2626            ; check current state and change servo angle
12E5 E560      2627            mov a, Control_FSM_state
12E7           2628            
12E7           2629            ; handle state 0
12E7 B40004    2630            cjne a, #0, servo_state1
12EA C227      2631            clr servo_angle_zero ; close door at state 0
12EC 802C      2632            sjmp check_servo_flag
12EE           2633   
12EE           2634            ; handle state 1
12EE           2635            servo_state1:
12EE B40104    2636            cjne a, #1, servo_state2
12F1 D227      2637            setb servo_angle_zero ; open door at state 1
12F3 8025      2638            sjmp check_servo_flag
12F5           2639   
12F5           2640            ; handle state 2
12F5           2641            servo_state2:
12F5 B40204    2642            cjne a, #2, servo_state3
12F8 C227      2643            clr servo_angle_zero ; close door at state 2
12FA 801E      2644            sjmp check_servo_flag
12FC           2645   
12FC           2646            ; handle state 3
12FC           2647            servo_state3:
12FC B40304    2648            cjne a, #3, servo_state4
12FF C227      2649            clr servo_angle_zero ; close door at state 3
1301 8017      2650            sjmp check_servo_flag
1303           2651   
1303           2652            ; handle state 4
1303           2653            servo_state4:
1303 B40404    2654            cjne a, #4, servo_state5
1306 C227      2655            clr servo_angle_zero ; close door at state 4
1308 8010      2656            sjmp check_servo_flag
130A           2657   
130A           2658            ; handle state 5
130A           2659            servo_state5:
130A B40504    2660            cjne a, #5, servo_state6
130D C227      2661            clr servo_angle_zero ; close door at state 5
130F 8009      2662            sjmp check_servo_flag
1311           2663   
1311           2664            ; handle state 6
1311           2665            servo_state6:
1311 B40604    2666            cjne a, #6, servo_state7
1314 C227      2667            clr servo_angle_zero ; close door at state 6
1316 8002      2668            sjmp check_servo_flag
1318           2669   
1318           2670            ; handle state 7
1318           2671            servo_state7:
1318 D227      2672            setb servo_angle_zero ; open door at state 7
131A           2673   
131A           2674   check_servo_flag:
131A           2675            ; check 1 ms flag
131A 102601    2676            jbc one_millisecond_flag_servo, run_servo_control
131D 22        2677            ret
131E           2678   
131E           2679   run_servo_control:
131E 121322    2680            lcall servo_control
1321 22        2681            ret
1322           2682   
1322           2683   ;---------------------------------------------------------------
1322           2684   ; servo control
1322           2685   ; generate a 20 ms period pwm signal to control the servo motor
1322           2686   ; able to make the servo motor stay at 0 degree and 180 degree
1322           2687   ;---------------------------------------------------------------
1322           2688   servo_control:
1322 D2ED      2689       setb LEDRA.5
1324 C0E0      2690            push acc
1326 C0D0      2691            push psw
1328 E579      2692            mov a, servo_pwm_counter ; move servo counter to accumulator
132A 04        2693            inc A ; a += 1
132B B41402    2694            cjne a, #SERVO_PERIOD, servo_pwm_angle_compare ; jump if wrapup not needed
132E 7400      2695            mov a, #0
1330           2696   
1330           2697   servo_pwm_angle_compare: ; read target angle
1330 F579      2698            mov servo_pwm_counter, A
1332 202709    2699            jb servo_angle_zero, set_zero_degree ; set servo motor to 0 degree
1335           2700            ; set servo motor to 180 degrees
1335 E579      2701            mov a, servo_pwm_counter
1337 C3        2702            clr c
1338 9402      2703            subb a, #SERVO_180
133A 400B      2704            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 180 degrees duty cycle
133C 800D      2705            sjmp servo_pwm_set_low ; set low if greater
133E           2706   
133E           2707   set_zero_degree:
133E           2708            ; set servo motor to 0 degree
133E E579      2709            mov a, servo_pwm_counter
1340 C3        2710            clr c
1341 9401      2711            subb a, #SERVO_0
1343 4002      2712            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 0 degrees duty cycle
1345 8004      2713            sjmp servo_pwm_set_low ; set low if greater
1347           2714   
1347           2715   servo_pwm_set_high:
1347           2716            ; set pwm pin high
1347 D2B6      2717            setb SERVO_OUT
1349 8002      2718            sjmp servo_control_done
134B           2719   
134B           2720   servo_pwm_set_low:
134B           2721            ; set pwm pin low
134B C2B6      2722            clr SERVO_OUT
134D           2723   
134D           2724   servo_control_done:
134D D0D0      2725            pop psw
134F D0E0      2726            pop acc
1351 22        2727            ret
1352           2728   
1352           2729   ;-------------------------------------------------------------------------------
1352           2730   ; power_control
1352           2731   ;-------------------------------------------------------------------------------
1352           2732   ; Determine the power output based on current state and current temperature 
1352           2733   ; input parameter: Control_FSM_state
1352           2734   ;-------------------------------------------------------------------------------
1352           2735   ; Update LED indicators based on power_output
1352           2736   ; 0%  -> all off
1352           2737   ; <50% -> LED_LEFT on
1352           2738   ; 50%-99% -> LED_LEFT + LED_MID on
1352           2739   ; >=100% -> LED_LEFT + LED_MID + LED_RIGHT on
1352           2740   Update_Power_LEDs:
1352           2741       ; Check for exact 0 (all bytes zero)
1352 E558      2742       mov a, power_output
1354 4559      2743       orl a, power_output+1
1356 455A      2744       orl a, power_output+2
1358 455B      2745       orl a, power_output+3
135A 6032      2746       jz power_leds_low
135C           2747   
135C 85583A    2748       mov x, power_output
135F 85593B    2749       mov x+1, power_output+1
1362 855A3C    2750       mov x+2, power_output+2
1365 855B3D    2751       mov x+3, power_output+3
1368           2752   
1368 753EEE    2753            mov y+0, #low (HALF_POWER % 0x10000) 
136B 753F02    2753            mov y+1, #high(HALF_POWER % 0x10000) 
136E 754000    2753            mov y+2, #low (HALF_POWER / 0x10000) 
1371 754100    2753            mov y+3, #high(HALF_POWER / 0x10000) 
1374 12011A    2754       lcall x_lt_y
1377 200014    2755       jb mf, power_leds_low
137A           2756   
137A 753EDC    2757            mov y+0, #low (MAX_POWER % 0x10000) 
137D 753F05    2757            mov y+1, #high(MAX_POWER % 0x10000) 
1380 754000    2757            mov y+2, #low (MAX_POWER / 0x10000) 
1383 754100    2757            mov y+3, #high(MAX_POWER / 0x10000) 
1386 12011A    2758       lcall x_lt_y
1389 200009    2759       jb mf, power_leds_mid
138C           2760   
138C 800E      2761       sjmp power_leds_high
138E           2762   
138E           2763   power_leds_low:
138E C2B4      2764       clr  LED_LEFT
1390 C2B3      2765       clr  LED_MID
1392 C2B2      2766       clr  LED_RIGHT
1394 22        2767       ret
1395           2768   
1395           2769   power_leds_mid:
1395 D2B4      2770       setb LED_LEFT
1397 C2B3      2771       clr LED_MID
1399 C2B2      2772       clr  LED_RIGHT
139B 22        2773       ret
139C           2774   
139C           2775   power_leds_high:
139C D2B4      2776       setb LED_LEFT
139E D2B3      2777       setb LED_MID
13A0 D2B2      2778       setb LED_RIGHT
13A2 22        2779       ret
13A3           2780   
13A3           2781   proportional_power_control:
13A3 E560      2782            mov a, Control_FSM_state
13A5           2783   
13A5           2784   state0_power_control:
13A5           2785            ; idle
13A5           2786            ; 0% power
13A5 B40012    2787            cjne a, #0, state1_power_control
13A8 755800    2788            mov power_output, #low(NO_POWER)
13AB 755900    2789            mov power_output+1, #low(NO_POWER)
13AE 755A00    2790            mov power_output+2, #0
13B1 755B00    2791            mov power_output+3, #0
13B4 12138E    2792       lcall power_leds_low
13B7 0215A8    2793            ljmp power_control_done
13BA           2794   
13BA           2795   state1_power_control:
13BA           2796            ; idle
13BA           2797            ; 0% power
13BA B40112    2798            cjne a, #1, state2_power_control
13BD 755800    2799            mov power_output, #low(NO_POWER)
13C0 755900    2800            mov power_output+1, #low(NO_POWER)
13C3 755A00    2801            mov power_output+2, #0
13C6 755B00    2802            mov power_output+3, #0
13C9 12138E    2803       lcall power_leds_low
13CC 0215A8    2804            ljmp power_control_done
13CF           2805            
13CF           2806   state2_power_control:
13CF           2807            ; ramp to soak, ramp to ~150C
13CF           2808            ; 100% power
13CF B40253    2809            cjne a, #2, state3_power_control
13D2           2810       
13D2 854B3A    2811       mov x, soak_temp
13D5 854C3B    2812       mov x+1, soak_temp+1
13D8 854D3C    2813       mov x+2, soak_temp+2
13DB 854E3D    2814       mov x+3, soak_temp+3
13DE 753E05    2815            mov y+0, #low (5 % 0x10000) 
13E1 753F00    2815            mov y+1, #high(5 % 0x10000) 
13E4 754000    2815            mov y+2, #low (5 / 0x10000) 
13E7 754100    2815            mov y+3, #high(5 / 0x10000) 
13EA 1200F6    2816       lcall sub32 
13ED           2817       ; now x holds soak_temp-5
13ED           2818       ; turn power to 20% when current_temp > soak_temp-5
13ED           2819   
13ED 85473E    2820       mov y, current_temp
13F0 85483F    2821       mov y+1, current_temp+1
13F3 854940    2822       mov y+2, current_temp+2
13F6 854A41    2823       mov y+3, current_temp+3
13F9           2824   
13F9 C200      2825       clr mf
13FB 120178    2826       lcall x_gteq_y
13FE           2827       
13FE 100012    2828       jbc mf, state_2_full_power ; turn on full power when current_temp <= soak_temp-5
1401           2829       ; turn on 20% power when current_temp > soak_temp-5
1401 75582C    2830       mov power_output, #low(BASE_POWER)
1404 755901    2831       mov power_output+1, #high(BASE_POWER)
1407 755A00    2832       mov power_output+2, #0
140A 755B00    2833       mov power_output+3, #0
140D 121395    2834       lcall power_leds_mid
1410 0215A8    2835       ljmp power_control_done
1413           2836   
1413           2837   state_2_full_power:
1413 7558DC    2838            mov power_output, #low(MAX_POWER)
1416 755905    2839            mov power_output+1, #high(MAX_POWER)
1419 755A00    2840            mov power_output+2, #0
141C 755B00    2841            mov power_output+3, #0
141F 12139C    2842       lcall power_leds_high
1422 0215A8    2843            ljmp power_control_done
1425           2844   
1425           2845   state3_power_control:
1425           2846            ; soak period, hold at 150C
1425           2847            ; 20% base power + proportional calculated power
1425 B40305    2848            cjne a, #3, jump_state4_power_control
1428 121395    2849       lcall power_leds_mid
142B 8003      2850            sjmp state3_power_control_calculation
142D           2851   
142D           2852   jump_state4_power_control:
142D 02155A    2853            ljmp state4_power_control
1430           2854   
1430           2855   state3_power_control_calculation:
1430           2856            ; move soak_temp to x
1430 854B3A    2857            mov x, soak_temp
1433 854C3B    2858            mov x+1, soak_temp+1
1436 854D3C    2859            mov x+2, soak_temp+2
1439 854E3D    2860            mov x+3, soak_temp+3
143C           2861            ; move current_temp to y
143C 85473E    2862            mov y, current_temp
143F 85483F    2863            mov y+1, current_temp+1
1442 854940    2864            mov y+2, current_temp+2
1445 854A41    2865            mov y+3, current_temp+3
1448           2866   
1448           2867            ; compare between soak_temp and current_temp
1448 C200      2868            clr mf
144A 120178    2869            lcall x_gteq_y
144D 10002B    2870            jbc mf, st_sub_ct
1450           2871            ; current_temp - soak_temp if st < ct
1450 C228      2872            clr soak_temp_greater
1452           2873            ; move current_temp to y
1452 854B3E    2874            mov y, soak_temp
1455 854C3F    2875            mov y+1, soak_temp+1
1458 854D40    2876            mov y+2, soak_temp+2
145B 854E41    2877            mov y+3, soak_temp+3
145E           2878            ; move current_temp to x
145E 85473A    2879            mov x, current_temp
1461 85483B    2880            mov x+1, current_temp+1
1464 85493C    2881            mov x+2, current_temp+2
1467 854A3D    2882            mov x+3, current_temp+3
146A 1200F6    2883            lcall sub32
146D 853A62    2884            mov soak_temp_diff, x
1470 853B63    2885            mov soak_temp_diff+1, x+1
1473 853C64    2886            mov soak_temp_diff+2, x+2
1476 853D65    2887            mov soak_temp_diff+3, x+3
1479 8011      2888            sjmp proportional_input_soak
147B           2889   
147B           2890   st_sub_ct:
147B           2891            ; soak_temp - current_temp
147B D228      2892            setb soak_temp_greater
147D 1200F6    2893            lcall sub32
1480 853A62    2894            mov soak_temp_diff, x
1483 853B63    2895            mov soak_temp_diff+1, x+1
1486 853C64    2896            mov soak_temp_diff+2, x+2
1489 853D65    2897            mov soak_temp_diff+3, x+3
148C           2898   
148C           2899   proportional_input_soak:
148C           2900            ; proportaional block calculation       
148C           2901            ; move soak_temp_diff to x
148C 85623A    2902            mov x, soak_temp_diff
148F 85633B    2903            mov x+1, soak_temp_diff+1
1492 85643C    2904            mov x+2, soak_temp_diff+2
1495 85653D    2905            mov x+3, soak_temp_diff+3
1498           2906            ; move proportional gain to y
1498 753E05    2907            mov y+0, #low (KP % 0x10000) 
149B 753F00    2907            mov y+1, #high(KP % 0x10000) 
149E 754000    2907            mov y+2, #low (KP / 0x10000) 
14A1 754100    2907            mov y+3, #high(KP / 0x10000) 
14A4 12018C    2908            lcall mul32 ; proportional_output = proportional_gain * difference
14A7           2909            
14A7 853A66    2910            mov proportional_gain_var, x
14AA 853B67    2911            mov proportional_gain_var+1, x+1
14AD 853C68    2912            mov proportional_gain_var+2, x+2
14B0 853D69    2913            mov proportional_gain_var+3, x+3
14B3           2914   
14B3           2915            ; base_power + soak_power when soak_temp > current_temp
14B3 302829    2916            jnb soak_temp_greater, sub_proportional_soak
14B6 85663A    2917            mov x, proportional_gain_var
14B9 85673B    2918            mov x+1, proportional_gain_var+1
14BC 85683C    2919            mov x+2, proportional_gain_var+2
14BF 85693D    2920            mov x+3, proportional_gain_var+3
14C2 753E2C    2921            mov y+0, #low (BASE_POWER % 0x10000) 
14C5 753F01    2921            mov y+1, #high(BASE_POWER % 0x10000) 
14C8 754000    2921            mov y+2, #low (BASE_POWER / 0x10000) 
14CB 754100    2921            mov y+3, #high(BASE_POWER / 0x10000) 
14CE 1200D3    2922            lcall add32
14D1           2923            ; x now holds the power output before the saturator
14D1 853A66    2924            mov proportional_gain_var, x
14D4 853B67    2925            mov proportional_gain_var+1, x+1
14D7 853C68    2926            mov proportional_gain_var+2, x+2
14DA 853D69    2927            mov proportional_gain_var+3, x+3
14DD 803D      2928            sjmp saturator_soak
14DF           2929   
14DF           2930   sub_proportional_soak:
14DF           2931            ; base_power - soak_power when soak_temp <= current_temp
14DF 753A2C    2932            mov x+0, #low (BASE_POWER % 0x10000) 
14E2 753B01    2932            mov x+1, #high(BASE_POWER % 0x10000) 
14E5 753C00    2932            mov x+2, #low (BASE_POWER / 0x10000) 
14E8 753D00    2932            mov x+3, #high(BASE_POWER / 0x10000) 
14EB 85663E    2933            mov y, proportional_gain_var
14EE 85673F    2934            mov y+1, proportional_gain_var+1
14F1 856840    2935            mov y+2, proportional_gain_var+2
14F4 856941    2936            mov y+3, proportional_gain_var+3
14F7           2937   
14F7           2938            ; compare whether base_power < proportional_gain_var
14F7 C200      2939            clr mf
14F9 12011A    2940            lcall x_lt_y ; set mf to 1 if base_power < proportional_gain_var, clamp output to 0
14FC 30000E    2941            jnb mf, bp_gteq_pgv
14FF 756600    2942            mov proportional_gain_var, #low(NO_POWER)
1502 756700    2943            mov proportional_gain_var+1, #high(NO_POWER)
1505 756800    2944            mov proportional_gain_var+2, #0
1508 756900    2945            mov proportional_gain_var+3, #0
150B 800F      2946            sjmp saturator_soak
150D           2947   
150D           2948   bp_gteq_pgv:
150D           2949            ; calculate subtracted gain
150D 1200F6    2950            lcall sub32
1510           2951            ; x now holds the power output before the saturator
1510 853A66    2952            mov proportional_gain_var, x
1513 853B67    2953            mov proportional_gain_var+1, x+1
1516 853C68    2954            mov proportional_gain_var+2, x+2
1519 853D69    2955            mov proportional_gain_var+3, x+3
151C           2956   
151C           2957   saturator_soak:
151C           2958            ; proportional_gain_var now holds the power output before the saturator
151C           2959            ; saturate power output to max power
151C 85663A    2960            mov x, proportional_gain_var
151F 85673B    2961            mov x+1, proportional_gain_var+1
1522 85683C    2962            mov x+2, proportional_gain_var+2
1525 85693D    2963            mov x+3, proportional_gain_var+3
1528           2964   
1528 753EDC    2965            mov y+0, #low (MAX_POWER % 0x10000) 
152B 753F05    2965            mov y+1, #high(MAX_POWER % 0x10000) 
152E 754000    2965            mov y+2, #low (MAX_POWER / 0x10000) 
1531 754100    2965            mov y+3, #high(MAX_POWER / 0x10000) 
1534           2966   
1534 C200      2967            clr mf
1536 120136    2968            lcall x_gt_y ; set mf to 1 if calculated power output greater than max power
1539 20000F    2969            jb mf, saturated_soak
153C           2970            ; set power_output to calculated power if not saturated
153C 856658    2971            mov power_output, proportional_gain_var
153F 856759    2972            mov power_output+1, proportional_gain_var+1
1542 85685A    2973            mov power_output+2, proportional_gain_var+2
1545 85695B    2974            mov power_output+3, proportional_gain_var+3
1548 0215A8    2975            ljmp power_control_done
154B           2976   
154B           2977   saturated_soak:
154B 7558DC    2978            mov power_output, #low(MAX_POWER)
154E 755905    2979            mov power_output+1, #high(MAX_POWER)
1551 755A00    2980            mov power_output+2, #0
1554 755B00    2981            mov power_output+3, #0
1557 0215A8    2982            ljmp power_control_done
155A           2983   
155A           2984   
155A           2985   state4_power_control:
155A           2986            ; ramp to reflow, max power
155A B40412    2987            cjne a, #4, state5_power_control
155D 7558DC    2988            mov power_output, #low(MAX_POWER)
1560 755905    2989            mov power_output+1, #high(MAX_POWER)
1563 755A00    2990            mov power_output+2, #0
1566 755B00    2991            mov power_output+3, #0
1569 12139C    2992       lcall power_leds_high
156C 0215A8    2993            ljmp power_control_done
156F           2994   
156F           2995   state5_power_control:
156F           2996            ; reflow 20% base power
156F B40512    2997            cjne a, #5, state6_power_control
1572 75582C    2998            mov power_output, #low(BASE_POWER)  
1575 755901    2999            mov power_output+1, #high(BASE_POWER)
1578 755A00    3000            mov power_output+2, #0
157B 755B00    3001            mov power_output+3, #0
157E 121395    3002       lcall power_leds_mid
1581 0215A8    3003            ljmp power_control_done
1584           3004   
1584           3005   state6_power_control:
1584           3006            ; cooling 0% power
1584 B40612    3007            cjne a, #6, state_7_power_control
1587 755800    3008            mov power_output, #low(NO_POWER)
158A 755900    3009            mov power_output+1, #high(NO_POWER)
158D 755A00    3010            mov power_output+2, #0
1590 755B00    3011            mov power_output+3, #0
1593 12138E    3012       lcall power_leds_low
1596 0215A8    3013            ljmp power_control_done
1599           3014   
1599           3015   state_7_power_control:
1599           3016            ; idle 0% power
1599 755800    3017            mov power_output, #low(NO_POWER)
159C 755900    3018            mov power_output+1, #high(NO_POWER)
159F 755A00    3019            mov power_output+2, #0
15A2 755B00    3020            mov power_output+3, #0
15A5 12138E    3021       lcall power_leds_low
15A8           3022   power_control_done:
15A8 22        3023            ret
15A9           3024   
15A9           3025   ;----------------------------------------------------------------------------------------
15A9           3026   ; function for playing the boot up music
15A9           3027   music:
15A9           3028            ; 1
15A9 121601    3029            lcall playC
15AC 121691    3030            lcall delayHalfSec
15AF           3031            ; 1
15AF 121601    3032            lcall playC
15B2 121691    3033            lcall delayHalfSec
15B5           3034            ; 5
15B5 121619    3035            lcall playG
15B8 121691    3036            lcall delayHalfSec
15BB           3037            ; 5
15BB 121619    3038            lcall playG
15BE 121691    3039            lcall delayHalfSec
15C1           3040            ; 6
15C1 121631    3041            lcall PlayA
15C4 121691    3042            lcall delayHalfSec
15C7           3043            ; 6
15C7 121631    3044            lcall PlayA
15CA 121691    3045            lcall delayHalfSec
15CD           3046            ; 5
15CD 121619    3047            lcall playG
15D0 121691    3048            lcall delayHalfSec
15D3           3049            ; 4
15D3 121649    3050            lcall playF
15D6 121691    3051            lcall delayHalfSec
15D9           3052   
15D9           3053            ; 4
15D9 121649    3054            lcall playF
15DC 121691    3055            lcall delayHalfSec
15DF           3056            ; 3
15DF 121661    3057            lcall playE
15E2 121691    3058            lcall delayHalfSec
15E5           3059   
15E5           3060            ; 3
15E5 121661    3061            lcall playE
15E8 121691    3062            lcall delayHalfSec
15EB           3063   
15EB           3064            ; 2
15EB 121679    3065            lcall playD
15EE 121691    3066            lcall delayHalfSec
15F1           3067   
15F1           3068            ; 2
15F1 121679    3069            lcall playD
15F4 121691    3070            lcall delayHalfSec
15F7           3071            ; 1
15F7 121601    3072            lcall playC
15FA 121691    3073            lcall delayHalfSec
15FD           3074            
15FD 121691    3075            lcall delayHalfSec
1600 22        3076            ret
1601           3077   
1601           3078   ;------------------------------------
1601           3079   ; Play_C_0p5s
1601           3080   ; Plays ~523 Hz on P1.7 for 0.5 seconds
1601           3081   ;------------------------------------
1601           3082   playC:
1601 7F14      3083       MOV R7, #20        ; outer loop counter
1603           3084   
1603           3085   OUTER_LOOP:
1603 7E1A      3086       MOV R6, #26        ; inner loop counter
1605           3087   
1605           3088   INNER_LOOP:
1605 B295      3089       CPL SOUND_OUT           ; toggle buzzer pin
1607 121611    3090       LCALL Delay_C      ; ~960 s delay
160A DEF9      3091       DJNZ R6, INNER_LOOP
160C           3092   
160C DFF5      3093       DJNZ R7, OUTER_LOOP
160E           3094   
160E C295      3095       CLR SOUND_OUT           ; stop sound (pin low)
1610 22        3096       RET
1611           3097       
1611           3098   Delay_C:
1611 7D18      3099       MOV R5, #24        ; 24  40 s = 960 s
1613           3100   DELAY_LOOP:
1613 12071D    3101       LCALL Wait40uSec
1616 DDFB      3102       DJNZ R5, DELAY_LOOP
1618 22        3103       RET
1619           3104       
1619           3105   
1619           3106   ;------------------------------------
1619           3107   ; Play_G_0p5s
1619           3108   ; Plays ~784 Hz on P1.7 for 0.5 seconds
1619           3109   ;------------------------------------
1619           3110   playG:
1619 7F1F      3111       MOV R7, #31        ; outer loop
161B           3112   
161B           3113   OUTER_G:
161B 7E19      3114       MOV R6, #25        ; inner loop 31  25 = 775 toggles
161D           3115   
161D           3116   INNER_G:
161D B295      3117       CPL SOUND_OUT           ; toggle buzzer pin
161F 121629    3118       LCALL Delay_G      ; ~640 s delay
1622 DEF9      3119       DJNZ R6, INNER_G
1624           3120   
1624 DFF5      3121       DJNZ R7, OUTER_G
1626           3122   
1626 C295      3123       CLR SOUND_OUT           ; stop sound
1628 22        3124       RET
1629           3125       
1629           3126   Delay_G:
1629 7D10      3127       MOV R5, #16        ; 16  40 s = 640 s
162B           3128   DELAY_G_LOOP:
162B 12071D    3129       LCALL Wait40uSec
162E DDFB      3130       DJNZ R5, DELAY_G_LOOP
1630 22        3131       RET
1631           3132            
1631           3133    
1631           3134    ;------------------------------------
1631           3135   ; Play_A_0p5s
1631           3136   ; Plays ~880 Hz on P1.7 for 0.5 seconds
1631           3137   ;------------------------------------
1631           3138   playA:
1631 7F22      3139       MOV R7, #34        ; outer loop counter
1633           3140   
1633           3141   OUTER_A:
1633 7E1A      3142       MOV R6, #26        ; inner loop ? 34  26 = 884 toggles
1635           3143   
1635           3144   INNER_A:
1635 B295      3145       CPL SOUND_OUT           ; toggle buzzer pin
1637 121641    3146       LCALL Delay_A      ; ~560 s delay
163A DEF9      3147       DJNZ R6, INNER_A
163C           3148   
163C DFF5      3149       DJNZ R7, OUTER_A
163E           3150   
163E C295      3151       CLR SOUND_OUT          ; stop sound
1640 22        3152       RET
1641           3153   
1641           3154   Delay_A:
1641 7D0E      3155       MOV R5, #14        ; 14  40 s = 560 s
1643           3156   DELAY_A_LOOP:
1643 12071D    3157       LCALL Wait40uSec
1646 DDFB      3158       DJNZ R5, DELAY_A_LOOP
1648 22        3159       RET
1649           3160   
1649           3161   ;------------------------------------
1649           3162   ; Play_F_0p5s
1649           3163   ; Plays ~698 Hz on P1.7 for 0.5 seconds
1649           3164   ;------------------------------------
1649           3165   playF:
1649 7F1A      3166       MOV R7, #26        ; outer loop
164B           3167   
164B           3168   OUTER_F:
164B 7E1B      3169       MOV R6, #27        ; inner loop ? 26  27 = 702 toggles
164D           3170   
164D           3171   INNER_F:
164D B295      3172       CPL SOUND_OUT          ; toggle buzzer pin
164F 121659    3173       LCALL Delay_F      ; ~720 s delay
1652 DEF9      3174       DJNZ R6, INNER_F
1654           3175   
1654 DFF5      3176       DJNZ R7, OUTER_F
1656           3177   
1656 C295      3178       CLR SOUND_OUT           ; stop sound
1658 22        3179       RET
1659           3180   
1659           3181   Delay_F:
1659 7D12      3182       MOV R5, #18        ; 18  40 s = 720 s
165B           3183   DELAY_F_LOOP:
165B 12071D    3184       LCALL Wait40uSec
165E DDFB      3185       DJNZ R5, DELAY_F_LOOP
1660 22        3186       RET
1661           3187   
1661           3188   
1661           3189   ;------------------------------------
1661           3190   ; Play_E_0p5s
1661           3191   ; Plays ~659 Hz on P1.7 for 0.5 seconds
1661           3192   ;------------------------------------
1661           3193   playE:
1661 7F1A      3194       MOV R7, #26        ; outer loop
1663           3195   
1663           3196   OUTER_E:
1663 7E19      3197       MOV R6, #25        ; inner loop ? 26  25 = 650 toggles
1665           3198   
1665           3199   INNER_E:
1665 B295      3200       CPL SOUND_OUT           ; toggle buzzer pin
1667 121671    3201       LCALL Delay_E      ; ~760 s delay
166A DEF9      3202       DJNZ R6, INNER_E
166C           3203   
166C DFF5      3204       DJNZ R7, OUTER_E
166E           3205   
166E C295      3206       CLR SOUND_OUT          ; stop sound
1670 22        3207       RET
1671           3208       
1671           3209   Delay_E:
1671 7D13      3210       MOV R5, #19        ; 19  40 s = 760 s
1673           3211   DELAY_E_LOOP:
1673 12071D    3212       LCALL Wait40uSec
1676 DDFB      3213       DJNZ R5, DELAY_E_LOOP
1678 22        3214       RET
1679           3215   
1679           3216   
1679           3217   ;------------------------------------
1679           3218   ; Play_D_0p5s
1679           3219   ; Plays ~587 Hz on P1.7 for 0.5 seconds
1679           3220   ;------------------------------------
1679           3221   playD:
1679 7F19      3222       MOV R7, #25        ; outer loop
167B           3223   
167B           3224   OUTER_D:
167B 7E18      3225       MOV R6, #24        ; inner loop ? 25  24 = 600 toggles
167D           3226   
167D           3227   INNER_D:
167D B295      3228       CPL SOUND_OUT          ; toggle buzzer pin
167F 121689    3229       LCALL Delay_D      ; ~840 s delay
1682 DEF9      3230       DJNZ R6, INNER_D
1684           3231   
1684 DFF5      3232       DJNZ R7, OUTER_D
1686           3233   
1686 C295      3234       CLR SOUND_OUT         ; stop sound
1688 22        3235       RET
1689           3236       
1689           3237   Delay_D:
1689 7D15      3238       MOV R5, #21        ; 21  40 s = 840 s
168B           3239   DELAY_D_LOOP:
168B 12071D    3240       LCALL Wait40uSec
168E DDFB      3241       DJNZ R5, DELAY_D_LOOP
1690 22        3242       RET
1691           3243   
1691           3244   delayHalfSec:
1691 7A7D      3245            mov     R2, #125
1693 121697    3246            lcall WaitmilliSec
1696           3247            ;lcall WaitmilliSec
1696 22        3248            ret
1697           3249   
1697           3250   ;---------------------------------;
1697           3251   ; Wait 'R2' milliseconds, blocking;
1697           3252   ;---------------------------------;
1697           3253   WaitmilliSec:
1697 C000      3254       push AR0
1699 C001      3255       push AR1
169B 7928      3256   loop3: mov R1, #40
169D 7868      3257   loop2: mov R0, #104
169F D8FE      3258   loop1: djnz R0, loop1 ; 4 cycles->4*60.24ns*104=25.0us
16A1 D9FA      3259       djnz R1, loop2 ; 25us*40=1.0ms
16A3 DAF6      3260       djnz R2, loop3 ; number of millisecons to wait passed in R2
16A5 D001      3261       pop AR1
16A7 D000      3262       pop AR0
16A9 22        3263       ret
16AA           3264   ;-------------------------------------------------------------------------------
16AA           3265   
16AA           3266   ;------------------------------------------------------------------------------
16AA           3267   ; dc_control
16AA           3268   ; turns on the dc motor in cooling stage
16AA           3269   ;------------------------------------------------------------------------------
16AA           3270   dc_control:
16AA E560      3271       mov a, Control_FSM_state
16AC           3272            
16AC           3273            ; handle state 0
16AC B40004    3274            cjne a, #0, dc_state1
16AF C2C0      3275            clr DC_OUT
16B1 802C      3276       sjmp dc_control_done
16B3           3277   
16B3           3278            ; handle state 1
16B3           3279            dc_state1:
16B3 B40104    3280            cjne a, #1, dc_state2
16B6 C2C0      3281            clr DC_OUT
16B8 8025      3282       sjmp dc_control_done
16BA           3283   
16BA           3284            ; handle state 2
16BA           3285            dc_state2:
16BA B40204    3286            cjne a, #2, dc_state3
16BD C2C0      3287            clr DC_OUT
16BF 801E      3288       sjmp dc_control_done
16C1           3289   
16C1           3290            ; handle state 3
16C1           3291            dc_state3:
16C1 B40304    3292            cjne a, #3, dc_state4
16C4 C2C0      3293            clr DC_OUT
16C6 8017      3294       sjmp dc_control_done
16C8           3295   
16C8           3296            ; handle state 4
16C8           3297            dc_state4:
16C8 B40404    3298            cjne a, #4, dc_state5
16CB C2C0      3299            clr DC_OUT
16CD 8010      3300       sjmp dc_control_done
16CF           3301   
16CF           3302            ; handle state 5
16CF           3303            dc_state5:
16CF B40504    3304            cjne a, #5, dc_state6
16D2 C2C0      3305            clr DC_OUT
16D4 8009      3306       sjmp dc_control_done
16D6           3307   
16D6           3308            ; handle state 6
16D6           3309            dc_state6:
16D6 B40604    3310       cjne a, #6, dc_state7
16D9 D2C0      3311            setb DC_OUT
16DB 8002      3312       sjmp dc_control_done
16DD           3313   
16DD           3314            ; handle state 7
16DD           3315            dc_state7:
16DD C2C0      3316            clr DC_OUT  
16DF           3317   
16DF           3318   dc_control_done:
16DF 22        3319       ret
16E0           3320   
16E0           3321   ;-------------------------------------------------------------------------------;
16E0           3322   ;         Main program.          
16E0           3323   ;-------------------------------------------------------------------------------;
16E0           3324   main:
16E0           3325   
16E0           3326       ; --------------------------------------------------------
16E0           3327       ; 1. SAFETY SHUTDOWN
16E0           3328       ; --------------------------------------------------------
16E0 C2AF      3329       clr EA              ; FORCE Interrupts OFF immediately
16E2 7581C0    3330       mov SP, #0xC0       ; Reset Stack Pointer to safe location
16E5           3331       
16E5           3332       ; --------------------------------------------------------
16E5           3333       ; THE "DIRTY DELAY" (Fixes Reset Garbage)
16E5           3334       ; We burn ~100ms here using a raw loop. 
16E5           3335       ; We cannot use timers yet because they aren't initialized.
16E5           3336       ; --------------------------------------------------------
16E5 78FA      3337       mov R0, #250
16E7           3338   Reset_Delay_Outer:
16E7 79FF      3339       mov R1, #255
16E9           3340   Reset_Delay_Inner:
16E9 D9FE      3341       djnz R1, Reset_Delay_Inner
16EB D8FA      3342       djnz R0, Reset_Delay_Outer
16ED           3343       
16ED           3344       ; --- PORT CONFIGURATION ---
16ED 759AAA    3345       mov P0MOD, #0xAA
16F0           3346       ; P1: Mixed usage 
16F0           3347       ; P1.7(LCD_RS), P1.6(Row3), P1.5(Sound), P1.4(Row2)
16F0           3348       ; P1.3(PWM), P1.2(Row1), P1.1(LCD_E) -> All Outputs
16F0           3349       ; P1.0 (Unused/RX) -> Input
16F0           3350       ; Binary: 11111110 -> Hex: 0xFE
16F0 759BFE    3351       mov P1MOD, #0xFE
16F3           3352   
16F3           3353       ; P2: Row4(Out), Cols(In)
16F3           3354       ; P2.0 (Row4) is Out (1). P2.2, P2.4, P2.6 (Cols) are In (0).
16F3           3355       ; Binary: 00000001 -> Hex: 0x01
16F3 759C01    3356       mov P2MOD, #0x01
16F6           3357   
16F6           3358       ; P3: Col4(In)
16F6           3359       ; P3.0 (Col4) is In (0).
16F6 759D40    3360       mov P3MOD, #01000000B
16F9 75C101    3361       mov P4MOD, #00000001B
16FC           3362   
16FC           3363       ; Turn off all the LEDs
16FC 75E800    3364       mov LEDRA, #0 ; LEDRA is bit addressable
16FF 759500    3365       mov LEDRB, #0 ; LEDRB is NOT bit addresable
1702           3366   
1702           3367       ; Enable Global interrupts
1702 D2AF      3368       setb EA  
1704           3369   
1704           3370            ; FSM initial states
1704 757000    3371            mov SEC_FSM_state, #0
1707 756000    3372            mov Control_FSM_state, #0
170A 756100    3373            mov Current_State, #0
170D           3374            ; FSM timers initialization
170D 756F00    3375            mov SEC_FSM_timer, #0
1710           3376            ; time counters initialization
1710 753000    3377            mov current_time_sec, #0
1713 753100    3378            mov current_time_minute, #0
1716 753200    3379            mov soak_time_sec, #0
1719 753300    3380            mov soak_time_minute, #0
171C 753400    3381            mov reflow_time_sec, #0
171F 753500    3382            mov reflow_time_minute, #0
1722 753600    3383            mov soak_end_time_sec, #0
1725 753700    3384            mov soak_end_time_minute, #0
1728 753800    3385            mov reflow_end_time_sec, #0
172B 753900    3386            mov reflow_end_time_minute, #0
172E           3387       ; Initialize counter to zero
172E 755C00    3388       mov pwm_counter, #0
1731 755D00    3389       mov pwm_counter+1, #0
1734 755E00    3390       mov pwm_counter+2, #0
1737 755F00    3391       mov pwm_counter+3, #0
173A           3392       ; Initialize power output
173A 755B00    3393       mov power_output+3, #0
173D 755A00    3394       mov power_output+2, #0
1740 755902    3395       mov power_output+1, #02H
1743 7558EE    3396       mov power_output, #0EEH ; (initilize to 750 for testing)
1746           3397            ; FSM Buttons push button init
1746 757200    3398            mov     PB0_DEB_state, #0
1749 757400    3399            mov     PB2_DEB_state, #0
174C 757100    3400            mov     PB0_DEB_timer, #0
174F 757300    3401            mov     PB2_DEB_timer, #0
1752           3402       ; [FIX] ADD THIS BLOCK TO STOP STARTUP BEEP
1752 757600    3403       mov beep_state, #0
1755 757500    3404       mov beep_count, #0
1758 757700    3405       mov beep_tmr, #0
175B 757800    3406       mov beep_tmr+1, #0
175E           3407       ; Buttons 
175E 757A00    3408       mov BTN_DEB_state, #0
1761 757B00    3409       mov BTN_DEB_timer, #0
1764 757C00    3410       mov BTN_DEB_id, #0
1767 757900    3411       mov servo_pwm_counter, #0
176A 757D00    3412       mov rx_idx, #0
176D 757E00    3413       mov rx_ready, #0
1770 C218      3414       clr one_ms_beep_flag
1772 C28C      3415       clr TR0 ; Force buzzer hardware OFF
1774           3416   
1774           3417            ; Clear all the flags
1774 C295      3418            clr SOUND_OUT
1776 C219      3419       clr beep_error_done
1778 C213      3420            clr tc_missing_abort
177A C20B      3421            clr stop_signal
177C C215      3422            clr PB0_flag
177E C216      3423            clr PB1_flag
1780 C217      3424            clr PB2_flag
1782 C201      3425            clr one_second_flag
1784 C204      3426            clr one_second_lcd_flag
1786 C20E      3427            clr config_finish_signal
1788 C20D      3428       clr time_count_doing_signal
178A C224      3429       clr fullscreen_update_signal
178C C205      3430            clr soak_temp_reached
178E C208      3431            clr soak_time_reached
1790 C206      3432            clr reflow_temp_reached
1792 C209      3433            clr reflow_time_reached
1794 C207      3434            clr cooling_temp_reached
1796 C210      3435       clr state_change_signal_TC
1798 C211      3436            clr state_change_signal_Count
179A C212      3437       clr state_change_beep_signal
179C C226      3438       clr one_millisecond_flag_servo
179E C229      3439       clr remote_config_mode
17A0 C2C0      3440       clr DC_OUT
17A2           3441       ; Set bit
17A2 D20F      3442            setb state_change_signal
17A4 D214      3443       setb tc_startup_window
17A6           3444   
17A6 12045D    3445       lcall Timer0_Init
17A9 1206A6    3446       lcall Timer2_Init
17AC 120779    3447       lcall ELCD_4BIT
17AF           3448       ;----- Two new lines I added to initialize the UI
17AF 1211BD    3449       lcall Init_All_Buffers
17B2 120477    3450       lcall Initialize_Serial_Port
17B5 1215A9    3451       lcall music
17B8           3452   ;-------------------------------------------------------------------------------;
17B8           3453   ; while(1) loop
17B8           3454   ;-------------------------------------------------------------------------------;
17B8           3455   loop:
17B8           3456   
17B8 120BC4    3457            lcall SEC_FSM
17BB           3458   
17BB           3459            ; Check the FSM for the overall control flow of the reflow process
17BB 120E73    3460       lcall Control_FSM
17BE           3461   
17BE           3462       ; Check the FSM for PB01 debounce
17BE 120B56    3463       lcall PB0_DEB
17C1 120B8E    3464            lcall PB2_DEB
17C4           3465       
17C4           3466       ; Added to take temp readings
17C4 121210    3467       lcall Read_Thermocouple
17C7           3468       
17C7           3469       ; 1. Check if we reached temp (Observer)
17C7 120CAF    3470       lcall Temp_Compare
17CA           3471       
17CA           3472       ; 2. Decide heater power based on flags (Driver)
17CA           3473       ;lcall Power_Control
17CA 1213A3    3474       lcall proportional_power_control
17CD           3475       
17CD 120DA0    3476       lcall Safety_Check_TC
17D0           3477   
17D0 120C20    3478            lcall Time_Counter
17D3           3479   
17D3           3480            ; Update Variables (times and temp)
17D3 120F4E    3481            lcall Update_FSM_Variables
17D6           3482   
17D6           3483       ; GUI Interface polling uart port
17D6 1204AC    3484       lcall Serial_RX_Pump
17D9 120505    3485       lcall Serial_Process_Line
17DC           3486   
17DC           3487            ; Update while at state 1
17DC           3488            ; LCD
17DC 120A02    3489            lcall Update_Screen_Full 
17DF           3490            ; Buttons
17DF 120FD2    3491            lcall Check_Buttons 
17E2           3492            ; PB0pad
17E2 121091    3493       lcall Check_Keypad
17E5           3494   
17E5           3495       ; Update the LCD display based on the current state
17E5 12083E    3496       lcall LCD_Display_Update_func
17E8           3497   
17E8 120C42    3498            lcall Time_Compare_MMSS
17EB           3499   
17EB           3500       ; Update the pwm output for the ssr
17EB 120D29    3501       lcall PWM_Wave 
17EE           3502            ; Update the Buzzer 
17EE 120E3A    3503            lcall Beep_Task
17F1           3504       ; Update the pwm output for the servo
17F1 1212E5    3505       lcall call_servo_control
17F4           3506   
17F4 120DF1    3507       lcall Beep_Judge
17F7           3508   
17F7 1216AA    3509       lcall dc_control
17FA           3510   
17FA           3511       ; After initialization the program stays in this 'forever' loop
17FA 0217B8    3512       ljmp loop
17FD           3513   ;-------------------------------------------------------------------------------;
17FD           3514   END
