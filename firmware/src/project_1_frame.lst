0000              1   ; Project 1
0000              2   ; CV-8052 microcontroller in DE10-Lite board
0000              3   ;-------------------------------------------------------------------------------
0000              4   ; Reset vector
0000              5   org 0x0000
0000 021302       6       ljmp main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9       reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 02046E      12       ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15       reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18       reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 32          21       reti
0024             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
002B 02052E      24       ljmp Timer2_ISR
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 32   $LIST
0320             34   ; ----------------------------------------------------------------------------------------------;
0320             35   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             36   dseg at 0x30
0030             37   ; time buffer 
0030             38   current_time_sec:     ds 1
0031             39   current_time_minute:  ds 1
0032             40   soak_time_sec:        ds 1
0033             41   soak_time_minute:     ds 1
0034             42   reflow_time_sec:      ds 1
0035             43   reflow_time_minute:   ds 1
0036             44   soak_end_time_sec:      ds 1
0037             45   soak_end_time_minute:   ds 1
0038             46   reflow_end_time_sec:    ds 1
0039             47   reflow_end_time_minute: ds 1
003A             48   
003A             49   ; math32 buffer variables
003A             50   x:      ds  4
003E             51   y:      ds  4
0042             52   bcd:    ds  5
0047             53   
0047             54   current_temp: ds 4 ;
004B             55   soak_temp:    ds 4 ;
004F             56   reflow_temp:  ds 4 ;
0053             57   
0053             58   wait25_btn_cnt:    ds 1
0054             59   wait25_keypad_cnt: ds 1
0055             60   wait25_adc_cnt:    ds 1
0056             61   wait25_lcd_cnt:    ds 1
0057             62   wait25_count:      ds 1
0058             63   
0058             64   power_output:  ds 4 ;
005C             65   pwm_counter:   ds 4 ; counter for pwm (0-1500_timer: ds 1
0060             66   
0060             67   Control_FSM_state: ds 1 
0061             68   Current_State:     ds 1
0062             69   
0062             70   soak_temp_diff: ds 4 ; temperature difference between target soak temp and current oven temp 
0066             71   proportional_gain_var: ds 4 ; power gain calculated from the proportional block
006A             72   
006A             73   ;-- UI buffers I added (ayaan)
006A             74   Cursor_Idx: ds 1
006B             75   
006B             76   ; Buzzer module variables
006B             77   buzz_state:      ds 1   ; 0=IDLE, 1=ON, 2=OFF
006C             78   buzz_timer:      ds 1   ; counts ms within ON/OFF window
006D             79   buzz_beeps_left: ds 1   ; how many beeps remaining
006E             80   buzz_priority:   ds 1   ; 0 none, 1=state, 2=done, 3=error
006F             81   
006F             82   SEC_FSM_timer: ds 1
0070             83   SEC_FSM_state: ds 1
0071             84   ; Push buttons for globel interrupt 
0071             85   PB0_DEB_timer:  ds 1
0072             86   PB0_DEB_state:  ds 1
0073             87   PB2_DEB_timer:  ds 1
0074             88   PB2_DEB_state:  ds 1
0075             89   
0075             90   ; Buzzer state
0075             91   beep_count:  ds 1      ; remaining beeps
0076             92   beep_state:  ds 1      ; 0=idle, 1=ON, 2=OFF
0077             93   beep_tmr:    ds 2      ; 16-bit ms timer (needs to reach 500)
0079             94   
0079             95   servo_pwm_counter: ds 1 ; counter for the servo pwm signal
007A             96   
0080             97   iseg at 0x80
0080             98   Buf_Soak_Temp: ds 4   
0084             99   Buf_Soak_Time: ds 5   
0089            100   Buf_Refl_Temp: ds 4   
008D            101   Buf_Refl_Time: ds 5
0092            102   ; 
0092            103   ;-------------------------------------------------------------------------------
0092            104   ; bit operation setb, clr, jb, and jnb
0000            105   bseg
0000            106   mf:     dbit 1 ; math32 sign
0001            107   one_second_flag: dbit 1
0002            108   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003            109   one_ms_buzz_flag: dbit 1 ; one_millisecond_flag for buzz
0004            110   one_second_lcd_flag: dbit 1
0005            111   
0005            112   soak_temp_reached: dbit 1
0006            113   reflow_temp_reached: dbit 1
0007            114   cooling_temp_reached: dbit 1
0008            115   
0008            116   soak_time_reached: dbit 1
0009            117   reflow_time_reached: dbit 1
000A            118   
000A            119   reset_signal: dbit 1
000B            120   stop_signal: dbit 1
000C            121   start_signal_count: dbit 1
000D            122   time_count_doing_signal: dbit 1
000E            123   config_finish_signal: dbit 1
000F            124   
000F            125   state_change_signal: dbit 1
0010            126   state_change_signal_TC: dbit 1
0011            127   state_change_signal_Count: dbit 1
0012            128   state_change_beep_signal: dbit 1
0013            129   
0013            130   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
0014            131   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0015            132   
0015            133   PB0_flag: dbit 1 ; start entire program
0016            134   PB1_flag: dbit 1 ; start soak
0017            135   PB2_flag: dbit 1 ; pause process
0018            136   
0018            137   ;buzzer beep
0018            138   one_ms_beep_flag: dbit 1
0019            139   beep_error_done: dbit 1
001A            140   
001A            141   ; BSEG (Bit Segment)
001A            142   wait25_active: dbit 1 ; 1 = We are currently waiting
001B            143   wait25_done:   dbit 1 ; 1 = The 25ms has finished
001C            144   wait25_btn_active:    dbit 1
001D            145   wait25_btn_done:      dbit 1
001E            146   wait25_keypad_active: dbit 1
001F            147   wait25_keypad_done:   dbit 1
0020            148   wait25_adc_active:    dbit 1
0021            149   wait25_adc_done:      dbit 1
0022            150   wait25_lcd_active:    dbit 1
0023            151   wait25_lcd_done:      dbit 1
0024            152   
0024            153   fullscreen_update_signal: dbit 1
0025            154   
0025            155   one_second_flag_test: dbit 1
0026            156   one_millisecond_flag_servo: dbit 1 ; set the one millsiecond flag for servo pwm signal generation
0027            157   
0027            158   servo_angle_zero: dbit 1 ; flag for indicating whether the servo angle should be at 0 or not: 1 -> 0; 0 -> 180
0028            159   soak_temp_greater: dbit 1 ; target soak_temp greater than current_temp
0029            160   ; 11 bits used
0029            161   
0029            162   ;-------------------------------------------------------------------------------
0320            163   cseg
0320            164   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            165   BAUD           EQU 57600
0320            166   
0320            167   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            168   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            169   ; is always 12 unlike the N76E003 where is selectable.
0320            170   
0320            171   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            172   
0320            173   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            174   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            175   
0320            176   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            177   
0320            178   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            179   BEEP_ON_MS          EQU 100  ; 100ms
0320            180   BEEP_OFF_MS    EQU 100  ; 100ms
0320            181   
0320            182   PWM_OUT        EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            183   
0320            184   ; These 'equ' must match the wiring between the DE10Lite board and the LCD!
0320            185   ; P0 is in connector JPIO.
0320            186   
0320            187   ;Added correct I/O definitions
0320            188   ;-- LCD Pins ---
0320            189   ELCD_RS equ P1.7
0320            190   ELCD_E  equ P1.1
0320            191   ELCD_D4 equ P0.7
0320            192   ELCD_D5 equ P0.5
0320            193   ELCD_D6 equ P0.3
0320            194   ELCD_D7 equ P0.1
0320            195   
0320            196   ; -- Buttons --
0320            197   BTN_SOAK_TEMP equ P0.0
0320            198   BTN_SOAK_TIME equ P0.2
0320            199   BTN_REFL_TEMP equ P0.4
0320            200   BTN_REFL_TIME equ P0.6
0320            201   PB0                equ P1.0
0320            202   PB2                equ P3.7
0320            203   
0320            204   ; --- PB0PAD ---
0320            205   ROW1 equ P1.2
0320            206   ROW2 equ P1.4
0320            207   ROW3 equ P1.6
0320            208   ROW4 equ P2.0
0320            209   COL1 equ P2.2
0320            210   COL2 equ P2.4
0320            211   COL3 equ P2.6
0320            212   COL4 equ P3.0
0320            213   
0320            214   SERVO_OUT      EQU p3.6 ; servo pin
0320            215   
0320            216   SERVO_PERIOD   EQU 20 ; pwm signal period for the servo motor (20 ms)
0320            217   SERVO_0        EQU 1 ; pwm high time for the servo motor to stay at 0 degree
0320            218   SERVO_180      EQU 2 ; pwm high time for the servo motor to stay at 180 degrees
0320            219   
0320            220   COLD_JUNCTION_TEMP equ 20
0320            221   MAX_POWER           EQU 1500 ; max oven power
0320            222   NO_POWER            EQU 0    ; no power
0320            223   BASE_POWER     EQU (MAX_POWER/5) ; 20% base power for state 2, 4
0320            224   KP                          EQU 5 ; proportional gain
0320            225   
0320            226   ;                     1234567890123456 <-- 16 characters per line LCD
0320 696E6974   227   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   228   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   229   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            230   
0350            231   ; --- UI STRINGS (REQUIRED FOR PB0PAD LOGIC), <- I can fix if duplicates
0350 53656C65   232   Txt_Home:     db 'Select Mode:    ', 0
     6374204D
     6F64653A
     20202020
     00
0361 53657420   233   Txt_SoakT:    db 'Set Soak Temp   ', 0
     536F616B
     2054656D
     70202020
     00
0372 53657420   234   Txt_SoakTime: db 'Set Soak Time   ', 0
     536F616B
     2054696D
     65202020
     00
0383 53657420   235   Txt_ReflT:    db 'Set Reflow Temp ', 0
     5265666C
     6F772054
     656D7020
     00
0394 53657420   236   Txt_ReflTime: db 'Set Reflow Time ', 0
     5265666C
     6F772054
     696D6520
     00
03A5            237   
03A5            238   ;                       1234567890123456
03A5 53657420   239   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
03B5 536F616B   240   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
03C0 5265666C   241   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
03CD 536F616B   242   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
03D8 5265666C   243   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03E5            244   
03E5 54656D70   245   String_temp_line:  db 'Temp: ', 0
     3A2000
03EC            246   
03EC            247   ;                     1234567890123456
03EC 52616D70   248   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03FC 536F616B   249   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
040C 52616D70   250   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
041C 5265666C   251   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
042C 436F6F6C   252   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
043C 50726F63   253   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
044C            254   
044C 20202020   255   String_Blank:    db '                ', 0
     20202020
     20202020
     20202020
     00
045D            256   
045D            257   ;-------------------------------------------------------------------------------
045D            258   ; Timers Setting:
045D            259   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
045D            260   ;   Timer 1: Serial port baud rate 57600 generator
045D            261   ;   Timer 2: 1ms interrupt for BCD counter increment/decrement
045D            262   ;-------------------------------------------------------------------------------
045D            263   ; Routine to initialize the ISR for Timer 0 ;
045D            264   Timer0_Init:
045D E589       265       mov a, TMOD
045F 54F0       266       anl a, #0xf0 ; Clear the bits for timer 0
0461 4401       267       orl a, #0x01 ; Configure timer 0 as 16-timer
0463 F589       268       mov TMOD, a
0465 758CFD     269       mov TH0, #high(TIMER0_RELOAD)
0468 758A5A     270       mov TL0, #low(TIMER0_RELOAD)
046B            271       ; Enable the timer and interrupts
046B D2A9       272       setb ET0  ; Enable timer 0 interrupt
046D            273       ; setb TR0  (no need to open at first)
046D 22         274       ret
046E            275   ; ISR for timer 0.  Set to execute every 1/4096Hz 
046E            276   ; to generate a 2048 Hz square wave at pin P1.5 
046E            277   Timer0_ISR:
046E            278       ;clr TF0  ; According to the data sheet this is done for us already.
046E 758CFD     279       mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
0471 758A5A     280       mov TL0, #low(TIMER0_RELOAD)
0474 B295       281       cpl SOUND_OUT ; Connect speaker to P1.5
0476 32         282       reti
0477            283   ; -----------------------------------------------------------------------------------------------;
0477            284   
0477            285   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
0477            286   Initialize_Serial_Port:
0477            287       ; Configure serial port and baud rate
0477 C28E       288       clr TR1 ; Disable timer 1
0479 53890F     289       anl TMOD, #0x0f ; Mask the bits for timer 1
047C 438920     290       orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
047F 438780     291       orl PCON, #80H ; Set SMOD to 1
0482 758DFD     292       mov TH1, #low(TIMER_1_RELOAD)
0485 758BFD     293       mov TL1, #low(TIMER_1_RELOAD) 
0488 D28E       294       setb TR1 ; Enable timer 1
048A 759852     295       mov SCON, #52H
048D 22         296       ret
048E            297   
048E            298   ; uart sending functions
048E            299   putchar:
048E 109902     300       jbc TI, putchar_L1
0491 80FB       301       sjmp putchar
0493            302   putchar_L1:
0493 F599       303       mov SBUF,a
0495 22         304       ret
0496            305   
0496            306   SendString:
0496 E4         307       clr a
0497 93         308       movc a, @a+dptr
0498 6006       309       jz SendString_L1
049A 12048E     310       lcall putchar
049D A3         311       inc dptr
049E 80F6       312       sjmp SendString  
04A0            313   SendString_L1:
04A0 22         314       ret
04A1            315   
04A1            316   ;-------------------------------------------------------------------------------
04A1            317   ; serial debugging
04A1            318   ; send a four byte number via serial to laptop
04A1            319   ; need to be used with python script
04A1            320   ; content needed to be sent should be stored in the varaible x
04A1            321   ;-------------------------------------------------------------------------------
04A1            322   Send32:
04A1            323       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
04A1 74AA       324       mov A, #0AAH
04A3 12048E     325       lcall putchar
04A6 7455       326       mov A, #055H
04A8 12048E     327       lcall putchar
04AB            328   
04AB E53D       329       mov A, x+3
04AD 12048E     330       lcall putchar
04B0 E53C       331       mov A, x+2
04B2 12048E     332       lcall putchar
04B5 E53B       333       mov A, x+1
04B7 12048E     334       lcall putchar
04BA E53A       335       mov A, x+0
04BC 12048E     336       lcall putchar
04BF            337   
04BF 740A       338       mov A, #0AH
04C1 12048E     339       lcall putchar
04C4 22         340       ret
04C5            341   ; -----------------------------------------------------------------------------------------------;
04C5            342   
04C5            343   ;-------------------------------------------------------------------------------
04C5            344   ; Serial temperature line for PuTTY/screen
04C5            345   ; Outputs: "Temp: XXXC\r\n"
04C5            346   ;-------------------------------------------------------------------------------
04C5            347   Serial_Send_Temp_Line:
04C5 9003E5     348       mov dptr, #String_temp_line
04C8 120496     349       lcall SendString
04CB            350   
04CB            351       ; Convert current_temp to BCD (same as LCD)
04CB 85473A     352       mov x, current_temp
04CE 85483B     353       mov x+1, current_temp+1
04D1 85493C     354       mov x+2, current_temp+2
04D4 854A3D     355       mov x+3, current_temp+3
04D7 12002E     356       lcall hex2bcd
04DA            357   
04DA 7F00       358       mov R7, #0          ; printed_flag = 0
04DC            359   
04DC            360       ; Print Hundreds (if non-zero)
04DC E543       361       mov a, bcd+1
04DE 540F       362       anl a, #0x0F
04E0 6007       363       jz Serial_Skip_Hundreds
04E2 2430       364       add a, #0x30
04E4 12048E     365       lcall putchar
04E7 7F01       366       mov R7, #1
04E9            367   Serial_Skip_Hundreds:
04E9            368   
04E9            369       ; Print Tens (if non-zero or if hundreds already printed)
04E9 E542       370       mov a, bcd+0
04EB C4         371       swap a
04EC 540F       372       anl a, #0x0F
04EE 7003       373       jnz Serial_Print_Tens
04F0 EF         374       mov a, R7
04F1 600C       375       jz Serial_Skip_Tens
04F3            376   Serial_Print_Tens:
04F3 E542       377       mov a, bcd+0
04F5 C4         378       swap a
04F6 540F       379       anl a, #0x0F
04F8 2430       380       add a, #0x30
04FA 12048E     381       lcall putchar
04FD 7F01       382       mov R7, #1
04FF            383   Serial_Skip_Tens:
04FF            384   
04FF            385       ; Print Ones (always)
04FF E542       386       mov a, bcd+0
0501 540F       387       anl a, #0x0F
0503 2430       388       add a, #0x30
0505 12048E     389       lcall putchar
0508            390   
0508            391       ; Print 'C' and newline
0508 7443       392       mov a, #'C'
050A 12048E     393       lcall putchar
050D 740D       394       mov a, #0DH     ; CR
050F 12048E     395       lcall putchar
0512 740A       396       mov a, #0AH     ; LF
0514 12048E     397       lcall putchar
0517 22         398       ret
0518            399   
0518            400   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
0518              1   ;-------------------------------------------------------------------------------
0518              2   ; Timer2_ISR.inc
0518              3   ; Contains Initialization and ISR for the 1ms System Timer
0518              4   ;-------------------------------------------------------------------------------
0518              5   
0518              6   ;-------------------------------------------------------------------------------
0518              7   ; Routine to initialize the ISR for timer 2
0518              8   ;-------------------------------------------------------------------------------
0518              9   Timer2_Init:
0518 75C800      10       mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
051B 75CDF5      11       mov TH2, #high(TIMER2_RELOAD)
051E 75CC27      12       mov TL2, #low(TIMER2_RELOAD)
0521             13       ; Set the reload value
0521 75CBF5      14       mov RCAP2H, #high(TIMER2_RELOAD)
0524 75CA27      15       mov RCAP2L, #low(TIMER2_RELOAD)
0527             16       
0527 C2CF        17       clr TF2       ; Clear flag just in case
0529             18       ; Enable the timer and interrupts
0529 D2AD        19       setb ET2      ; Enable timer 2 interrupt
052B D2CA        20       setb TR2      ; Enable timer 2
052D 22          21       ret
052E             22   
052E             23   ;-------------------------------------------------------------------------------
052E             24   ; ISR for timer 2.  Runs every 1 ms
052E             25   ;-------------------------------------------------------------------------------
052E             26   Timer2_ISR:
052E C0E0        27       push acc
0530 C0D0        28       push psw
0532             29       
0532 C2CF        30       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
0534             31   
0534             32       ; --- 1. Existing Non-Blocking Seconds Increment and Periphals Debounce Timers ---
0534 056F        33       inc SEC_FSM_timer
0536 D202        34       setb one_ms_pwm_flag 
0538 D203        35            setb one_ms_buzz_flag
053A D218        36       setb one_ms_beep_flag
053C             37   
053C 0571        38       inc PB0_DEB_timer
053E 0573        39       inc PB2_DEB_timer
0540 D218        40       setb one_ms_beep_flag
0542 D226        41       setb one_millisecond_flag_servo
0544             42   
0544             43       ; --- 2. NEW: Non-Blocking Delay Counters ---
0544             44       ; A. BUTTON DELAY
0544 301C0B      45       jnb wait25_btn_active, T2_Check_Keypad
0547 0553        46       inc wait25_btn_cnt
0549 E553        47       mov a, wait25_btn_cnt
054B B41904      48       cjne a, #25, T2_Check_Keypad
054E D21D        49       setb wait25_btn_done
0550 C21C        50       clr wait25_btn_active
0552             51       
0552             52       ; B. KEYPAD DELAY
0552             53   T2_Check_Keypad:
0552 301E0B      54       jnb wait25_keypad_active, T2_Check_ADC
0555 0554        55       inc wait25_keypad_cnt
0557 E554        56       mov a, wait25_keypad_cnt
0559 B41904      57       cjne a, #25, T2_Check_ADC
055C D21F        58       setb wait25_keypad_done
055E C21E        59       clr wait25_keypad_active
0560             60   
0560             61       ; C. ADC DELAY (Thermocouple)
0560             62   T2_Check_ADC:
0560 30200B      63       jnb wait25_adc_active, T2_Check_LCD
0563 0555        64       inc wait25_adc_cnt
0565 E555        65       mov a, wait25_adc_cnt
0567 B41904      66       cjne a, #25, T2_Check_LCD
056A D221        67       setb wait25_adc_done
056C C220        68       clr wait25_adc_active
056E             69   
056E             70       ; D. LCD DELAY
056E             71   T2_Check_LCD:
056E 30220B      72       jnb wait25_lcd_active, T2_Check_Generic
0571 0556        73       inc wait25_lcd_cnt
0573 E556        74       mov a, wait25_lcd_cnt
0575 B41904      75       cjne a, #25, T2_Check_Generic
0578 D223        76       setb wait25_lcd_done
057A C222        77       clr wait25_lcd_active
057C             78   
057C             79       ; E. GENERIC DELAY (Used by Wait_25ms in Main)
057C             80   T2_Check_Generic:
057C 301A0B      81       jnb wait25_active, Timer2_ISR_done
057F 0557        82       inc wait25_count
0581 E557        83       mov a, wait25_count
0583 B41904      84       cjne a, #25, Timer2_ISR_done
0586 D21B        85       setb wait25_done      ; Tells Wait_25ms that we are finished
0588 C21A        86       clr wait25_active     ; Stop counting
058A             87   
058A             88   Timer2_ISR_done:
058A D0D0        89       pop psw
058C D0E0        90       pop acc
058E 32          91       reti
058F             92            
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
058F              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
058F              2   cseg
058F              3   
058F              4   ; When using a 33.333333MHz crystal clock
058F              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
058F              6   
058F              7   ;---------------------------------;
058F              8   ; Wait 40 microseconds            ;
058F              9   ;---------------------------------;
058F             10   Wait40uSec:
058F C000        11            push AR0
0591 78BE        12            mov R0, #190
0593             13   L0: 
0593 00          14            nop
0594 00          15            nop
0595 00          16            nop
0596 00          17            nop
0597 D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
0599 D000        19            pop AR0
059B 22          20       ret
059C             21   
059C             22   ;---------------------------------;
059C             23   ; Wait 'R2' milliseconds          ;
059C             24   ;---------------------------------;
                 25   Wait_Milli_Seconds mac
                 26   	push AR2
                 27   	mov R2, %0
                 28   	lcall ?Wait_Milli_Seconds
                 29   	pop AR2
                 30   endmac
059C             31   
059C             32   ?Wait_Milli_Seconds:
059C C000        33            push AR0
059E C001        34            push AR1
05A0 7932        35   L3: mov R1, #50
05A2 78DF        36   L2: mov R0, #223
05A4 D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
05A6 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
05A8 DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
05AA D001        40       pop AR1
05AC D000        41       pop AR0
05AE 22          42       ret
05AF             43            
05AF             44   ;---------------------------------;
05AF             45   ; Toggles the 'E' pin in the LCD  ;
05AF             46   ;---------------------------------;
05AF             47   ELCD_pulse:
05AF D291        48            setb ELCD_E
05B1 12058F      49            lcall Wait40uSec
05B4 C291        50            clr ELCD_E
05B6 12058F      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
05B9 22          52       ret
05BA             53   
05BA             54   ;---------------------------------;
05BA             55   ; Writes acc to LCD in 4-bit mode ;
05BA             56   ;---------------------------------;
05BA             57   ELCD_byte:
05BA             58            ; Write high 4 bits first
05BA A2E7        59            mov c, ACC.7
05BC 9281        60            mov ELCD_D7, c
05BE A2E6        61            mov c, ACC.6
05C0 9283        62            mov ELCD_D6, c
05C2 A2E5        63            mov c, ACC.5
05C4 9285        64            mov ELCD_D5, c
05C6 A2E4        65            mov c, ACC.4
05C8 9287        66            mov ELCD_D4, c
05CA 1205AF      67       lcall ELCD_pulse
05CD             68            ; Write low 4 bits next
05CD A2E3        69            mov c, ACC.3
05CF 9281        70            mov ELCD_D7, c
05D1 A2E2        71            mov c, ACC.2
05D3 9283        72            mov ELCD_D6, c
05D5 A2E1        73            mov c, ACC.1
05D7 9285        74            mov ELCD_D5, c
05D9 A2E0        75            mov c, ACC.0
05DB 9287        76            mov ELCD_D4, c
05DD 1205AF      77       lcall ELCD_pulse
05E0 22          78            ret
05E1             79   
05E1             80   ;---------------------------------;
05E1             81   ; Write data to LCD               ;
05E1             82   ;---------------------------------;
                 83   WriteData mac
                 84   	mov a, %0
                 85   	lcall ?WriteData
                 86   endmac
05E1             87            
05E1             88   ?WriteData:
05E1 D297        89            setb ELCD_RS
05E3 0205BA      90            ljmp ELCD_byte
05E6             91   
05E6             92   ;---------------------------------;
05E6             93   ; Write command to LCD            ;
05E6             94   ;---------------------------------;
                 95   WriteCommand mac
                 96   	mov a, %0
                 97   	lcall ?WriteCommand
                 98   endmac
05E6             99   
05E6            100   ?WriteCommand:
05E6 C297       101            clr ELCD_RS
05E8 0205BA     102            ljmp ELCD_byte
05EB            103   
05EB            104   ;---------------------------------;
05EB            105   ; Configure LCD in 4-bit mode     ;
05EB            106   ;---------------------------------;
05EB            107   ELCD_4BIT:
05EB C291       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
05ED            109            ;clr ELCD_RW  ; RW forced to zero
05ED            110            
05ED            111            ; After power on, let the LCD start up before initializing
05ED C002       112            push AR2
05EF 7A28       112            mov R2, #40
05F1 12059C     112            lcall ?Wait_Milli_Seconds
05F4 D002       112            pop AR2
05F6            113            
05F6            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
05F6 7433       115            mov a, #0x33
05F8 1205E6     115            lcall ?WriteCommand
05FB 7433       116            mov a, #0x33
05FD 1205E6     116            lcall ?WriteCommand
0600 7432       117            mov a, #0x32
0602 1205E6     117            lcall ?WriteCommand ; change to 4-bit mode
0605            118   
0605            119            ; Configure the LCD
0605 7428       120            mov a, #0x28
0607 1205E6     120            lcall ?WriteCommand
060A 740C       121            mov a, #0x0c
060C 1205E6     121            lcall ?WriteCommand
060F 7401       122            mov a, #0x01
0611 1205E6     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
0614            123   
0614            124       ;Wait for the clear screen command to finish.
0614 C002       125            push AR2
0616 7A02       125            mov R2, #2
0618 12059C     125            lcall ?Wait_Milli_Seconds
061B D002       125            pop AR2
061D 22         126       ret
061E            127   
061E            128   ;---------------------------------;
061E            129   ; Send a constant string to LCD   ;
061E            130   ;---------------------------------;
                131   Send_Constant_String mac
                132   	push dph
                133   	push dpl
                134   	push acc
                135   	mov dptr, %0
                136   	lcall ?Send_Constant_String
                137   	pop acc
                138   	pop dpl
                139   	pop dph
                140   endmac
061E            141   
061E            142   ?Send_Constant_String:
061E E4         143       clr a
061F 93         144       movc a, @a+dptr
0620 6006       145       jz ?Send_Constant_String_Done
0622 1205E1     146       lcall ?WriteData
0625 A3         147       inc dptr
0626 80F6       148       sjmp ?Send_Constant_String
0628            149   ?Send_Constant_String_Done:
0628 22         150       ret  
0629            151   
0629            152   ;---------------------------------;
0629            153   ; Set LCD cursor at row, column   ;
0629            154   ;---------------------------------;
                155   Set_Cursor mac
                156   	push acc
                157   	mov a, #%1
                158   	dec a
                159   	lcall ?Set_Cursor_%0 ; Select column and row
                160   	pop acc
                161   endmac
0629            162   
0629            163   ?Set_Cursor_2:
0629 4440       164            orl a, #01000000B
062B            165   ?Set_Cursor_1:
062B 4480       166            orl a, #10000000B
062D 0205E6     167            ljmp ?WriteCommand ; Select column and row
0630            168   
0630            169   ;---------------------------------;
0630            170   ; Display a BCD number in the LCD ;
0630            171   ;---------------------------------;
                172   Display_BCD mac
                173   	push ar0
                174   	mov r0, %0
                175   	lcall ?Display_BCD
                176   	pop ar0
                177   endmac
0630            178   
0630            179   ?Display_BCD:
0630 C0E0       180            push acc
0632            181            ; Write most significant digit
0632 E8         182            mov a, r0
0633 C4         183            swap a
0634 540F       184            anl a, #0fh
0636 4430       185            orl a, #30h
0638 1205E1     186            lcall ?WriteData
063B            187            ; write least significant digit
063B E8         188            mov a, r0
063C 540F       189            anl a, #0fh
063E 4430       190            orl a, #30h
0640 1205E1     191            lcall ?WriteData
0643 D0E0       192            pop acc
0645 22         193            ret
0646            194   
0646            195   ;------------------------------------;
0646            196   ; Display a char in the LCD          ;
0646            197   ;------------------------------------;
                198   Display_char mac
                199   	push acc
                200   	mov a, %0
                201   	lcall ?WriteData
                202   	pop acc
                203   endmac
0646            204   
0646            403            ;-----------------------------------------------------------------------------------------------;
0646            404   
0646            405   ;-------------------------------------------------------------------------------
0646            406   ; Display Function for 7-segment displays       
0646            407   ;-------------------------------------------------------------------------------
0646            408   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
0646            409   T_7seg:
0646 C0F9A4B0   410       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
064B 9282F880   411       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
0650 8883C6A1   412       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
0656            413   
0656            414   ; Displays a BCD number pased in R0 in HEX5-HEX0
0656            415   Display_BCD_7_Seg_HEX10:
0656 900646     416       mov dptr, #T_7seg
0659 E8         417       mov a, R0
065A C4         418       swap a
065B 540F       419       anl a, #0FH
065D 93         420       movc a, @a+dptr
065E F592       421       mov HEX1, a
0660 E8         422       mov a, R0
0661 540F       423       anl a, #0FH
0663 93         424       movc a, @a+dptr
0664 F591       425       mov HEX0, a
0666 22         426       ret
0667            427   
0667            428   Display_BCD_7_Seg_HEX32:
0667 900646     429       mov dptr, #T_7seg
066A E8         430       mov a, R0
066B C4         431       swap a
066C 540F       432       anl a, #0FH
066E 93         433       movc a, @a+dptr
066F F594       434       mov HEX3, a
0671 E8         435       mov a, R0
0672 540F       436       anl a, #0FH
0674 93         437       movc a, @a+dptr
0675 F593       438       mov HEX2, a
0677 22         439       ret
0678            440   
0678            441   Display_BCD_7_Seg_HEX54:
0678 900646     442       mov dptr, #T_7seg
067B E8         443       mov a, R0
067C C4         444       swap a
067D 540F       445       anl a, #0FH
067F 93         446       movc a, @a+dptr
0680 F58F       447       mov HEX5, a
0682 E8         448       mov a, R0
0683 540F       449       anl a, #0FH
0685 93         450       movc a, @a+dptr
0686 F58E       451       mov HEX4, a
0688 22         452       ret
0689            453   
0689            454   ; The 8-bit hex number passed in the accumulator is converted to
0689            455   ; BCD and stored in [R1, R0]
0689            456   Hex_to_bcd_8bit:
0689 75F064     457       mov b, #100
068C 84         458       div ab
068D F9         459       mov R1, a   ; After dividing, a has the 100s
068E E5F0       460       mov a, b    ; Remainder is in register b
0690 75F00A     461       mov b, #10
0693 84         462       div ab ; The tens are stored in a, the units are stored in b 
0694 C4         463       swap a
0695 54F0       464       anl a, #0xf0
0697 45F0       465       orl a, b
0699 F8         466       mov R0, a
069A 22         467       ret
069B            468   ;-------------------------------------------------------------------------------
069B            469   ; Display Function for LCD                      
069B            470   ;-------------------------------------------------------------------------------
069B            471   LCD_Print_2Digits:
069B 120689     472       lcall Hex_to_bcd_8bit
069E E8         473       mov a, R0
069F C4         474       swap a
06A0 540F       475       anl a, #0x0F
06A2 2430       476       add a, #0x30
06A4 1205E1     477       lcall ?WriteData
06A7 E8         478       mov a, R0
06A8 540F       479       anl a, #0x0F
06AA 2430       480       add a, #0x30
06AC 1205E1     481       lcall ?WriteData
06AF 22         482       ret
06B0            483   
06B0            484   LCD_Display_Update_func:
06B0 C0E0       485       push acc
06B2            486       
06B2            487       ; ==========================================
06B2            488       ; PART 1: STATIC TEXT (Title)
06B2            489       ; Runs ONLY when the state changes
06B2            490       ; ==========================================
06B2            491       
06B2            492       ; [FIX] "Trampoline" logic for long distance jump
06B2            493       ; If signal is SET (1), we stay here and update.
06B2            494       ; If signal is CLEAR (0), we Long Jump to the Live Update section.
06B2 300F04     495       jnb state_change_signal, Do_Dynamic_Update
06B5 C20F       496            clr state_change_signal
06B7 8003       497            sjmp Do_Static_Update
06B9            498   Do_Dynamic_Update:
06B9 0207F0     499            ljmp Check_Live_Update
06BC            500   
06BC            501   Do_Static_Update:
06BC            502       ; State Changed: Clear Screen and Write Title
06BC 120983     503       lcall Clear_Screen_Func
06BF E560       504       mov a, Control_FSM_state
06C1            505       
06C1            506       ; State 0: Welcome
06C1 B4003B     507       cjne a, #0, LCD_Check_1
06C4 C0E0       508            push acc
06C6 7401       508            mov a, #1
06C8 14         508            dec a
06C9 12062B     508            lcall ?Set_Cursor_1 ; Select column and row
06CC D0E0       508            pop acc
06CE C083       509            push dph
06D0 C082       509            push dpl
06D2 C0E0       509            push acc
06D4 900330     509            mov dptr, #String_state0_1
06D7 12061E     509            lcall ?Send_Constant_String
06DA D0E0       509            pop acc
06DC D082       509            pop dpl
06DE D083       509            pop dph
06E0 C0E0       510            push acc
06E2 7401       510            mov a, #1
06E4 14         510            dec a
06E5 120629     510            lcall ?Set_Cursor_2 ; Select column and row
06E8 D0E0       510            pop acc
06EA C083       511            push dph
06EC C082       511            push dpl
06EE C0E0       511            push acc
06F0 900340     511            mov dptr, #String_state0_2
06F3 12061E     511            lcall ?Send_Constant_String
06F6 D0E0       511            pop acc
06F8 D082       511            pop dpl
06FA D083       511            pop dph
06FC 0207ED     512       ljmp LCD_Done_Bridge ; Exit
06FF            513   
06FF            514   LCD_Check_1: ; Setup
06FF B4011F     515       cjne a, #1, LCD_Check_2
0702 C0E0       516            push acc
0704 7401       516            mov a, #1
0706 14         516            dec a
0707 12062B     516            lcall ?Set_Cursor_1 ; Select column and row
070A D0E0       516            pop acc
070C C083       517            push dph
070E C082       517            push dpl
0710 C0E0       517            push acc
0712 9003A5     517            mov dptr, #String_state1
0715 12061E     517            lcall ?Send_Constant_String
0718 D0E0       517            pop acc
071A D082       517            pop dpl
071C D083       517            pop dph
071E 0207ED     518       ljmp LCD_Done_Bridge
0721            519   
0721            520   LCD_Check_2: ; Ramp to Soak
0721 B4021F     521       cjne a, #2, LCD_Check_3
0724 C0E0       522            push acc
0726 7401       522            mov a, #1
0728 14         522            dec a
0729 12062B     522            lcall ?Set_Cursor_1 ; Select column and row
072C D0E0       522            pop acc
072E C083       523            push dph
0730 C082       523            push dpl
0732 C0E0       523            push acc
0734 9003EC     523            mov dptr, #String_state2
0737 12061E     523            lcall ?Send_Constant_String
073A D0E0       523            pop acc
073C D082       523            pop dpl
073E D083       523            pop dph
0740 020810     524       ljmp LCD_Update_Temp_Value ; Draw Temp immediately!
0743            525   
0743            526   LCD_Check_3: ; Soak
0743 B4031F     527       cjne a, #3, LCD_Check_4
0746 C0E0       528            push acc
0748 7401       528            mov a, #1
074A 14         528            dec a
074B 12062B     528            lcall ?Set_Cursor_1 ; Select column and row
074E D0E0       528            pop acc
0750 C083       529            push dph
0752 C082       529            push dpl
0754 C0E0       529            push acc
0756 9003FC     529            mov dptr, #String_state3
0759 12061E     529            lcall ?Send_Constant_String
075C D0E0       529            pop acc
075E D082       529            pop dpl
0760 D083       529            pop dph
0762 020810     530       ljmp LCD_Update_Temp_Value
0765            531   
0765            532   LCD_Check_4: ; Ramp to Peak
0765 B4041F     533       cjne a, #4, LCD_Check_5
0768 C0E0       534            push acc
076A 7401       534            mov a, #1
076C 14         534            dec a
076D 12062B     534            lcall ?Set_Cursor_1 ; Select column and row
0770 D0E0       534            pop acc
0772 C083       535            push dph
0774 C082       535            push dpl
0776 C0E0       535            push acc
0778 90040C     535            mov dptr, #String_state4
077B 12061E     535            lcall ?Send_Constant_String
077E D0E0       535            pop acc
0780 D082       535            pop dpl
0782 D083       535            pop dph
0784 020810     536       ljmp LCD_Update_Temp_Value
0787            537   
0787            538   LCD_Check_5: ; Reflow
0787 B4051F     539       cjne a, #5, LCD_Check_6
078A C0E0       540            push acc
078C 7401       540            mov a, #1
078E 14         540            dec a
078F 12062B     540            lcall ?Set_Cursor_1 ; Select column and row
0792 D0E0       540            pop acc
0794 C083       541            push dph
0796 C082       541            push dpl
0798 C0E0       541            push acc
079A 90041C     541            mov dptr, #String_state5
079D 12061E     541            lcall ?Send_Constant_String
07A0 D0E0       541            pop acc
07A2 D082       541            pop dpl
07A4 D083       541            pop dph
07A6 020810     542       ljmp LCD_Update_Temp_Value
07A9            543   
07A9            544   LCD_Check_6: ; Cooling
07A9 B4061F     545       cjne a, #6, LCD_Check_7
07AC C0E0       546            push acc
07AE 7401       546            mov a, #1
07B0 14         546            dec a
07B1 12062B     546            lcall ?Set_Cursor_1 ; Select column and row
07B4 D0E0       546            pop acc
07B6 C083       547            push dph
07B8 C082       547            push dpl
07BA C0E0       547            push acc
07BC 90042C     547            mov dptr, #String_state6
07BF 12061E     547            lcall ?Send_Constant_String
07C2 D0E0       547            pop acc
07C4 D082       547            pop dpl
07C6 D083       547            pop dph
07C8 020810     548       ljmp LCD_Update_Temp_Value
07CB            549   
07CB            550   LCD_Check_7: ; Done
07CB            551       ; [FIX] Check distance safe logic for State 7
07CB B4071F     552       cjne a, #7, LCD_Done_Bridge ; If not 7, we are done
07CE C0E0       553            push acc
07D0 7401       553            mov a, #1
07D2 14         553            dec a
07D3 12062B     553            lcall ?Set_Cursor_1 ; Select column and row
07D6 D0E0       553            pop acc
07D8 C083       554            push dph
07DA C082       554            push dpl
07DC C0E0       554            push acc
07DE 90043C     554            mov dptr, #String_state7
07E1 12061E     554            lcall ?Send_Constant_String
07E4 D0E0       554            pop acc
07E6 D082       554            pop dpl
07E8 D083       554            pop dph
07EA 0207ED     555       ljmp LCD_Done_Bridge
07ED            556   
07ED            557   ; Local bridge to reach the far-away LCD_Done
07ED            558   LCD_Done_Bridge:
07ED 020871     559       ljmp LCD_Done
07F0            560   
07F0            561   ; ==========================================
07F0            562   ; PART 2: DYNAMIC VALUES (Temperature)
07F0            563   ; Runs every time 'one_second_flag' is set
07F0            564   ; ==========================================
07F0            565   Check_Live_Update:
07F0 3001FA     566       jnb one_second_flag, LCD_Done_Bridge
07F3 C201       567       clr one_second_flag
07F5            568       
07F5            569       ; Only update temp for States 2, 3, 4, 5, 6
07F5 E560       570       mov a, Control_FSM_state
07F7 B40202     571       cjne a, #2, Check_St3
07FA 8014       572       sjmp LCD_Update_Temp_Value
07FC            573   Check_St3:
07FC B40302     574       cjne a, #3, Check_St4
07FF 800F       575       sjmp LCD_Update_Temp_Value
0801            576   Check_St4:
0801 B40402     577       cjne a, #4, Check_St5
0804 800A       578       sjmp LCD_Update_Temp_Value
0806            579   Check_St5:
0806 B40502     580       cjne a, #5, Check_St6
0809 8005       581       sjmp LCD_Update_Temp_Value
080B            582   Check_St6:
080B B40663     583       cjne a, #6, LCD_Done
080E 8000       584       sjmp LCD_Update_Temp_Value
0810            585   
0810            586   ; --- HELPER: Prints "XXX C" on Line 2 ---
0810            587   LCD_Update_Temp_Value:
0810 C0E0       588            push acc
0812 7401       588            mov a, #1
0814 14         588            dec a
0815 120629     588            lcall ?Set_Cursor_2 ; Select column and row
0818 D0E0       588            pop acc
081A            589       
081A            590       ; Convert current_temp to BCD
081A 85473A     591       mov x, current_temp
081D 85483B     592       mov x+1, current_temp+1
0820 85493C     593       mov x+2, current_temp+2
0823 854A3D     594       mov x+3, current_temp+3
0826 12002E     595       lcall hex2bcd
0829            596   
0829            597       ; Update HEX2-HEX0 with temperature
0829 1209AE     598       lcall Update_HEX_Temp
082C            599       
082C            600       ; Print Hundreds
082C E543       601       mov a, bcd+1
082E 540F       602       anl a, #0x0F
0830 2430       603       add a, #0x30
0832 1205E1     604       lcall ?WriteData
0835            605       
0835            606       ; Print Tens
0835 E542       607       mov a, bcd+0
0837 C4         608       swap a
0838 540F       609       anl a, #0x0F
083A 2430       610       add a, #0x30
083C 1205E1     611       lcall ?WriteData
083F            612       
083F            613       ; Print Ones
083F E542       614       mov a, bcd+0
0841 540F       615       anl a, #0x0F
0843 2430       616       add a, #0x30
0845 1205E1     617       lcall ?WriteData
0848            618       
0848            619       ; Print 'C'
0848 7443       620       mov a, #'C'
084A 1205E1     621       lcall ?WriteData
084D            622       
084D            623       ; Clear remaining line space (prevents garbage)
084D 7420       624       mov a, #' '
084F 1205E1     625       lcall ?WriteData
0852 1205E1     626       lcall ?WriteData
0855            627   
0855            628       ; Print time MM:SS at bottom right
0855 C0E0       629            push acc
0857 740C       629            mov a, #12
0859 14         629            dec a
085A 120629     629            lcall ?Set_Cursor_2 ; Select column and row
085D D0E0       629            pop acc
085F E531       630       mov a, current_time_minute
0861 12069B     631       lcall LCD_Print_2Digits
0864 743A       632       mov a, #':'
0866 1205E1     633       lcall ?WriteData
0869 E530       634       mov a, current_time_sec
086B 12069B     635       lcall LCD_Print_2Digits
086E            636   
086E            637       ; Mirror temp to serial (PuTTY/screen)
086E 1204C5     638       lcall Serial_Send_Temp_Line
0871            639   
0871            640   LCD_Done:
0871 D0E0       641       pop acc
0873 22         642       ret
0874            643   
0874            644   ; ----------------------------------------------------------------
0874            645   ; MODULE: SCREEN UPDATE (Visual Logic)
0874            646   ; ----------------------------------------------------------------
0874            647   Update_Screen_Full:
0874 E560       648            mov a, Control_FSM_state
0876 B40102     649            cjne a, #1, Update_Screen_Full_ret
0879 8001       650            sjmp Update_Screen_Full_do
087B            651   Update_Screen_Full_ret:
087B 22         652            ret
087C            653   Update_Screen_Full_do:
087C 3024FC     654       jnb fullscreen_update_signal, Update_Screen_Full_ret
087F C224       655       clr fullscreen_update_signal
0881            656   
0881 120983     657       lcall Clear_Screen_Func
0884 C0E0       658            push acc
0886 7401       658            mov a, #1
0888 14         658            dec a
0889 12062B     658            lcall ?Set_Cursor_1 ; Select column and row
088C D0E0       658            pop acc
088E            659       ; --- Draw Line 1 (Titles) ---
088E E561       660       mov A, Current_State
0890 B40013     661       cjne A, #0, Update_State_1
0893 C083       662            push dph
0895 C082       662            push dpl
0897 C0E0       662            push acc
0899 900350     662            mov dptr, #Txt_Home
089C 12061E     662            lcall ?Send_Constant_String
089F D0E0       662            pop acc
08A1 D082       662            pop dpl
08A3 D083       662            pop dph
08A5 22         663       ret 
08A6            664   Update_State_1:
08A6 B40114     665       cjne A, #1, Update_State_2
08A9 C083       666            push dph
08AB C082       666            push dpl
08AD C0E0       666            push acc
08AF 900361     666            mov dptr, #Txt_SoakT
08B2 12061E     666            lcall ?Send_Constant_String
08B5 D0E0       666            pop acc
08B7 D082       666            pop dpl
08B9 D083       666            pop dph
08BB 8042       667       sjmp Draw_Temp_Format
08BD            668   Update_State_2:
08BD B40214     669       cjne A, #2, Update_State_3
08C0 C083       670            push dph
08C2 C082       670            push dpl
08C4 C0E0       670            push acc
08C6 900372     670            mov dptr, #Txt_SoakTime
08C9 12061E     670            lcall ?Send_Constant_String
08CC D0E0       670            pop acc
08CE D082       670            pop dpl
08D0 D083       670            pop dph
08D2 8046       671       sjmp Draw_Time_Format
08D4            672   Update_State_3:
08D4 B40314     673       cjne A, #3, Update_State_4
08D7 C083       674            push dph
08D9 C082       674            push dpl
08DB C0E0       674            push acc
08DD 900383     674            mov dptr, #Txt_ReflT
08E0 12061E     674            lcall ?Send_Constant_String
08E3 D0E0       674            pop acc
08E5 D082       674            pop dpl
08E7 D083       674            pop dph
08E9 8014       675       sjmp Draw_Temp_Format
08EB            676   Update_State_4:
08EB C083       677            push dph
08ED C082       677            push dpl
08EF C0E0       677            push acc
08F1 900394     677            mov dptr, #Txt_ReflTime
08F4 12061E     677            lcall ?Send_Constant_String
08F7 D0E0       677            pop acc
08F9 D082       677            pop dpl
08FB D083       677            pop dph
08FD 801B       678       sjmp Draw_Time_Format
08FF            679   
08FF            680   ; --- Draw Line 2 (Values) ---
08FF            681   Draw_Temp_Format:
08FF C0E0       682            push acc
0901 7401       682            mov a, #1
0903 14         682            dec a
0904 120629     682            lcall ?Set_Cursor_2 ; Select column and row
0907 D0E0       682            pop acc
0909 120997     683       lcall Get_Current_Buffer_Addr
090C 120979     684       lcall Print_String_RAM
090F C0E0       685            push acc
0911 7443       685            mov a, #'C'
0913 1205E1     685            lcall ?WriteData
0916 D0E0       685            pop acc
0918 8034       686       sjmp Restore_Cursor
091A            687   
091A            688   Draw_Time_Format:
091A C0E0       689            push acc
091C 7401       689            mov a, #1
091E 14         689            dec a
091F 120629     689            lcall ?Set_Cursor_2 ; Select column and row
0922 D0E0       689            pop acc
0924 120997     690       lcall Get_Current_Buffer_Addr
0927            691       ; MM
0927 E6         692       mov A, @R0
0928 1205E1     693       lcall ?WriteData
092B 08         694       inc R0
092C E6         695       mov A, @R0
092D 1205E1     696       lcall ?WriteData
0930 08         697       inc R0
0931            698       ; Colon
0931 C0E0       699            push acc
0933 743A       699            mov a, #':'
0935 1205E1     699            lcall ?WriteData
0938 D0E0       699            pop acc
093A            700       ; SS
093A E6         701       mov A, @R0
093B 1205E1     702       lcall ?WriteData
093E 08         703       inc R0
093F E6         704       mov A, @R0
0940 1205E1     705       lcall ?WriteData
0943            706       ; Unit
0943 C0E0       707            push acc
0945 7473       707            mov a, #'s'
0947 1205E1     707            lcall ?WriteData
094A D0E0       707            pop acc
094C 8000       708       sjmp Restore_Cursor
094E            709   
094E            710   ; --- Restore Cursor Position ---
094E            711   Restore_Cursor:
094E E561       712       mov A, Current_State
0950 B40202     713       cjne A, #2, RC_Check_State_4  
0953 800C       714       sjmp Adjust_Cursor_Time
0955            715   RC_Check_State_4:             
0955 B40402     716       cjne A, #4, Normal_Cursor
0958 8007       717       sjmp Adjust_Cursor_Time
095A            718   
095A            719   Normal_Cursor:
095A E56A       720       mov A, Cursor_Idx
095C 24C0       721       add A, #0xC0
095E 1205E6     722       lcall ?WriteCommand
0961            723   
0961            724   Adjust_Cursor_Time:
0961            725       ; Skip the colon index (2)
0961 E56A       726       mov A, Cursor_Idx
0963 B40201     727       cjne A, #2, No_Skip
0966 04         728       inc A 
0967            729   No_Skip:
0967            730       ; Add 1 if past the colon
0967 C3         731       clr C
0968 9402       732       subb A, #2
096A 4005       733       jc No_Add
096C E56A       734       mov A, Cursor_Idx
096E 04         735       inc A
096F 8002       736       sjmp Final_Cursor_Set
0971            737   No_Add:
0971 E56A       738       mov A, Cursor_Idx
0973            739   Final_Cursor_Set:
0973 24C0       740       add A, #0xC0
0975 1205E6     741       lcall ?WriteCommand
0978 22         742       ret
0979            743   
0979            744   Print_String_RAM:
0979 E6         745       mov A, @R0
097A 6006       746       jz Print_String_Done
097C 1205E1     747       lcall ?WriteData
097F 08         748       inc R0
0980 80F7       749       sjmp Print_String_RAM
0982            750   Print_String_Done:
0982 22         751       ret
0983            752   
0983            753   ; --- Clear Screen with hardware delay ---
0983            754   Clear_Screen_Func:
0983 7401       755            mov a, #0x01
0985 1205E6     755            lcall ?WriteCommand        ; Clear display command
0988 C002       756            push AR2
098A 7A02       756            mov R2, #2
098C 12059C     756            lcall ?Wait_Milli_Seconds
098F D002       756            pop AR2     ; LCD needs ~2ms to clear
0991 740C       757            mov a, #0x0C
0993 1205E6     757            lcall ?WriteCommand        ; Display ON, Cursor OFF
0996 22         758       ret
0997            759   
0997            760   Get_Current_Buffer_Addr:
0997 E561       761       mov A, Current_State
0999 B40103     762       cjne A, #1, Get_Buf_2
099C 7880       763       mov R0, #Buf_Soak_Temp
099E 22         764       ret
099F            765   Get_Buf_2:
099F B40203     766       cjne A, #2, Get_Buf_3
09A2 7884       767       mov R0, #Buf_Soak_Time
09A4 22         768       ret
09A5            769   Get_Buf_3:
09A5 B40303     770       cjne A, #3, Get_Buf_4
09A8 7889       771       mov R0, #Buf_Refl_Temp
09AA 22         772       ret
09AB            773   Get_Buf_4:
09AB 788D       774       mov R0, #Buf_Refl_Time
09AD 22         775       ret
09AE            776   
09AE            777   ;-------------------------------------------------------------------------------
09AE            778   ; Update HEX2-HEX0 with temperature (3 digits)
09AE            779   ;-------------------------------------------------------------------------------
09AE            780   Update_HEX_Temp:
09AE 900646     781       mov dptr, #T_7seg
09B1            782       ; Hundreds -> HEX2
09B1 E543       783       mov a, bcd+1
09B3 540F       784       anl a, #0x0F
09B5 93         785       movc a, @a+dptr
09B6 F593       786       mov HEX2, a
09B8            787       ; Tens -> HEX1
09B8 E542       788       mov a, bcd+0
09BA C4         789       swap a
09BB 540F       790       anl a, #0x0F
09BD 93         791       movc a, @a+dptr
09BE F592       792       mov HEX1, a
09C0            793       ; Ones -> HEX0
09C0 E542       794       mov a, bcd+0
09C2 540F       795       anl a, #0x0F
09C4 93         796       movc a, @a+dptr
09C5 F591       797       mov HEX0, a
09C7 22         798       ret
09C8            799       
09C8            800   ;---------------------------------------------------------
09C8            801   PB0_DEB:
09C8            802   ;non-blocking state machine for PB0 debounce
09C8 E572       803       mov a, PB0_DEB_state
09CA            804   PB0_DEB_state0:
09CA B4000A     805       cjne a, #0, PB0_DEB_state1
09CD 20902F     806       jb PB0, PB0_DEB_done
09D0 757100     807       mov PB0_DEB_timer, #0
09D3 0572       808       inc PB0_DEB_state
09D5 8028       809       sjmp PB0_DEB_done
09D7            810   PB0_DEB_state1:
09D7 B40109     811       cjne a, #1, PB0_DEB_state2
09DA            812       ; this is the debounce state
09DA E571       813       mov a, PB0_DEB_timer
09DC B43220     814       cjne a, #50, PB0_DEB_done ; 50 ms passed?
09DF 0572       815       inc PB0_DEB_state
09E1 801C       816       sjmp PB0_DEB_done  
09E3            817   PB0_DEB_state2:
09E3 B4020C     818       cjne a, #2, PB0_DEB_state3
09E6 209004     819       jb PB0, PB0_DEB_state2b
09E9 0572       820       inc PB0_DEB_state
09EB 8012       821       sjmp PB0_DEB_done  
09ED            822   PB0_DEB_state2b:
09ED 757200     823       mov PB0_DEB_state, #0
09F0 800D       824       sjmp PB0_DEB_done
09F2            825   PB0_DEB_state3:
09F2 B4030A     826       cjne a, #3, PB0_DEB_done
09F5 309007     827       jnb PB0, PB0_DEB_done
09F8 D215       828       setb PB0_flag ; Suscesfully detected a valid PB0 press/release
09FA B2ED       829            cpl LEDRA.5
09FC 757200     830       mov PB0_DEB_state, #0  
09FF            831   PB0_DEB_done:
09FF 22         832       ret
0A00            833   
0A00            834   PB2_DEB:
0A00            835   ;non-blocking state machine for PB2 debounce
0A00 E574       836       mov a, PB2_DEB_state
0A02            837   PB2_DEB_state0:
0A02 B4000A     838       cjne a, #0, PB2_DEB_state1
0A05 20B72D     839       jb PB2, PB2_DEB_done
0A08 757300     840       mov PB2_DEB_timer, #0
0A0B 0574       841       inc PB2_DEB_state
0A0D 8026       842       sjmp PB2_DEB_done
0A0F            843   PB2_DEB_state1:
0A0F B40109     844       cjne a, #1, PB2_DEB_state2
0A12            845       ; this is the debounce state
0A12 E573       846       mov a, PB2_DEB_timer
0A14 B4321E     847       cjne a, #50, PB2_DEB_done ; 50 ms passed?
0A17 0574       848       inc PB2_DEB_state
0A19 801A       849       sjmp PB2_DEB_done  
0A1B            850   PB2_DEB_state2:
0A1B B4020C     851       cjne a, #2, PB2_DEB_state3
0A1E 20B704     852       jb PB2, PB2_DEB_state2b
0A21 0574       853       inc PB2_DEB_state
0A23 8010       854       sjmp PB2_DEB_done  
0A25            855   PB2_DEB_state2b:
0A25 757400     856       mov PB2_DEB_state, #0
0A28 800B       857       sjmp PB2_DEB_done
0A2A            858   PB2_DEB_state3:
0A2A B40308     859       cjne a, #3, PB2_DEB_done
0A2D 30B705     860       jnb PB2, PB2_DEB_done
0A30 D217       861       setb PB2_flag ; Suscesfully detected a valid PB2 press/release
0A32 757400     862       mov PB2_DEB_state, #0  
0A35            863   PB2_DEB_done:
0A35 22         864       ret
0A36            865   
0A36            866   ; ------------------------------------------------------------------------------
0A36            867   ; Non-blocking FSM for the one second counter
0A36            868   ;-------------------------------------------------------------------------------
0A36            869   SEC_FSM:
0A36 E570       870       mov a, SEC_FSM_state
0A38            871   SEC_FSM_state0:
0A38 B4000C     872       cjne a, #0, SEC_FSM_state1
0A3B E56F       873       mov a, SEC_FSM_timer
0A3D B4FA51     874       cjne a, #250, SEC_FSM_done
0A40 756F00     875       mov SEC_FSM_timer, #0
0A43 0570       876       inc SEC_FSM_state
0A45 804A       877       sjmp SEC_FSM_done
0A47            878   SEC_FSM_state1:  
0A47 B4010E     879       cjne a, #1, SEC_FSM_state2
0A4A D2E9       880       setb LEDRA.1
0A4C E56F       881       mov a, SEC_FSM_timer
0A4E B4FA40     882       cjne a, #250, SEC_FSM_done
0A51 756F00     883       mov SEC_FSM_timer, #0
0A54 0570       884       inc SEC_FSM_state
0A56 8039       885       sjmp SEC_FSM_done
0A58            886   SEC_FSM_state2:  
0A58 B4020E     887       cjne a, #2, SEC_FSM_state3
0A5B D2EA       888       setb LEDRA.2
0A5D E56F       889       mov a, SEC_FSM_timer
0A5F B4FA2F     890       cjne a, #250, SEC_FSM_done
0A62 756F00     891       mov SEC_FSM_timer, #0
0A65 0570       892       inc SEC_FSM_state
0A67 8028       893       sjmp SEC_FSM_done
0A69            894   SEC_FSM_state3:  
0A69 B40325     895       cjne a, #3, SEC_FSM_done
0A6C D2EB       896       setb LEDRA.3
0A6E E56F       897       mov a, SEC_FSM_timer
0A70 B4FA1E     898       cjne a, #250, SEC_FSM_done
0A73 756F00     899       mov SEC_FSM_timer, #0
0A76 757000     900       mov SEC_FSM_state, #0
0A79            901       
0A79            902       ; These flags are always set (global use)
0A79 D204       903       setb one_second_lcd_flag
0A7B D201       904       setb one_second_flag
0A7D            905       
0A7D            906       ; Heartbeat LED always toggles
0A7D B2E8       907       cpl LEDRA.0
0A7F            908       
0A7F            909       ; Only update time if counting is enabled
0A7F 300D0F     910       jnb time_count_doing_signal, SEC_FSM_done
0A82            911       
0A82            912       ; Update current time (only when counting)
0A82 E530       913       mov a, current_time_sec
0A84 04         914       inc a
0A85 B43C07     915       cjne a, #60, SEC_NoMinuteCarry
0A88 753000     916       mov current_time_sec, #0
0A8B 0531       917       inc current_time_minute
0A8D 8002       918       sjmp SEC_FSM_done
0A8F            919   SEC_NoMinuteCarry:
0A8F F530       920       mov current_time_sec, a
0A91            921   SEC_FSM_done:
0A91 22         922       ret
0A92            923   
0A92            924   ; ------------------------------------------------------------------------------
0A92            925   ; Counting the processing time 
0A92            926   ;-------------------------------------------------------------------------------
0A92            927   Time_Counter:
0A92 C0E0       928       push ACC
0A94 C0D0       929       push psw
0A96 E560       930       mov a, Control_FSM_state
0A98            931       
0A98            932       ; State 2: Start counting
0A98 B4020F     933       cjne a, #2, Time_Counter_Nstate2
0A9B 101102     934       jbc state_change_signal_Count, Time_Counter_Start
0A9E 800F       935       sjmp Time_Counter_Done
0AA0            936   
0AA0            937   Time_Counter_Start:
0AA0 753000     938       mov current_time_sec, #0
0AA3 753100     939       mov current_time_minute, #0
0AA6 D20D       940       setb time_count_doing_signal
0AA8 8005       941       sjmp Time_Counter_Done
0AAA            942   
0AAA            943   Time_Counter_Nstate2:
0AAA            944       ; State 6: Stop counting
0AAA B40602     945       cjne a, #6, Time_Counter_Done
0AAD C20D       946       clr time_count_doing_signal
0AAF            947   
0AAF            948   Time_Counter_Done:
0AAF D0D0       949       pop psw
0AB1 D0E0       950       pop ACC
0AB3 22         951       ret
0AB4            952   
0AB4            953   
0AB4            954   ;-------------------------------------------------------------------------------
0AB4            955   ; Time_Compare_MMSS
0AB4            956   ;
0AB4            957   ; PURPOSE:
0AB4            958   ;   Compare elapsed time (current_time_minute:current_time_sec)
0AB4            959   ;   against soak and reflow setpoints (soak_time_*, reflow_time_*).
0AB4            960   ;
0AB4            961   ; BEHAVIOR:
0AB4            962   ;   - If current_time >= soak_time   if soak_time_reached    = 1
0AB4            963   ;   - If current_time >= reflow_time if reflow_time_reached = 1
0AB4            964   ;
0AB4            965   ; NOTES:
0AB4            966   ;   Compare minutes first, then seconds.
0AB4            967   ;-------------------------------------------------------------------------------
0AB4            968   Time_Compare_MMSS:
0AB4 C0E0       969       push acc
0AB6 C0D0       970       push psw
0AB8            971   
0AB8 E560       972            mov a, Control_FSM_state
0ABA B4032E     973            cjne a, #3, TC_Not_Soak
0ABD            974   ; soak state time comparison
0ABD 101002     975            jbc state_change_signal_TC, TC_Soak_Start_Record
0AC0 8015       976            sjmp TC_Soak_Comparing
0AC2            977   
0AC2            978   TC_Soak_Start_Record:
0AC2 E531       979            mov a, current_time_minute
0AC4 2533       980            add a, soak_time_minute
0AC6 F537       981            mov soak_end_time_minute, a
0AC8            982   
0AC8 E530       983            mov a, current_time_sec
0ACA 2532       984            add a, soak_time_sec
0ACC F536       985            mov soak_end_time_sec, a
0ACE            986   
0ACE C3         987            clr c
0ACF 943C       988            subb a, #60
0AD1 4004       989            jc TC_Soak_Comparing
0AD3            990   
0AD3 F536       991            mov soak_end_time_sec, a
0AD5 0537       992            inc soak_end_time_minute
0AD7            993   
0AD7            994   TC_Soak_Comparing:
0AD7 E531       995       mov  a, current_time_minute
0AD9 C3         996       clr  c
0ADA 9537       997       subb a, soak_end_time_minute
0ADC 403C       998            jc   TC_Done                   ; current_min < end_min
0ADE 7007       999       jnz  TC_Soak_Reached           ; current_min > end_min
0AE0           1000   
0AE0           1001       ; minutes equal -> compare seconds
0AE0 E530      1002       mov  a, current_time_sec
0AE2 C3        1003       clr  c
0AE3 9536      1004       subb a, soak_end_time_sec
0AE5 7033      1005       jnz   TC_Done
0AE7           1006   
0AE7           1007   TC_Soak_Reached:
0AE7 D208      1008       setb soak_time_reached
0AE9 802F      1009            sjmp TC_Done
0AEB           1010   
0AEB           1011   TC_Not_Soak:
0AEB E560      1012            mov a, Control_FSM_state
0AED B4052A    1013            cjne a, #5, TC_Done
0AF0           1014   ; soak state time comparison
0AF0 101002    1015            jbc state_change_signal_TC, TC_Reflow_Start_Record
0AF3 8013      1016            sjmp TC_Reflow_Comparing
0AF5           1017   
0AF5           1018   TC_Reflow_Start_Record:
0AF5 E531      1019            mov a, current_time_minute
0AF7 2535      1020            add a, reflow_time_minute
0AF9 F539      1021            mov reflow_end_time_minute, a
0AFB           1022   
0AFB E530      1023            mov a, current_time_sec
0AFD 2534      1024            add a, reflow_time_sec
0AFF F538      1025            mov reflow_end_time_sec, a
0B01 C3        1026            clr c
0B02 943C      1027            subb a, #60
0B04           1028   
0B04 F538      1029            mov reflow_end_time_sec, a
0B06 0539      1030            inc reflow_end_time_minute
0B08           1031   
0B08           1032   TC_Reflow_Comparing:
0B08 E531      1033       mov  a, current_time_minute
0B0A C3        1034       clr  c
0B0B 9539      1035       subb a, reflow_end_time_minute
0B0D 400B      1036       jc   TC_Done
0B0F 7007      1037       jnz  TC_Reflow_Reached
0B11           1038   
0B11 E530      1039       mov  a, current_time_sec
0B13 C3        1040       clr  c
0B14 9538      1041       subb a, reflow_end_time_sec
0B16 4002      1042            jc   TC_Done
0B18           1043   
0B18           1044   TC_Reflow_Reached:
0B18 D209      1045       setb reflow_time_reached
0B1A           1046   
0B1A           1047   TC_Done:
0B1A D0D0      1048       pop  psw
0B1C D0E0      1049       pop  acc
0B1E 22        1050       ret
0B1F           1051   
0B1F           1052   ;-------------------------------------------------------------------------------;
0B1F           1053   ; Temp_Compare
0B1F           1054   ; Checks if we have reached the user's target temperatures.
0B1F           1055   ; Only compares relevant temperature based on current Control_FSM_state:
0B1F           1056   ;   State 2: Sets 'soak_temp_reached' if current_temp >= soak_temp
0B1F           1057   ;   State 4: Sets 'reflow_temp_reached' if current_temp >= reflow_temp
0B1F           1058   ;   State 6: Sets 'cooling_temp_reached' if current_temp < 100C
0B1F           1059   ;-------------------------------------------------------------------------------;
0B1F           1060   Temp_Compare:
0B1F C0E0      1061       push acc
0B21 C0D0      1062       push psw
0B23 C000      1063       push AR0
0B25 C001      1064       push AR1
0B27 C002      1065       push AR2
0B29           1066       
0B29 E560      1067       mov a, Control_FSM_state
0B2B           1068       
0B2B           1069       ; --- CHECK STATE 2: SOAK TEMP ---
0B2B B40202    1070       cjne a, #2, Temp_Compare_Check_State4
0B2E 800A      1071       sjmp Check_Soak_Threshold
0B30           1072       
0B30           1073   Temp_Compare_Check_State4:
0B30           1074       ; --- CHECK STATE 4: REFLOW TEMP ---
0B30 B40402    1075       cjne a, #4, Temp_Compare_Check_State6
0B33 801D      1076       sjmp Check_Reflow_Threshold
0B35           1077       
0B35           1078   Temp_Compare_Check_State6:
0B35           1079       ; --- CHECK STATE 6: COOLING TEMP ---
0B35 B4064D    1080       cjne a, #6, Temp_Compare_Done
0B38 8030      1081       sjmp Check_Cooling_Threshold
0B3A           1082   
0B3A           1083   Check_Soak_Threshold:
0B3A           1084       ; Copy current_temp to X
0B3A 7847      1085       mov R0, #current_temp
0B3C 793A      1086       mov R1, #x
0B3E 120B90    1087       lcall Copy4_Bytes_R0_to_R1
0B41           1088   
0B41           1089       ; Copy soak_temp to Y
0B41 784B      1090       mov R0, #soak_temp
0B43 793E      1091       mov R1, #y
0B45 120B90    1092       lcall Copy4_Bytes_R0_to_R1
0B48           1093   
0B48           1094       ; Compare: Is X (Current) < Y (Target)?
0B48 12011A    1095       lcall x_lt_y
0B4B 200037    1096       jb mf, Temp_Compare_Done          ; If Current < Target, not reached yet
0B4E           1097       
0B4E           1098       ; If Current >= Target
0B4E D205      1099       setb soak_temp_reached
0B50 8033      1100       sjmp Temp_Compare_Done
0B52           1101   
0B52           1102   Check_Reflow_Threshold:
0B52           1103       ; Copy current_temp to X
0B52 7847      1104       mov R0, #current_temp
0B54 793A      1105       mov R1, #x
0B56 120B90    1106       lcall Copy4_Bytes_R0_to_R1
0B59           1107   
0B59           1108       ; Copy reflow_temp to Y
0B59 784F      1109       mov R0, #reflow_temp
0B5B 793E      1110       mov R1, #y
0B5D 120B90    1111       lcall Copy4_Bytes_R0_to_R1
0B60           1112   
0B60           1113       ; Compare
0B60 12011A    1114       lcall x_lt_y
0B63 20001F    1115       jb mf, Temp_Compare_Done          ; If Current < Target, not reached yet
0B66           1116       
0B66           1117       ; If Current >= Target
0B66 D206      1118       setb reflow_temp_reached
0B68 801B      1119       sjmp Temp_Compare_Done
0B6A           1120   
0B6A           1121   Check_Cooling_Threshold:
0B6A           1122       ; Copy current_temp to X
0B6A 7847      1123       mov R0, #current_temp
0B6C 793A      1124       mov R1, #x
0B6E 120B90    1125       lcall Copy4_Bytes_R0_to_R1
0B71           1126       
0B71 753E64    1127            mov y+0, #low (100 % 0x10000) 
0B74 753F00    1127            mov y+1, #high(100 % 0x10000) 
0B77 754000    1127            mov y+2, #low (100 / 0x10000) 
0B7A 754100    1127            mov y+3, #high(100 / 0x10000)                         ; Cooling target = 100C
0B7D 12011A    1128       lcall x_lt_y
0B80 300002    1129       jnb mf, Temp_Compare_Done         ; If temp >= 100, not cooled yet
0B83           1130       
0B83           1131       ; If Current < 100C
0B83 D207      1132       setb cooling_temp_reached
0B85           1133   
0B85           1134   ; ---------------------------------------------------------
0B85           1135   Temp_Compare_Done:
0B85 D002      1136       pop AR2
0B87 D001      1137       pop AR1
0B89 D000      1138       pop AR0
0B8B D0D0      1139       pop psw
0B8D D0E0      1140       pop acc
0B8F 22        1141       ret
0B90           1142   
0B90           1143   ;-------------------------------------------------------------------------------;
0B90           1144   ; Copy4_Bytes_R0_to_R1
0B90           1145   ;
0B90           1146   ; PURPOSE:
0B90           1147   ;   Utility routine to copy a 32-bit value (4 bytes)
0B90           1148   ;   from one memory location to another.
0B90           1149   ;
0B90           1150   ; INPUTS:
0B90           1151   ;   R0 st source address
0B90           1152   ;   R1 at destination address
0B90           1153   ;
0B90           1154   ; USES:
0B90           1155   ;   R2 as loop counter
0B90           1156   ;
0B90           1157   ; EXAMPLE:
0B90           1158   ;   mov R0, #current_temp
0B90           1159   ;   mov R1, #x
0B90           1160   ;   lcall Copy4_Bytes_R0_to_R1
0B90           1161   ;-------------------------------------------------------------------------------;
0B90           1162   Copy4_Bytes_R0_to_R1:
0B90 7A04      1163       mov  R2, #4
0B92           1164   Copy4_Loop:
0B92 E6        1165       mov  a, @R0
0B93 F7        1166       mov  @R1, a
0B94 08        1167       inc  R0
0B95 09        1168       inc  R1
0B96 DAFA      1169       djnz R2, Copy4_Loop
0B98 22        1170       ret
0B99           1171   
0B99           1172   ;-------------------------------------------------------------------------------
0B99           1173   ; PWM
0B99           1174   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0B99           1175   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0B99           1176   ; ------------------------------------------------------------------------------
0B99           1177   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0B99 100202    1178       jbc one_ms_pwm_flag, pwm_wave_generator
0B9C 8071      1179       sjmp end_pwm_generator
0B9E           1180   
0B9E           1181   pwm_wave_generator:
0B9E C200      1182       clr mf
0BA0           1183       ; move pwm counter value into x for comparison purpose
0BA0 855C3A    1184       mov x, pwm_counter
0BA3 855D3B    1185       mov x+1, pwm_counter+1
0BA6 855E3C    1186       mov x+2, pwm_counter+2
0BA9 855F3D    1187       mov x+3, pwm_counter+3
0BAC           1188   
0BAC 753EDB    1189            mov y+0, #low (PWM_PERIOD % 0x10000) 
0BAF 753F05    1189            mov y+1, #high(PWM_PERIOD % 0x10000) 
0BB2 754000    1189            mov y+2, #low (PWM_PERIOD / 0x10000) 
0BB5 754100    1189            mov y+3, #high(PWM_PERIOD / 0x10000) 
0BB8           1190   
0BB8           1191       ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
0BB8           1192       ; increase x by 1
0BB8 120152    1193       lcall x_eq_y 
0BBB 20001D    1194       jb mf, wrap_pwm_counter
0BBE           1195       ; x not equal 1499, increment by 1
0BBE 753E01    1196            mov y+0, #low (1 % 0x10000) 
0BC1 753F00    1196            mov y+1, #high(1 % 0x10000) 
0BC4 754000    1196            mov y+2, #low (1 / 0x10000) 
0BC7 754100    1196            mov y+3, #high(1 / 0x10000) 
0BCA 1200D3    1197       lcall add32
0BCD           1198       ; update pwm_counter
0BCD 853A5C    1199       mov pwm_counter, x
0BD0 853B5D    1200       mov pwm_counter+1, x+1
0BD3 853C5E    1201       mov pwm_counter+2, x+2
0BD6 853D5F    1202       mov pwm_counter+3, x+3
0BD9 8018      1203       sjmp set_pwm
0BDB           1204   
0BDB           1205   wrap_pwm_counter:
0BDB           1206       ; x equal 1499, wrap to 0
0BDB 753A00    1207            mov x+0, #low (0 % 0x10000) 
0BDE 753B00    1207            mov x+1, #high(0 % 0x10000) 
0BE1 753C00    1207            mov x+2, #low (0 / 0x10000) 
0BE4 753D00    1207            mov x+3, #high(0 / 0x10000) 
0BE7 853A5C    1208       mov pwm_counter, x
0BEA 853B5D    1209       mov pwm_counter+1, x+1
0BED 853C5E    1210       mov pwm_counter+2, x+2
0BF0 853D5F    1211       mov pwm_counter+3, x+3
0BF3           1212   
0BF3           1213   set_pwm:
0BF3           1214       ; compare with power_output, if pwm counter smaller than power_output, 
0BF3           1215       ; set pwm pin high; else set pwm pin low load y with power output value
0BF3 85583E    1216       mov y, power_output
0BF6 85593F    1217       mov y+1, power_output+1
0BF9 855A40    1218       mov y+2, power_output+2
0BFC 855B41    1219       mov y+3, power_output+3
0BFF           1220   
0BFF           1221       ; compare x(pwm counter) with y(power output)
0BFF 12011A    1222       lcall x_lt_y
0C02 200006    1223       jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
0C05           1224       ;output set pwm pin low if pwm counter greater than power output
0C05 C293      1225       clr PWM_OUT
0C07 C2EC      1226       clr LEDRA.4
0C09 8004      1227       sjmp end_pwm_generator
0C0B           1228   
0C0B           1229   set_pwm_high:
0C0B D293      1230       setb PWM_OUT
0C0D D2EC      1231       setb LEDRA.4
0C0F           1232   
0C0F           1233   end_pwm_generator:
0C0F 22        1234       ret
0C10           1235   
0C10           1236   ;-------------------------------------------------------------------------------
0C10           1237   
0C10           1238   ;-------------------------------------------------------------------------------;
0C10           1239   ; Abort condition safety check Temperature time
0C10           1240   ;
0C10           1241   ; PURPOSE:
0C10           1242   ;   Automatic cycle termination on error:
0C10           1243   ;   Abort if oven fails to reach at least 50C in first 60s.
0C10           1244   ;
0C10           1245   ; TRIP CONDITION:
0C10           1246   ;   if (current_time >= 60s) AND (current_temp < 50C)
0C10           1247   ;       -> set tc_missing_abort
0C10           1248   ;       -> set stop_signal
0C10           1249   ;
0C10           1250   ; ASSUMPTIONS:
0C10           1251   ;   - current_time is in SECONDS (32-bit, little-endian)
0C10           1252   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
0C10           1253   ;
0C10           1254   ;   the Load_Y constants accordingly.
0C10           1255   ;-------------------------------------------------------------------------------;
0C10           1256   ;-------------------------------------------------------------------------------;
0C10           1257   ; Abort condition safety check Temperature time
0C10           1258   ;
0C10           1259   ; PURPOSE:
0C10           1260   ;   Automatic cycle termination on error:
0C10           1261   ;   Abort if oven fails to reach at least 50C in first 60s (1 minute).
0C10           1262   ;
0C10           1263   ; TRIP CONDITION:
0C10           1264   ;   if (current_time_minute >= 1) AND (current_temp < 50C)
0C10           1265   ;       -> set tc_missing_abort
0C10           1266   ;       -> set stop_signal
0C10           1267   ;
0C10           1268   ; ASSUMPTIONS:
0C10           1269   ;   - current_time_sec (byte): seconds 0-59
0C10           1270   ;   - current_time_minute (byte): minutes counter
0C10           1271   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
0C10           1272   ;-------------------------------------------------------------------------------;
0C10           1273   Safety_Check_TC:
0C10 C0E0      1274       push acc
0C12 C0D0      1275       push psw
0C14 C000      1276       push AR0
0C16 C001      1277       push AR1
0C18           1278   
0C18           1279       ; ---------------------------------------------------------
0C18           1280       ; GATEKEEPER: IGNORE UNLESS IN STATE 2 (RAMP TO SOAK)
0C18           1281       ; ---------------------------------------------------------
0C18 E560      1282       mov a, Control_FSM_state
0C1A B40202    1283       cjne a, #2, Safety_TC_Exit_Bridge ; If State != 2, skip everything
0C1D 8003      1284       sjmp Safety_Logic_Proceed         ; If State == 2, do the check
0C1F           1285   
0C1F           1286   Safety_TC_Exit_Bridge:
0C1F 020C58    1287       ljmp Safety_TC_Done               ; Jump to the end
0C22           1288   
0C22           1289   Safety_Logic_Proceed:
0C22           1290       ; If already aborted or startup window closed, do nothing
0C22 201333    1291       jb   tc_missing_abort, Safety_TC_Done
0C25 301430    1292       jnb  tc_startup_window, Safety_TC_Done
0C28           1293   
0C28           1294       ; Check: current_time_minute >= 1 ? (has 1 minute passed?)
0C28 E531      1295       mov  a, current_time_minute
0C2A 602C      1296       jz   Safety_TC_Done               ; minute == 0, still waiting
0C2C           1297   
0C2C           1298       ; We reached 1 minute: close the startup window so it won't re-check later
0C2C C214      1299       clr  tc_startup_window
0C2E           1300   
0C2E           1301       ; Now check: current_temp < 50 ?
0C2E 7847      1302       mov  R0, #current_temp
0C30 793A      1303       mov  R1, #x
0C32 120B90    1304       lcall Copy4_Bytes_R0_to_R1
0C35           1305   
0C35 753E32    1306            mov y+0, #low (50 % 0x10000) 
0C38 753F00    1306            mov y+1, #high(50 % 0x10000) 
0C3B 754000    1306            mov y+2, #low (50 / 0x10000) 
0C3E 754100    1306            mov y+3, #high(50 / 0x10000) 
0C41 12011A    1307       lcall x_lt_y
0C44 300011    1308       jnb  mf, Safety_TC_Done           ; temp >= 50  pass
0C47           1309   
0C47           1310       ; FAIL: at 1 minute, still below 50C  abort
0C47 C293      1311       clr  PWM_OUT
0C49 D213      1312       setb tc_missing_abort
0C4B D20B      1313       setb stop_signal
0C4D 120C95    1314       lcall Beep_Ten
0C50           1315       
0C50           1316       ; Force FSM to State 0 (Welcome)
0C50 756000    1317       mov Control_FSM_state, #0
0C53           1318       
0C53           1319       ; Force UI to State 0 (Home Screen)
0C53 756100    1320       mov Current_State, #0
0C56           1321       
0C56           1322       ; Trigger Screen Refresh
0C56 D20F      1323       setb state_change_signal          ; Tell loop to redraw "Welcome"
0C58           1324   
0C58           1325   Safety_TC_Done:
0C58 D001      1326       pop  AR1
0C5A D000      1327       pop  AR0
0C5C D0D0      1328       pop  psw
0C5E D0E0      1329       pop  acc
0C60 22        1330       ret
0C61           1331   
0C61           1332   ; ============================================================
0C61           1333   ; BUZZER STARTUP FUNCTIONS
0C61           1334   ; ============================================================
0C61           1335   ;============================================================
0C61           1336   ; Beep_Judge
0C61           1337   ; Purpose: Trigger appropriate beep pattern based on events
0C61           1338   ;   - Beep once when state changes
0C61           1339   ;   - Beep five times when entering state 6 (cooling/finished)
0C61           1340   ;   - Beep ten times if tc_missing_abort = 1 (error)
0C61           1341   ;
0C61           1342   ; Call this in main loop after Control_FSM
0C61           1343   ;============================================================
0C61           1344   Beep_Judge:
0C61 C0E0      1345       push acc
0C63 C0D0      1346       push psw
0C65           1347   
0C65           1348       ; --- Priority 1: Error condition (highest priority) ---
0C65 30130A    1349       jnb tc_missing_abort, Beep_Judge_Check_State6
0C68           1350       ; Error detected - beep 10 times (only once per error)
0C68 20191B    1351       jb beep_error_done, Beep_Judge_Done   ; Already beeped for this error?
0C6B D219      1352       setb beep_error_done                   ; Mark as handled
0C6D 120C95    1353       lcall Beep_Ten
0C70 8014      1354       sjmp Beep_Judge_Done
0C72           1355   
0C72           1356   Beep_Judge_Check_State6:
0C72           1357       ; --- Priority 2: Entering State 6 (finished) ---
0C72 301211    1358       jnb state_change_beep_signal, Beep_Judge_Done  ; No state change? Exit
0C75           1359       
0C75 E560      1360       mov a, Control_FSM_state
0C77 B40607    1361       cjne a, #6, Beep_Judge_Normal_Change
0C7A           1362       ; Entering state 6 - beep 5 times
0C7A C212      1363       clr state_change_beep_signal               ; Consume the signal
0C7C 120C90    1364       lcall Beep_Five
0C7F 8005      1365       sjmp Beep_Judge_Done
0C81           1366   
0C81           1367   Beep_Judge_Normal_Change:
0C81           1368       ; --- Priority 3: Normal state change - beep once ---
0C81 C212      1369       clr state_change_beep_signal               ; Consume the signal
0C83 120C8B    1370       lcall Beep_Once
0C86           1371   
0C86           1372   Beep_Judge_Done:
0C86 D0D0      1373       pop psw
0C88 D0E0      1374       pop acc
0C8A 22        1375       ret
0C8B           1376   
0C8B           1377   Beep_Once:
0C8B 757501    1378       mov beep_count, #1
0C8E 800A      1379       sjmp Beep_Start
0C90           1380   
0C90           1381   Beep_Five:
0C90 757505    1382       mov beep_count, #5
0C93 8005      1383       sjmp Beep_Start
0C95           1384   
0C95           1385   Beep_Ten:
0C95 75750A    1386       mov beep_count, #10
0C98 8000      1387       sjmp Beep_Start      ; [FIX] Added explicit jump for safety
0C9A           1388   
0C9A           1389   Beep_Start:
0C9A C28C      1390       clr TR0              ; [FIX] Stop timer briefly to reset cleanly
0C9C 757601    1391       mov beep_state, #1   ; Set State to ON
0C9F 757700    1392       mov beep_tmr, #0     ; Reset Timer High Byte
0CA2 757800    1393       mov beep_tmr+1, #0   ; Reset Timer Low Byte
0CA5 D2A9      1394       setb ET0             ; [FIX] Ensure Interrupt is enabled
0CA7 D28C      1395       setb TR0             ; START the 2kHz tone
0CA9 22        1396       ret
0CAA           1397   ;============================================================
0CAA           1398   
0CAA           1399   ;============================================================
0CAA           1400   ; Buzzer beep Task 
0CAA           1401   ; Purpose: beeps, holds, stop
0CAA           1402   ; Buzzer task:
0CAA           1403   ; Beep once when state changes
0CAA           1404   ; Beep five times if finished
0CAA           1405   ; Beep ten times if meets error
0CAA           1406   ;============================================================
0CAA           1407   Beep_Task:
0CAA 301835    1408       jnb one_ms_beep_flag, Beep_Done
0CAD C218      1409       clr one_ms_beep_flag
0CAF           1410   
0CAF E576      1411       mov a, beep_state
0CB1 602F      1412       jz Beep_Done
0CB3           1413   
0CB3           1414   ; ---- increment 16-bit timer ----
0CB3 0577      1415       inc beep_tmr
0CB5 E577      1416       mov a, beep_tmr
0CB7 7002      1417       jnz Beep_Check
0CB9 0578      1418       inc beep_tmr+1
0CBB           1419   
0CBB           1420   Beep_Check:
0CBB           1421       ; [FIX] FUZZY TIMER CHECK
0CBB           1422       ; Check if High Byte is non-zero (Time >= 256ms)
0CBB E578      1423       mov a, beep_tmr+1
0CBD 6023      1424       jz Beep_Done        ; If 0, keep beeping
0CBF           1425   
0CBF           1426       ; --- Time Limit Reached ---
0CBF 757700    1427       mov beep_tmr, #0    ; Reset timer
0CC2 757800    1428       mov beep_tmr+1, #0
0CC5           1429   
0CC5 E576      1430       mov a, beep_state
0CC7 B40106    1431       cjne a, #1, Beep_Off_State
0CCA           1432   
0CCA           1433       ; State was 1 (ON) -> Turn OFF
0CCA C28C      1434       clr TR0             ; Hardware Silence
0CCC 757602    1435       mov beep_state, #2  ; Set State to OFF (Pause)
0CCF 22        1436       ret
0CD0           1437   
0CD0           1438   Beep_Off_State:
0CD0           1439   ; ---- OFF finished -> decrement count / next ON ----
0CD0 1575      1440       dec beep_count
0CD2 E575      1441       mov a, beep_count
0CD4 6006      1442       jz  Beep_Stop
0CD6           1443   
0CD6 757601    1444       mov beep_state, #1
0CD9 D28C      1445       setb TR0
0CDB 22        1446       ret
0CDC           1447   
0CDC           1448   Beep_Stop:
0CDC C28C      1449       clr TR0
0CDE 757600    1450       mov beep_state, #0
0CE1 22        1451       ret
0CE2           1452   
0CE2           1453   Beep_Done:
0CE2 22        1454       ret
0CE3           1455   ;==================================================================
0CE3           1456   
0CE3           1457   ;-------------------------------------------------------------------------------;
0CE3           1458   ; Main Control FSM for the entire process
0CE3           1459   ;-------------------------------------------------------------------------------;
0CE3           1460   ;-------------------------------------------------------------------------------;
0CE3           1461   ; FSM LOGIC (Button Logic Fixed)
0CE3           1462   ;-------------------------------------------------------------------------------;
0CE3           1463   Control_FSM:
0CE3 E560      1464       mov a, Control_FSM_state
0CE5 8008      1465       sjmp Control_FSM_state0
0CE7           1466   
0CE7           1467   Control_FSM_state0_a:
0CE7 756000    1468            mov Control_FSM_state, #0
0CEA D20F      1469            setb state_change_signal
0CEC D210      1470            setb state_change_signal_TC
0CEE 22        1471            ret
0CEF           1472   Control_FSM_state0:
0CEF B40017    1473       cjne a, #0, Control_FSM_state1
0CF2 C219      1474       clr beep_error_done
0CF4 301504    1475       jnb PB0_flag, Control_FSM_state0_ret  ; Check flag
0CF7 C215      1476       clr PB0_flag                 
0CF9 8001      1477       sjmp Control_FSM_state1_a
0CFB           1478   Control_FSM_state0_ret:
0CFB 22        1479       ret
0CFC           1480   
0CFC           1481   Control_FSM_state1_a:
0CFC 756001    1482       mov Control_FSM_state, #1
0CFF 756100    1483       mov Current_State, #0
0D02 D20F      1484       setb state_change_signal
0D04 D210      1485            setb state_change_signal_TC
0D06 D212      1486       setb state_change_beep_signal
0D08 22        1487            ret
0D09           1488   Control_FSM_state1:
0D09 B40114    1489       cjne a, #1, Control_FSM_state2
0D0C 301504    1490       jnb PB0_flag, Control_FSM_state1_ret  ; Check flag
0D0F C215      1491       clr PB0_flag                    
0D11 8001      1492       sjmp Control_FSM_state2_a
0D13           1493   Control_FSM_state1_ret:
0D13 22        1494       ret
0D14           1495   
0D14           1496   ; --- STATE 2: RAMP TO SOAK ---
0D14           1497   Control_FSM_state2_a:
0D14 756002    1498            mov Control_FSM_state, #2
0D17 D20F      1499            setb state_change_signal
0D19 D210      1500            setb state_change_signal_TC
0D1B D211      1501            setb state_change_signal_Count
0D1D D212      1502       setb state_change_beep_signal
0D1F 22        1503            ret
0D20           1504   Control_FSM_state2:
0D20 B4021C    1505       cjne a, #2, Control_FSM_state3
0D23 301705    1506       jnb PB2_flag, State2_Check
0D26 C217      1507       clr PB2_flag
0D28 020D8D    1508       ljmp Control_FSM_state6_a ; Pause
0D2B           1509   
0D2B           1510   State2_Check:
0D2B 300506    1511       jnb soak_temp_reached, State2_Ret
0D2E           1512       
0D2E           1513       ; --- We reached Temp! Move to State 3 ---
0D2E C205      1514       clr soak_temp_reached
0D30 C208      1515       clr soak_time_reached
0D32 8001      1516            sjmp Control_FSM_state3_a
0D34           1517   State2_Ret:
0D34 22        1518       ret
0D35           1519   
0D35           1520   ; --- STATE 3: SOAK PHASE ---
0D35           1521   Control_FSM_state3_a:
0D35 756003    1522            mov Control_FSM_state, #3
0D38 D20F      1523            setb state_change_signal
0D3A D210      1524            setb state_change_signal_TC
0D3C D212      1525       setb state_change_beep_signal
0D3E 22        1526            ret
0D3F           1527   Control_FSM_state3:
0D3F B4031A    1528       cjne a, #3, Control_FSM_state4
0D42 301705    1529       jnb PB2_flag, State3_Check
0D45 C217      1530       clr PB2_flag
0D47 020D8D    1531       ljmp Control_FSM_state6_a
0D4A           1532   State3_Check:
0D4A 300804    1533       jnb soak_time_reached, State3_Ret
0D4D C208      1534       clr soak_time_reached
0D4F 8001      1535       sjmp Control_FSM_state4_a
0D51           1536   State3_Ret:
0D51 22        1537       ret
0D52           1538   
0D52           1539   ; --- STATE 4: RAMP TO PEAK ---
0D52           1540   Control_FSM_state4_a:
0D52 756004    1541            mov Control_FSM_state, #4
0D55 D20F      1542            setb state_change_signal
0D57 D210      1543            setb state_change_signal_TC
0D59 D212      1544       setb state_change_beep_signal
0D5B 22        1545            ret
0D5C           1546   Control_FSM_state4:
0D5C B4041C    1547       cjne a, #4, Control_FSM_state5
0D5F 301705    1548       jnb PB2_flag, State4_Check
0D62 C217      1549       clr PB2_flag
0D64 020D8D    1550       ljmp Control_FSM_state6_a
0D67           1551   State4_Check:
0D67 300606    1552       jnb reflow_temp_reached, State4_Ret
0D6A C206      1553       clr reflow_temp_reached
0D6C C209      1554       clr reflow_time_reached
0D6E 8001      1555            sjmp Control_FSM_state5_a
0D70           1556   State4_Ret:
0D70 22        1557       ret
0D71           1558   
0D71           1559   ; --- STATE 5: REFLOW PHASE ---
0D71           1560   Control_FSM_state5_a:
0D71 756005    1561            mov Control_FSM_state, #5
0D74 D20F      1562            setb state_change_signal
0D76 D210      1563            setb state_change_signal_TC
0D78 D212      1564       setb state_change_beep_signal
0D7A 22        1565            ret
0D7B           1566   Control_FSM_state5:
0D7B B4051B    1567       cjne a, #5, Control_FSM_state6
0D7E 301704    1568       jnb PB2_flag, State5_Check
0D81 C217      1569       clr PB2_flag
0D83 8008      1570       sjmp Control_FSM_state6_a
0D85           1571   State5_Check:
0D85 300904    1572       jnb reflow_time_reached, State5_Ret
0D88 C209      1573       clr reflow_time_reached
0D8A 8001      1574       sjmp Control_FSM_state6_a
0D8C           1575   State5_Ret:
0D8C 22        1576       ret
0D8D           1577   
0D8D           1578   ; --- STATE 6: COOLING ---
0D8D           1579   Control_FSM_state6_a:
0D8D 756006    1580            mov Control_FSM_state, #6
0D90 D20F      1581            setb state_change_signal
0D92 D210      1582            setb state_change_signal_TC
0D94 D211      1583            setb state_change_signal_Count
0D96 D212      1584       setb state_change_beep_signal
0D98 22        1585            ret
0D99           1586   Control_FSM_state6:
0D99 B40612    1587       cjne a, #6, Control_FSM_state7
0D9C           1588       ; Wait for Cooling Temp Reached
0D9C 300704    1589       jnb cooling_temp_reached, State6_Ret
0D9F C207      1590       clr cooling_temp_reached
0DA1 8001      1591       sjmp Control_FSM_state7_a
0DA3           1592   State6_Ret:
0DA3 22        1593       ret
0DA4           1594   
0DA4           1595   ; --- STATE 7: DONE ---
0DA4           1596   Control_FSM_state7_a:
0DA4 756007    1597            mov Control_FSM_state, #7
0DA7 D20F      1598            setb state_change_signal
0DA9 D210      1599            setb state_change_signal_TC
0DAB D212      1600       setb state_change_beep_signal
0DAD 22        1601            ret
0DAE           1602   Control_FSM_state7:
0DAE B40708    1603       cjne a, #7, Control_FSM_done
0DB1           1604       ; Let's assume you meant the physical button P1.0 like State 0
0DB1 101502    1605       jbc PB0_flag, Control_FSM_state7_pressed
0DB4 8003      1606            sjmp Control_FSM_done
0DB6           1607   Control_FSM_state7_pressed:
0DB6 020CE7    1608       ljmp Control_FSM_state0_a
0DB9           1609   
0DB9           1610   Control_FSM_done:
0DB9 22        1611       ret
0DBA           1612   
0DBA           1613   ; ================================================================
0DBA           1614   ; UI & HELPER SUBROUTINES
0DBA           1615   ; ================================================================
0DBA           1616   
0DBA           1617   ; ----------------------------------------------------------------
0DBA           1618   ; MODULE: BRIDGE (Text to Integer Conversion)
0DBA           1619   ; ----------------------------------------------------------------
0DBA           1620   
0DBA           1621   ;--------------------------
0DBA           1622   ;keep updating varaibles
0DBA           1623   Update_FSM_Variables:
0DBA C0E0      1624            push ACC
0DBC C006      1625            push AR6
0DBE C007      1626            push AR7
0DC0 E560      1627            mov a, Control_FSM_state
0DC2 B40132    1628            cjne a, #1, Update_FSM_Variables_done
0DC5           1629   
0DC5           1630       ; --- 1. SOAK TEMP ---
0DC5 7880      1631       mov R0, #Buf_Soak_Temp
0DC7 120DFE    1632       lcall Parse_Temp_String
0DCA 8F4B      1633       mov soak_temp+0, R7
0DCC 754C00    1634       mov soak_temp+1, #0
0DCF 754D00    1635       mov soak_temp+2, #0
0DD2 754E00    1636       mov soak_temp+3, #0
0DD5           1637   
0DD5           1638       ; --- 2. REFLOW TEMP ---
0DD5 7889      1639       mov R0, #Buf_Refl_Temp
0DD7 120DFE    1640       lcall Parse_Temp_String
0DDA 8F4F      1641       mov reflow_temp+0, R7
0DDC 755000    1642       mov reflow_temp+1, #0
0DDF 755100    1643       mov reflow_temp+2, #0
0DE2 755200    1644       mov reflow_temp+3, #0
0DE5           1645   
0DE5           1646       ; --- 3. SOAK TIME ---
0DE5 7884      1647       mov R0, #Buf_Soak_Time
0DE7 120E12    1648       lcall Parse_Time_String
0DEA 8F33      1649       mov soak_time_minute, R7
0DEC 8E32      1650       mov soak_time_sec, R6
0DEE           1651   
0DEE           1652       ; --- 4. REFLOW TIME ---
0DEE 788D      1653       mov R0, #Buf_Refl_Time
0DF0 120E12    1654       lcall Parse_Time_String
0DF3 8F35      1655       mov reflow_time_minute, R7
0DF5 8E34      1656       mov reflow_time_sec, R6
0DF7           1657   
0DF7           1658   Update_FSM_Variables_done:
0DF7 D007      1659            pop AR7
0DF9 D006      1660            pop AR6
0DFB D0E0      1661            pop ACC
0DFD 22        1662       ret
0DFE           1663   ;--------------------------
0DFE           1664   
0DFE           1665   ; --- Helper: Parse "123" to Integer ---
0DFE           1666   Parse_Temp_String:
0DFE 7F00      1667       mov R7, #0              ; Clear Result
0E00           1668   Parse_Temp_Loop:
0E00 E6        1669       mov A, @R0
0E01 600E      1670       jz Parse_Temp_Done      ; If Null, we are done
0E03           1671       
0E03           1672       ; Convert ASCII to Digit
0E03 C3        1673       clr C
0E04 9430      1674       subb A, #0x30
0E06 FD        1675       mov R5, A               ; R5 = New Digit
0E07           1676       
0E07           1677       ; Result = (Result * 10) + New Digit
0E07 EF        1678       mov A, R7
0E08 75F00A    1679       mov B, #10
0E0B A4        1680       mul AB
0E0C 2D        1681       add A, R5
0E0D FF        1682       mov R7, A
0E0E           1683       
0E0E 08        1684       inc R0
0E0F 80EF      1685       sjmp Parse_Temp_Loop
0E11           1686   Parse_Temp_Done:
0E11 22        1687       ret
0E12           1688   
0E12           1689   ; --- Helper: Parse "MMSS" to Seconds ---
0E12           1690   Parse_Time_String:
0E12           1691       ; Minutes tens
0E12 E6        1692       mov A, @R0
0E13 C3        1693       clr C
0E14 9430      1694       subb A, #0x30
0E16 75F00A    1695       mov B, #10
0E19 A4        1696       mul AB
0E1A FD        1697       mov R5, A
0E1B 08        1698       inc R0
0E1C           1699   
0E1C           1700       ; Minutes ones
0E1C E6        1701       mov A, @R0
0E1D C3        1702       clr C
0E1E 9430      1703       subb A, #0x30
0E20 2D        1704       add A, R5
0E21 FD        1705       mov R5, A
0E22 08        1706       inc R0
0E23           1707   
0E23           1708       ; Seconds tens
0E23 E6        1709       mov A, @R0
0E24 C3        1710       clr C
0E25 9430      1711       subb A, #0x30
0E27 75F00A    1712       mov B, #10
0E2A A4        1713       mul AB
0E2B FC        1714       mov R4, A
0E2C 08        1715       inc R0
0E2D           1716   
0E2D           1717       ; Seconds ones
0E2D E6        1718       mov A, @R0
0E2E C3        1719       clr C
0E2F 9430      1720       subb A, #0x30
0E31 2C        1721       add A, R4
0E32 FC        1722       mov R4, A
0E33           1723   
0E33           1724       ; Return minutes/seconds
0E33 ED        1725            mov a, R5
0E34 FF        1726       mov R7, a     ; minutes
0E35 EC        1727            mov a, R4
0E36 FE        1728       mov R6, a     ; seconds
0E37 22        1729       ret
0E38           1730   
0E38           1731   ; ----------------------------------------------------------------
0E38           1732   ; MODULE: BUTTON HANDLER (Mode Selection)
0E38           1733   ; ----------------------------------------------------------------
0E38           1734   ; Blocking wrapper for LCD clear (keeps old behavior just for this)
0E38           1735   Wait_25ms_BLOCKING:
0E38 120FAD    1736       lcall Wait_25ms
0E3B 50FB      1737       jnc Wait_25ms_BLOCKING ; Keep jumping back until Done (C=1)
0E3D 22        1738       ret
0E3E           1739   
0E3E           1740   Check_Buttons:
0E3E C0E0      1741            push ACC
0E40 E560      1742            mov a, Control_FSM_state
0E42 B4014C    1743            cjne a, #1, Check_Buttons_ret
0E45           1744   
0E45           1745       ; --- FORCE INPUT MODE ---
0E45           1746       ; This clears any '0' the LCD library might have written to our buttons
0E45 438055    1747       orl P0, #055H   ; Sets P0.0, P0.2, P0.4, and P0.6 to '1' (Input Mode)
0E48           1748       ; ------------------------
0E48           1749   
0E48 30800C    1750       jnb BTN_SOAK_TEMP, Btn_Soak_Temp_Press
0E4B 308214    1751       jnb BTN_SOAK_TIME, Btn_Soak_Time_Press
0E4E 30841C    1752       jnb BTN_REFL_TEMP, Btn_Refl_Temp_Press
0E51 308624    1753       jnb BTN_REFL_TIME, Btn_Refl_Time_Press
0E54           1754   
0E54 D0E0      1755            pop ACC
0E56 22        1756       ret
0E57           1757   
0E57           1758   Btn_Soak_Temp_Press:
0E57 120E38    1759       lcall Wait_25ms_BLOCKING
0E5A 756101    1760       mov Current_State, #1
0E5D 756A00    1761       mov Cursor_Idx, #0
0E60 8021      1762       sjmp Redraw_Screen
0E62           1763   
0E62           1764   Btn_Soak_Time_Press:
0E62 120E38    1765       lcall Wait_25ms_BLOCKING
0E65 756102    1766       mov Current_State, #2
0E68 756A00    1767       mov Cursor_Idx, #0
0E6B 8016      1768       sjmp Redraw_Screen
0E6D           1769   
0E6D           1770   Btn_Refl_Temp_Press:
0E6D 120E38    1771       lcall Wait_25ms_BLOCKING
0E70 756103    1772       mov Current_State, #3
0E73 756A00    1773       mov Cursor_Idx, #0
0E76 800B      1774       sjmp Redraw_Screen
0E78           1775   
0E78           1776   Btn_Refl_Time_Press:
0E78 120E38    1777       lcall Wait_25ms_BLOCKING 
0E7B 756104    1778       mov Current_State, #4
0E7E 756A00    1779       mov Cursor_Idx, #0
0E81 8000      1780       sjmp Redraw_Screen
0E83           1781   
0E83           1782   Redraw_Screen:
0E83           1783       ; Wait for button release
0E83 3080FD    1784       jnb BTN_SOAK_TEMP, $
0E86 3082FD    1785       jnb BTN_SOAK_TIME, $
0E89 3084FD    1786       jnb BTN_REFL_TEMP, $
0E8C 3086FD    1787       jnb BTN_REFL_TIME, $
0E8F           1788   
0E8F D224      1789       setb fullscreen_update_signal
0E91           1790   Check_Buttons_ret:
0E91 D0E0      1791       pop ACC
0E93 22        1792       ret
0E94           1793   
0E94           1794   ; ----------------------------------------------------------------
0E94           1795   ; MODULE: KEYPAD HANDLER (Input Logic)
0E94           1796   ; ----------------------------------------------------------------
0E94           1797   Check_Keypad:
0E94 E560      1798       mov a, Control_FSM_state
0E96 B40152    1799       cjne a, #1, Keypad_Exit
0E99           1800   
0E99           1801       ; If State is 0 (Home), ignore keypad
0E99 E561      1802       mov A, Current_State
0E9B 604E      1803       jz Keypad_Exit
0E9D           1804       
0E9D 120EEC    1805       lcall Keypad_Scan
0EA0 5049      1806       jnc Keypad_Exit         ; Carry = 0 means no key pressed
0EA2           1807   
0EA2           1808       ; --- Check Special Keys ---
0EA2 EF        1809       mov A, R7
0EA3 B40E09    1810       cjne A, #14, Check_Hash ; 14 is Star (*)
0EA6           1811       
0EA6           1812       ; Star Key Pressed: Reset Buffer
0EA6 120FF0    1813       lcall Reset_Current_Buffer
0EA9 D224      1814       setb fullscreen_update_signal
0EAB 756A00    1815       mov Cursor_Idx, #0
0EAE 22        1816       ret
0EAF           1817   
0EAF           1818   Check_Hash:
0EAF EF        1819       mov A, R7
0EB0 B40C01    1820       cjne A, #12, Check_Numeric ; 12 is Hash (#)
0EB3 22        1821       ret                     ; Ignore Hash key
0EB4           1822   
0EB4           1823   Check_Numeric:
0EB4           1824       ; Ensure key is 0-9
0EB4 EF        1825       mov A, R7
0EB5 C3        1826       clr C
0EB6 940A      1827       subb A, #10
0EB8 5030      1828       jnc Symbol_Key_Ignored
0EBA           1829       
0EBA           1830       ; Convert to ASCII
0EBA EF        1831       mov A, R7
0EBB 2430      1832       add A, #0x30
0EBD FD        1833       mov R5, A
0EBE           1834   
0EBE           1835       ; Save to Buffer
0EBE 120997    1836       lcall Get_Current_Buffer_Addr
0EC1 E56A      1837       mov A, Cursor_Idx
0EC3 28        1838       add A, R0
0EC4 F8        1839       mov R0, A
0EC5 ED        1840       mov A, R5
0EC6 F6        1841       mov @R0, A
0EC7 056A      1842       inc Cursor_Idx
0EC9           1843   
0EC9           1844       ; --- Check Cursor Limits ---
0EC9 E561      1845       mov A, Current_State
0ECB B40102    1846       cjne A, #1, Check_Limit_Time_1
0ECE 8005      1847       sjmp Limit_Temp_3
0ED0           1848   
0ED0           1849   Check_Limit_Time_1:
0ED0 B4030B    1850       cjne A, #3, Limit_Time_4
0ED3 8000      1851       sjmp Limit_Temp_3
0ED5           1852   
0ED5           1853   Limit_Temp_3:
0ED5 E56A      1854       mov A, Cursor_Idx
0ED7 B4030D    1855       cjne A, #3, Do_Refresh
0EDA 156A      1856       dec Cursor_Idx          ; Stay at last digit
0EDC 8009      1857       sjmp Do_Refresh
0EDE           1858   
0EDE           1859   Limit_Time_4:
0EDE E56A      1860       mov A, Cursor_Idx
0EE0 B40404    1861       cjne A, #4, Do_Refresh
0EE3 156A      1862       dec Cursor_Idx          ; Stay at last digit
0EE5 8000      1863       sjmp Do_Refresh
0EE7           1864   
0EE7           1865   Do_Refresh:
0EE7 D224      1866       setb fullscreen_update_signal
0EE9 22        1867       ret
0EEA           1868   
0EEA           1869   Symbol_Key_Ignored:
0EEA 22        1870       ret
0EEB           1871   Keypad_Exit:
0EEB 22        1872       ret
0EEC           1873   
0EEC           1874   ; ----------------------------------------------------------------
0EEC           1875   ; MODULE: HARDWARE SCANNER (Matrix Logic)
0EEC           1876   ; ----------------------------------------------------------------
0EEC           1877   Keypad_Scan:
0EEC           1878       ; Step 1: Check if ANY key is pressed (All Rows Low)
0EEC C292      1879       clr ROW1
0EEE C294      1880       clr ROW2
0EF0 C296      1881       clr ROW3
0EF2 C2A0      1882       clr ROW4
0EF4 A2A2      1883       mov C, COL1
0EF6 82A4      1884       anl C, COL2
0EF8 82A6      1885       anl C, COL3
0EFA 82B0      1886       anl C, COL4
0EFC 5002      1887       jnc Keypad_Debounce
0EFE C3        1888       clr C
0EFF 22        1889       ret
0F00           1890   
0F00           1891   Keypad_Debounce:
0F00 120E38    1892       lcall Wait_25ms_BLOCKING
0F03 A2A2      1893       mov C, COL1
0F05 82A4      1894       anl C, COL2
0F07 82A6      1895       anl C, COL3
0F09 82B0      1896       anl C, COL4
0F0B 5002      1897       jnc Keypad_Find_Row
0F0D C3        1898       clr C
0F0E 22        1899       ret
0F0F           1900   
0F0F           1901   Keypad_Find_Row:
0F0F D292      1902       setb ROW1
0F11 D294      1903       setb ROW2
0F13 D296      1904       setb ROW3
0F15 D2A0      1905       setb ROW4
0F17           1906   
0F17           1907       ; Row 1
0F17 C292      1908       clr ROW1
0F19 30A23D    1909       jnb COL1, Keypad_Key_1
0F1C 30A43E    1910       jnb COL2, Keypad_Key_2
0F1F 30A63F    1911       jnb COL3, Keypad_Key_3
0F22 30B040    1912       jnb COL4, Keypad_Key_A
0F25 D292      1913       setb ROW1
0F27           1914   
0F27           1915       ; Row 2
0F27 C294      1916       clr ROW2
0F29 30A23D    1917       jnb COL1, Keypad_Key_4
0F2C 30A43E    1918       jnb COL2, Keypad_Key_5
0F2F 30A63F    1919       jnb COL3, Keypad_Key_6
0F32 30B040    1920       jnb COL4, Keypad_Key_B
0F35 D294      1921       setb ROW2
0F37           1922   
0F37           1923       ; Row 3
0F37 C296      1924       clr ROW3
0F39 30A23D    1925       jnb COL1, Keypad_Key_7
0F3C 30A43E    1926       jnb COL2, Keypad_Key_8
0F3F 30A63F    1927       jnb COL3, Keypad_Key_9
0F42 30B040    1928       jnb COL4, Keypad_Key_C
0F45 D296      1929       setb ROW3
0F47           1930   
0F47           1931       ; Row 4
0F47 C2A0      1932       clr ROW4
0F49 30A23D    1933       jnb COL1, Keypad_Key_Star
0F4C 30A43E    1934       jnb COL2, Keypad_Key_0
0F4F 30A63F    1935       jnb COL3, Keypad_Key_Hash
0F52 30B040    1936       jnb COL4, Keypad_Key_D
0F55 D2A0      1937       setb ROW4
0F57 C3        1938       clr C
0F58 22        1939       ret
0F59           1940   
0F59           1941   ; Key Mapping (Renamed to avoid conflicts)
0F59 7F01      1942   Keypad_Key_1: mov R7, #1
0F5B 803C      1943          sjmp Wait_Release
0F5D 7F02      1944   Keypad_Key_2: mov R7, #2
0F5F 8038      1945          sjmp Wait_Release
0F61 7F03      1946   Keypad_Key_3: mov R7, #3
0F63 8034      1947          sjmp Wait_Release
0F65 7F0A      1948   Keypad_Key_A: mov R7, #10
0F67 8030      1949          sjmp Wait_Release
0F69 7F04      1950   Keypad_Key_4: mov R7, #4
0F6B 802C      1951          sjmp Wait_Release
0F6D 7F05      1952   Keypad_Key_5: mov R7, #5
0F6F 8028      1953          sjmp Wait_Release
0F71 7F06      1954   Keypad_Key_6: mov R7, #6
0F73 8024      1955          sjmp Wait_Release
0F75 7F0B      1956   Keypad_Key_B: mov R7, #11
0F77 8020      1957          sjmp Wait_Release
0F79 7F07      1958   Keypad_Key_7: mov R7, #7
0F7B 801C      1959          sjmp Wait_Release
0F7D 7F08      1960   Keypad_Key_8: mov R7, #8
0F7F 8018      1961          sjmp Wait_Release
0F81 7F09      1962   Keypad_Key_9: mov R7, #9
0F83 8014      1963          sjmp Wait_Release
0F85 7F0D      1964   Keypad_Key_C: mov R7, #13
0F87 8010      1965          sjmp Wait_Release
0F89 7F0E      1966   Keypad_Key_Star: mov R7, #14
0F8B 800C      1967          sjmp Wait_Release
0F8D 7F00      1968   Keypad_Key_0: mov R7, #0
0F8F 8008      1969          sjmp Wait_Release
0F91 7F0C      1970   Keypad_Key_Hash: mov R7, #12
0F93 8004      1971          sjmp Wait_Release
0F95 7F0F      1972   Keypad_Key_D: mov R7, #15
0F97 8000      1973          sjmp Wait_Release
0F99           1974   
0F99           1975   Wait_Release:
0F99 A2A2      1976       mov C, COL1
0F9B 82A4      1977       anl C, COL2
0F9D 82A6      1978       anl C, COL3
0F9F 82B0      1979       anl C, COL4
0FA1 50F6      1980       jnc Wait_Release
0FA3 D3        1981       setb C
0FA4 D292      1982       setb ROW1
0FA6 D294      1983       setb ROW2
0FA8 D296      1984       setb ROW3
0FAA D2A0      1985       setb ROW4
0FAC 22        1986       ret
0FAD           1987   
0FAD           1988   Wait_25ms:
0FAD           1989       ; 1. Check if we are already waiting
0FAD 201A0E    1990       jb wait25_active, Check_Timer_Status
0FB0           1991       
0FB0           1992       ; 2. Check if we just finished
0FB0 301B04    1993       jnb wait25_done, Start_New_Timer
0FB3           1994       
0FB3           1995       ; 3. Timer is DONE! Reset flags and return True
0FB3 C21B      1996       clr wait25_done
0FB5 D3        1997       setb C          ; Carry = 1 means "Done"
0FB6 22        1998       ret
0FB7           1999   
0FB7           2000   Start_New_Timer:
0FB7           2001       ; 4. Start a new 25ms wait
0FB7 755700    2002       mov wait25_count, #0
0FBA D21A      2003       setb wait25_active
0FBC C3        2004       clr C           ; Carry = 0 means "Not Done Yet"
0FBD 22        2005       ret
0FBE           2006   
0FBE           2007   Check_Timer_Status:
0FBE           2008       ; 5. Still waiting... return False immediately
0FBE C3        2009       clr C           ; Carry = 0 means "Not Done Yet"
0FBF 22        2010       ret
0FC0           2011   
0FC0           2012   ; ----------------------------------------------------------------
0FC0           2013   ; MODULE: BUFFER INIT (Reset Logic)
0FC0           2014   ; ----------------------------------------------------------------
0FC0           2015   Init_All_Buffers:
0FC0 7880      2016       mov R0, #Buf_Soak_Temp
0FC2 120FD5    2017       lcall Init_Temp_Template
0FC5 7889      2018       mov R0, #Buf_Refl_Temp
0FC7 120FD5    2019       lcall Init_Temp_Template
0FCA 7884      2020       mov R0, #Buf_Soak_Time
0FCC 120FE1    2021       lcall Init_Time_Template
0FCF 788D      2022       mov R0, #Buf_Refl_Time
0FD1 120FE1    2023       lcall Init_Time_Template
0FD4 22        2024       ret
0FD5           2025   
0FD5           2026   Init_Temp_Template:
0FD5 7630      2027       mov @R0, #'0'
0FD7 08        2028       inc R0
0FD8 7630      2029       mov @R0, #'0'
0FDA 08        2030       inc R0
0FDB 7630      2031       mov @R0, #'0'
0FDD 08        2032       inc R0
0FDE 7600      2033       mov @R0, #0
0FE0 22        2034       ret
0FE1           2035   
0FE1           2036   Init_Time_Template:
0FE1 7630      2037       mov @R0, #'0'
0FE3 08        2038       inc R0
0FE4 7630      2039       mov @R0, #'0'
0FE6 08        2040       inc R0
0FE7 7630      2041       mov @R0, #'0'
0FE9 08        2042       inc R0
0FEA 7630      2043       mov @R0, #'0'
0FEC 08        2044       inc R0
0FED 7600      2045       mov @R0, #0
0FEF 22        2046       ret
0FF0           2047   
0FF0           2048   Reset_Current_Buffer:
0FF0 E561      2049       mov A, Current_State
0FF2 B40106    2050       cjne A, #1, Reset_Chk_2
0FF5 7880      2051       mov R0, #Buf_Soak_Temp
0FF7 120FD5    2052       lcall Init_Temp_Template
0FFA 22        2053       ret
0FFB           2054   Reset_Chk_2:
0FFB B40206    2055       cjne A, #2, Reset_Chk_3
0FFE 7884      2056       mov R0, #Buf_Soak_Time
1000 120FE1    2057       lcall Init_Time_Template
1003 22        2058       ret
1004           2059   Reset_Chk_3:
1004 B40306    2060       cjne A, #3, Reset_Chk_4
1007 7889      2061       mov R0, #Buf_Refl_Temp
1009 120FD5    2062       lcall Init_Temp_Template
100C 22        2063       ret
100D           2064   Reset_Chk_4:
100D 788D      2065       mov R0, #Buf_Refl_Time
100F 120FE1    2066       lcall Init_Time_Template
1012 22        2067       ret 
1013           2068       
1013           2069   ; ================================================================
1013           2070   ; MODULE: THERMOCOUPLE ADC DRIVER (WITH NOISE SUPPRESSION & JUMP FIX)
1013           2071   ; ================================================================
1013           2072   Read_Thermocouple:
1013           2073       ; 1. Check Non-Blocking Timer
1013 120FAD    2074       lcall Wait_25ms
1016           2075       
1016           2076       ; [FIX] TRAMPOLINE JUMP
1016           2077       ; "jnc" cannot jump to the end because the code is too long.
1016           2078       ; We invert logic: If Carry=1 (Time is up), Jump NEARBY.
1016 4001      2079       jc Proceed_Reading
1018 22        2080       ret  ; If Carry=0, Return immediately.
1019           2081   
1019           2082   Proceed_Reading:
1019           2083       ; --- 25ms Passed! Time to Read ---
1019           2084   
1019           2085       ; [FIX] SILENCE THE BUZZER (Noise Suppression)
1019           2086       ; Save buzzer state and force it OFF during the sensitive read
1019 E588      2087       mov A, TCON      
101B 5410      2088       anl A, #0x10     ; Isolate TR0 bit
101D C0E0      2089       push acc         ; Save it
101F C28C      2090       clr TR0          ; STOP NOISE
1021           2091   
1021           2092       ; 2. Initialize / Trigger ADC
1021 75A180    2093       mov ADC_C, #0x80    ; Reset
1024 00        2094       nop
1025 00        2095       nop
1026 75A101    2096       mov ADC_C, #0x01    ; Start Channel 0
1029           2097       
1029           2098       ; 3. Settle Delay
1029 7DFA      2099       mov R5, #250
102B           2100   ADC_Settle_Loop:
102B 00        2101       nop
102C 00        2102       nop
102D DDFC      2103       djnz R5, ADC_Settle_Loop
102F           2104       
102F           2105       ; 4. Read Raw Data
102F 85A23A    2106       mov x+0, ADC_L
1032 85A33B    2107       mov x+1, ADC_H
1035 753C00    2108       mov x+2, #0
1038 753D00    2109       mov x+3, #0
103B           2110       
103B           2111       ; 5. Mask Data
103B E53B      2112       mov a, x+1
103D 540F      2113       anl a, #0x0F
103F F53B      2114       mov x+1, a
1041           2115       
1041           2116       ; [FIX] RESTORE THE BUZZER
1041 D0E0      2117       pop acc          ; Get previous state
1043 6002      2118       jz Skip_Restore  ; If it was OFF, keep it OFF
1045 D28C      2119       setb TR0         ; If it was ON, turn it back ON
1047           2120   Skip_Restore:
1047           2121   
1047           2122       ; 6. Math Conversions
1047 753E16    2123            mov y+0, #low (4118 % 0x10000) 
104A 753F10    2123            mov y+1, #high(4118 % 0x10000) 
104D 754000    2123            mov y+2, #low (4118 / 0x10000) 
1050 754100    2123            mov y+3, #high(4118 / 0x10000) 
1053 12018C    2124       lcall mul32       
1056           2125   
1056 75A104    2126       mov ADC_C, #0x04    ; Read LM4040
1059 85A23E    2127       mov y+0, ADC_L      
105C 85A33F    2128       mov y+1, ADC_H      
105F 754000    2129       mov y+2, #0
1062 754100    2130       mov y+3, #0
1065 75A100    2131       mov ADC_C, #0x00    ; Reset
1068           2132       
1068 120280    2133       lcall div32         
106B 753E64    2134            mov y+0, #low (100 % 0x10000) 
106E 753F00    2134            mov y+1, #high(100 % 0x10000) 
1071 754000    2134            mov y+2, #low (100 / 0x10000) 
1074 754100    2134            mov y+3, #high(100 / 0x10000) 
1077 12018C    2135       lcall mul32
107A 753E2B    2136            mov y+0, #low (1323 % 0x10000) 
107D 753F05    2136            mov y+1, #high(1323 % 0x10000) 
1080 754000    2136            mov y+2, #low (1323 / 0x10000) 
1083 754100    2136            mov y+3, #high(1323 / 0x10000)         
1086 120280    2137       lcall div32    
1089 753E14    2138            mov y+0, #low (COLD_JUNCTION_TEMP % 0x10000) 
108C 753F00    2138            mov y+1, #high(COLD_JUNCTION_TEMP % 0x10000) 
108F 754000    2138            mov y+2, #low (COLD_JUNCTION_TEMP / 0x10000) 
1092 754100    2138            mov y+3, #high(COLD_JUNCTION_TEMP / 0x10000) 
1095 1200D3    2139       lcall add32     
1098           2140       
1098           2141       ; 8. Store Result
1098 853A47    2142       mov current_temp+0, x+0
109B 853B48    2143       mov current_temp+1, x+1
109E 853C49    2144       mov current_temp+2, x+2
10A1 853D4A    2145       mov current_temp+3, x+3
10A4           2146   
10A4 22        2147       ret
10A5           2148       
10A5           2149   ; ================================================================
10A5           2150   ; MODULE: POWER CONTROLLER (The Brain)
10A5           2151   ; ================================================================
10A5           2152   Power_Control:
10A5           2153       ; Default: Turn Heat OFF (Safety)
10A5 755800    2154       mov power_output+0, #0
10A8 755900    2155       mov power_output+1, #0
10AB 755A00    2156       mov power_output+2, #0
10AE 755B00    2157       mov power_output+3, #0
10B1           2158   
10B1 E560      2159       mov a, Control_FSM_state
10B3           2160   
10B3           2161       ; --- State 2: RAMP TO SOAK ---
10B3 B40202    2162       cjne a, #2, PC_Check_Soak
10B6           2163       ; Mode: Full Speed Ahead
10B6 8016      2164       sjmp Set_Max_Power
10B8           2165   
10B8           2166   PC_Check_Soak:
10B8           2167       ; --- State 3: SOAK PHASE ---
10B8 B40305    2168       cjne a, #3, PC_Check_Ramp_Reflow
10BB           2169       ; Mode: Maintenance (Low Power)
10BB           2170       ; If Temp > Target, OFF. If Temp < Target, 20% Power.
10BB 20050F    2171       jb soak_temp_reached, PC_Done ; If hot enough, stay OFF
10BE 801B      2172       sjmp Set_20_Percent_Power     ; If cold, use 20%
10C0           2173   
10C0           2174   PC_Check_Ramp_Reflow:
10C0           2175       ; --- State 4: RAMP TO REFLOW ---
10C0 B40402    2176       cjne a, #4, PC_Check_Reflow
10C3           2177       ; Mode: Full Speed Ahead
10C3 8009      2178       sjmp Set_Max_Power
10C5           2179   
10C5           2180   PC_Check_Reflow:
10C5           2181       ; --- State 5: REFLOW PHASE ---
10C5 B40505    2182       cjne a, #5, PC_Done
10C8           2183       ; Mode: Maintenance (Low Power)
10C8 200602    2184       jb reflow_temp_reached, PC_Done
10CB 800E      2185       sjmp Set_20_Percent_Power
10CD           2186   
10CD           2187   PC_Done:
10CD 22        2188       ret
10CE           2189   
10CE           2190   ; --- Power Helpers ---
10CE           2191   
10CE           2192   Set_Max_Power:
10CE           2193       ; Load 1500 (0x05DC) = 100% Duty Cycle
10CE 7558DC    2194       mov power_output+0, #0xDC
10D1 755905    2195       mov power_output+1, #0x05
10D4 755A00    2196       mov power_output+2, #0
10D7 755B00    2197       mov power_output+3, #0
10DA 22        2198       ret
10DB           2199   
10DB           2200   Set_20_Percent_Power:
10DB           2201       ; Load 300 (0x012C) = 20% Duty Cycle
10DB 75582C    2202       mov power_output+0, #0x2C
10DE 755901    2203       mov power_output+1, #0x01
10E1 755A00    2204       mov power_output+2, #0
10E4 755B00    2205       mov power_output+3, #0
10E7 22        2206       ret
10E8           2207   
10E8           2208   ;--------------------------------------------------------------
10E8           2209   ; set servo angle according to the state
10E8           2210   ; call servo control function every 1ms
10E8           2211   ;--------------------------------------------------------------
10E8           2212   call_servo_control:
10E8           2213            ; check current state and change servo angle
10E8 E560      2214            mov a, Control_FSM_state
10EA           2215            
10EA           2216            ; handle state 0
10EA B40004    2217            cjne a, #0, servo_state1
10ED C227      2218            clr servo_angle_zero ; close door at state 0
10EF 802C      2219            sjmp check_servo_flag
10F1           2220   
10F1           2221            ; handle state 1
10F1           2222            servo_state1:
10F1 B40104    2223            cjne a, #1, servo_state2
10F4 D227      2224            setb servo_angle_zero ; open door at state 1
10F6 8025      2225            sjmp check_servo_flag
10F8           2226   
10F8           2227            ; handle state 2
10F8           2228            servo_state2:
10F8 B40204    2229            cjne a, #2, servo_state3
10FB C227      2230            clr servo_angle_zero ; close door at state 2
10FD 801E      2231            sjmp check_servo_flag
10FF           2232   
10FF           2233            ; handle state 3
10FF           2234            servo_state3:
10FF B40304    2235            cjne a, #3, servo_state4
1102 C227      2236            clr servo_angle_zero ; close door at state 3
1104 8017      2237            sjmp check_servo_flag
1106           2238   
1106           2239            ; handle state 4
1106           2240            servo_state4:
1106 B40404    2241            cjne a, #4, servo_state5
1109 C227      2242            clr servo_angle_zero ; close door at state 4
110B 8010      2243            sjmp check_servo_flag
110D           2244   
110D           2245            ; handle state 5
110D           2246            servo_state5:
110D B40504    2247            cjne a, #5, servo_state6
1110 C227      2248            clr servo_angle_zero ; close door at state 5
1112 8009      2249            sjmp check_servo_flag
1114           2250   
1114           2251            ; handle state 6
1114           2252            servo_state6:
1114 B40604    2253            cjne a, #6, servo_state7
1117 C227      2254            clr servo_angle_zero ; close door at state 6
1119 8002      2255            sjmp check_servo_flag
111B           2256   
111B           2257            ; handle state 7
111B           2258            servo_state7:
111B D227      2259            setb servo_angle_zero ; open door at state 7
111D           2260   
111D           2261   check_servo_flag:
111D           2262            ; check 1 ms flag
111D 102601    2263            jbc one_millisecond_flag_servo, run_servo_control
1120 22        2264            ret
1121           2265   
1121           2266   run_servo_control:
1121 121125    2267            lcall servo_control
1124 22        2268            ret
1125           2269   
1125           2270   
1125           2271   ;---------------------------------------------------------------
1125           2272   ; servo control
1125           2273   ; generate a 20 ms period pwm signal to control the servo motor
1125           2274   ; able to make the servo motor stay at 0 degree and 180 degree
1125           2275   ;---------------------------------------------------------------
1125           2276   servo_control:
1125 D2ED      2277       setb LEDRA.5
1127 C0E0      2278            push acc
1129 C0D0      2279            push psw
112B E579      2280            mov a, servo_pwm_counter ; move servo counter to accumulator
112D 04        2281            inc A ; a += 1
112E B41402    2282            cjne a, #SERVO_PERIOD, servo_pwm_angle_compare ; jump if wrapup not needed
1131 7400      2283            mov a, #0
1133           2284   
1133           2285   servo_pwm_angle_compare: ; read target angle
1133 F579      2286            mov servo_pwm_counter, A
1135 202709    2287            jb servo_angle_zero, set_zero_degree ; set servo motor to 0 degree
1138           2288            ; set servo motor to 180 degrees
1138 E579      2289            mov a, servo_pwm_counter
113A C3        2290            clr c
113B 9402      2291            subb a, #SERVO_180
113D 400B      2292            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 180 degrees duty cycle
113F 800D      2293            sjmp servo_pwm_set_low ; set low if greater
1141           2294   
1141           2295   set_zero_degree:
1141           2296            ; set servo motor to 0 degree
1141 E579      2297            mov a, servo_pwm_counter
1143 C3        2298            clr c
1144 9401      2299            subb a, #SERVO_0
1146 4002      2300            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 0 degrees duty cycle
1148 8004      2301            sjmp servo_pwm_set_low ; set low if greater
114A           2302   
114A           2303   servo_pwm_set_high:
114A           2304            ; set pwm pin high
114A D2B6      2305            setb SERVO_OUT
114C 8002      2306            sjmp servo_control_done
114E           2307   
114E           2308   servo_pwm_set_low:
114E           2309            ; set pwm pin low
114E C2B6      2310            clr SERVO_OUT
1150           2311   
1150           2312   servo_control_done:
1150 D0D0      2313            pop psw
1152 D0E0      2314            pop acc
1154 22        2315            ret
1155           2316   
1155           2317   ;-------------------------------------------------------------------------------
1155           2318   ; power_control
1155           2319   ;-------------------------------------------------------------------------------
1155           2320   ; Determine the power output based on current state and current temperature 
1155           2321   ; input parameter: Control_FSM_state
1155           2322   ;-------------------------------------------------------------------------------
1155           2323   
1155           2324   proportional_power_control:
1155 E560      2325            mov a, Control_FSM_state
1157           2326   
1157           2327   state0_power_control:
1157           2328            ; idle
1157           2329            ; 0% power
1157 B4000F    2330            cjne a, #0, state1_power_control
115A 755800    2331            mov power_output, #low(NO_POWER)
115D 755900    2332            mov power_output+1, #low(NO_POWER)
1160 755A00    2333            mov power_output+2, #0
1163 755B00    2334            mov power_output+3, #0
1166 021301    2335            ljmp power_control_done
1169           2336   
1169           2337   state1_power_control:
1169           2338            ; idle
1169           2339            ; 0% power
1169 B4010F    2340            cjne a, #1, state2_power_control
116C 755800    2341            mov power_output, #low(NO_POWER)
116F 755900    2342            mov power_output+1, #low(NO_POWER)
1172 755A00    2343            mov power_output+2, #0
1175 755B00    2344            mov power_output+3, #0
1178 021301    2345            ljmp power_control_done
117B           2346            
117B           2347   state2_power_control:
117B           2348            ; ramp to soak, ramp to ~150C
117B           2349            ; 100% power
117B B4020F    2350            cjne a, #2, state3_power_control
117E 7558DC    2351            mov power_output, #low(MAX_POWER)
1181 755905    2352            mov power_output+1, #high(MAX_POWER)
1184 755A00    2353            mov power_output+2, #0
1187 755B00    2354            mov power_output+3, #0
118A 021301    2355            ljmp power_control_done
118D           2356   
118D           2357   state3_power_control:
118D           2358            ; soak period, hold at 150C
118D           2359            ; 20% base power + proportional calculated power
118D B40302    2360            cjne a, #3, jump_state4_power_control
1190 8003      2361            sjmp state3_power_control_calculation
1192           2362   
1192           2363   jump_state4_power_control:
1192 0212BF    2364            ljmp state4_power_control
1195           2365   
1195           2366   state3_power_control_calculation:
1195           2367            ; move soak_temp to x
1195 854B3A    2368            mov x, soak_temp
1198 854C3B    2369            mov x+1, soak_temp+1
119B 854D3C    2370            mov x+2, soak_temp+2
119E 854E3D    2371            mov x+3, soak_temp+3
11A1           2372            ; move current_temp to y
11A1 85473E    2373            mov y, current_temp
11A4 85483F    2374            mov y+1, current_temp+1
11A7 854940    2375            mov y+2, current_temp+2
11AA 854A41    2376            mov y+3, current_temp+3
11AD           2377   
11AD           2378            ; compare between soak_temp and current_temp
11AD C200      2379            clr mf
11AF 120178    2380            lcall x_gteq_y
11B2 10002B    2381            jbc mf, st_sub_ct
11B5           2382            ; current_temp - soak_temp if st < ct
11B5 C228      2383            clr soak_temp_greater
11B7           2384            ; move current_temp to y
11B7 854B3E    2385            mov y, soak_temp
11BA 854C3F    2386            mov y+1, soak_temp+1
11BD 854D40    2387            mov y+2, soak_temp+2
11C0 854E41    2388            mov y+3, soak_temp+3
11C3           2389            ; move current_temp to x
11C3 85473A    2390            mov x, current_temp
11C6 85483B    2391            mov x+1, current_temp+1
11C9 85493C    2392            mov x+2, current_temp+2
11CC 854A3D    2393            mov x+3, current_temp+3
11CF 1200F6    2394            lcall sub32
11D2 853A62    2395            mov soak_temp_diff, x
11D5 853B63    2396            mov soak_temp_diff+1, x+1
11D8 853C64    2397            mov soak_temp_diff+2, x+2
11DB 853D65    2398            mov soak_temp_diff+3, x+3
11DE 8011      2399            sjmp proportional_input_soak
11E0           2400   
11E0           2401   st_sub_ct:
11E0           2402            ; soak_temp - current_temp
11E0 D228      2403            setb soak_temp_greater
11E2 1200F6    2404            lcall sub32
11E5 853A62    2405            mov soak_temp_diff, x
11E8 853B63    2406            mov soak_temp_diff+1, x+1
11EB 853C64    2407            mov soak_temp_diff+2, x+2
11EE 853D65    2408            mov soak_temp_diff+3, x+3
11F1           2409   
11F1           2410   proportional_input_soak:
11F1           2411            ; proportaional block calculation       
11F1           2412            ; move soak_temp_diff to x
11F1 85623A    2413            mov x, soak_temp_diff
11F4 85633B    2414            mov x+1, soak_temp_diff+1
11F7 85643C    2415            mov x+2, soak_temp_diff+2
11FA 85653D    2416            mov x+3, soak_temp_diff+3
11FD           2417            ; move proportional gain to y
11FD 753E05    2418            mov y+0, #low (KP % 0x10000) 
1200 753F00    2418            mov y+1, #high(KP % 0x10000) 
1203 754000    2418            mov y+2, #low (KP / 0x10000) 
1206 754100    2418            mov y+3, #high(KP / 0x10000) 
1209 12018C    2419            lcall mul32 ; proportional_output = proportional_gain * difference
120C           2420            
120C 853A66    2421            mov proportional_gain_var, x
120F 853B67    2422            mov proportional_gain_var+1, x+1
1212 853C68    2423            mov proportional_gain_var+2, x+2
1215 853D69    2424            mov proportional_gain_var+3, x+3
1218           2425   
1218           2426            ; base_power + soak_power when soak_temp > current_temp
1218 302829    2427            jnb soak_temp_greater, sub_proportional_soak
121B 85663A    2428            mov x, proportional_gain_var
121E 85673B    2429            mov x+1, proportional_gain_var+1
1221 85683C    2430            mov x+2, proportional_gain_var+2
1224 85693D    2431            mov x+3, proportional_gain_var+3
1227 753E2C    2432            mov y+0, #low (BASE_POWER % 0x10000) 
122A 753F01    2432            mov y+1, #high(BASE_POWER % 0x10000) 
122D 754000    2432            mov y+2, #low (BASE_POWER / 0x10000) 
1230 754100    2432            mov y+3, #high(BASE_POWER / 0x10000) 
1233 1200D3    2433            lcall add32
1236           2434            ; x now holds the power output before the saturator
1236 853A66    2435            mov proportional_gain_var, x
1239 853B67    2436            mov proportional_gain_var+1, x+1
123C 853C68    2437            mov proportional_gain_var+2, x+2
123F 853D69    2438            mov proportional_gain_var+3, x+3
1242 803D      2439            sjmp saturator_soak
1244           2440   
1244           2441   sub_proportional_soak:
1244           2442            ; base_power - soak_power when soak_temp <= current_temp
1244 753A2C    2443            mov x+0, #low (BASE_POWER % 0x10000) 
1247 753B01    2443            mov x+1, #high(BASE_POWER % 0x10000) 
124A 753C00    2443            mov x+2, #low (BASE_POWER / 0x10000) 
124D 753D00    2443            mov x+3, #high(BASE_POWER / 0x10000) 
1250 85663E    2444            mov y, proportional_gain_var
1253 85673F    2445            mov y+1, proportional_gain_var+1
1256 856840    2446            mov y+2, proportional_gain_var+2
1259 856941    2447            mov y+3, proportional_gain_var+3
125C           2448   
125C           2449            ; compare whether base_power < proportional_gain_var
125C C200      2450            clr mf
125E 12011A    2451            lcall x_lt_y ; set mf to 1 if base_power < proportional_gain_var, clamp output to 0
1261 30000E    2452            jnb mf, bp_gteq_pgv
1264 756600    2453            mov proportional_gain_var, #low(NO_POWER)
1267 756700    2454            mov proportional_gain_var+1, #high(NO_POWER)
126A 756800    2455            mov proportional_gain_var+2, #0
126D 756900    2456            mov proportional_gain_var+3, #0
1270 800F      2457            sjmp saturator_soak
1272           2458   
1272           2459   bp_gteq_pgv:
1272           2460            ; calculate subtracted gain
1272 1200F6    2461            lcall sub32
1275           2462            ; x now holds the power output before the saturator
1275 853A66    2463            mov proportional_gain_var, x
1278 853B67    2464            mov proportional_gain_var+1, x+1
127B 853C68    2465            mov proportional_gain_var+2, x+2
127E 853D69    2466            mov proportional_gain_var+3, x+3
1281           2467   
1281           2468   saturator_soak:
1281           2469            ; proportional_gain_var now holds the power output before the saturator
1281           2470            ; saturate power output to max power
1281 85663A    2471            mov x, proportional_gain_var
1284 85673B    2472            mov x+1, proportional_gain_var+1
1287 85683C    2473            mov x+2, proportional_gain_var+2
128A 85693D    2474            mov x+3, proportional_gain_var+3
128D           2475   
128D 753EDC    2476            mov y+0, #low (MAX_POWER % 0x10000) 
1290 753F05    2476            mov y+1, #high(MAX_POWER % 0x10000) 
1293 754000    2476            mov y+2, #low (MAX_POWER / 0x10000) 
1296 754100    2476            mov y+3, #high(MAX_POWER / 0x10000) 
1299           2477   
1299 C200      2478            clr mf
129B 120136    2479            lcall x_gt_y ; set mf to 1 if calculated power output greater than max power
129E 20000F    2480            jb mf, saturated_soak
12A1           2481            ; set power_output to calculated power if not saturated
12A1 856658    2482            mov power_output, proportional_gain_var
12A4 856759    2483            mov power_output+1, proportional_gain_var+1
12A7 85685A    2484            mov power_output+2, proportional_gain_var+2
12AA 85695B    2485            mov power_output+3, proportional_gain_var+3
12AD 021301    2486            ljmp power_control_done
12B0           2487   
12B0           2488   saturated_soak:
12B0 7558DC    2489            mov power_output, #low(MAX_POWER)
12B3 755905    2490            mov power_output+1, #high(MAX_POWER)
12B6 755A00    2491            mov power_output+2, #0
12B9 755B00    2492            mov power_output+3, #0
12BC 021301    2493            ljmp power_control_done
12BF           2494   
12BF           2495   
12BF           2496   state4_power_control:
12BF           2497            ; ramp to reflow, max power
12BF B4040F    2498            cjne a, #4, state5_power_control
12C2 7558DC    2499            mov power_output, #low(MAX_POWER)
12C5 755905    2500            mov power_output+1, #high(MAX_POWER)
12C8 755A00    2501            mov power_output+2, #0
12CB 755B00    2502            mov power_output+3, #0
12CE 021301    2503            ljmp power_control_done
12D1           2504   
12D1           2505   state5_power_control:
12D1           2506            ; reflow 20% base power
12D1 B4050F    2507            cjne a, #5, state6_power_control
12D4 75582C    2508            mov power_output, #low(BASE_POWER)  
12D7 755901    2509            mov power_output+1, #high(BASE_POWER)
12DA 755A00    2510            mov power_output+2, #0
12DD 755B00    2511            mov power_output+3, #0
12E0 021301    2512            ljmp power_control_done
12E3           2513   
12E3           2514   state6_power_control:
12E3           2515            ; cooling 0% power
12E3 B4060F    2516            cjne a, #6, state_7_power_control
12E6 755800    2517            mov power_output, #low(NO_POWER)
12E9 755900    2518            mov power_output+1, #high(NO_POWER)
12EC 755A00    2519            mov power_output+2, #0
12EF 755B00    2520            mov power_output+3, #0
12F2 021301    2521            ljmp power_control_done
12F5           2522   
12F5           2523   state_7_power_control:
12F5           2524            ; idle 0% power
12F5 755800    2525            mov power_output, #low(NO_POWER)
12F8 755900    2526            mov power_output+1, #high(NO_POWER)
12FB 755A00    2527            mov power_output+2, #0
12FE 755B00    2528            mov power_output+3, #0
1301           2529   
1301           2530   power_control_done:
1301 22        2531            ret
1302           2532   
1302           2533   ;-------------------------------------------------------------------------------;
1302           2534   ;         Main program.          
1302           2535   ;-------------------------------------------------------------------------------;
1302           2536   main:
1302           2537   
1302           2538       ; --------------------------------------------------------
1302           2539       ; 1. SAFETY SHUTDOWN
1302           2540       ; --------------------------------------------------------
1302 C2AF      2541       clr EA              ; FORCE Interrupts OFF immediately
1304 7581C0    2542       mov SP, #0xC0       ; Reset Stack Pointer to safe location
1307           2543       
1307           2544       ; --------------------------------------------------------
1307           2545       ; THE "DIRTY DELAY" (Fixes Reset Garbage)
1307           2546       ; We burn ~100ms here using a raw loop. 
1307           2547       ; We cannot use timers yet because they aren't initialized.
1307           2548       ; --------------------------------------------------------
1307 78FA      2549       mov R0, #250
1309           2550   Reset_Delay_Outer:
1309 79FF      2551       mov R1, #255
130B           2552   Reset_Delay_Inner:
130B D9FE      2553       djnz R1, Reset_Delay_Inner
130D D8FA      2554       djnz R0, Reset_Delay_Outer
130F           2555       
130F           2556       ; --- PORT CONFIGURATION ---
130F 759AAA    2557       mov P0MOD, #0xAA
1312           2558       ; P1: Mixed usage 
1312           2559       ; P1.7(LCD_RS), P1.6(Row3), P1.5(Sound), P1.4(Row2)
1312           2560       ; P1.3(PWM), P1.2(Row1), P1.1(LCD_E) -> All Outputs
1312           2561       ; P1.0 (Unused/RX) -> Input
1312           2562       ; Binary: 11111110 -> Hex: 0xFE
1312 759BFE    2563       mov P1MOD, #0xFE
1315           2564   
1315           2565       ; P2: Row4(Out), Cols(In)
1315           2566       ; P2.0 (Row4) is Out (1). P2.2, P2.4, P2.6 (Cols) are In (0).
1315           2567       ; Binary: 00000001 -> Hex: 0x01
1315 759C01    2568       mov P2MOD, #0x01
1318           2569   
1318           2570       ; P3: Col4(In)
1318           2571       ; P3.0 (Col4) is In (0).
1318 759D00    2572       mov P3MOD, #0x00
131B           2573       ; Turn off all the LEDs
131B 75E800    2574       mov LEDRA, #0 ; LEDRA is bit addressable
131E 759500    2575       mov LEDRB, #0 ; LEDRB is NOT bit addresable
1321           2576   
1321           2577       ; Enable Global interrupts
1321 D2AF      2578       setb EA  
1323           2579   
1323           2580            ; FSM initial states
1323 757000    2581            mov SEC_FSM_state, #0
1326 756000    2582            mov Control_FSM_state, #0
1329 756100    2583            mov Current_State, #0
132C           2584            ; FSM timers initialization
132C 756F00    2585            mov SEC_FSM_timer, #0
132F           2586            ; time counters initialization
132F 753000    2587            mov current_time_sec, #0
1332 753100    2588            mov current_time_minute, #0
1335 753200    2589            mov soak_time_sec, #0
1338 753300    2590            mov soak_time_minute, #0
133B 753400    2591            mov reflow_time_sec, #0
133E 753500    2592            mov reflow_time_minute, #0
1341 753600    2593            mov soak_end_time_sec, #0
1344 753700    2594            mov soak_end_time_minute, #0
1347 753800    2595            mov reflow_end_time_sec, #0
134A 753900    2596            mov reflow_end_time_minute, #0
134D           2597       ; Initialize counter to zero
134D 755C00    2598       mov pwm_counter, #0
1350 755D00    2599       mov pwm_counter+1, #0
1353 755E00    2600       mov pwm_counter+2, #0
1356 755F00    2601       mov pwm_counter+3, #0
1359           2602       ; Initialize power output
1359 755B00    2603       mov power_output+3, #0
135C 755A00    2604       mov power_output+2, #0
135F 755902    2605       mov power_output+1, #02H
1362 7558EE    2606       mov power_output, #0EEH ; (initilize to 750 for testing)
1365           2607            ; FSM Buttons push button init
1365 757200    2608            mov     PB0_DEB_state, #0
1368 757400    2609            mov     PB2_DEB_state, #0
136B 757100    2610            mov     PB0_DEB_timer, #0
136E 757300    2611            mov     PB2_DEB_timer, #0
1371           2612       ; [FIX] ADD THIS BLOCK TO STOP STARTUP BEEP
1371 757600    2613       mov beep_state, #0
1374 757500    2614       mov beep_count, #0
1377 757700    2615       mov beep_tmr, #0
137A 757800    2616       mov beep_tmr+1, #0
137D C218      2617       clr one_ms_beep_flag
137F C28C      2618       clr TR0 ; Force buzzer hardware OFF
1381           2619   
1381           2620            ; Clear all the flags
1381 C295      2621            clr SOUND_OUT
1383 C219      2622       clr beep_error_done
1385 C213      2623            clr tc_missing_abort
1387 C20B      2624            clr stop_signal
1389 C215      2625            clr PB0_flag
138B C216      2626            clr PB1_flag
138D C217      2627            clr PB2_flag
138F C201      2628            clr one_second_flag
1391 C204      2629            clr one_second_lcd_flag
1393 C20E      2630            clr config_finish_signal
1395 C20D      2631       clr time_count_doing_signal
1397 C224      2632       clr fullscreen_update_signal
1399 C205      2633            clr soak_temp_reached
139B C208      2634            clr soak_time_reached
139D C206      2635            clr reflow_temp_reached
139F C209      2636            clr reflow_time_reached
13A1 C207      2637            clr cooling_temp_reached
13A3 C210      2638       clr state_change_signal_TC
13A5 C211      2639            clr state_change_signal_Count
13A7 C212      2640       clr state_change_beep_signal
13A9           2641       ; Set bit
13A9 D20F      2642            setb state_change_signal
13AB D214      2643       setb tc_startup_window
13AD           2644   
13AD 12045D    2645       lcall Timer0_Init
13B0 120518    2646       lcall Timer2_Init
13B3 1205EB    2647       lcall ELCD_4BIT
13B6           2648       ;----- Two new lines I added to initialize the UI
13B6 120FC0    2649       lcall Init_All_Buffers
13B9 120477    2650       lcall Initialize_Serial_Port
13BC           2651   ;-------------------------------------------------------------------------------;
13BC           2652   ; while(1) loop
13BC           2653   ;-------------------------------------------------------------------------------;
13BC           2654   loop:
13BC           2655   
13BC 120A36    2656            lcall SEC_FSM
13BF           2657   
13BF           2658            ; Check the FSM for the overall control flow of the reflow process
13BF 120CE3    2659       lcall Control_FSM
13C2           2660   
13C2           2661       ; Check the FSM for PB01 debounce
13C2 1209C8    2662       lcall PB0_DEB
13C5 120A00    2663            lcall PB2_DEB
13C8           2664       
13C8           2665       ; Added to take temp readings
13C8 121013    2666       lcall Read_Thermocouple
13CB           2667       
13CB           2668       ; 1. Check if we reached temp (Observer)
13CB 120B1F    2669       lcall Temp_Compare
13CE           2670       
13CE           2671       ; 2. Decide heater power based on flags (Driver)
13CE           2672       ;lcall Power_Control
13CE 121155    2673       lcall proportional_power_control
13D1           2674       
13D1 120C10    2675       lcall Safety_Check_TC
13D4           2676   
13D4 120A92    2677            lcall Time_Counter
13D7           2678   
13D7           2679            ; Update Variables (times and temp)
13D7 120DBA    2680            lcall Update_FSM_Variables
13DA           2681   
13DA           2682            ; Update while at state 1
13DA           2683            ; LCD
13DA 120874    2684            lcall Update_Screen_Full 
13DD           2685            ; Buttons
13DD 120E3E    2686            lcall Check_Buttons 
13E0           2687            ; PB0pad
13E0 120E94    2688       lcall Check_Keypad
13E3           2689   
13E3           2690       ; Update the LCD display based on the current state
13E3 1206B0    2691       lcall LCD_Display_Update_func
13E6           2692   
13E6 120AB4    2693            lcall Time_Compare_MMSS
13E9           2694   
13E9           2695       ; Update the pwm output for the ssr
13E9 120B99    2696       lcall PWM_Wave 
13EC           2697            ; Update the Buzzer 
13EC 120CAA    2698            lcall Beep_Task
13EF           2699       ; Update the pwm output for the servo
13EF 1210E8    2700       lcall call_servo_control
13F2           2701   
13F2 120C61    2702       lcall Beep_Judge
13F5           2703   
13F5           2704       ; After initialization the program stays in this 'forever' loop
13F5 0213BC    2705       ljmp loop
13F8           2706   ;-------------------------------------------------------------------------------;
13F8           2707   EN
