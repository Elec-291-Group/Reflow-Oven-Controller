0000              1   ; Project 1
0000              2   ; CV-8052 microcontroller in DE10-Lite board
0000              3   ;-------------------------------------------------------------------------------
0000              4   ; Reset vector
0000              5   org 0x0000
<<<<<<< HEAD
0000 020F90       6       ljmp main
=======
0000 020BC1       6       ljmp main
>>>>>>> main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9       reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 02046E      12       ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15       reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18       reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 32          21       reti
0024             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
<<<<<<< HEAD
002B 0204D4      24       ljmp Timer2_ISR
=======
002B 02052E      24       ljmp Timer2_ISR
>>>>>>> main
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 32   $LIST
0320             34   ; ----------------------------------------------------------------------------------------------;
0320             35   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             36   dseg at 0x30
<<<<<<< HEAD
0030             37   ; time buffer 
0030             38   current_time_sec:     ds 1
0031             39   current_time_minute:  ds 1
0032             40   soak_time_sec:        ds 1
0033             41   soak_time_minute:     ds 1
0034             42   reflow_time_sec:      ds 1
0035             43   reflow_time_minute:   ds 1
0036             44   soak_end_time_sec:      ds 1
0037             45   soak_end_time_minute:   ds 1
0038             46   reflow_end_time_sec:    ds 1
0039             47   reflow_end_time_minute: ds 1
003A             48   
003A             49   ; math32 buffer variables
003A             50   x:      ds  4
003E             51   y:      ds  4
0042             52   bcd:    ds  5
0047             53   
0047             54   current_temp: ds 4 ;
004B             55   soak_temp:    ds 4 ;
004F             56   reflow_temp:  ds 4 ;
0053             57   
0053             58   wait25_btn_cnt:    ds 1
0054             59   wait25_keypad_cnt: ds 1
0055             60   wait25_adc_cnt:    ds 1
0056             61   wait25_lcd_cnt:    ds 1
0057             62   wait25_count:      ds 1
0058             63   
0058             64   power_output:  ds 4 ;
005C             65   pwm_counter:   ds 4 ; counter for pwm (0-1500_timer: ds 1
0060             66   
0060             67   Control_FSM_state: ds 1 
0061             68   Current_State:     ds 1
0062             69   
0062             70   ;-- UI buffers I added (ayaan)
0062             71   Cursor_Idx: ds 1
0063             72   
0063             73   ; Buzzer module variables
0063             74   buzz_state:      ds 1   ; 0=IDLE, 1=ON, 2=OFF
0064             75   buzz_timer:      ds 1   ; counts ms within ON/OFF window
0065             76   buzz_beeps_left: ds 1   ; how many beeps remaining
0066             77   buzz_priority:   ds 1   ; 0 none, 1=state, 2=done, 3=error
0067             78   
0067             79   SEC_FSM_timer: ds 1
0068             80   SEC_FSM_state: ds 1
0069             81   ; Push buttons for globel interrupt 
0069             82   PB0_DEB_timer:  ds 1
006A             83   PB0_DEB_state:  ds 1
006B             84   PB2_DEB_timer:  ds 1
006C             85   PB2_DEB_state:  ds 1
006D             86   
0080             87   iseg at 0x80
0080             88   ; These hold the TEXT (ASCII) safely
0080             89   ; Digits Only + Null Terminator, got rid of C,:, and s 
0080             90   Buf_Soak_Temp: ds 4   
0084             91   Buf_Soak_Time: ds 5   
0089             92   Buf_Refl_Temp: ds 4   
008D             93   Buf_Refl_Time: ds 5
0092             94   ; 
0092             95   ;-------------------------------------------------------------------------------
0092             96   ; bit operation setb, clr, jb, and jnb
0000             97   bseg
0000             98   mf:     dbit 1 ; math32 sign
0001             99   one_second_flag: dbit 1
0002            100   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003            101   one_ms_buzz_flag: dbit 1 ; one_millisecond_flag for buzz
0004            102   one_second_lcd_flag: dbit 1
0005            103   
0005            104   soak_temp_reached: dbit 1
0006            105   reflow_temp_reached: dbit 1
0007            106   cooling_temp_reached: dbit 1
0008            107   
0008            108   soak_time_reached: dbit 1
0009            109   reflow_time_reached: dbit 1
000A            110   
000A            111   reset_signal: dbit 1
000B            112   stop_signal: dbit 1
000C            113   start_signal_count: dbit 1
000D            114   time_count_doing_signal: dbit 1
000E            115   config_finish_signal: dbit 1
000F            116   
000F            117   state_change_signal: dbit 1
0010            118   state_change_signal_TC: dbit 1
0011            119   state_change_signal_Count: dbit 1
0012            120   
0012            121   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
0013            122   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0014            123   
0014            124   PB0_flag: dbit 1 ; start entire program
0015            125   PB1_flag: dbit 1 ; start soak
0016            126   PB2_flag: dbit 1 ; pause process
0017            127   
0017            128   ; BSEG (Bit Segment)
0017            129   wait25_active: dbit 1 ; 1 = We are currently waiting
0018            130   wait25_done:   dbit 1 ; 1 = The 25ms has finished
0019            131   wait25_btn_active:    dbit 1
001A            132   wait25_btn_done:      dbit 1
001B            133   wait25_keypad_active: dbit 1
001C            134   wait25_keypad_done:   dbit 1
001D            135   wait25_adc_active:    dbit 1
001E            136   wait25_adc_done:      dbit 1
001F            137   wait25_lcd_active:    dbit 1
0020            138   wait25_lcd_done:      dbit 1
0021            139   
0021            140   fullscreen_update_signal: dbit 1
0022            141   
0022            142   one_second_flag_test: dbit 1
0023            143   
0023            144   ;-------------------------------------------------------------------------------
0320            145   cseg
0320            146   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            147   BAUD           EQU 57600
0320            148   
0320            149   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            150   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            151   ; is always 12 unlike the N76E003 where is selectable.
0320            152   
0320            153   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            154   
0320            155   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            156   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            157   
0320            158   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            159   
0320            160   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            161   BEEP_ON_MS          EQU 100  ; 100ms
0320            162   BEEP_OFF_MS    EQU 100  ; 100ms
0320            163   
0320            164   PWM_OUT        EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            165   
0320            166   ; These 'equ' must match the wiring between the DE10Lite board and the LCD!
0320            167   ; P0 is in connector JPIO.
0320            168   
0320            169   ;Added correct I/O definitions
0320            170   ;-- LCD Pins ---
0320            171   ELCD_RS equ P1.7
0320            172   ELCD_E  equ P1.1
0320            173   ELCD_D4 equ P0.7
0320            174   ELCD_D5 equ P0.5
0320            175   ELCD_D6 equ P0.3
0320            176   ELCD_D7 equ P0.1
0320            177   
0320            178   ; -- Buttons --
0320            179   BTN_SOAK_TEMP equ P0.0
0320            180   BTN_SOAK_TIME equ P0.2
0320            181   BTN_REFL_TEMP equ P0.4
0320            182   BTN_REFL_TIME equ P0.6
0320            183   PB0                equ P1.0
0320            184   PB2                equ P3.7
0320            185   
0320            186   ; --- PB0PAD ---
0320            187   ROW1 equ P1.2
0320            188   ROW2 equ P1.4
0320            189   ROW3 equ P1.6
0320            190   ROW4 equ P2.0
0320            191   COL1 equ P2.2
0320            192   COL2 equ P2.4
0320            193   COL3 equ P2.6
0320            194   COL4 equ P3.0
0320            195   
0320            196   ;                     1234567890123456 <-- 16 characters per line LCD
0320 696E6974   197   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   198   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   199   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            200   
0350            201   ; --- UI STRINGS (REQUIRED FOR PB0PAD LOGIC), <- I can fix if duplicates
0350 53656C65   202   Txt_Home:     db 'Select Mode:    ', 0
=======
0030             37   current_time_sec:     ds 1
0031             38   current_time_minute:  ds 1
0032             39   ; math32 buffer variables
0032             40   x:      ds  4
0036             41   y:      ds  4
003A             42   bcd:    ds  5
003F             43   
003F             44   current_temp: ds 4 ;
0043             45   soak_temp:    ds 4 ;
0047             46   reflow_temp:  ds 4 ;
004B             47   
004B             48   wait25_btn_cnt:    ds 1
004C             49   wait25_keypad_cnt: ds 1
004D             50   wait25_adc_cnt:    ds 1
004E             51   wait25_lcd_cnt:    ds 1
004F             52   wait25_count: ds 1  
0050             53   
0050             54   current_time: ds 4 ;
0054             55   soak_time:    ds 4 ;
0058             56   reflow_time:  ds 4 ;
005C             57   
005C             58   power_output:  ds 4 ;
0060             59   pwm_counter: ds 4 ; counter for pwm (0-1500)
0064             60   
0064             61   KEY1_DEB_timer: ds 1
0065             62   SEC_FSM_timer:  ds 1
0066             63   KEY1_DEB_state:    ds 1
0067             64   SEC_FSM_state:     ds 1
0068             65   Control_FSM_state: ds 1 
0069             66   
0069             67   Current_State:     ds 1
006A             68   soak_temp_diff: ds 4 ; temperature difference between target soak temp and current oven temp 
006E             69   proportional_gain_var: ds 4 ; power gain calculated from the proportional block
0072             70   ;-- UI buffers I added (ayaan)
0072             71   Cursor_Idx: ds 1
0073             72   
0073             73   ; These hold the TEXT (ASCII) safely
0073             74   ; Digits Only + Null Terminator, got rid of C,:, and s 
0073             75   
0073             76   ; Buzzer state
0073             77   beep_count:  ds 1      ; remaining beeps
0074             78   beep_state:  ds 1      ; 0=idle, 1=ON, 2=OFF
0075             79   beep_tmr:    ds 2      ; 16-bit ms timer (needs to reach 500)
0077             80   
0077             81   servo_pwm_counter: ds 1 ; counter for the servo pwm signal
0078             82   
0080             83   iseg at 0x80
0080             84   Buf_Soak_Temp: ds 4   
0084             85   Buf_Soak_Time: ds 5   
0089             86   Buf_Refl_Temp: ds 4   
008D             87   Buf_Refl_Time: ds 5
0092             88   
0092             89   
0092             90   
0092             91   ; 46d bytes used
0092             92   
0092             93   ;-------------------------------------------------------------------------------
0092             94   ; bit operation setb, clr, jb, and jnb
0000             95   bseg
0000             96   mf:     dbit 1 ; math32 sign
0001             97   one_second_flag: dbit 1
0002             98   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003             99   
0003            100   soak_temp_reached: dbit 1
0004            101   reflow_temp_reached: dbit 1
0005            102   cooling_temp_reached: dbit 1
0006            103   
0006            104   soak_time_reached: dbit 1
0007            105   reflow_time_reached: dbit 1
0008            106   
0008            107   reset_signal: dbit 1
0009            108   stop_signal: dbit 1
000A            109   start_signal: dbit 1
000B            110   config_finish_signal: dbit 1
000C            111   
000C            112   state_change_signal: dbit 1
000D            113   
000D            114   Key1_flag: dbit 1
000E            115   
000E            116   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
000F            117   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0010            118   PB0_flag: dbit 1 ; start entire program
0011            119   PB1_flag: dbit 1 ; start soak
0012            120   PB2_flag: dbit 1 ; pause process
0013            121   
0013            122   ;buzzer beep
0013            123   one_ms_beep_flag: dbit 1
0014            124   
0014            125   ; BSEG (Bit Segment)
0014            126   wait25_active: dbit 1 ; 1 = We are currently waiting
0015            127   wait25_done:   dbit 1 ; 1 = The 25ms has finished
0016            128   wait25_btn_active:    dbit 1
0017            129   wait25_btn_done:      dbit 1
0018            130   wait25_keypad_active: dbit 1
0019            131   wait25_keypad_done:   dbit 1
001A            132   wait25_adc_active:    dbit 1
001B            133   wait25_adc_done:      dbit 1
001C            134   wait25_lcd_active:    dbit 1
001D            135   wait25_lcd_done:      dbit 1
001E            136   
001E            137   one_millisecond_flag_servo: dbit 1 ; set the one millsiecond flag for servo pwm signal generation
001F            138   servo_angle_zero: dbit 1 ; flag for indicating whether the servo angle should be at 0 or not: 1 -> 0; 0 -> 180
0020            139   soak_temp_greater: dbit 1 ; target soak_temp greater than current_temp
0021            140   ; 11 bits used
0021            141   
0021            142   ;-------------------------------------------------------------------------------
0320            143   cseg
0320            144   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            145   BAUD           EQU 57600
0320            146   
0320            147   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            148   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            149   ; is always 12 unlike the N76E003 where is selectable.
0320            150   
0320            151   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            152   
0320            153   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            154   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            155   
0320            156   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            157   
0320            158   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            159   
0320            160   PWM_OUT        EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            161   
0320            162   ; These 'equ' must match the wiring between the DE10Lite board and the LCD!
0320            163   ; P0 is in connector JPIO.
0320            164   
0320            165   ;Added correct I/O definitions
0320            166   ;-- LCD Pins ---
0320            167   ELCD_RS equ P1.7
0320            168   ELCD_E  equ P1.1
0320            169   ELCD_D4 equ P0.7
0320            170   ELCD_D5 equ P0.5
0320            171   ELCD_D6 equ P0.3
0320            172   ELCD_D7 equ P0.1
0320            173   
0320            174   ; -- Buttons --
0320            175   BTN_SOAK_TEMP equ P0.0
0320            176   BTN_SOAK_TIME equ P0.2
0320            177   BTN_REFL_TEMP equ P0.4
0320            178   BTN_REFL_TIME equ P0.6
0320            179   
0320            180   ; --- KEYPAD ---
0320            181   ROW1 equ P1.2
0320            182   ROW2 equ P1.4
0320            183   ROW3 equ P1.6
0320            184   ROW4 equ P2.0
0320            185   COL1 equ P2.2
0320            186   COL2 equ P2.4
0320            187   COL3 equ P2.6
0320            188   COL4 equ P3.0
0320            189   
0320            190   SERVO_OUT      EQU p3.6 ; servo pin
0320            191   
0320            192   SERVO_PERIOD   EQU 20 ; pwm signal period for the servo motor (20 ms)
0320            193   SERVO_0        EQU 1 ; pwm high time for the servo motor to stay at 0 degree
0320            194   SERVO_180      EQU 2 ; pwm high time for the servo motor to stay at 180 degrees
0320            195   
0320            196   COLD_JUNCTION_TEMP equ 20
0320            197   MAX_POWER           EQU 1500 ; max oven power
0320            198   NO_POWER            EQU 0    ; no power
0320            199   BASE_POWER     EQU (MAX_POWER/5) ; 20% base power for state 2, 4
0320            200   KP                          EQU 5 ; proportional gain
0320            201   
0320            202   ;                     1234567890123456 <-- 16 characters per line LCD
0320 696E6974   203   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   204   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   205   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            206   
0350            207   ; --- UI STRINGS (REQUIRED FOR KEYPAD LOGIC), <- I can fix if duplicates
0350 53656C65   208   Txt_Home:     db 'Select Mode:    ', 0
>>>>>>> main
     6374204D
     6F64653A
     20202020
     00
<<<<<<< HEAD
0361 53657420   203   Txt_SoakT:    db 'Set Soak Temp   ', 0
=======
0361 53657420   209   Txt_SoakT:    db 'Set Soak Temp   ', 0
>>>>>>> main
     536F616B
     2054656D
     70202020
     00
<<<<<<< HEAD
0372 53657420   204   Txt_SoakTime: db 'Set Soak Time   ', 0
=======
0372 53657420   210   Txt_SoakTime: db 'Set Soak Time   ', 0
>>>>>>> main
     536F616B
     2054696D
     65202020
     00
<<<<<<< HEAD
0383 53657420   205   Txt_ReflT:    db 'Set Reflow Temp ', 0
=======
0383 53657420   211   Txt_ReflT:    db 'Set Reflow Temp ', 0
>>>>>>> main
     5265666C
     6F772054
     656D7020
     00
<<<<<<< HEAD
0394 53657420   206   Txt_ReflTime: db 'Set Reflow Time ', 0
=======
0394 53657420   212   Txt_ReflTime: db 'Set Reflow Time ', 0
>>>>>>> main
     5265666C
     6F772054
     696D6520
     00
<<<<<<< HEAD
03A5            207   
03A5            208   ;                       1234567890123456
03A5 53657420   209   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
03B5 536F616B   210   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
03C0 5265666C   211   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
03CD 536F616B   212   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
03D8 5265666C   213   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03E5            214   
03E5            215   ;                     1234567890123456
03E5 52616D70   216   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03F5 536F616B   217   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
0405 52616D70   218   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
0415 5265666C   219   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
0425 436F6F6C   220   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
0435 50726F63   221   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
0445            222   
0445 20202020   223   String_Blank:    db '                ', 0
=======
03A5            213   
03A5            214   ;                       1234567890123456
03A5 53657420   215   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
03B5 536F616B   216   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
03C0 5265666C   217   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
03CD 536F616B   218   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
03D8 5265666C   219   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03E5            220   
03E5 54656D70   221   String_temp_line:  db 'Temp: ', 0
     3A2000
03EC            222   
03EC            223   ;                     1234567890123456
03EC 52616D70   224   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03FC 536F616B   225   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
040C 52616D70   226   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
041C 5265666C   227   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
042C 436F6F6C   228   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
043C 50726F63   229   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
044C            230   
044C 20202020   231   String_Blank:    db '                ', 0
>>>>>>> main
     20202020
     20202020
     20202020
     00
<<<<<<< HEAD
0456            224   
0456            225   ;-------------------------------------------------------------------------------
0456            226   ; Timers Setting:
0456            227   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
0456            228   ;   Timer 1: Serial port baud rate 57600 generator
0456            229   ;   Timer 2: 1ms interrupt for BCD counter increment/decrement
0456            230   ;-------------------------------------------------------------------------------
0456            231   ; Routine to initialize the ISR for Timer 0 ;
0456            232   Timer0_Init:
0456 E589       233       mov a, TMOD
0458 54F0       234       anl a, #0xf0 ; Clear the bits for timer 0
045A 4401       235       orl a, #0x01 ; Configure timer 0 as 16-timer
045C F589       236       mov TMOD, a
045E 758CFD     237       mov TH0, #high(TIMER0_RELOAD)
0461 758A5A     238       mov TL0, #low(TIMER0_RELOAD)
0464            239       ; Enable the timer and interrupts
0464 D2A9       240       setb ET0  ; Enable timer 0 interrupt
0466 D28C       241       setb TR0  ; Start timer 0
0468 22         242       ret
0469            243   ; ISR for timer 0.  Set to execute every 1/4096Hz 
0469            244   ; to generate a 2048 Hz square wave at pin P1.5 
0469            245   Timer0_ISR:
0469            246       ;clr TF0  ; According to the data sheet this is done for us already.
0469 758CFD     247       mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
046C 758A5A     248       mov TL0, #low(TIMER0_RELOAD)
046F            249       ;cpl SOUND_OUT ; Connect speaker to P1.5
046F 32         250       reti
0470            251   ; -----------------------------------------------------------------------------------------------;
0470            252   
0470            253   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
0470            254   Initialize_Serial_Port:
0470            255       ; Configure serial port and baud rate
0470 C28E       256       clr TR1 ; Disable timer 1
0472 53890F     257       anl TMOD, #0x0f ; Mask the bits for timer 1
0475 438920     258       orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
0478 438780     259       orl PCON, #80H ; Set SMOD to 1
047B 758DFD     260       mov TH1, #low(TIMER_1_RELOAD)
047E 758BFD     261       mov TL1, #low(TIMER_1_RELOAD) 
0481 D28E       262       setb TR1 ; Enable timer 1
0483 759852     263       mov SCON, #52H
0486 22         264       ret
0487            265   
0487            266   ; uart sending functions
0487            267   putchar:
0487 109902     268       jbc TI, putchar_L1
048A 80FB       269       sjmp putchar
048C            270   putchar_L1:
048C F599       271       mov SBUF,a
048E 22         272       ret
048F            273   
048F            274   SendString:
048F E4         275       clr a
0490 93         276       movc a, @a+dptr
0491 6006       277       jz SendString_L1
0493 120487     278       lcall putchar
0496 A3         279       inc dptr
0497 80F6       280       sjmp SendString  
0499            281   SendString_L1:
0499 22         282       ret
049A            283   
049A            284   ;-------------------------------------------------------------------------------
049A            285   ; serial debugging
049A            286   ; send a four byte number via serial to laptop
049A            287   ; need to be used with python script
049A            288   ; content needed to be sent should be stored in the varaible x
049A            289   ;-------------------------------------------------------------------------------
049A            290   Send32:
049A            291       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
049A 74AA       292       mov A, #0AAH
049C 120487     293       lcall putchar
049F 7455       294       mov A, #055H
04A1 120487     295       lcall putchar
04A4            296   
04A4 E53D       297       mov A, x+3
04A6 120487     298       lcall putchar
04A9 E53C       299       mov A, x+2
04AB 120487     300       lcall putchar
04AE E53B       301       mov A, x+1
04B0 120487     302       lcall putchar
04B3 E53A       303       mov A, x+0
04B5 120487     304       lcall putchar
04B8            305   
04B8 740A       306       mov A, #0AH
04BA 120487     307       lcall putchar
04BD 22         308       ret
04BE            309   ; -----------------------------------------------------------------------------------------------;
04BE            310   
04BE            311   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
04BE              1   ;-------------------------------------------------------------------------------
04BE              2   ; Timer2_ISR.inc
04BE              3   ; Contains Initialization and ISR for the 1ms System Timer
04BE              4   ;-------------------------------------------------------------------------------
04BE              5   
04BE              6   ;-------------------------------------------------------------------------------
04BE              7   ; Routine to initialize the ISR for timer 2
04BE              8   ;-------------------------------------------------------------------------------
04BE              9   Timer2_Init:
04BE 75C800      10       mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
04C1 75CDF5      11       mov TH2, #high(TIMER2_RELOAD)
04C4 75CC27      12       mov TL2, #low(TIMER2_RELOAD)
04C7             13       ; Set the reload value
04C7 75CBF5      14       mov RCAP2H, #high(TIMER2_RELOAD)
04CA 75CA27      15       mov RCAP2L, #low(TIMER2_RELOAD)
04CD             16       
04CD C2CF        17       clr TF2       ; Clear flag just in case
04CF             18       ; Enable the timer and interrupts
04CF D2AD        19       setb ET2      ; Enable timer 2 interrupt
04D1 D2CA        20       setb TR2      ; Enable timer 2
04D3 22          21       ret
04D4             22   
04D4             23   ;-------------------------------------------------------------------------------
04D4             24   ; ISR for timer 2.  Runs every 1 ms
04D4             25   ;-------------------------------------------------------------------------------
04D4             26   Timer2_ISR:
04D4 C0E0        27       push acc
04D6 C0D0        28       push psw
04D8             29       
04D8 C2CF        30       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
04DA             31   
04DA             32       ; --- 1. Existing Non-Blocking Seconds Increment and Periphals Debounce Timers ---
04DA 0567        33       inc SEC_FSM_timer
04DC D202        34       setb one_ms_pwm_flag 
04DE D203        35            setb one_ms_buzz_flag
04E0             36   
04E0 0569        37       inc PB0_DEB_timer
04E2 056B        38       inc PB2_DEB_timer
04E4             39   
04E4             40       ; --- 2. NEW: Non-Blocking Delay Counters ---
04E4             41       ; A. BUTTON DELAY
04E4 30190B      42       jnb wait25_btn_active, T2_Check_Keypad
04E7 0553        43       inc wait25_btn_cnt
04E9 E553        44       mov a, wait25_btn_cnt
04EB B41904      45       cjne a, #25, T2_Check_Keypad
04EE D21A        46       setb wait25_btn_done
04F0 C219        47       clr wait25_btn_active
04F2             48       
04F2             49       ; B. KEYPAD DELAY
04F2             50   T2_Check_Keypad:
04F2 301B0B      51       jnb wait25_keypad_active, T2_Check_ADC
04F5 0554        52       inc wait25_keypad_cnt
04F7 E554        53       mov a, wait25_keypad_cnt
04F9 B41904      54       cjne a, #25, T2_Check_ADC
04FC D21C        55       setb wait25_keypad_done
04FE C21B        56       clr wait25_keypad_active
0500             57   
0500             58       ; C. ADC DELAY (Thermocouple)
0500             59   T2_Check_ADC:
0500 301D0B      60       jnb wait25_adc_active, T2_Check_LCD
0503 0555        61       inc wait25_adc_cnt
0505 E555        62       mov a, wait25_adc_cnt
0507 B41904      63       cjne a, #25, T2_Check_LCD
050A D21E        64       setb wait25_adc_done
050C C21D        65       clr wait25_adc_active
050E             66   
050E             67       ; D. LCD DELAY
050E             68   T2_Check_LCD:
050E 301F0B      69       jnb wait25_lcd_active, T2_Check_Generic
0511 0556        70       inc wait25_lcd_cnt
0513 E556        71       mov a, wait25_lcd_cnt
0515 B41904      72       cjne a, #25, T2_Check_Generic
0518 D220        73       setb wait25_lcd_done
051A C21F        74       clr wait25_lcd_active
051C             75   
051C             76       ; E. GENERIC DELAY (Used by Wait_25ms in Main)
051C             77   T2_Check_Generic:
051C 30170B      78       jnb wait25_active, Timer2_ISR_done
051F 0557        79       inc wait25_count
0521 E557        80       mov a, wait25_count
0523 B41904      81       cjne a, #25, Timer2_ISR_done
0526 D218        82       setb wait25_done      ; Tells Wait_25ms that we are finished
0528 C217        83       clr wait25_active     ; Stop counting
052A             84   
052A             85   Timer2_ISR_done:
052A D0D0        86       pop psw
052C D0E0        87       pop acc
052E 32          88       reti
052F             89            
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
052F              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
052F              2   cseg
052F              3   
052F              4   ; When using a 33.333333MHz crystal clock
052F              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
052F              6   
052F              7   ;---------------------------------;
052F              8   ; Wait 40 microseconds            ;
052F              9   ;---------------------------------;
052F             10   Wait40uSec:
052F C000        11            push AR0
0531 78BE        12            mov R0, #190
0533             13   L0: 
0533 00          14            nop
0534 00          15            nop
0535 00          16            nop
0536 00          17            nop
0537 D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
0539 D000        19            pop AR0
053B 22          20       ret
053C             21   
053C             22   ;---------------------------------;
053C             23   ; Wait 'R2' milliseconds          ;
053C             24   ;---------------------------------;
=======
045D            232   
045D            233   ;-------------------------------------------------------------------------------
045D            234   ; Timers Setting:
045D            235   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
045D            236   ;   Timer 1: Serial port baud rate 57600 generator
045D            237   ;   Timer 2: 1ms interrupt for BCD counter increment/decrement
045D            238   ;-------------------------------------------------------------------------------
045D            239   ; Routine to initialize the ISR for Timer 0 ;
045D            240   Timer0_Init:
045D E589       241       mov a, TMOD
045F 54F0       242       anl a, #0xf0 ; Clear the bits for timer 0
0461 4401       243       orl a, #0x01 ; Configure timer 0 as 16-timer
0463 F589       244       mov TMOD, a
0465 758CFD     245       mov TH0, #high(TIMER0_RELOAD)
0468 758A5A     246       mov TL0, #low(TIMER0_RELOAD)
046B            247       ; Enable the timer and interrupts
046B D2A9       248       setb ET0  ; Enable timer 0 interrupt
046D            249       ; setb TR0  (no need to open at first)
046D 22         250       ret
046E            251   ; ISR for timer 0.  Set to execute every 1/4096Hz 
046E            252   ; to generate a 2048 Hz square wave at pin P1.5 
046E            253   Timer0_ISR:
046E            254       ;clr TF0  ; According to the data sheet this is done for us already.
046E 758CFD     255       mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
0471 758A5A     256       mov TL0, #low(TIMER0_RELOAD)
0474 B295       257       cpl SOUND_OUT ; Connect speaker to P1.5
0476 32         258       reti
0477            259   ; -----------------------------------------------------------------------------------------------;
0477            260   
0477            261   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
0477            262   Initialize_Serial_Port:
0477            263       ; Configure serial port and baud rate
0477 C28E       264       clr TR1 ; Disable timer 1
0479 53890F     265       anl TMOD, #0x0f ; Mask the bits for timer 1
047C 438920     266       orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
047F 438780     267       orl PCON, #80H ; Set SMOD to 1
0482 758DFD     268       mov TH1, #low(TIMER_1_RELOAD)
0485 758BFD     269       mov TL1, #low(TIMER_1_RELOAD) 
0488 D28E       270       setb TR1 ; Enable timer 1
048A 759852     271       mov SCON, #52H
048D 22         272       ret
048E            273   
048E            274   ; uart sending functions
048E            275   putchar:
048E 109902     276       jbc TI, putchar_L1
0491 80FB       277       sjmp putchar
0493            278   putchar_L1:
0493 F599       279       mov SBUF,a
0495 22         280       ret
0496            281   
0496            282   SendString:
0496 E4         283       clr a
0497 93         284       movc a, @a+dptr
0498 6006       285       jz SendString_L1
049A 12048E     286       lcall putchar
049D A3         287       inc dptr
049E 80F6       288       sjmp SendString  
04A0            289   SendString_L1:
04A0 22         290       ret
04A1            291   
04A1            292   ;-------------------------------------------------------------------------------
04A1            293   ; serial debugging
04A1            294   ; send a four byte number via serial to laptop
04A1            295   ; need to be used with python script
04A1            296   ; content needed to be sent should be stored in the varaible x
04A1            297   ;-------------------------------------------------------------------------------
04A1            298   Send32:
04A1            299       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
04A1 74AA       300       mov A, #0AAH
04A3 12048E     301       lcall putchar
04A6 7455       302       mov A, #055H
04A8 12048E     303       lcall putchar
04AB            304   
04AB E535       305       mov A, x+3
04AD 12048E     306       lcall putchar
04B0 E534       307       mov A, x+2
04B2 12048E     308       lcall putchar
04B5 E533       309       mov A, x+1
04B7 12048E     310       lcall putchar
04BA E532       311       mov A, x+0
04BC 12048E     312       lcall putchar
04BF            313   
04BF 740A       314       mov A, #0AH
04C1 12048E     315       lcall putchar
04C4 22         316       ret
04C5            317   ; -----------------------------------------------------------------------------------------------;
04C5            318   
04C5            319   ;-------------------------------------------------------------------------------
04C5            320   ; Serial temperature line for PuTTY/screen
04C5            321   ; Outputs: "Temp: XXXC\r\n"
04C5            322   ;-------------------------------------------------------------------------------
04C5            323   Serial_Send_Temp_Line:
04C5 9003E5     324       mov dptr, #String_temp_line
04C8 120496     325       lcall SendString
04CB            326   
04CB            327       ; Convert current_temp to BCD (same as LCD)
04CB 853F32     328       mov x, current_temp
04CE 854033     329       mov x+1, current_temp+1
04D1 854134     330       mov x+2, current_temp+2
04D4 854235     331       mov x+3, current_temp+3
04D7 12002E     332       lcall hex2bcd
04DA            333   
04DA 7F00       334       mov R7, #0          ; printed_flag = 0
04DC            335   
04DC            336       ; Print Hundreds (if non-zero)
04DC E53B       337       mov a, bcd+1
04DE 540F       338       anl a, #0x0F
04E0 6007       339       jz Serial_Skip_Hundreds
04E2 2430       340       add a, #0x30
04E4 12048E     341       lcall putchar
04E7 7F01       342       mov R7, #1
04E9            343   Serial_Skip_Hundreds:
04E9            344   
04E9            345       ; Print Tens (if non-zero or if hundreds already printed)
04E9 E53A       346       mov a, bcd+0
04EB C4         347       swap a
04EC 540F       348       anl a, #0x0F
04EE 7003       349       jnz Serial_Print_Tens
04F0 EF         350       mov a, R7
04F1 600C       351       jz Serial_Skip_Tens
04F3            352   Serial_Print_Tens:
04F3 E53A       353       mov a, bcd+0
04F5 C4         354       swap a
04F6 540F       355       anl a, #0x0F
04F8 2430       356       add a, #0x30
04FA 12048E     357       lcall putchar
04FD 7F01       358       mov R7, #1
04FF            359   Serial_Skip_Tens:
04FF            360   
04FF            361       ; Print Ones (always)
04FF E53A       362       mov a, bcd+0
0501 540F       363       anl a, #0x0F
0503 2430       364       add a, #0x30
0505 12048E     365       lcall putchar
0508            366   
0508            367       ; Print 'C' and newline
0508 7443       368       mov a, #'C'
050A 12048E     369       lcall putchar
050D 740D       370       mov a, #0DH     ; CR
050F 12048E     371       lcall putchar
0512 740A       372       mov a, #0AH     ; LF
0514 12048E     373       lcall putchar
0517 22         374       ret
0518            375   
0518            376   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
0518              1   ;-------------------------------------------------------------------------------
0518              2   ; Timer2_ISR.inc
0518              3   ; Contains Initialization and ISR for the 1ms System Timer
0518              4   ;-------------------------------------------------------------------------------
0518              5   
0518              6   ;-------------------------------------------------------------------------------
0518              7   ; Routine to initialize the ISR for timer 2
0518              8   ;-------------------------------------------------------------------------------
0518              9   Timer2_Init:
0518 75C800      10       mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
051B 75CDF5      11       mov TH2, #high(TIMER2_RELOAD)
051E 75CC27      12       mov TL2, #low(TIMER2_RELOAD)
0521             13       ; Set the reload value
0521 75CBF5      14       mov RCAP2H, #high(TIMER2_RELOAD)
0524 75CA27      15       mov RCAP2L, #low(TIMER2_RELOAD)
0527             16       
0527 C2CF        17       clr TF2       ; Clear flag just in case
0529             18       ; Enable the timer and interrupts
0529 D2AD        19       setb ET2      ; Enable timer 2 interrupt
052B D2CA        20       setb TR2      ; Enable timer 2
052D 22          21       ret
052E             22   
052E             23   ;-------------------------------------------------------------------------------
052E             24   ; ISR for timer 2.  Runs every 1 ms
052E             25   ;-------------------------------------------------------------------------------
052E             26   Timer2_ISR:
052E C0E0        27       push acc
0530 C0D0        28       push psw
0532             29       
0532 C2CF        30       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
0534             31   
0534             32       ; --- 1. Existing FSM Timers ---
0534 0564        33       inc KEY1_DEB_timer
0536 0565        34       inc SEC_FSM_timer
0538 D202        35       setb one_ms_pwm_flag 
053A D213        36       setb one_ms_beep_flag
053C D21E        37       setb one_millisecond_flag_servo
053E             38   
053E             39       ; --- 2. NEW: Non-Blocking Delay Counters ---
053E             40       
053E             41       ; A. BUTTON DELAY
053E 30160B      42       jnb wait25_btn_active, T2_Check_Keypad
0541 054B        43       inc wait25_btn_cnt
0543 E54B        44       mov a, wait25_btn_cnt
0545 B41904      45       cjne a, #25, T2_Check_Keypad
0548 D217        46       setb wait25_btn_done
054A C216        47       clr wait25_btn_active
054C             48       
054C             49       ; B. KEYPAD DELAY
054C             50   T2_Check_Keypad:
054C 30180B      51       jnb wait25_keypad_active, T2_Check_ADC
054F 054C        52       inc wait25_keypad_cnt
0551 E54C        53       mov a, wait25_keypad_cnt
0553 B41904      54       cjne a, #25, T2_Check_ADC
0556 D219        55       setb wait25_keypad_done
0558 C218        56       clr wait25_keypad_active
055A             57   
055A             58       ; C. ADC DELAY (Thermocouple)
055A             59   T2_Check_ADC:
055A 301A0B      60       jnb wait25_adc_active, T2_Check_LCD
055D 054D        61       inc wait25_adc_cnt
055F E54D        62       mov a, wait25_adc_cnt
0561 B41904      63       cjne a, #25, T2_Check_LCD
0564 D21B        64       setb wait25_adc_done
0566 C21A        65       clr wait25_adc_active
0568             66   
0568             67       ; D. LCD DELAY
0568             68   T2_Check_LCD:
0568 301C0B      69       jnb wait25_lcd_active, T2_Check_Generic
056B 054E        70       inc wait25_lcd_cnt
056D E54E        71       mov a, wait25_lcd_cnt
056F B41904      72       cjne a, #25, T2_Check_Generic
0572 D21D        73       setb wait25_lcd_done
0574 C21C        74       clr wait25_lcd_active
0576             75   
0576             76       ; E. GENERIC DELAY (Used by Wait_25ms in Main)
0576             77   T2_Check_Generic:
0576 30140B      78       jnb wait25_active, Timer2_ISR_done
0579 054F        79       inc wait25_count
057B E54F        80       mov a, wait25_count
057D B41904      81       cjne a, #25, Timer2_ISR_done
0580 D215        82       setb wait25_done      ; Tells Wait_25ms that we are finished
0582 C214        83       clr wait25_active     ; Stop counting
0584             84   
0584             85   Timer2_ISR_done:
0584 D0D0        86       pop psw
0586 D0E0        87       pop acc
0588 32          88       reti
0589             89            
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
0589              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
0589              2   cseg
0589              3   
0589              4   ; When using a 33.333333MHz crystal clock
0589              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
0589              6   
0589              7   ;---------------------------------;
0589              8   ; Wait 40 microseconds            ;
0589              9   ;---------------------------------;
0589             10   Wait40uSec:
0589 C000        11            push AR0
058B 78BE        12            mov R0, #190
058D             13   L0: 
058D 00          14            nop
058E 00          15            nop
058F 00          16            nop
0590 00          17            nop
0591 D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
0593 D000        19            pop AR0
0595 22          20       ret
0596             21   
0596             22   ;---------------------------------;
0596             23   ; Wait 'R2' milliseconds          ;
0596             24   ;---------------------------------;
>>>>>>> main
                 25   Wait_Milli_Seconds mac
                 26   	push AR2
                 27   	mov R2, %0
                 28   	lcall ?Wait_Milli_Seconds
                 29   	pop AR2
                 30   endmac
<<<<<<< HEAD
053C             31   
053C             32   ?Wait_Milli_Seconds:
053C C000        33            push AR0
053E C001        34            push AR1
0540 7932        35   L3: mov R1, #50
0542 78DF        36   L2: mov R0, #223
0544 D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
0546 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
0548 DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
054A D001        40       pop AR1
054C D000        41       pop AR0
054E 22          42       ret
054F             43            
054F             44   ;---------------------------------;
054F             45   ; Toggles the 'E' pin in the LCD  ;
054F             46   ;---------------------------------;
054F             47   ELCD_pulse:
054F D291        48            setb ELCD_E
0551 12052F      49            lcall Wait40uSec
0554 C291        50            clr ELCD_E
0556 12052F      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
0559 22          52       ret
055A             53   
055A             54   ;---------------------------------;
055A             55   ; Writes acc to LCD in 4-bit mode ;
055A             56   ;---------------------------------;
055A             57   ELCD_byte:
055A             58            ; Write high 4 bits first
055A A2E7        59            mov c, ACC.7
055C 9281        60            mov ELCD_D7, c
055E A2E6        61            mov c, ACC.6
0560 9283        62            mov ELCD_D6, c
0562 A2E5        63            mov c, ACC.5
0564 9285        64            mov ELCD_D5, c
0566 A2E4        65            mov c, ACC.4
0568 9287        66            mov ELCD_D4, c
056A 12054F      67       lcall ELCD_pulse
056D             68            ; Write low 4 bits next
056D A2E3        69            mov c, ACC.3
056F 9281        70            mov ELCD_D7, c
0571 A2E2        71            mov c, ACC.2
0573 9283        72            mov ELCD_D6, c
0575 A2E1        73            mov c, ACC.1
0577 9285        74            mov ELCD_D5, c
0579 A2E0        75            mov c, ACC.0
057B 9287        76            mov ELCD_D4, c
057D 12054F      77       lcall ELCD_pulse
0580 22          78            ret
0581             79   
0581             80   ;---------------------------------;
0581             81   ; Write data to LCD               ;
0581             82   ;---------------------------------;
=======
0596             31   
0596             32   ?Wait_Milli_Seconds:
0596 C000        33            push AR0
0598 C001        34            push AR1
059A 7932        35   L3: mov R1, #50
059C 78DF        36   L2: mov R0, #223
059E D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
05A0 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
05A2 DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
05A4 D001        40       pop AR1
05A6 D000        41       pop AR0
05A8 22          42       ret
05A9             43            
05A9             44   ;---------------------------------;
05A9             45   ; Toggles the 'E' pin in the LCD  ;
05A9             46   ;---------------------------------;
05A9             47   ELCD_pulse:
05A9 D291        48            setb ELCD_E
05AB 120589      49            lcall Wait40uSec
05AE C291        50            clr ELCD_E
05B0 120589      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
05B3 22          52       ret
05B4             53   
05B4             54   ;---------------------------------;
05B4             55   ; Writes acc to LCD in 4-bit mode ;
05B4             56   ;---------------------------------;
05B4             57   ELCD_byte:
05B4             58            ; Write high 4 bits first
05B4 A2E7        59            mov c, ACC.7
05B6 9281        60            mov ELCD_D7, c
05B8 A2E6        61            mov c, ACC.6
05BA 9283        62            mov ELCD_D6, c
05BC A2E5        63            mov c, ACC.5
05BE 9285        64            mov ELCD_D5, c
05C0 A2E4        65            mov c, ACC.4
05C2 9287        66            mov ELCD_D4, c
05C4 1205A9      67       lcall ELCD_pulse
05C7             68            ; Write low 4 bits next
05C7 A2E3        69            mov c, ACC.3
05C9 9281        70            mov ELCD_D7, c
05CB A2E2        71            mov c, ACC.2
05CD 9283        72            mov ELCD_D6, c
05CF A2E1        73            mov c, ACC.1
05D1 9285        74            mov ELCD_D5, c
05D3 A2E0        75            mov c, ACC.0
05D5 9287        76            mov ELCD_D4, c
05D7 1205A9      77       lcall ELCD_pulse
05DA 22          78            ret
05DB             79   
05DB             80   ;---------------------------------;
05DB             81   ; Write data to LCD               ;
05DB             82   ;---------------------------------;
>>>>>>> main
                 83   WriteData mac
                 84   	mov a, %0
                 85   	lcall ?WriteData
                 86   endmac
<<<<<<< HEAD
0581             87            
0581             88   ?WriteData:
0581 D297        89            setb ELCD_RS
0583 02055A      90            ljmp ELCD_byte
0586             91   
0586             92   ;---------------------------------;
0586             93   ; Write command to LCD            ;
0586             94   ;---------------------------------;
=======
05DB             87            
05DB             88   ?WriteData:
05DB D297        89            setb ELCD_RS
05DD 0205B4      90            ljmp ELCD_byte
05E0             91   
05E0             92   ;---------------------------------;
05E0             93   ; Write command to LCD            ;
05E0             94   ;---------------------------------;
>>>>>>> main
                 95   WriteCommand mac
                 96   	mov a, %0
                 97   	lcall ?WriteCommand
                 98   endmac
<<<<<<< HEAD
0586             99   
0586            100   ?WriteCommand:
0586 C297       101            clr ELCD_RS
0588 02055A     102            ljmp ELCD_byte
058B            103   
058B            104   ;---------------------------------;
058B            105   ; Configure LCD in 4-bit mode     ;
058B            106   ;---------------------------------;
058B            107   ELCD_4BIT:
058B C291       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
058D            109            ;clr ELCD_RW  ; RW forced to zero
058D            110            
058D            111            ; After power on, let the LCD start up before initializing
058D C002       112            push AR2
058F 7A28       112            mov R2, #40
0591 12053C     112            lcall ?Wait_Milli_Seconds
0594 D002       112            pop AR2
0596            112   
0596            113            
0596            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
0596 7433       115            mov a, #0x33
0598 120586     115            lcall ?WriteCommand
059B 7433       116            mov a, #0x33
059D 120586     116            lcall ?WriteCommand
05A0 7432       117            mov a, #0x32
05A2 120586     117            lcall ?WriteCommand ; change to 4-bit mode
05A5            118   
05A5            119            ; Configure the LCD
05A5 7428       120            mov a, #0x28
05A7 120586     120            lcall ?WriteCommand
05AA 740C       121            mov a, #0x0c
05AC 120586     121            lcall ?WriteCommand
05AF 7401       122            mov a, #0x01
05B1 120586     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
05B4            123   
05B4            124       ;Wait for the clear screen command to finish.
05B4 C002       125            push AR2
05B6 7A02       125            mov R2, #2
05B8 12053C     125            lcall ?Wait_Milli_Seconds
05BB D002       125            pop AR2
05BD            125   
05BD 22         126       ret
05BE            127   
05BE            128   ;---------------------------------;
05BE            129   ; Send a constant string to LCD   ;
05BE            130   ;---------------------------------;
=======
05E0             99   
05E0            100   ?WriteCommand:
05E0 C297       101            clr ELCD_RS
05E2 0205B4     102            ljmp ELCD_byte
05E5            103   
05E5            104   ;---------------------------------;
05E5            105   ; Configure LCD in 4-bit mode     ;
05E5            106   ;---------------------------------;
05E5            107   ELCD_4BIT:
05E5 C291       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
05E7            109            ;clr ELCD_RW  ; RW forced to zero
05E7            110            
05E7            111            ; After power on, let the LCD start up before initializing
05E7 C002       112            push AR2
05E9 7A28       112            mov R2, #40
05EB 120596     112            lcall ?Wait_Milli_Seconds
05EE D002       112            pop AR2
05F0            113            
05F0            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
05F0 7433       115            mov a, #0x33
05F2 1205E0     115            lcall ?WriteCommand
05F5 7433       116            mov a, #0x33
05F7 1205E0     116            lcall ?WriteCommand
05FA 7432       117            mov a, #0x32
05FC 1205E0     117            lcall ?WriteCommand ; change to 4-bit mode
05FF            118   
05FF            119            ; Configure the LCD
05FF 7428       120            mov a, #0x28
0601 1205E0     120            lcall ?WriteCommand
0604 740C       121            mov a, #0x0c
0606 1205E0     121            lcall ?WriteCommand
0609 7401       122            mov a, #0x01
060B 1205E0     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
060E            123   
060E            124       ;Wait for the clear screen command to finish.
060E C002       125            push AR2
0610 7A02       125            mov R2, #2
0612 120596     125            lcall ?Wait_Milli_Seconds
0615 D002       125            pop AR2
0617 22         126       ret
0618            127   
0618            128   ;---------------------------------;
0618            129   ; Send a constant string to LCD   ;
0618            130   ;---------------------------------;
>>>>>>> main
                131   Send_Constant_String mac
                132   	push dph
                133   	push dpl
                134   	push acc
                135   	mov dptr, %0
                136   	lcall ?Send_Constant_String
                137   	pop acc
                138   	pop dpl
                139   	pop dph
                140   endmac
<<<<<<< HEAD
05BE            141   
05BE            142   ?Send_Constant_String:
05BE E4         143       clr a
05BF 93         144       movc a, @a+dptr
05C0 6006       145       jz ?Send_Constant_String_Done
05C2 120581     146       lcall ?WriteData
05C5 A3         147       inc dptr
05C6 80F6       148       sjmp ?Send_Constant_String
05C8            149   ?Send_Constant_String_Done:
05C8 22         150       ret  
05C9            151   
05C9            152   ;---------------------------------;
05C9            153   ; Set LCD cursor at row, column   ;
05C9            154   ;---------------------------------;
=======
0618            141   
0618            142   ?Send_Constant_String:
0618 E4         143       clr a
0619 93         144       movc a, @a+dptr
061A 6006       145       jz ?Send_Constant_String_Done
061C 1205DB     146       lcall ?WriteData
061F A3         147       inc dptr
0620 80F6       148       sjmp ?Send_Constant_String
0622            149   ?Send_Constant_String_Done:
0622 22         150       ret  
0623            151   
0623            152   ;---------------------------------;
0623            153   ; Set LCD cursor at row, column   ;
0623            154   ;---------------------------------;
>>>>>>> main
                155   Set_Cursor mac
                156   	push acc
                157   	mov a, #%1
                158   	dec a
                159   	lcall ?Set_Cursor_%0 ; Select column and row
                160   	pop acc
                161   endmac
<<<<<<< HEAD
05C9            162   
05C9            163   ?Set_Cursor_2:
05C9 4440       164            orl a, #01000000B
05CB            165   ?Set_Cursor_1:
05CB 4480       166            orl a, #10000000B
05CD 020586     167            ljmp ?WriteCommand ; Select column and row
05D0            168   
05D0            169   ;---------------------------------;
05D0            170   ; Display a BCD number in the LCD ;
05D0            171   ;---------------------------------;
=======
0623            162   
0623            163   ?Set_Cursor_2:
0623 4440       164            orl a, #01000000B
0625            165   ?Set_Cursor_1:
0625 4480       166            orl a, #10000000B
0627 0205E0     167            ljmp ?WriteCommand ; Select column and row
062A            168   
062A            169   ;---------------------------------;
062A            170   ; Display a BCD number in the LCD ;
062A            171   ;---------------------------------;
>>>>>>> main
                172   Display_BCD mac
                173   	push ar0
                174   	mov r0, %0
                175   	lcall ?Display_BCD
                176   	pop ar0
                177   endmac
<<<<<<< HEAD
05D0            178   
05D0            179   ?Display_BCD:
05D0 C0E0       180            push acc
05D2            181            ; Write most significant digit
05D2 E8         182            mov a, r0
05D3 C4         183            swap a
05D4 540F       184            anl a, #0fh
05D6 4430       185            orl a, #30h
05D8 120581     186            lcall ?WriteData
05DB            187            ; write least significant digit
05DB E8         188            mov a, r0
05DC 540F       189            anl a, #0fh
05DE 4430       190            orl a, #30h
05E0 120581     191            lcall ?WriteData
05E3 D0E0       192            pop acc
05E5 22         193            ret
05E6            194   
05E6            195   ;------------------------------------;
05E6            196   ; Display a char in the LCD          ;
05E6            197   ;------------------------------------;
=======
062A            178   
062A            179   ?Display_BCD:
062A C0E0       180            push acc
062C            181            ; Write most significant digit
062C E8         182            mov a, r0
062D C4         183            swap a
062E 540F       184            anl a, #0fh
0630 4430       185            orl a, #30h
0632 1205DB     186            lcall ?WriteData
0635            187            ; write least significant digit
0635 E8         188            mov a, r0
0636 540F       189            anl a, #0fh
0638 4430       190            orl a, #30h
063A 1205DB     191            lcall ?WriteData
063D D0E0       192            pop acc
063F 22         193            ret
0640            194   
0640            195   ;------------------------------------;
0640            196   ; Display a char in the LCD          ;
0640            197   ;------------------------------------;
>>>>>>> main
                198   Display_char mac
                199   	push acc
                200   	mov a, %0
                201   	lcall ?WriteData
                202   	pop acc
                203   endmac
<<<<<<< HEAD
05E6            204   
05E6            314            ;-----------------------------------------------------------------------------------------------;
05E6            315   
05E6            316   ;-------------------------------------------------------------------------------
05E6            317   ; Display Function for 7-segment displays       
05E6            318   ;-------------------------------------------------------------------------------
05E6            319   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
05E6            320   T_7seg:
05E6 C0F9A4B0   321       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
05EB 9282F880   322       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
05F0 8883C6A1   323       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
05F6            324   
05F6            325   ; Displays a BCD number pased in R0 in HEX5-HEX0
05F6            326   Display_BCD_7_Seg_HEX10:
05F6 9005E6     327       mov dptr, #T_7seg
05F9 E8         328       mov a, R0
05FA C4         329       swap a
05FB 540F       330       anl a, #0FH
05FD 93         331       movc a, @a+dptr
05FE F592       332       mov HEX1, a
0600 E8         333       mov a, R0
0601 540F       334       anl a, #0FH
0603 93         335       movc a, @a+dptr
0604 F591       336       mov HEX0, a
0606 22         337       ret
0607            338   
0607            339   Display_BCD_7_Seg_HEX32:
0607 9005E6     340       mov dptr, #T_7seg
060A E8         341       mov a, R0
060B C4         342       swap a
060C 540F       343       anl a, #0FH
060E 93         344       movc a, @a+dptr
060F F594       345       mov HEX3, a
0611 E8         346       mov a, R0
0612 540F       347       anl a, #0FH
0614 93         348       movc a, @a+dptr
0615 F593       349       mov HEX2, a
0617 22         350       ret
0618            351   
0618            352   Display_BCD_7_Seg_HEX54:
0618 9005E6     353       mov dptr, #T_7seg
061B E8         354       mov a, R0
061C C4         355       swap a
061D 540F       356       anl a, #0FH
061F 93         357       movc a, @a+dptr
0620 F58F       358       mov HEX5, a
0622 E8         359       mov a, R0
0623 540F       360       anl a, #0FH
0625 93         361       movc a, @a+dptr
0626 F58E       362       mov HEX4, a
0628 22         363       ret
0629            364   
0629            365   ; The 8-bit hex number passed in the accumulator is converted to
0629            366   ; BCD and stored in [R1, R0]
0629            367   Hex_to_bcd_8bit:
0629 75F064     368       mov b, #100
062C 84         369       div ab
062D F9         370       mov R1, a   ; After dividing, a has the 100s
062E E5F0       371       mov a, b    ; Remainder is in register b
0630 75F00A     372       mov b, #10
0633 84         373       div ab ; The tens are stored in a, the units are stored in b 
0634 C4         374       swap a
0635 54F0       375       anl a, #0xf0
0637 45F0       376       orl a, b
0639 F8         377       mov R0, a
063A 22         378       ret
063B            379   ;-------------------------------------------------------------------------------
063B            380   ; Display Function for LCD                      
063B            381   ;-------------------------------------------------------------------------------
063B            382   LCD_Display_Update_func:
063B C0E0       383       push acc
063D            384       
063D            385       ; ==========================================
063D            386       ; PART 1: STATIC TEXT (Title)
063D            387       ; Runs ONLY when the state changes
063D            388       ; ==========================================
063D            389       
063D            390       ; [FIX] "Trampoline" logic for long distance jump
063D            391       ; If signal is SET (1), we stay here and update.
063D            392       ; If signal is CLEAR (0), we Long Jump to the Live Update section.
063D 300F04     393       jnb state_change_signal, Do_Dynamic_Update
0640 C20F       394            clr state_change_signal
0642 8003       395            sjmp Do_Static_Update
0644            396   Do_Dynamic_Update:
0644 02077B     397            ljmp Check_Live_Update
0647            398   
0647            399   Do_Static_Update:
0647            400       ; State Changed: Clear Screen and Write Title
0647 12091A     401       lcall Clear_Screen_Func
064A E560       402       mov a, Control_FSM_state
064C            403       
064C            404       ; State 0: Welcome
064C B4003B     405       cjne a, #0, LCD_Check_1
064F C0E0       406            push acc
0651 7401       406            mov a, #1
0653 14         406            dec a
0654 1205CB     406            lcall ?Set_Cursor_1 ; Select column and row
0657 D0E0       406            pop acc
0659 C083       407            push dph
065B C082       407            push dpl
065D C0E0       407            push acc
065F 900330     407            mov dptr, #String_state0_1
0662 1205BE     407            lcall ?Send_Constant_String
0665 D0E0       407            pop acc
0667 D082       407            pop dpl
0669 D083       407            pop dph
066B C0E0       408            push acc
066D 7401       408            mov a, #1
066F 14         408            dec a
0670 1205C9     408            lcall ?Set_Cursor_2 ; Select column and row
0673 D0E0       408            pop acc
0675 C083       409            push dph
0677 C082       409            push dpl
0679 C0E0       409            push acc
067B 900340     409            mov dptr, #String_state0_2
067E 1205BE     409            lcall ?Send_Constant_String
0681 D0E0       409            pop acc
0683 D082       409            pop dpl
0685 D083       409            pop dph
0687 020778     410       ljmp LCD_Done_Bridge ; Exit
068A            411   
068A            412   LCD_Check_1: ; Setup
068A B4011F     413       cjne a, #1, LCD_Check_2
068D C0E0       414            push acc
068F 7401       414            mov a, #1
0691 14         414            dec a
0692 1205CB     414            lcall ?Set_Cursor_1 ; Select column and row
0695 D0E0       414            pop acc
0697 C083       415            push dph
0699 C082       415            push dpl
069B C0E0       415            push acc
069D 9003A5     415            mov dptr, #String_state1
06A0 1205BE     415            lcall ?Send_Constant_String
06A3 D0E0       415            pop acc
06A5 D082       415            pop dpl
06A7 D083       415            pop dph
06A9 020778     416       ljmp LCD_Done_Bridge
06AC            417   
06AC            418   LCD_Check_2: ; Ramp to Soak
06AC B4021F     419       cjne a, #2, LCD_Check_3
06AF C0E0       420            push acc
06B1 7401       420            mov a, #1
06B3 14         420            dec a
06B4 1205CB     420            lcall ?Set_Cursor_1 ; Select column and row
06B7 D0E0       420            pop acc
06B9 C083       421            push dph
06BB C082       421            push dpl
06BD C0E0       421            push acc
06BF 9003E5     421            mov dptr, #String_state2
06C2 1205BE     421            lcall ?Send_Constant_String
06C5 D0E0       421            pop acc
06C7 D082       421            pop dpl
06C9 D083       421            pop dph
06CB 020799     422       ljmp LCD_Update_Temp_Value ; Draw Temp immediately!
06CE            423   
06CE            424   LCD_Check_3: ; Soak
06CE B4031F     425       cjne a, #3, LCD_Check_4
06D1 C0E0       426            push acc
06D3 7401       426            mov a, #1
06D5 14         426            dec a
06D6 1205CB     426            lcall ?Set_Cursor_1 ; Select column and row
06D9 D0E0       426            pop acc
06DB C083       427            push dph
06DD C082       427            push dpl
06DF C0E0       427            push acc
06E1 9003F5     427            mov dptr, #String_state3
06E4 1205BE     427            lcall ?Send_Constant_String
06E7 D0E0       427            pop acc
06E9 D082       427            pop dpl
06EB D083       427            pop dph
06ED 020799     428       ljmp LCD_Update_Temp_Value
06F0            429   
06F0            430   LCD_Check_4: ; Ramp to Peak
06F0 B4041F     431       cjne a, #4, LCD_Check_5
06F3 C0E0       432            push acc
06F5 7401       432            mov a, #1
06F7 14         432            dec a
06F8 1205CB     432            lcall ?Set_Cursor_1 ; Select column and row
06FB D0E0       432            pop acc
06FD C083       433            push dph
06FF C082       433            push dpl
0701 C0E0       433            push acc
0703 900405     433            mov dptr, #String_state4
0706 1205BE     433            lcall ?Send_Constant_String
0709 D0E0       433            pop acc
070B D082       433            pop dpl
070D D083       433            pop dph
070F 020799     434       ljmp LCD_Update_Temp_Value
0712            435   
0712            436   LCD_Check_5: ; Reflow
0712 B4051F     437       cjne a, #5, LCD_Check_6
0715 C0E0       438            push acc
0717 7401       438            mov a, #1
0719 14         438            dec a
071A 1205CB     438            lcall ?Set_Cursor_1 ; Select column and row
071D D0E0       438            pop acc
071F C083       439            push dph
0721 C082       439            push dpl
0723 C0E0       439            push acc
0725 900415     439            mov dptr, #String_state5
0728 1205BE     439            lcall ?Send_Constant_String
072B D0E0       439            pop acc
072D D082       439            pop dpl
072F D083       439            pop dph
0731 020799     440       ljmp LCD_Update_Temp_Value
0734            441   
0734            442   LCD_Check_6: ; Cooling
0734 B4061F     443       cjne a, #6, LCD_Check_7
0737 C0E0       444            push acc
0739 7401       444            mov a, #1
073B 14         444            dec a
073C 1205CB     444            lcall ?Set_Cursor_1 ; Select column and row
073F D0E0       444            pop acc
0741 C083       445            push dph
0743 C082       445            push dpl
0745 C0E0       445            push acc
0747 900425     445            mov dptr, #String_state6
074A 1205BE     445            lcall ?Send_Constant_String
074D D0E0       445            pop acc
074F D082       445            pop dpl
0751 D083       445            pop dph
0753 020799     446       ljmp LCD_Update_Temp_Value
0756            447   
0756            448   LCD_Check_7: ; Done
0756            449       ; [FIX] Check distance safe logic for State 7
0756 B4071F     450       cjne a, #7, LCD_Done_Bridge ; If not 7, we are done
0759 C0E0       451            push acc
075B 7401       451            mov a, #1
075D 14         451            dec a
075E 1205CB     451            lcall ?Set_Cursor_1 ; Select column and row
0761 D0E0       451            pop acc
0763 C083       452            push dph
0765 C082       452            push dpl
0767 C0E0       452            push acc
0769 900435     452            mov dptr, #String_state7
076C 1205BE     452            lcall ?Send_Constant_String
076F D0E0       452            pop acc
0771 D082       452            pop dpl
0773 D083       452            pop dph
0775 020778     453       ljmp LCD_Done_Bridge
0778            454   
0778            455   ; Local bridge to reach the far-away LCD_Done
0778            456   LCD_Done_Bridge:
0778 0207DB     457       ljmp LCD_Done
077B            458   
077B            459   ; ==========================================
077B            460   ; PART 2: DYNAMIC VALUES (Temperature)
077B            461   ; Runs every time 'one_second_flag' is set
077B            462   ; ==========================================
077B            463   Check_Live_Update:
077B 3001FA     464       jnb one_second_flag, LCD_Done_Bridge
077E            465       
077E            466       ; Only update temp for States 2, 3, 4, 5, 6
077E E560       467       mov a, Control_FSM_state
0780 B40202     468       cjne a, #2, Check_St3
0783 8014       469       sjmp LCD_Update_Temp_Value
0785            470   Check_St3:
0785 B40302     471       cjne a, #3, Check_St4
0788 800F       472       sjmp LCD_Update_Temp_Value
078A            473   Check_St4:
078A B40402     474       cjne a, #4, Check_St5
078D 800A       475       sjmp LCD_Update_Temp_Value
078F            476   Check_St5:
078F B40502     477       cjne a, #5, Check_St6
0792 8005       478       sjmp LCD_Update_Temp_Value
0794            479   Check_St6:
0794 B40644     480       cjne a, #6, LCD_Done
0797 8000       481       sjmp LCD_Update_Temp_Value
0799            482   
0799            483   ; --- HELPER: Prints "XXX C" on Line 2 ---
0799            484   LCD_Update_Temp_Value:
0799 C0E0       485            push acc
079B 7401       485            mov a, #1
079D 14         485            dec a
079E 1205C9     485            lcall ?Set_Cursor_2 ; Select column and row
07A1 D0E0       485            pop acc
07A3            486       
07A3            487       ; Convert current_temp to BCD
07A3 85473A     488       mov x, current_temp
07A6 85483B     489       mov x+1, current_temp+1
07A9 85493C     490       mov x+2, current_temp+2
07AC 854A3D     491       mov x+3, current_temp+3
07AF 12002E     492       lcall hex2bcd
07B2            493       
07B2            494       ; Print Hundreds
07B2 E543       495       mov a, bcd+1
07B4 540F       496       anl a, #0x0F
07B6 2430       497       add a, #0x30
07B8 120581     498       lcall ?WriteData
07BB            499       
07BB            500       ; Print Tens
07BB E542       501       mov a, bcd+0
07BD C4         502       swap a
07BE 540F       503       anl a, #0x0F
07C0 2430       504       add a, #0x30
07C2 120581     505       lcall ?WriteData
07C5            506       
07C5            507       ; Print Ones
07C5 E542       508       mov a, bcd+0
07C7 540F       509       anl a, #0x0F
07C9 2430       510       add a, #0x30
07CB 120581     511       lcall ?WriteData
07CE            512       
07CE            513       ; Print 'C'
07CE 7443       514       mov a, #'C'
07D0 120581     515       lcall ?WriteData
07D3            516       
07D3            517       ; Clear remaining line space (prevents garbage)
07D3 7420       518       mov a, #' '
07D5 120581     519       lcall ?WriteData
07D8 120581     520       lcall ?WriteData
07DB            521   
07DB            522   LCD_Done:
07DB D0E0       523       pop acc
07DD 22         524       ret
07DE            525   
07DE            526   ; ==========================================
07DE            527   ; PART 3: DYNAMIC VALUES (Time)
07DE            528   ; Runs every time 'one_second_flag' is set
07DE            529   ; ==========================================
07DE            530   LCD_Display_Update_Time:
07DE 300D2B     531            jnb time_count_doing_signal, LCD_Display_Update_Time_done
07E1 100402     532            jbc one_second_lcd_flag, LCD_Display_Update_Time_do
07E4 8026       533            sjmp LCD_Display_Update_Time_done
07E6            534   
07E6            535   LCD_Display_Update_Time_do:
07E6 C0E0       536            push acc
07E8 740E       536            mov a, #14
07EA 14         536            dec a
07EB 1205C9     536            lcall ?Set_Cursor_2 ; Select column and row
07EE D0E0       536            pop acc
07F0 C000       537            push ar0
07F2 A830       537            mov r0, current_time_sec
07F4 1205D0     537            lcall ?Display_BCD
07F7 D000       537            pop ar0
07F9 C0E0       538            push acc
07FB 740B       538            mov a, #11
07FD 14         538            dec a
07FE 1205C9     538            lcall ?Set_Cursor_2 ; Select column and row
0801 D0E0       538            pop acc
0803 C000       539            push ar0
0805 A831       539            mov r0, current_time_minute
0807 1205D0     539            lcall ?Display_BCD
080A D000       539            pop ar0
080C            540   
080C            541   LCD_Display_Update_Time_done:
080C 22         542            ret
080D            543   
080D            544   ; ----------------------------------------------------------------
080D            545   ; MODULE: SCREEN UPDATE (Visual Logic)
080D            546   ; ----------------------------------------------------------------
080D            547   Update_Screen_Full:
080D E560       548            mov a, Control_FSM_state
080F B40102     549            cjne a, #1, Update_Screen_Full_ret
0812 8001       550            sjmp Update_Screen_Full_do
0814            551   Update_Screen_Full_ret:
0814 22         552            ret
0815            553   Update_Screen_Full_do:
0815 3021FC     554       jnb fullscreen_update_signal, Update_Screen_Full_ret
0818 C221       555       clr fullscreen_update_signal
081A            556   
081A C0E0       557            push acc
081C 7401       557            mov a, #1
081E 14         557            dec a
081F 1205CB     557            lcall ?Set_Cursor_1 ; Select column and row
0822 D0E0       557            pop acc
0824            558       ; --- Draw Line 1 (Titles) ---
0824 E561       559       mov A, Current_State
0826 B40013     560       cjne A, #0, Update_State_1
0829 C083       561            push dph
082B C082       561            push dpl
082D C0E0       561            push acc
082F 900350     561            mov dptr, #Txt_Home
0832 1205BE     561            lcall ?Send_Constant_String
0835 D0E0       561            pop acc
0837 D082       561            pop dpl
0839 D083       561            pop dph
083B 22         562       ret 
083C            563   Update_State_1:
083C B40114     564       cjne A, #1, Update_State_2
083F C083       565            push dph
0841 C082       565            push dpl
0843 C0E0       565            push acc
0845 900361     565            mov dptr, #Txt_SoakT
0848 1205BE     565            lcall ?Send_Constant_String
084B D0E0       565            pop acc
084D D082       565            pop dpl
084F D083       565            pop dph
0851 8042       566       sjmp Draw_Temp_Format
0853            567   Update_State_2:
0853 B40214     568       cjne A, #2, Update_State_3
0856 C083       569            push dph
0858 C082       569            push dpl
085A C0E0       569            push acc
085C 900372     569            mov dptr, #Txt_SoakTime
085F 1205BE     569            lcall ?Send_Constant_String
0862 D0E0       569            pop acc
0864 D082       569            pop dpl
0866 D083       569            pop dph
0868 8046       570       sjmp Draw_Time_Format
086A            571   Update_State_3:
086A B40314     572       cjne A, #3, Update_State_4
086D C083       573            push dph
086F C082       573            push dpl
0871 C0E0       573            push acc
0873 900383     573            mov dptr, #Txt_ReflT
0876 1205BE     573            lcall ?Send_Constant_String
0879 D0E0       573            pop acc
087B D082       573            pop dpl
087D D083       573            pop dph
087F 8014       574       sjmp Draw_Temp_Format
0881            575   Update_State_4:
0881 C083       576            push dph
0883 C082       576            push dpl
0885 C0E0       576            push acc
0887 900394     576            mov dptr, #Txt_ReflTime
088A 1205BE     576            lcall ?Send_Constant_String
088D D0E0       576            pop acc
088F D082       576            pop dpl
0891 D083       576            pop dph
0893 801B       577       sjmp Draw_Time_Format
0895            578   
0895            579   ; --- Draw Line 2 (Values) ---
0895            580   Draw_Temp_Format:
0895 C0E0       581            push acc
0897 7401       581            mov a, #1
0899 14         581            dec a
089A 1205C9     581            lcall ?Set_Cursor_2 ; Select column and row
089D D0E0       581            pop acc
089F 12092E     582       lcall Get_Current_Buffer_Addr
08A2 120910     583       lcall Print_String_RAM
08A5 C0E0       584            push acc
08A7 7443       584            mov a, #'C'
08A9 120581     584            lcall ?WriteData
08AC D0E0       584            pop acc
08AE 8034       585       sjmp Restore_Cursor
08B0            586   
08B0            587   Draw_Time_Format:
08B0 C0E0       588            push acc
08B2 7401       588            mov a, #1
08B4 14         588            dec a
08B5 1205C9     588            lcall ?Set_Cursor_2 ; Select column and row
08B8 D0E0       588            pop acc
08BA 12092E     589       lcall Get_Current_Buffer_Addr
08BD            590       ; MM
08BD E6         591       mov A, @R0
08BE 120581     592       lcall ?WriteData
08C1 08         593       inc R0
08C2 E6         594       mov A, @R0
08C3 120581     595       lcall ?WriteData
08C6 08         596       inc R0
08C7            597       ; Colon
08C7 C0E0       598            push acc
08C9 743A       598            mov a, #':'
08CB 120581     598            lcall ?WriteData
08CE D0E0       598            pop acc
08D0            599       ; SS
08D0 E6         600       mov A, @R0
08D1 120581     601       lcall ?WriteData
08D4 08         602       inc R0
08D5 E6         603       mov A, @R0
08D6 120581     604       lcall ?WriteData
08D9            605       ; Unit
08D9 C0E0       606            push acc
08DB 7473       606            mov a, #'s'
08DD 120581     606            lcall ?WriteData
08E0 D0E0       606            pop acc
08E2 8000       607       sjmp Restore_Cursor
08E4            608   
08E4            609   ; --- Restore Cursor Position ---
08E4            610   Restore_Cursor:
08E4 E561       611       mov A, Current_State
08E6 B40202     612       cjne A, #2, RC_Check_State_4  
08E9 800D       613       sjmp Adjust_Cursor_Time
08EB            614   RC_Check_State_4:             
08EB B40402     615       cjne A, #4, Normal_Cursor
08EE 8008       616       sjmp Adjust_Cursor_Time
08F0            617   
08F0            618   Normal_Cursor:
08F0 E562       619       mov A, Cursor_Idx
08F2 24C0       620       add A, #0xC0
08F4 120586     621       lcall ?WriteCommand
08F7 22         622       ret
08F8            623   
08F8            624   Adjust_Cursor_Time:
08F8            625       ; Skip the colon index (2)
08F8 E562       626       mov A, Cursor_Idx
08FA B40201     627       cjne A, #2, No_Skip
08FD 04         628       inc A 
08FE            629   No_Skip:
08FE            630       ; Add 1 if past the colon
08FE C3         631       clr C
08FF 9402       632       subb A, #2
0901 4005       633       jc No_Add
0903 E562       634       mov A, Cursor_Idx
0905 04         635       inc A
0906 8002       636       sjmp Final_Cursor_Set
0908            637   No_Add:
0908 E562       638       mov A, Cursor_Idx
090A            639   Final_Cursor_Set:
090A 24C0       640       add A, #0xC0
090C 120586     641       lcall ?WriteCommand
090F 22         642       ret
0910            643   
0910            644   Print_String_RAM:
0910 E6         645       mov A, @R0
0911 6006       646       jz Print_String_Done
0913 120581     647       lcall ?WriteData
0916 08         648       inc R0
0917 80F7       649       sjmp Print_String_RAM
0919            650   Print_String_Done:
0919 22         651       ret
091A            652   
091A            653   ; --- Clear Screen with hardware delay ---
091A            654   Clear_Screen_Func:
091A 7401       655            mov a, #0x01
091C 120586     655            lcall ?WriteCommand        ; Clear display command
091F C002       656            push AR2
0921 7A02       656            mov R2, #2
0923 12053C     656            lcall ?Wait_Milli_Seconds
0926 D002       656            pop AR2     ; LCD needs ~2ms to clear
0928 740C       657            mov a, #0x0C
092A 120586     657            lcall ?WriteCommand        ; Display ON, Cursor OFF
092D 22         658       ret
092E            659   
092E            660   Get_Current_Buffer_Addr:
092E E561       661       mov A, Current_State
0930 B40103     662       cjne A, #1, Get_Buf_2
0933 7880       663       mov R0, #Buf_Soak_Temp
0935 22         664       ret
0936            665   Get_Buf_2:
0936 B40203     666       cjne A, #2, Get_Buf_3
0939 7884       667       mov R0, #Buf_Soak_Time
093B 22         668       ret
093C            669   Get_Buf_3:
093C B40303     670       cjne A, #3, Get_Buf_4
093F 7889       671       mov R0, #Buf_Refl_Temp
0941 22         672       ret
0942            673   Get_Buf_4:
0942 788D       674       mov R0, #Buf_Refl_Time
0944 22         675       ret
0945            676       
0945            677   ;---------------------------------------------------------
0945            678   PB0_DEB:
0945            679   ;non-blocking state machine for PB0 debounce
0945 E56A       680       mov a, PB0_DEB_state
0947            681   PB0_DEB_state0:
0947 B4000A     682       cjne a, #0, PB0_DEB_state1
094A 20902F     683       jb PB0, PB0_DEB_done
094D 756900     684       mov PB0_DEB_timer, #0
0950 056A       685       inc PB0_DEB_state
0952 8028       686       sjmp PB0_DEB_done
0954            687   PB0_DEB_state1:
0954 B40109     688       cjne a, #1, PB0_DEB_state2
0957            689       ; this is the debounce state
0957 E569       690       mov a, PB0_DEB_timer
0959 B43220     691       cjne a, #50, PB0_DEB_done ; 50 ms passed?
095C 056A       692       inc PB0_DEB_state
095E 801C       693       sjmp PB0_DEB_done  
0960            694   PB0_DEB_state2:
0960 B4020C     695       cjne a, #2, PB0_DEB_state3
0963 209004     696       jb PB0, PB0_DEB_state2b
0966 056A       697       inc PB0_DEB_state
0968 8012       698       sjmp PB0_DEB_done  
096A            699   PB0_DEB_state2b:
096A 756A00     700       mov PB0_DEB_state, #0
096D 800D       701       sjmp PB0_DEB_done
096F            702   PB0_DEB_state3:
096F B4030A     703       cjne a, #3, PB0_DEB_done
0972 309007     704       jnb PB0, PB0_DEB_done
0975 D214       705       setb PB0_flag ; Suscesfully detected a valid PB0 press/release
0977 B2ED       706            cpl LEDRA.5
0979 756A00     707       mov PB0_DEB_state, #0  
097C            708   PB0_DEB_done:
097C 22         709       ret
097D            710   
097D            711   PB2_DEB:
097D            712   ;non-blocking state machine for PB2 debounce
097D E56C       713       mov a, PB2_DEB_state
097F            714   PB2_DEB_state0:
097F B4000A     715       cjne a, #0, PB2_DEB_state1
0982 20B72D     716       jb PB2, PB2_DEB_done
0985 756B00     717       mov PB2_DEB_timer, #0
0988 056C       718       inc PB2_DEB_state
098A 8026       719       sjmp PB2_DEB_done
098C            720   PB2_DEB_state1:
098C B40109     721       cjne a, #1, PB2_DEB_state2
098F            722       ; this is the debounce state
098F E56B       723       mov a, PB2_DEB_timer
0991 B4321E     724       cjne a, #50, PB2_DEB_done ; 50 ms passed?
0994 056C       725       inc PB2_DEB_state
0996 801A       726       sjmp PB2_DEB_done  
0998            727   PB2_DEB_state2:
0998 B4020C     728       cjne a, #2, PB2_DEB_state3
099B 20B704     729       jb PB2, PB2_DEB_state2b
099E 056C       730       inc PB2_DEB_state
09A0 8010       731       sjmp PB2_DEB_done  
09A2            732   PB2_DEB_state2b:
09A2 756C00     733       mov PB2_DEB_state, #0
09A5 800B       734       sjmp PB2_DEB_done
09A7            735   PB2_DEB_state3:
09A7 B40308     736       cjne a, #3, PB2_DEB_done
09AA 30B705     737       jnb PB2, PB2_DEB_done
09AD D216       738       setb PB2_flag ; Suscesfully detected a valid PB2 press/release
09AF 756C00     739       mov PB2_DEB_state, #0  
09B2            740   PB2_DEB_done:
09B2 22         741       ret
09B3            742   
09B3            743   ; ------------------------------------------------------------------------------
09B3            744   ; Non-blocking FSM for the one second counter
09B3            745   ;-------------------------------------------------------------------------------
09B3            746   SEC_FSM:
09B3 E568       747       mov a, SEC_FSM_state
09B5            748   SEC_FSM_state0:
09B5 B4000C     749       cjne a, #0, SEC_FSM_state1
09B8 E567       750       mov a, SEC_FSM_timer
09BA B4FA51     751       cjne a, #250, SEC_FSM_done
09BD 756700     752       mov SEC_FSM_timer, #0
09C0 0568       753       inc SEC_FSM_state
09C2 804A       754       sjmp SEC_FSM_done
09C4            755   SEC_FSM_state1:  
09C4 B4010E     756       cjne a, #1, SEC_FSM_state2
09C7 D2E9       757       setb LEDRA.1
09C9 E567       758       mov a, SEC_FSM_timer
09CB B4FA40     759       cjne a, #250, SEC_FSM_done
09CE 756700     760       mov SEC_FSM_timer, #0
09D1 0568       761       inc SEC_FSM_state
09D3 8039       762       sjmp SEC_FSM_done
09D5            763   SEC_FSM_state2:  
09D5 B4020E     764       cjne a, #2, SEC_FSM_state3
09D8 D2EA       765       setb LEDRA.2
09DA E567       766       mov a, SEC_FSM_timer
09DC B4FA2F     767       cjne a, #250, SEC_FSM_done
09DF 756700     768       mov SEC_FSM_timer, #0
09E2 0568       769       inc SEC_FSM_state
09E4 8028       770       sjmp SEC_FSM_done
09E6            771   SEC_FSM_state3:  
09E6 B40325     772       cjne a, #3, SEC_FSM_done
09E9 D2EB       773       setb LEDRA.3
09EB E567       774       mov a, SEC_FSM_timer
09ED B4FA1E     775       cjne a, #250, SEC_FSM_done
09F0 756700     776       mov SEC_FSM_timer, #0
09F3 756800     777       mov SEC_FSM_state, #0
09F6            778       
09F6            779       ; These flags are always set (global use)
09F6 D204       780       setb one_second_lcd_flag
09F8 D201       781       setb one_second_flag
09FA            782       
09FA            783       ; Heartbeat LED always toggles
09FA B2E8       784       cpl LEDRA.0
09FC            785       
09FC            786       ; Only update time if counting is enabled
09FC 300D0F     787       jnb time_count_doing_signal, SEC_FSM_done
09FF            788       
09FF            789       ; Update current time (only when counting)
09FF E530       790       mov a, current_time_sec
0A01 04         791       inc a
0A02 B43C07     792       cjne a, #60, SEC_NoMinuteCarry
0A05 753000     793       mov current_time_sec, #0
0A08 0531       794       inc current_time_minute
0A0A 8002       795       sjmp SEC_FSM_done
0A0C            796   SEC_NoMinuteCarry:
0A0C F530       797       mov current_time_sec, a
0A0E            798   SEC_FSM_done:
0A0E 22         799       ret
0A0F            800   
0A0F            801   ; ------------------------------------------------------------------------------
0A0F            802   ; Counting the processing time 
0A0F            803   ;-------------------------------------------------------------------------------
0A0F            804   Time_Counter:
0A0F C0E0       805       push ACC
0A11 C0D0       806       push psw
0A13 E560       807       mov a, Control_FSM_state
0A15            808       
0A15            809       ; State 2: Start counting
0A15 B4020F     810       cjne a, #2, Time_Counter_Nstate2
0A18 101102     811       jbc state_change_signal_Count, Time_Counter_Start
0A1B 800F       812       sjmp Time_Counter_Done
0A1D            813   
0A1D            814   Time_Counter_Start:
0A1D 753000     815       mov current_time_sec, #0
0A20 753100     816       mov current_time_minute, #0
0A23 D20D       817       setb time_count_doing_signal
0A25 8005       818       sjmp Time_Counter_Done
0A27            819   
0A27            820   Time_Counter_Nstate2:
0A27            821       ; State 6: Stop counting
0A27 B40602     822       cjne a, #6, Time_Counter_Done
0A2A C20D       823       clr time_count_doing_signal
0A2C            824   
0A2C            825   Time_Counter_Done:
0A2C D0D0       826       pop psw
0A2E D0E0       827       pop ACC
0A30 22         828       ret
0A31            829   
0A31            830   
0A31            831   ;-------------------------------------------------------------------------------
0A31            832   ; Time_Compare_MMSS
0A31            833   ;
0A31            834   ; PURPOSE:
0A31            835   ;   Compare elapsed time (current_time_minute:current_time_sec)
0A31            836   ;   against soak and reflow setpoints (soak_time_*, reflow_time_*).
0A31            837   ;
0A31            838   ; BEHAVIOR:
0A31            839   ;   - If current_time >= soak_time   if soak_time_reached    = 1
0A31            840   ;   - If current_time >= reflow_time if reflow_time_reached = 1
0A31            841   ;
0A31            842   ; NOTES:
0A31            843   ;   Compare minutes first, then seconds.
0A31            844   ;-------------------------------------------------------------------------------
0A31            845   Time_Compare_MMSS:
0A31 C0E0       846       push acc
0A33 C0D0       847       push psw
0A35            848   
0A35 E560       849            mov a, Control_FSM_state
0A37 B4032E     850            cjne a, #3, TC_Not_Soak
0A3A            851   ; soak state time comparison
0A3A 101002     852            jbc state_change_signal_TC, TC_Soak_Start_Record
0A3D 8015       853            sjmp TC_Soak_Comparing
0A3F            854   
0A3F            855   TC_Soak_Start_Record:
0A3F E531       856            mov a, current_time_minute
0A41 2533       857            add a, soak_time_minute
0A43 F537       858            mov soak_end_time_minute, a
0A45            859   
0A45 E530       860            mov a, current_time_sec
0A47 2532       861            add a, soak_time_sec
0A49 F536       862            mov soak_end_time_sec, a
0A4B            863   
0A4B C3         864            clr c
0A4C 943C       865            subb a, #60
0A4E 4004       866            jc TC_Soak_Comparing
0A50            867   
0A50 F536       868            mov soak_end_time_sec, a
0A52 0537       869            inc soak_end_time_minute
0A54            870   
0A54            871   TC_Soak_Comparing:
0A54 E531       872       mov  a, current_time_minute
0A56 C3         873       clr  c
0A57 9537       874       subb a, soak_end_time_minute
0A59 403C       875            jc   TC_Done                   ; current_min < end_min
0A5B 7007       876       jnz  TC_Soak_Reached           ; current_min > end_min
0A5D            877   
0A5D            878       ; minutes equal -> compare seconds
0A5D E530       879       mov  a, current_time_sec
0A5F C3         880       clr  c
0A60 9536       881       subb a, soak_end_time_sec
0A62 7033       882       jnz   TC_Done
0A64            883   
0A64            884   TC_Soak_Reached:
0A64 D208       885       setb soak_time_reached
0A66 802F       886            sjmp TC_Done
0A68            887   
0A68            888   TC_Not_Soak:
0A68 E560       889            mov a, Control_FSM_state
0A6A B4052A     890            cjne a, #5, TC_Done
0A6D            891   ; soak state time comparison
0A6D 101002     892            jbc state_change_signal_TC, TC_Reflow_Start_Record
0A70 8013       893            sjmp TC_Reflow_Comparing
0A72            894   
0A72            895   TC_Reflow_Start_Record:
0A72 E531       896            mov a, current_time_minute
0A74 2535       897            add a, reflow_time_minute
0A76 F539       898            mov reflow_end_time_minute, a
0A78            899   
0A78 E530       900            mov a, current_time_sec
0A7A 2534       901            add a, reflow_time_sec
0A7C F538       902            mov reflow_end_time_sec, a
0A7E C3         903            clr c
0A7F 943C       904            subb a, #60
0A81            905   
0A81 F538       906            mov reflow_end_time_sec, a
0A83 0539       907            inc reflow_end_time_minute
0A85            908   
0A85            909   TC_Reflow_Comparing:
0A85 E531       910       mov  a, current_time_minute
0A87 C3         911       clr  c
0A88 9539       912       subb a, reflow_end_time_minute
0A8A 400B       913       jc   TC_Done
0A8C 7007       914       jnz  TC_Reflow_Reached
0A8E            915   
0A8E E530       916       mov  a, current_time_sec
0A90 C3         917       clr  c
0A91 9538       918       subb a, reflow_end_time_sec
0A93 4002       919            jc   TC_Done
0A95            920   
0A95            921   TC_Reflow_Reached:
0A95 D209       922       setb reflow_time_reached
0A97            923   
0A97            924   TC_Done:
0A97 D0D0       925       pop  psw
0A99 D0E0       926       pop  acc
0A9B 22         927       ret
0A9C            928   
0A9C            929   ;-------------------------------------------------------------------------------;
0A9C            930   ; Temp_Compare
0A9C            931   ; Checks if we have reached the user's target temperatures.
0A9C            932   ; Sets 'soak_temp_reached' if current_temp >= soak_temp
0A9C            933   ; Sets 'reflow_temp_reached' if current_temp >= reflow_temp
0A9C            934   ;-------------------------------------------------------------------------------;
0A9C            935   Temp_Compare:
0A9C            936       ; Reset flags initially
0A9C C205       937       clr soak_temp_reached
0A9E C206       938       clr reflow_temp_reached
0AA0 C207       939            clr cooling_temp_reached
0AA2            940   
0AA2 C0E0       941       push acc
0AA4 C0D0       942       push psw
0AA6 C000       943       push AR0
0AA8 C001       944       push AR1
0AAA C002       945       push AR2
0AAC            946       
0AAC            947       ; --- 1. CHECK SOAK TEMP ---
0AAC            948       ; Copy current_temp to X
0AAC 7847       949       mov R0, #current_temp
0AAE 793A       950       mov R1, #x
0AB0 120AFE     951       lcall Copy4_Bytes_R0_to_R1
0AB3            952   
0AB3            953       ; Copy soak_temp to Y
0AB3 784B       954       mov R0, #soak_temp
0AB5 793E       955       mov R1, #y
0AB7 120AFE     956       lcall Copy4_Bytes_R0_to_R1
0ABA            957   
0ABA            958       ; Compare: Is X (Current) < Y (Target)?
0ABA 12011A     959       lcall x_lt_y
0ABD 200002     960       jb mf, Check_Reflow_Threshold ; If Current < Target, jump (Flag stays 0)
0AC0            961       
0AC0            962       ; If we are here, Current >= Target
0AC0 D205       963       setb soak_temp_reached
0AC2            964   
0AC2            965   Check_Reflow_Threshold:
0AC2            966       ; --- 2. CHECK REFLOW TEMP ---
0AC2            967       ; Copy current_temp to X (Need to reload X because math32 destroys it)
0AC2 7847       968       mov R0, #current_temp
0AC4 793A       969       mov R1, #x
0AC6 120AFE     970       lcall Copy4_Bytes_R0_to_R1
0AC9            971   
0AC9            972       ; Copy reflow_temp to Y
0AC9 784F       973       mov R0, #reflow_temp
0ACB 793E       974       mov R1, #y
0ACD 120AFE     975       lcall Copy4_Bytes_R0_to_R1
0AD0            976   
0AD0            977       ; Compare
0AD0 12011A     978       lcall x_lt_y
0AD3 20001D     979       jb mf, Temp_Compare_Done
0AD6            980       
0AD6            981       ; If Current >= Target
0AD6 D206       982       setb reflow_temp_reached
0AD8            983   
0AD8            984   Check_Cooling_Threshold:
0AD8            985       ; --- 3. CHECK COOLING TEMP (< 100C) ---
0AD8 7847       986       mov R0, #current_temp
0ADA 793A       987       mov R1, #x
0ADC 120AFE     988       lcall Copy4_Bytes_R0_to_R1
0ADF            989       
0ADF 753E64     990            mov y+0, #low (100 % 0x10000) 
0AE2 753F00     990            mov y+1, #high(100 % 0x10000) 
0AE5 754000     990            mov y+2, #low (100 / 0x10000) 
0AE8 754100     990            mov y+3, #high(100 / 0x10000)                         ; Cooling target = 100C
0AEB 12011A     991       lcall x_lt_y
0AEE 300002     992       jnb mf, Temp_Compare_Done         ; If temp >= 100, not cooled yet
0AF1            993       
0AF1            994       ; If Current < 100C
0AF1 D207       995       setb cooling_temp_reached
0AF3            996   
0AF3            997   Temp_Compare_Done:
0AF3 D002       998       pop AR2
0AF5 D001       999       pop AR1
0AF7 D000      1000       pop AR0
0AF9 D0D0      1001       pop psw
0AFB D0E0      1002       pop acc
0AFD 22        1003       ret
0AFE           1004   
0AFE           1005   ;-------------------------------------------------------------------------------;
0AFE           1006   ; Copy4_Bytes_R0_to_R1
0AFE           1007   ;
0AFE           1008   ; PURPOSE:
0AFE           1009   ;   Utility routine to copy a 32-bit value (4 bytes)
0AFE           1010   ;   from one memory location to another.
0AFE           1011   ;
0AFE           1012   ; INPUTS:
0AFE           1013   ;   R0 st source address
0AFE           1014   ;   R1 at destination address
0AFE           1015   ;
0AFE           1016   ; USES:
0AFE           1017   ;   R2 as loop counter
0AFE           1018   ;
0AFE           1019   ; EXAMPLE:
0AFE           1020   ;   mov R0, #current_temp
0AFE           1021   ;   mov R1, #x
0AFE           1022   ;   lcall Copy4_Bytes_R0_to_R1
0AFE           1023   ;-------------------------------------------------------------------------------;
0AFE           1024   Copy4_Bytes_R0_to_R1:
0AFE 7A04      1025       mov  R2, #4
0B00           1026   Copy4_Loop:
0B00 E6        1027       mov  a, @R0
0B01 F7        1028       mov  @R1, a
0B02 08        1029       inc  R0
0B03 09        1030       inc  R1
0B04 DAFA      1031       djnz R2, Copy4_Loop
0B06 22        1032       ret
0B07           1033   
0B07           1034   ;-------------------------------------------------------------------------------
0B07           1035   ; PWM
0B07           1036   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0B07           1037   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0B07           1038   ; ------------------------------------------------------------------------------
0B07           1039   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0B07 100202    1040       jbc one_ms_pwm_flag, pwm_wave_generator
0B0A 8071      1041       sjmp end_pwm_generator
0B0C           1042   
0B0C           1043   pwm_wave_generator:
0B0C C200      1044       clr mf
0B0E           1045       ; move pwm counter value into x for comparison purpose
0B0E 855C3A    1046       mov x, pwm_counter
0B11 855D3B    1047       mov x+1, pwm_counter+1
0B14 855E3C    1048       mov x+2, pwm_counter+2
0B17 855F3D    1049       mov x+3, pwm_counter+3
0B1A           1050   
0B1A 753EDB    1051            mov y+0, #low (PWM_PERIOD % 0x10000) 
0B1D 753F05    1051            mov y+1, #high(PWM_PERIOD % 0x10000) 
0B20 754000    1051            mov y+2, #low (PWM_PERIOD / 0x10000) 
0B23 754100    1051            mov y+3, #high(PWM_PERIOD / 0x10000) 
0B26           1052   
0B26           1053       ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
0B26           1054       ; increase x by 1
0B26 120152    1055       lcall x_eq_y 
0B29 20001D    1056       jb mf, wrap_pwm_counter
0B2C           1057       ; x not equal 1499, increment by 1
0B2C 753E01    1058            mov y+0, #low (1 % 0x10000) 
0B2F 753F00    1058            mov y+1, #high(1 % 0x10000) 
0B32 754000    1058            mov y+2, #low (1 / 0x10000) 
0B35 754100    1058            mov y+3, #high(1 / 0x10000) 
0B38 1200D3    1059       lcall add32
0B3B           1060       ; update pwm_counter
0B3B 853A5C    1061       mov pwm_counter, x
0B3E 853B5D    1062       mov pwm_counter+1, x+1
0B41 853C5E    1063       mov pwm_counter+2, x+2
0B44 853D5F    1064       mov pwm_counter+3, x+3
0B47 8018      1065       sjmp set_pwm
0B49           1066   
0B49           1067   wrap_pwm_counter:
0B49           1068       ; x equal 1499, wrap to 0
0B49 753A00    1069            mov x+0, #low (0 % 0x10000) 
0B4C 753B00    1069            mov x+1, #high(0 % 0x10000) 
0B4F 753C00    1069            mov x+2, #low (0 / 0x10000) 
0B52 753D00    1069            mov x+3, #high(0 / 0x10000) 
0B55 853A5C    1070       mov pwm_counter, x
0B58 853B5D    1071       mov pwm_counter+1, x+1
0B5B 853C5E    1072       mov pwm_counter+2, x+2
0B5E 853D5F    1073       mov pwm_counter+3, x+3
0B61           1074   
0B61           1075   set_pwm:
0B61           1076       ; compare with power_output, if pwm counter smaller than power_output, 
0B61           1077       ; set pwm pin high; else set pwm pin low load y with power output value
0B61 85583E    1078       mov y, power_output
0B64 85593F    1079       mov y+1, power_output+1
0B67 855A40    1080       mov y+2, power_output+2
0B6A 855B41    1081       mov y+3, power_output+3
0B6D           1082   
0B6D           1083       ; compare x(pwm counter) with y(power output)
0B6D 12011A    1084       lcall x_lt_y
0B70 200006    1085       jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
0B73           1086       ;output set pwm pin low if pwm counter greater than power output
0B73 C293      1087       clr PWM_OUT
0B75 C2EC      1088       clr LEDRA.4
0B77 8004      1089       sjmp end_pwm_generator
0B79           1090   
0B79           1091   set_pwm_high:
0B79 D293      1092       setb PWM_OUT
0B7B D2EC      1093       setb LEDRA.4
0B7D           1094   
0B7D           1095   end_pwm_generator:
0B7D 22        1096       ret
0B7E           1097   
0B7E           1098   ;-------------------------------------------------------------------------------
0B7E           1099   
0B7E           1100   ;-------------------------------------------------------------------------------;
0B7E           1101   ; Abort condition safety check Temperature time
0B7E           1102   ;
0B7E           1103   ; PURPOSE:
0B7E           1104   ;   Automatic cycle termination on error:
0B7E           1105   ;   Abort if oven fails to reach at least 50C in first 60s.
0B7E           1106   ;
0B7E           1107   ; TRIP CONDITION:
0B7E           1108   ;   if (current_time >= 60s) AND (current_temp < 50C)
0B7E           1109   ;       -> set tc_missing_abort
0B7E           1110   ;       -> set stop_signal
0B7E           1111   ;
0B7E           1112   ; ASSUMPTIONS:
0B7E           1113   ;   - current_time is in SECONDS (32-bit, little-endian)
0B7E           1114   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
0B7E           1115   ;
0B7E           1116   ;   the Load_Y constants accordingly.
0B7E           1117   ;-------------------------------------------------------------------------------;
0B7E           1118   Safety_Check_TC:
0B7E C0E0      1119       push acc
0B80 C0D0      1120       push psw
0B82 C000      1121       push AR0
0B84 C001      1122       push AR1
0B86 C002      1123       push AR2
0B88           1124   
0B88           1125       ; If already aborted or startup window closed, do nothing
0B88 20122F    1126       jb   tc_missing_abort, Safety_TC_Done
0B8B 30132C    1127       jnb  tc_startup_window, Safety_TC_Done
0B8E           1128   
0B8E           1129       ; Check: elapsed >= 60 seconds ?
0B8E E531      1130       mov  a, current_time_minute
0B90 7007      1131       jnz  Safety_TC_At60          ; if minute >= 1, definitely >=60s
0B92           1132   
0B92 E530      1133       mov  a, current_time_sec
0B94 C3        1134       clr  c
0B95 943C      1135       subb a, #60
0B97 4021      1136       jc   Safety_TC_Done          ; still < 60s
0B99           1137   
0B99           1138   Safety_TC_At60:
0B99           1139   
0B99           1140       ; We reached 60s: close the startup window so it won't re-check later
0B99 C213      1141       clr  tc_startup_window
0B9B           1142   
0B9B           1143       ; Now check: current_temp < 50 ?
0B9B 7847      1144       mov  R0, #current_temp
0B9D 793A      1145       mov  R1, #x
0B9F 120AFE    1146       lcall Copy4_Bytes_R0_to_R1
0BA2           1147   
0BA2 753E32    1148            mov y+0, #low (50 % 0x10000) 
0BA5 753F00    1148            mov y+1, #high(50 % 0x10000) 
0BA8 754000    1148            mov y+2, #low (50 / 0x10000) 
0BAB 754100    1148            mov y+3, #high(50 / 0x10000) 
0BAE 12011A    1149       lcall x_lt_y
0BB1 300006    1150       jnb  mf, Safety_TC_Done        ; temp >= 50  pass
0BB4           1151   
0BB4           1152       ; FAIL: at 60s, still below 50C  abort
0BB4 D212      1153       setb tc_missing_abort
0BB6 D20B      1154       setb stop_signal
0BB8 C293      1155       clr  PWM_OUT
0BBA           1156   
0BBA           1157   Safety_TC_Done:
0BBA D002      1158       pop  AR2
0BBC D001      1159       pop  AR1
0BBE D000      1160       pop  AR0
0BC0 D0D0      1161       pop  psw
0BC2 D0E0      1162       pop  acc
0BC4 22        1163       ret
0BC5           1164   
0BC5           1165   ;-------------------------------------------------------------------------------;
0BC5           1166   ; Main Control FSM for the entire process
0BC5           1167   ;-------------------------------------------------------------------------------;
0BC5           1168   ;-------------------------------------------------------------------------------;
0BC5           1169   ; FSM LOGIC (Button Logic Fixed)
0BC5           1170   ;-------------------------------------------------------------------------------;
0BC5           1171   Control_FSM:
0BC5 E560      1172       mov a, Control_FSM_state
0BC7 8008      1173       sjmp Control_FSM_state0
0BC9           1174   
0BC9           1175   Control_FSM_state0_a:
0BC9 756000    1176            mov Control_FSM_state, #0
0BCC D20F      1177            setb state_change_signal
0BCE D210      1178            setb state_change_signal_TC
0BD0 22        1179            ret
0BD1           1180   Control_FSM_state0:
0BD1 B40013    1181       cjne a, #0, Control_FSM_state1
0BD4 301404    1182       jnb PB0_flag, Control_FSM_state0_ret  ; Check flag
0BD7 C214      1183       clr PB0_flag                 
0BD9 8001      1184       sjmp Control_FSM_state1_a
0BDB           1185   Control_FSM_state0_ret:
0BDB 22        1186       ret
0BDC           1187   
0BDC           1188   Control_FSM_state1_a:
0BDC 756001    1189       mov Control_FSM_state, #1
0BDF 756100    1190       mov Current_State, #0
0BE2 D20F      1191       setb state_change_signal
0BE4 D210      1192            setb state_change_signal_TC
0BE6 22        1193            ret
0BE7           1194   Control_FSM_state1:
0BE7 B40112    1195       cjne a, #1, Control_FSM_state2
0BEA 301404    1196       jnb PB0_flag, Control_FSM_state1_ret  ; Check flag
0BED C214      1197       clr PB0_flag                    
0BEF 8001      1198       sjmp Control_FSM_state2_a
0BF1           1199   Control_FSM_state1_ret:
0BF1 22        1200       ret
0BF2           1201   
0BF2           1202   ; --- STATE 2: RAMP TO SOAK ---
0BF2           1203   Control_FSM_state2_a:
0BF2 756002    1204            mov Control_FSM_state, #2
0BF5 D20F      1205            setb state_change_signal
0BF7 D210      1206            setb state_change_signal_TC
0BF9 D211      1207            setb state_change_signal_Count
0BFB 22        1208            ret
0BFC           1209   Control_FSM_state2:
0BFC B4021D    1210       cjne a, #2, Control_FSM_state3
0BFF 301605    1211       jnb PB2_flag, State2_Check
0C02 C216      1212       clr PB2_flag
0C04 020C69    1213       ljmp Control_FSM_state6_a ; Pause
0C07           1214   State2_Check:
0C07 120A9C    1215            lcall Temp_Compare
0C0A 300506    1216       jnb soak_temp_reached, State2_Ret
0C0D C205      1217       clr soak_temp_reached
0C0F C208      1218       clr soak_time_reached
0C11 8001      1219            sjmp Control_FSM_state3_a
0C13           1220   State2_Ret:
0C13 22        1221       ret
0C14           1222   
0C14           1223   ; --- STATE 3: SOAK PHASE ---
0C14           1224   Control_FSM_state3_a:
0C14 756003    1225            mov Control_FSM_state, #3
0C17 D20F      1226            setb state_change_signal
0C19 D210      1227            setb state_change_signal_TC
0C1B 22        1228            ret
0C1C           1229   Control_FSM_state3:
0C1C B40318    1230       cjne a, #3, Control_FSM_state4
0C1F 301605    1231       jnb PB2_flag, State3_Check
0C22 C216      1232       clr PB2_flag
0C24 020C69    1233       ljmp Control_FSM_state6_a
0C27           1234   State3_Check:
0C27 300804    1235       jnb soak_time_reached, State3_Ret
0C2A C208      1236       clr soak_time_reached
0C2C 8001      1237       sjmp Control_FSM_state4_a
0C2E           1238   State3_Ret:
0C2E 22        1239       ret
0C2F           1240   
0C2F           1241   ; --- STATE 4: RAMP TO PEAK ---
0C2F           1242   Control_FSM_state4_a:
0C2F 756004    1243            mov Control_FSM_state, #4
0C32 D20F      1244            setb state_change_signal
0C34 D210      1245            setb state_change_signal_TC
0C36 22        1246            ret
0C37           1247   Control_FSM_state4:
0C37 B4041D    1248       cjne a, #4, Control_FSM_state5
0C3A 301605    1249       jnb PB2_flag, State4_Check
0C3D C216      1250       clr PB2_flag
0C3F 020C69    1251       ljmp Control_FSM_state6_a
0C42           1252   State4_Check:
0C42 120A9C    1253            lcall Temp_Compare
0C45 300606    1254       jnb reflow_temp_reached, State4_Ret
0C48 C206      1255       clr reflow_temp_reached
0C4A C209      1256       clr reflow_time_reached
0C4C 8001      1257            sjmp Control_FSM_state5_a
0C4E           1258   State4_Ret:
0C4E 22        1259       ret
0C4F           1260   
0C4F           1261   ; --- STATE 5: REFLOW PHASE ---
0C4F           1262   Control_FSM_state5_a:
0C4F 756005    1263            mov Control_FSM_state, #5
0C52 D20F      1264            setb state_change_signal
0C54 D210      1265            setb state_change_signal_TC
0C56 22        1266            ret
0C57           1267   Control_FSM_state5:
0C57 B40519    1268       cjne a, #5, Control_FSM_state6
0C5A 301604    1269       jnb PB2_flag, State5_Check
0C5D C216      1270       clr PB2_flag
0C5F 8008      1271       sjmp Control_FSM_state6_a
0C61           1272   State5_Check:
0C61 300904    1273       jnb reflow_time_reached, State5_Ret
0C64 C209      1274       clr reflow_time_reached
0C66 8001      1275       sjmp Control_FSM_state6_a
0C68           1276   State5_Ret:
0C68 22        1277       ret
0C69           1278   
0C69           1279   ; --- STATE 6: COOLING ---
0C69           1280   Control_FSM_state6_a:
0C69 756006    1281            mov Control_FSM_state, #6
0C6C D20F      1282            setb state_change_signal
0C6E D210      1283            setb state_change_signal_TC
0C70 D211      1284            setb state_change_signal_Count
0C72 22        1285            ret
0C73           1286   Control_FSM_state6:
0C73 B40613    1287       cjne a, #6, Control_FSM_state7
0C76           1288       ; Wait for Cooling Temp Reached
0C76 120A9C    1289            lcall Temp_Compare
0C79 300704    1290       jnb cooling_temp_reached, State6_Ret
0C7C C207      1291       clr cooling_temp_reached
0C7E 8001      1292       sjmp Control_FSM_state7_a
0C80           1293   State6_Ret:
0C80 22        1294       ret
0C81           1295   
0C81           1296   ; --- STATE 7: DONE ---
0C81           1297   Control_FSM_state7_a:
0C81 756007    1298            mov Control_FSM_state, #7
0C84 D20F      1299            setb state_change_signal
0C86 D210      1300            setb state_change_signal_TC
0C88 22        1301            ret
0C89           1302   Control_FSM_state7:
0C89 B40708    1303       cjne a, #7, Control_FSM_done
0C8C           1304       ; Let's assume you meant the physical button P1.0 like State 0
0C8C 101402    1305       jbc PB0_flag, Control_FSM_state7_pressed
0C8F 8003      1306            sjmp Control_FSM_done
0C91           1307   Control_FSM_state7_pressed:
0C91 020BC9    1308       ljmp Control_FSM_state0_a
0C94           1309   
0C94           1310   Control_FSM_done:
0C94 22        1311       ret
0C95           1312   
0C95           1313   ; ================================================================
0C95           1314   ; UI & HELPER SUBROUTINES
0C95           1315   ; ================================================================
0C95           1316   
0C95           1317   ; ----------------------------------------------------------------
0C95           1318   ; MODULE: BRIDGE (Text to Integer Conversion)
0C95           1319   ; ----------------------------------------------------------------
0C95           1320   
0C95           1321   ;--------------------------
0C95           1322   ;keep updating varaibles
0C95           1323   Update_FSM_Variables:
0C95 C0E0      1324            push ACC
0C97 C006      1325            push AR6
0C99 C007      1326            push AR7
0C9B E560      1327            mov a, Control_FSM_state
0C9D B40132    1328            cjne a, #1, Update_FSM_Variables_done
0CA0           1329   
0CA0           1330       ; --- 1. SOAK TEMP ---
0CA0 7880      1331       mov R0, #Buf_Soak_Temp
0CA2 120CD9    1332       lcall Parse_Temp_String
0CA5 8F4B      1333       mov soak_temp+0, R7
0CA7 754C00    1334       mov soak_temp+1, #0
0CAA 754D00    1335       mov soak_temp+2, #0
0CAD 754E00    1336       mov soak_temp+3, #0
0CB0           1337   
0CB0           1338       ; --- 2. REFLOW TEMP ---
0CB0 7889      1339       mov R0, #Buf_Refl_Temp
0CB2 120CD9    1340       lcall Parse_Temp_String
0CB5 8F4F      1341       mov reflow_temp+0, R7
0CB7 755000    1342       mov reflow_temp+1, #0
0CBA 755100    1343       mov reflow_temp+2, #0
0CBD 755200    1344       mov reflow_temp+3, #0
0CC0           1345   
0CC0           1346       ; --- 3. SOAK TIME ---
0CC0 7884      1347       mov R0, #Buf_Soak_Time
0CC2 120CED    1348       lcall Parse_Time_String
0CC5 8F33      1349       mov soak_time_minute, R7
0CC7 8E32      1350       mov soak_time_sec, R6
0CC9           1351   
0CC9           1352       ; --- 4. REFLOW TIME ---
0CC9 788D      1353       mov R0, #Buf_Refl_Time
0CCB 120CED    1354       lcall Parse_Time_String
0CCE 8F35      1355       mov reflow_time_minute, R7
0CD0 8E34      1356       mov reflow_time_sec, R6
0CD2           1357   
0CD2           1358   Update_FSM_Variables_done:
0CD2 D007      1359            pop AR7
0CD4 D006      1360            pop AR6
0CD6 D0E0      1361            pop ACC
0CD8 22        1362       ret
0CD9           1363   ;--------------------------
0CD9           1364   
0CD9           1365   ; --- Helper: Parse "123" to Integer ---
0CD9           1366   Parse_Temp_String:
0CD9 7F00      1367       mov R7, #0              ; Clear Result
0CDB           1368   Parse_Temp_Loop:
0CDB E6        1369       mov A, @R0
0CDC 600E      1370       jz Parse_Temp_Done      ; If Null, we are done
0CDE           1371       
0CDE           1372       ; Convert ASCII to Digit
0CDE C3        1373       clr C
0CDF 9430      1374       subb A, #0x30
0CE1 FD        1375       mov R5, A               ; R5 = New Digit
0CE2           1376       
0CE2           1377       ; Result = (Result * 10) + New Digit
0CE2 EF        1378       mov A, R7
0CE3 75F00A    1379       mov B, #10
0CE6 A4        1380       mul AB
0CE7 2D        1381       add A, R5
0CE8 FF        1382       mov R7, A
0CE9           1383       
0CE9 08        1384       inc R0
0CEA 80EF      1385       sjmp Parse_Temp_Loop
0CEC           1386   Parse_Temp_Done:
0CEC 22        1387       ret
0CED           1388   
0CED           1389   ; --- Helper: Parse "MMSS" to Seconds ---
0CED           1390   Parse_Time_String:
0CED           1391       ; Minutes tens
0CED E6        1392       mov A, @R0
0CEE C3        1393       clr C
0CEF 9430      1394       subb A, #0x30
0CF1 75F00A    1395       mov B, #10
0CF4 A4        1396       mul AB
0CF5 FD        1397       mov R5, A
0CF6 08        1398       inc R0
0CF7           1399   
0CF7           1400       ; Minutes ones
0CF7 E6        1401       mov A, @R0
0CF8 C3        1402       clr C
0CF9 9430      1403       subb A, #0x30
0CFB 2D        1404       add A, R5
0CFC FD        1405       mov R5, A
0CFD 08        1406       inc R0
0CFE           1407   
0CFE           1408       ; Seconds tens
0CFE E6        1409       mov A, @R0
0CFF C3        1410       clr C
0D00 9430      1411       subb A, #0x30
0D02 75F00A    1412       mov B, #10
0D05 A4        1413       mul AB
0D06 FC        1414       mov R4, A
0D07 08        1415       inc R0
0D08           1416   
0D08           1417       ; Seconds ones
0D08 E6        1418       mov A, @R0
0D09 C3        1419       clr C
0D0A 9430      1420       subb A, #0x30
0D0C 2C        1421       add A, R4
0D0D FC        1422       mov R4, A
0D0E           1423   
0D0E           1424       ; Return minutes/seconds
0D0E ED        1425            mov a, R5
0D0F FF        1426       mov R7, a     ; minutes
0D10 EC        1427            mov a, R4
0D11 FE        1428       mov R6, a     ; seconds
0D12 22        1429       ret
0D13           1430   
0D13           1431   ; ----------------------------------------------------------------
0D13           1432   ; MODULE: BUTTON HANDLER (Mode Selection)
0D13           1433   ; ----------------------------------------------------------------
0D13           1434   ; Blocking wrapper for LCD clear (keeps old behavior just for this)
0D13           1435   Wait_25ms_BLOCKING:
0D13 120E88    1436       lcall Wait_25ms
0D16 50FB      1437       jnc Wait_25ms_BLOCKING ; Keep jumping back until Done (C=1)
0D18 22        1438       ret
0D19           1439   
0D19           1440   Check_Buttons:
0D19 C0E0      1441            push ACC
0D1B E560      1442            mov a, Control_FSM_state
0D1D B4014C    1443            cjne a, #1, Check_Buttons_ret
0D20           1444   
0D20           1445       ; --- FORCE INPUT MODE ---
0D20           1446       ; This clears any '0' the LCD library might have written to our buttons
0D20 438055    1447       orl P0, #055H   ; Sets P0.0, P0.2, P0.4, and P0.6 to '1' (Input Mode)
0D23           1448       ; ------------------------
0D23           1449   
0D23 30800C    1450       jnb BTN_SOAK_TEMP, Btn_Soak_Temp_Press
0D26 308214    1451       jnb BTN_SOAK_TIME, Btn_Soak_Time_Press
0D29 30841C    1452       jnb BTN_REFL_TEMP, Btn_Refl_Temp_Press
0D2C 308624    1453       jnb BTN_REFL_TIME, Btn_Refl_Time_Press
0D2F           1454   
0D2F D0E0      1455            pop ACC
0D31 22        1456       ret
0D32           1457   
0D32           1458   Btn_Soak_Temp_Press:
0D32 120D13    1459       lcall Wait_25ms_BLOCKING
0D35 756101    1460       mov Current_State, #1
0D38 756200    1461       mov Cursor_Idx, #0
0D3B 8021      1462       sjmp Redraw_Screen
0D3D           1463   
0D3D           1464   Btn_Soak_Time_Press:
0D3D 120D13    1465       lcall Wait_25ms_BLOCKING
0D40 756102    1466       mov Current_State, #2
0D43 756200    1467       mov Cursor_Idx, #0
0D46 8016      1468       sjmp Redraw_Screen
0D48           1469   
0D48           1470   Btn_Refl_Temp_Press:
0D48 120D13    1471       lcall Wait_25ms_BLOCKING
0D4B 756103    1472       mov Current_State, #3
0D4E 756200    1473       mov Cursor_Idx, #0
0D51 800B      1474       sjmp Redraw_Screen
0D53           1475   
0D53           1476   Btn_Refl_Time_Press:
0D53 120D13    1477       lcall Wait_25ms_BLOCKING 
0D56 756104    1478       mov Current_State, #4
0D59 756200    1479       mov Cursor_Idx, #0
0D5C 8000      1480       sjmp Redraw_Screen
0D5E           1481   
0D5E           1482   Redraw_Screen:
0D5E           1483       ; Wait for button release
0D5E 3080FD    1484       jnb BTN_SOAK_TEMP, $
0D61 3082FD    1485       jnb BTN_SOAK_TIME, $
0D64 3084FD    1486       jnb BTN_REFL_TEMP, $
0D67 3086FD    1487       jnb BTN_REFL_TIME, $
0D6A           1488   
0D6A D221      1489       setb fullscreen_update_signal
0D6C           1490   Check_Buttons_ret:
0D6C D0E0      1491       pop ACC
0D6E 22        1492       ret
0D6F           1493   
0D6F           1494   ; ----------------------------------------------------------------
0D6F           1495   ; MODULE: KEYPAD HANDLER (Input Logic)
0D6F           1496   ; ----------------------------------------------------------------
0D6F           1497   Check_Keypad:
0D6F E560      1498       mov a, Control_FSM_state
0D71 B40152    1499       cjne a, #1, Keypad_Exit
0D74           1500   
0D74           1501       ; If State is 0 (Home), ignore keypad
0D74 E561      1502       mov A, Current_State
0D76 604E      1503       jz Keypad_Exit
0D78           1504       
0D78 120DC7    1505       lcall Keypad_Scan
0D7B 5049      1506       jnc Keypad_Exit         ; Carry = 0 means no key pressed
0D7D           1507   
0D7D           1508       ; --- Check Special Keys ---
0D7D EF        1509       mov A, R7
0D7E B40E09    1510       cjne A, #14, Check_Hash ; 14 is Star (*)
0D81           1511       
0D81           1512       ; Star Key Pressed: Reset Buffer
0D81 120ECB    1513       lcall Reset_Current_Buffer
0D84 D221      1514       setb fullscreen_update_signal
0D86 756200    1515       mov Cursor_Idx, #0
0D89 22        1516       ret
0D8A           1517   
0D8A           1518   Check_Hash:
0D8A EF        1519       mov A, R7
0D8B B40C01    1520       cjne A, #12, Check_Numeric ; 12 is Hash (#)
0D8E 22        1521       ret                     ; Ignore Hash key
0D8F           1522   
0D8F           1523   Check_Numeric:
0D8F           1524       ; Ensure key is 0-9
0D8F EF        1525       mov A, R7
0D90 C3        1526       clr C
0D91 940A      1527       subb A, #10
0D93 5030      1528       jnc Symbol_Key_Ignored
0D95           1529       
0D95           1530       ; Convert to ASCII
0D95 EF        1531       mov A, R7
0D96 2430      1532       add A, #0x30
0D98 FD        1533       mov R5, A
0D99           1534   
0D99           1535       ; Save to Buffer
0D99 12092E    1536       lcall Get_Current_Buffer_Addr
0D9C E562      1537       mov A, Cursor_Idx
0D9E 28        1538       add A, R0
0D9F F8        1539       mov R0, A
0DA0 ED        1540       mov A, R5
0DA1 F6        1541       mov @R0, A
0DA2 0562      1542       inc Cursor_Idx
0DA4           1543   
0DA4           1544       ; --- Check Cursor Limits ---
0DA4 E561      1545       mov A, Current_State
0DA6 B40102    1546       cjne A, #1, Check_Limit_Time_1
0DA9 8005      1547       sjmp Limit_Temp_3
0DAB           1548   
0DAB           1549   Check_Limit_Time_1:
0DAB B4030B    1550       cjne A, #3, Limit_Time_4
0DAE 8000      1551       sjmp Limit_Temp_3
0DB0           1552   
0DB0           1553   Limit_Temp_3:
0DB0 E562      1554       mov A, Cursor_Idx
0DB2 B4030D    1555       cjne A, #3, Do_Refresh
0DB5 1562      1556       dec Cursor_Idx          ; Stay at last digit
0DB7 8009      1557       sjmp Do_Refresh
0DB9           1558   
0DB9           1559   Limit_Time_4:
0DB9 E562      1560       mov A, Cursor_Idx
0DBB B40404    1561       cjne A, #4, Do_Refresh
0DBE 1562      1562       dec Cursor_Idx          ; Stay at last digit
0DC0 8000      1563       sjmp Do_Refresh
0DC2           1564   
0DC2           1565   Do_Refresh:
0DC2 D221      1566       setb fullscreen_update_signal
0DC4 22        1567       ret
0DC5           1568   
0DC5           1569   Symbol_Key_Ignored:
0DC5 22        1570       ret
0DC6           1571   Keypad_Exit:
0DC6 22        1572       ret
0DC7           1573   
0DC7           1574   ; ----------------------------------------------------------------
0DC7           1575   ; MODULE: HARDWARE SCANNER (Matrix Logic)
0DC7           1576   ; ----------------------------------------------------------------
0DC7           1577   Keypad_Scan:
0DC7           1578       ; Step 1: Check if ANY key is pressed (All Rows Low)
0DC7 C292      1579       clr ROW1
0DC9 C294      1580       clr ROW2
0DCB C296      1581       clr ROW3
0DCD C2A0      1582       clr ROW4
0DCF A2A2      1583       mov C, COL1
0DD1 82A4      1584       anl C, COL2
0DD3 82A6      1585       anl C, COL3
0DD5 82B0      1586       anl C, COL4
0DD7 5002      1587       jnc Keypad_Debounce
0DD9 C3        1588       clr C
0DDA 22        1589       ret
0DDB           1590   
0DDB           1591   Keypad_Debounce:
0DDB 120D13    1592       lcall Wait_25ms_BLOCKING
0DDE A2A2      1593       mov C, COL1
0DE0 82A4      1594       anl C, COL2
0DE2 82A6      1595       anl C, COL3
0DE4 82B0      1596       anl C, COL4
0DE6 5002      1597       jnc Keypad_Find_Row
0DE8 C3        1598       clr C
0DE9 22        1599       ret
0DEA           1600   
0DEA           1601   Keypad_Find_Row:
0DEA D292      1602       setb ROW1
0DEC D294      1603       setb ROW2
0DEE D296      1604       setb ROW3
0DF0 D2A0      1605       setb ROW4
0DF2           1606   
0DF2           1607       ; Row 1
0DF2 C292      1608       clr ROW1
0DF4 30A23D    1609       jnb COL1, Keypad_Key_1
0DF7 30A43E    1610       jnb COL2, Keypad_Key_2
0DFA 30A63F    1611       jnb COL3, Keypad_Key_3
0DFD 30B040    1612       jnb COL4, Keypad_Key_A
0E00 D292      1613       setb ROW1
0E02           1614   
0E02           1615       ; Row 2
0E02 C294      1616       clr ROW2
0E04 30A23D    1617       jnb COL1, Keypad_Key_4
0E07 30A43E    1618       jnb COL2, Keypad_Key_5
0E0A 30A63F    1619       jnb COL3, Keypad_Key_6
0E0D 30B040    1620       jnb COL4, Keypad_Key_B
0E10 D294      1621       setb ROW2
0E12           1622   
0E12           1623       ; Row 3
0E12 C296      1624       clr ROW3
0E14 30A23D    1625       jnb COL1, Keypad_Key_7
0E17 30A43E    1626       jnb COL2, Keypad_Key_8
0E1A 30A63F    1627       jnb COL3, Keypad_Key_9
0E1D 30B040    1628       jnb COL4, Keypad_Key_C
0E20 D296      1629       setb ROW3
0E22           1630   
0E22           1631       ; Row 4
0E22 C2A0      1632       clr ROW4
0E24 30A23D    1633       jnb COL1, Keypad_Key_Star
0E27 30A43E    1634       jnb COL2, Keypad_Key_0
0E2A 30A63F    1635       jnb COL3, Keypad_Key_Hash
0E2D 30B040    1636       jnb COL4, Keypad_Key_D
0E30 D2A0      1637       setb ROW4
0E32 C3        1638       clr C
0E33 22        1639       ret
0E34           1640   
0E34           1641   ; Key Mapping (Renamed to avoid conflicts)
0E34 7F01      1642   Keypad_Key_1: mov R7, #1
0E36 803C      1643          sjmp Wait_Release
0E38 7F02      1644   Keypad_Key_2: mov R7, #2
0E3A 8038      1645          sjmp Wait_Release
0E3C 7F03      1646   Keypad_Key_3: mov R7, #3
0E3E 8034      1647          sjmp Wait_Release
0E40 7F0A      1648   Keypad_Key_A: mov R7, #10
0E42 8030      1649          sjmp Wait_Release
0E44 7F04      1650   Keypad_Key_4: mov R7, #4
0E46 802C      1651          sjmp Wait_Release
0E48 7F05      1652   Keypad_Key_5: mov R7, #5
0E4A 8028      1653          sjmp Wait_Release
0E4C 7F06      1654   Keypad_Key_6: mov R7, #6
0E4E 8024      1655          sjmp Wait_Release
0E50 7F0B      1656   Keypad_Key_B: mov R7, #11
0E52 8020      1657          sjmp Wait_Release
0E54 7F07      1658   Keypad_Key_7: mov R7, #7
0E56 801C      1659          sjmp Wait_Release
0E58 7F08      1660   Keypad_Key_8: mov R7, #8
0E5A 8018      1661          sjmp Wait_Release
0E5C 7F09      1662   Keypad_Key_9: mov R7, #9
0E5E 8014      1663          sjmp Wait_Release
0E60 7F0D      1664   Keypad_Key_C: mov R7, #13
0E62 8010      1665          sjmp Wait_Release
0E64 7F0E      1666   Keypad_Key_Star: mov R7, #14
0E66 800C      1667          sjmp Wait_Release
0E68 7F00      1668   Keypad_Key_0: mov R7, #0
0E6A 8008      1669          sjmp Wait_Release
0E6C 7F0C      1670   Keypad_Key_Hash: mov R7, #12
0E6E 8004      1671          sjmp Wait_Release
0E70 7F0F      1672   Keypad_Key_D: mov R7, #15
0E72 8000      1673          sjmp Wait_Release
0E74           1674   
0E74           1675   Wait_Release:
0E74 A2A2      1676       mov C, COL1
0E76 82A4      1677       anl C, COL2
0E78 82A6      1678       anl C, COL3
0E7A 82B0      1679       anl C, COL4
0E7C 50F6      1680       jnc Wait_Release
0E7E D3        1681       setb C
0E7F D292      1682       setb ROW1
0E81 D294      1683       setb ROW2
0E83 D296      1684       setb ROW3
0E85 D2A0      1685       setb ROW4
0E87 22        1686       ret
0E88           1687   
0E88           1688   Wait_25ms:
0E88           1689       ; 1. Check if we are already waiting
0E88 20170E    1690       jb wait25_active, Check_Timer_Status
0E8B           1691       
0E8B           1692       ; 2. Check if we just finished
0E8B 301804    1693       jnb wait25_done, Start_New_Timer
0E8E           1694       
0E8E           1695       ; 3. Timer is DONE! Reset flags and return True
0E8E C218      1696       clr wait25_done
0E90 D3        1697       setb C          ; Carry = 1 means "Done"
0E91 22        1698       ret
0E92           1699   
0E92           1700   Start_New_Timer:
0E92           1701       ; 4. Start a new 25ms wait
0E92 755700    1702       mov wait25_count, #0
0E95 D217      1703       setb wait25_active
0E97 C3        1704       clr C           ; Carry = 0 means "Not Done Yet"
0E98 22        1705       ret
0E99           1706   
0E99           1707   Check_Timer_Status:
0E99           1708       ; 5. Still waiting... return False immediately
0E99 C3        1709       clr C           ; Carry = 0 means "Not Done Yet"
0E9A 22        1710       ret
0E9B           1711   
0E9B           1712   ; ----------------------------------------------------------------
0E9B           1713   ; MODULE: BUFFER INIT (Reset Logic)
0E9B           1714   ; ----------------------------------------------------------------
0E9B           1715   Init_All_Buffers:
0E9B 7880      1716       mov R0, #Buf_Soak_Temp
0E9D 120EB0    1717       lcall Init_Temp_Template
0EA0 7889      1718       mov R0, #Buf_Refl_Temp
0EA2 120EB0    1719       lcall Init_Temp_Template
0EA5 7884      1720       mov R0, #Buf_Soak_Time
0EA7 120EBC    1721       lcall Init_Time_Template
0EAA 788D      1722       mov R0, #Buf_Refl_Time
0EAC 120EBC    1723       lcall Init_Time_Template
0EAF 22        1724       ret
0EB0           1725   
0EB0           1726   Init_Temp_Template:
0EB0 7630      1727       mov @R0, #'0'
0EB2 08        1728       inc R0
0EB3 7630      1729       mov @R0, #'0'
0EB5 08        1730       inc R0
0EB6 7630      1731       mov @R0, #'0'
0EB8 08        1732       inc R0
0EB9 7600      1733       mov @R0, #0
0EBB 22        1734       ret
0EBC           1735   
0EBC           1736   Init_Time_Template:
0EBC 7630      1737       mov @R0, #'0'
0EBE 08        1738       inc R0
0EBF 7630      1739       mov @R0, #'0'
0EC1 08        1740       inc R0
0EC2 7630      1741       mov @R0, #'0'
0EC4 08        1742       inc R0
0EC5 7630      1743       mov @R0, #'0'
0EC7 08        1744       inc R0
0EC8 7600      1745       mov @R0, #0
0ECA 22        1746       ret
0ECB           1747   
0ECB           1748   Reset_Current_Buffer:
0ECB E561      1749       mov A, Current_State
0ECD B40106    1750       cjne A, #1, Reset_Chk_2
0ED0 7880      1751       mov R0, #Buf_Soak_Temp
0ED2 120EB0    1752       lcall Init_Temp_Template
0ED5 22        1753       ret
0ED6           1754   Reset_Chk_2:
0ED6 B40206    1755       cjne A, #2, Reset_Chk_3
0ED9 7884      1756       mov R0, #Buf_Soak_Time
0EDB 120EBC    1757       lcall Init_Time_Template
0EDE 22        1758       ret
0EDF           1759   Reset_Chk_3:
0EDF B40306    1760       cjne A, #3, Reset_Chk_4
0EE2 7889      1761       mov R0, #Buf_Refl_Temp
0EE4 120EB0    1762       lcall Init_Temp_Template
0EE7 22        1763       ret
0EE8           1764   Reset_Chk_4:
0EE8 788D      1765       mov R0, #Buf_Refl_Time
0EEA 120EBC    1766       lcall Init_Time_Template
0EED 22        1767       ret 
0EEE           1768       
0EEE           1769   ; ================================================================
0EEE           1770   ; MODULE: THERMOCOUPLE ADC DRIVER
0EEE           1771   ; ================================================================
0EEE           1772   Read_Thermocouple:
0EEE           1773       ; 1. Check Non-Blocking Timer (Run once every 25ms)
0EEE 120E88    1774       lcall Wait_25ms
0EF1 5059      1775       jnc Read_TC_Exit ; If 25ms hasn't passed, exit immediately
0EF3           1776       
0EF3           1777       ; --- 25ms Passed! Time to Read ---
0EF3           1778       
0EF3           1779       ; 2. Initialize / Trigger ADC
0EF3           1780       ; Writing to ADC_C (0xA1) triggers the conversion
0EF3 75A180    1781       mov ADC_C, #0x80    ; Reset / Strobe
0EF6 00        1782       nop
0EF7 00        1783       nop
0EF8 75A100    1784       mov ADC_C, #0x00    ; Select Channel 0 (ADCINPUT 0) and Start
0EFB           1785       
0EFB           1786       ; 3. [FIX] Settle Delay
0EFB           1787       ; The DE10-Lite ADC bridge needs time to fetch data from the MAX10 chip.
0EFB           1788       ; We burn ~500 cycles to be absolutely safe.
0EFB 7DFA      1789       mov R5, #250
0EFD           1790   ADC_Settle_Loop:
0EFD 00        1791       nop
0EFE 00        1792       nop
0EFF DDFC      1793       djnz R5, ADC_Settle_Loop
0F01           1794       
0F01           1795       ; 4. Read Raw Data
0F01 85A23A    1796       mov x+0, ADC_L      ; Read Low Byte (0xA2)
0F04 85A33B    1797       mov x+1, ADC_H      ; Read High Byte (0xA3)
0F07 753C00    1798       mov x+2, #0
0F0A 753D00    1799       mov x+3, #0
0F0D           1800       
0F0D           1801       ; 5. [FIX] Mask the 12-bit Data
0F0D           1802       ; The ADC is 12-bit. We MUST zero out the upper 4 bits of the High Byte
0F0D           1803       ; or the math below will overflow and return 0.
0F0D E53B      1804       mov a, x+1
0F0F 540F      1805       anl a, #0x0F
0F11 F53B      1806       mov x+1, a
0F13           1807       
0F13           1808       ; 6. Convert to Voltage (Count * 5000 / 4095)
0F13 753E88    1809            mov y+0, #low (5000 % 0x10000) 
0F16 753F13    1809            mov y+1, #high(5000 % 0x10000) 
0F19 754000    1809            mov y+2, #low (5000 / 0x10000) 
0F1C 754100    1809            mov y+3, #high(5000 / 0x10000)         ; Vref = 5000mV
0F1F 12018C    1810       lcall mul32         
0F22           1811       
0F22 753EFF    1812            mov y+0, #low (4095 % 0x10000) 
0F25 753F0F    1812            mov y+1, #high(4095 % 0x10000) 
0F28 754000    1812            mov y+2, #low (4095 / 0x10000) 
0F2B 754100    1812            mov y+3, #high(4095 / 0x10000)         ; 12-bit resolution
0F2E 120280    1813       lcall div32         
0F31           1814       
0F31           1815       ; 7. Convert to Temp (Voltage / 10mV) -> e.g. 250mV / 10 = 25C
0F31           1816       ; Change this Load_y value if your amp gain is different!
0F31 753E0A    1817            mov y+0, #low (10 % 0x10000) 
0F34 753F00    1817            mov y+1, #high(10 % 0x10000) 
0F37 754000    1817            mov y+2, #low (10 / 0x10000) 
0F3A 754100    1817            mov y+3, #high(10 / 0x10000)           
0F3D 120280    1818       lcall div32         
0F40           1819       
0F40           1820       ; 8. Store Final Result
0F40 853A47    1821       mov current_temp+0, x+0
0F43 853B48    1822       mov current_temp+1, x+1
0F46 853C49    1823       mov current_temp+2, x+2
0F49 853D4A    1824       mov current_temp+3, x+3
0F4C           1825   
0F4C           1826   Read_TC_Exit:
0F4C 22        1827       ret
0F4D           1828       
0F4D           1829   ; ================================================================
0F4D           1830   ; MODULE: POWER CONTROLLER (The Brain)
0F4D           1831   ; ================================================================
0F4D           1832   Power_Control:
0F4D           1833       ; Default: Turn Heat OFF (Safety)
0F4D 755800    1834       mov power_output+0, #0
0F50 755900    1835       mov power_output+1, #0
0F53 755A00    1836       mov power_output+2, #0
0F56 755B00    1837       mov power_output+3, #0
0F59           1838   
0F59 E560      1839       mov a, Control_FSM_state
0F5B           1840   
0F5B           1841       ; --- State 2: RAMP TO SOAK ---
0F5B B40202    1842       cjne a, #2, PC_Check_Soak
0F5E           1843       ; Mode: Full Speed Ahead
0F5E 8016      1844       sjmp Set_Max_Power
0F60           1845   
0F60           1846   PC_Check_Soak:
0F60           1847       ; --- State 3: SOAK PHASE ---
0F60 B40305    1848       cjne a, #3, PC_Check_Ramp_Reflow
0F63           1849       ; Mode: Maintenance (Low Power)
0F63           1850       ; If Temp > Target, OFF. If Temp < Target, 20% Power.
0F63 20050F    1851       jb soak_temp_reached, PC_Done ; If hot enough, stay OFF
0F66 801B      1852       sjmp Set_20_Percent_Power     ; If cold, use 20%
0F68           1853   
0F68           1854   PC_Check_Ramp_Reflow:
0F68           1855       ; --- State 4: RAMP TO REFLOW ---
0F68 B40402    1856       cjne a, #4, PC_Check_Reflow
0F6B           1857       ; Mode: Full Speed Ahead
0F6B 8009      1858       sjmp Set_Max_Power
0F6D           1859   
0F6D           1860   PC_Check_Reflow:
0F6D           1861       ; --- State 5: REFLOW PHASE ---
0F6D B40505    1862       cjne a, #5, PC_Done
0F70           1863       ; Mode: Maintenance (Low Power)
0F70 200602    1864       jb reflow_temp_reached, PC_Done
0F73 800E      1865       sjmp Set_20_Percent_Power
0F75           1866   
0F75           1867   PC_Done:
0F75 22        1868       ret
0F76           1869   
0F76           1870   ; --- Power Helpers ---
0F76           1871   
0F76           1872   Set_Max_Power:
0F76           1873       ; Load 1500 (0x05DC) = 100% Duty Cycle
0F76 7558DC    1874       mov power_output+0, #0xDC
0F79 755905    1875       mov power_output+1, #0x05
0F7C 755A00    1876       mov power_output+2, #0
0F7F 755B00    1877       mov power_output+3, #0
0F82 22        1878       ret
0F83           1879   
0F83           1880   Set_20_Percent_Power:
0F83           1881       ; Load 300 (0x012C) = 20% Duty Cycle
0F83 75582C    1882       mov power_output+0, #0x2C
0F86 755901    1883       mov power_output+1, #0x01
0F89 755A00    1884       mov power_output+2, #0
0F8C 755B00    1885       mov power_output+3, #0
0F8F 22        1886       ret
0F90           1887   
0F90           1888   ;-------------------------------------------------------------------------------;
0F90           1889   ;         Main program.          
0F90           1890   ;-------------------------------------------------------------------------------;
0F90           1891   main:
0F90           1892   
0F90           1893       ; --------------------------------------------------------
0F90           1894       ; 1. SAFETY SHUTDOWN
0F90           1895       ; --------------------------------------------------------
0F90 C2AF      1896       clr EA              ; FORCE Interrupts OFF immediately
0F92 7581C0    1897       mov SP, #0xC0       ; Reset Stack Pointer to safe location
0F95           1898       
0F95           1899       ; --------------------------------------------------------
0F95           1900       ; 2. THE "DIRTY DELAY" (Fixes Reset Garbage)
0F95           1901       ; We burn ~100ms here using a raw loop. 
0F95           1902       ; We cannot use timers yet because they aren't initialized.
0F95           1903       ; --------------------------------------------------------
0F95 78FA      1904       mov R0, #250
0F97           1905   Reset_Delay_Outer:
0F97 79FF      1906       mov R1, #255
0F99           1907   Reset_Delay_Inner:
0F99 D9FE      1908       djnz R1, Reset_Delay_Inner
0F9B D8FA      1909       djnz R0, Reset_Delay_Outer
0F9D           1910       ; --------------------------------------------------------
0F9D           1911   
0F9D           1912       ; ... NOW continue with your normal Port Configuration ...
0F9D           1913       
0F9D           1914       ; --- PORT CONFIGURATION ---
0F9D 759AAA    1915       mov P0MOD, #0xAA
0FA0           1916   
0FA0           1917       ; P1: Mixed usage 
0FA0           1918       ; P1.7(LCD_RS), P1.6(Row3), P1.5(Sound), P1.4(Row2)
0FA0           1919       ; P1.3(PWM), P1.2(Row1), P1.1(LCD_E) -> All Outputs
0FA0           1920       ; P1.0 (Unused/RX) -> Input
0FA0           1921       ; Binary: 11111110 -> Hex: 0xFE
0FA0 759BFE    1922       mov P1MOD, #0xFE
0FA3           1923   
0FA3           1924       ; P2: Row4(Out), Cols(In)
0FA3           1925       ; P2.0 (Row4) is Out (1). P2.2, P2.4, P2.6 (Cols) are In (0).
0FA3           1926       ; Binary: 00000001 -> Hex: 0x01
0FA3 759C01    1927       mov P2MOD, #0x01
0FA6           1928   
0FA6           1929       ; P3: Col4(In)
0FA6           1930       ; P3.0 (Col4) is In (0).
0FA6 759D00    1931       mov P3MOD, #0x00
0FA9           1932       ; Turn off all the LEDs
0FA9 75E800    1933       mov LEDRA, #0 ; LEDRA is bit addressable
0FAC 759500    1934       mov LEDRB, #0 ; LEDRB is NOT bit addresable
0FAF           1935   
0FAF           1936       ; Enable Global interrupts
0FAF D2AF      1937       setb EA  
0FB1           1938   
0FB1           1939            ; FSM initial states
0FB1 756800    1940            mov SEC_FSM_state, #0
0FB4 756000    1941            mov Control_FSM_state, #0
0FB7 756100    1942            mov Current_State, #0
0FBA           1943            ; FSM timers initialization
0FBA 756700    1944            mov SEC_FSM_timer, #0
0FBD           1945            ; time counters initialization
0FBD 753000    1946            mov current_time_sec, #0
0FC0 753100    1947            mov current_time_minute, #0
0FC3 753200    1948            mov soak_time_sec, #0
0FC6 753300    1949            mov soak_time_minute, #0
0FC9 753400    1950            mov reflow_time_sec, #0
0FCC 753500    1951            mov reflow_time_minute, #0
0FCF 753600    1952            mov soak_end_time_sec, #0
0FD2 753700    1953            mov soak_end_time_minute, #0
0FD5 753800    1954            mov reflow_end_time_sec, #0
0FD8 753900    1955            mov reflow_end_time_minute, #0
0FDB           1956       ; Initialize counter to zero
0FDB 755C00    1957       mov pwm_counter, #0
0FDE 755D00    1958       mov pwm_counter+1, #0
0FE1 755E00    1959       mov pwm_counter+2, #0
0FE4 755F00    1960       mov pwm_counter+3, #0
0FE7           1961       ; Initialize power output
0FE7 755B00    1962       mov power_output+3, #0
0FEA 755A00    1963       mov power_output+2, #0
0FED 755902    1964       mov power_output+1, #02H
0FF0 7558EE    1965       mov power_output, #0EEH ; (initilize to 750 for testing)
0FF3           1966            ; FSM Buttons push button init
0FF3 756A00    1967            mov     PB0_DEB_state, #0
0FF6 756C00    1968            mov     PB2_DEB_state, #0
0FF9 756900    1969            mov     PB0_DEB_timer, #0
0FFC 756B00    1970            mov     PB2_DEB_timer, #0
0FFF           1971   
0FFF           1972            ; Clear all the flags
0FFF C295      1973            clr SOUND_OUT
1001 C212      1974            clr tc_missing_abort
1003 C20B      1975            clr stop_signal
1005 C214      1976            clr PB0_flag
1007 C215      1977            clr PB1_flag
1009 C216      1978            clr PB2_flag
100B C201      1979            clr one_second_flag
100D C204      1980            clr one_second_lcd_flag
100F C20E      1981            clr config_finish_signal
1011 C205      1982            clr soak_temp_reached
1013 C208      1983            clr soak_time_reached
1015 C206      1984            clr reflow_temp_reached
1017 C209      1985            clr reflow_time_reached
1019 C207      1986            clr cooling_temp_reached
101B C210      1987            clr state_change_signal_TC
101D C211      1988            clr state_change_signal_Count
101F C20D      1989            clr time_count_doing_signal
1021           1990   
1021 C222      1991            clr one_second_flag_test
1023           1992            
1023           1993       ; Set bit
1023 D20F      1994            setb state_change_signal
1025 D213      1995       setb tc_startup_window
1027           1996   
1027 120456    1997       lcall Timer0_Init
102A 1204BE    1998       lcall Timer2_Init
102D 12058B    1999       lcall ELCD_4BIT
1030           2000       ;----- Two new lines I added to initialize the UI
1030 120E9B    2001       lcall Init_All_Buffers
1033           2002       ;-----
1033 120470    2003       lcall Initialize_Serial_Port
1036           2004   ;-------------------------------------------------------------------------------;
1036           2005   ; while(1) loop
1036           2006   ;-------------------------------------------------------------------------------;
1036           2007   loop:
1036 1209B3    2008            lcall SEC_FSM
1039           2009            ;lcall FSM_test
1039           2010   
1039           2011            ; Check the FSM for the overall control flow of the reflow process
1039 120BC5    2012       lcall Control_FSM
103C           2013   
103C           2014       ; Check the FSM for PB01 debounce
103C 120945    2015       lcall PB0_DEB
103F 12097D    2016            lcall PB2_DEB
1042           2017       
1042           2018       ; Added to take temp readings
1042 120EEE    2019       lcall Read_Thermocouple
1045           2020       
1045           2021       ; 1. Check if we reached temp (Observer)
1045           2022       ;lcall Temp_Compare
1045           2023       
1045           2024       ; 2. Decide heater power based on flags (Driver)
1045 120F4D    2025       lcall Power_Control
1048           2026       
1048           2027       ;lcall Safety_Check_TC
1048           2028   
1048 120A0F    2029            lcall Time_Counter
104B           2030   
104B           2031            ; Update Variables (times and temp)
104B 120C95    2032            lcall Update_FSM_Variables
104E           2033   
104E           2034            ; Update while at state 1
104E           2035            ; LCD
104E 12080D    2036            lcall Update_Screen_Full 
1051           2037            ; Buttons
1051 120D19    2038            lcall Check_Buttons 
1054           2039            ; PB0pad
1054 120D6F    2040       lcall Check_Keypad
1057           2041   
1057           2042       ; Update the LCD display based on the current state
1057 12063B    2043       lcall LCD_Display_Update_func
105A           2044   
105A 1207DE    2045            lcall LCD_Display_Update_Time
105D           2046   
105D 120A31    2047            lcall Time_Compare_MMSS
1060           2048   
1060           2049       ; Update the pwm output for the ssr
1060 120B07    2050       lcall PWM_Wave 
1063           2051   
1063           2052       ; After initialization the program stays in this 'forever' loop
1063 021036    2053       ljmp loop
1066           2054   ;-------------------------------------------------------------------------------;
1066           2055   EN
=======
0640            204   
0640            379            ;-----------------------------------------------------------------------------------------------;
0640            380   
0640            381   ;-------------------------------------------------------------------------------
0640            382   ; Display Function for 7-segment displays       
0640            383   ;-------------------------------------------------------------------------------
0640            384   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
0640            385   T_7seg:
0640 C0F9A4B0   386       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
0645 9282F880   387       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
064A 8883C6A1   388       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
0650            389   
0650            390   ; Displays a BCD number pased in R0 in HEX5-HEX0
0650            391   Display_BCD_7_Seg_HEX10:
0650 900640     392       mov dptr, #T_7seg
0653 E8         393       mov a, R0
0654 C4         394       swap a
0655 540F       395       anl a, #0FH
0657 93         396       movc a, @a+dptr
0658 F592       397       mov HEX1, a
065A E8         398       mov a, R0
065B 540F       399       anl a, #0FH
065D 93         400       movc a, @a+dptr
065E F591       401       mov HEX0, a
0660 22         402       ret
0661            403   
0661            404   Display_BCD_7_Seg_HEX32:
0661 900640     405       mov dptr, #T_7seg
0664 E8         406       mov a, R0
0665 C4         407       swap a
0666 540F       408       anl a, #0FH
0668 93         409       movc a, @a+dptr
0669 F594       410       mov HEX3, a
066B E8         411       mov a, R0
066C 540F       412       anl a, #0FH
066E 93         413       movc a, @a+dptr
066F F593       414       mov HEX2, a
0671 22         415       ret
0672            416   
0672            417   Display_BCD_7_Seg_HEX54:
0672 900640     418       mov dptr, #T_7seg
0675 E8         419       mov a, R0
0676 C4         420       swap a
0677 540F       421       anl a, #0FH
0679 93         422       movc a, @a+dptr
067A F58F       423       mov HEX5, a
067C E8         424       mov a, R0
067D 540F       425       anl a, #0FH
067F 93         426       movc a, @a+dptr
0680 F58E       427       mov HEX4, a
0682 22         428       ret
0683            429   
0683            430   ; The 8-bit hex number passed in the accumulator is converted to
0683            431   ; BCD and stored in [R1, R0]
0683            432   Hex_to_bcd_8bit:
0683 75F064     433       mov b, #100
0686 84         434       div ab
0687 F9         435       mov R1, a   ; After dividing, a has the 100s
0688 E5F0       436       mov a, b    ; Remainder is in register b
068A 75F00A     437       mov b, #10
068D 84         438       div ab ; The tens are stored in a, the units are stored in b 
068E C4         439       swap a
068F 54F0       440       anl a, #0xf0
0691 45F0       441       orl a, b
0693 F8         442       mov R0, a
0694 22         443       ret
0695            444   ;-------------------------------------------------------------------------------
0695            445   ; Display Function for LCD                      
0695            446   ;-------------------------------------------------------------------------------
0695            447   LCD_Print_2Digits:
0695 120683     448       lcall Hex_to_bcd_8bit
0698 E8         449       mov a, R0
0699 C4         450       swap a
069A 540F       451       anl a, #0x0F
069C 2430       452       add a, #0x30
069E 1205DB     453       lcall ?WriteData
06A1 E8         454       mov a, R0
06A2 540F       455       anl a, #0x0F
06A4 2430       456       add a, #0x30
06A6 1205DB     457       lcall ?WriteData
06A9 22         458       ret
06AA            459   
06AA            460   LCD_Display_Update_func:
06AA C0E0       461       push acc
06AC            462       
06AC            463       ; ==========================================
06AC            464       ; PART 1: STATIC TEXT (Title)
06AC            465       ; Runs ONLY when the state changes
06AC            466       ; ==========================================
06AC            467       
06AC            468       ; [FIX] "Trampoline" logic for long distance jump
06AC            469       ; If signal is SET (1), we stay here and update.
06AC            470       ; If signal is CLEAR (0), we Long Jump to the Live Update section.
06AC 200C03     471       jb state_change_signal, Do_Static_Update
06AF 0207E8     472       ljmp Check_Live_Update
06B2            473   
06B2            474   Do_Static_Update:
06B2 C20C       475       clr state_change_signal
06B4            476       
06B4            477       ; State Changed: Clear Screen and Write Title
06B4 120FFA     478       lcall Clear_Screen_Func
06B7 E568       479       mov a, Control_FSM_state
06B9            480       
06B9            481       ; State 0: Welcome
06B9 B4003B     482       cjne a, #0, LCD_Check_1
06BC C0E0       483            push acc
06BE 7401       483            mov a, #1
06C0 14         483            dec a
06C1 120625     483            lcall ?Set_Cursor_1 ; Select column and row
06C4 D0E0       483            pop acc
06C6 C083       484            push dph
06C8 C082       484            push dpl
06CA C0E0       484            push acc
06CC 900330     484            mov dptr, #String_state0_1
06CF 120618     484            lcall ?Send_Constant_String
06D2 D0E0       484            pop acc
06D4 D082       484            pop dpl
06D6 D083       484            pop dph
06D8 C0E0       485            push acc
06DA 7401       485            mov a, #1
06DC 14         485            dec a
06DD 120623     485            lcall ?Set_Cursor_2 ; Select column and row
06E0 D0E0       485            pop acc
06E2 C083       486            push dph
06E4 C082       486            push dpl
06E6 C0E0       486            push acc
06E8 900340     486            mov dptr, #String_state0_2
06EB 120618     486            lcall ?Send_Constant_String
06EE D0E0       486            pop acc
06F0 D082       486            pop dpl
06F2 D083       486            pop dph
06F4 0207E5     487       ljmp LCD_Done_Bridge ; Exit
06F7            488   
06F7            489   LCD_Check_1: ; Setup
06F7 B4011F     490       cjne a, #1, LCD_Check_2
06FA C0E0       491            push acc
06FC 7401       491            mov a, #1
06FE 14         491            dec a
06FF 120625     491            lcall ?Set_Cursor_1 ; Select column and row
0702 D0E0       491            pop acc
0704 C083       492            push dph
0706 C082       492            push dpl
0708 C0E0       492            push acc
070A 9003A5     492            mov dptr, #String_state1
070D 120618     492            lcall ?Send_Constant_String
0710 D0E0       492            pop acc
0712 D082       492            pop dpl
0714 D083       492            pop dph
0716 0207E5     493       ljmp LCD_Done_Bridge
0719            494   
0719            495   LCD_Check_2: ; Ramp to Soak
0719 B4021F     496       cjne a, #2, LCD_Check_3
071C C0E0       497            push acc
071E 7401       497            mov a, #1
0720 14         497            dec a
0721 120625     497            lcall ?Set_Cursor_1 ; Select column and row
0724 D0E0       497            pop acc
0726 C083       498            push dph
0728 C082       498            push dpl
072A C0E0       498            push acc
072C 9003EC     498            mov dptr, #String_state2
072F 120618     498            lcall ?Send_Constant_String
0732 D0E0       498            pop acc
0734 D082       498            pop dpl
0736 D083       498            pop dph
0738 020808     499       ljmp LCD_Update_Temp_Value ; Draw Temp immediately!
073B            500   
073B            501   LCD_Check_3: ; Soak
073B B4031F     502       cjne a, #3, LCD_Check_4
073E C0E0       503            push acc
0740 7401       503            mov a, #1
0742 14         503            dec a
0743 120625     503            lcall ?Set_Cursor_1 ; Select column and row
0746 D0E0       503            pop acc
0748 C083       504            push dph
074A C082       504            push dpl
074C C0E0       504            push acc
074E 9003FC     504            mov dptr, #String_state3
0751 120618     504            lcall ?Send_Constant_String
0754 D0E0       504            pop acc
0756 D082       504            pop dpl
0758 D083       504            pop dph
075A 020808     505       ljmp LCD_Update_Temp_Value
075D            506   
075D            507   LCD_Check_4: ; Ramp to Peak
075D B4041F     508       cjne a, #4, LCD_Check_5
0760 C0E0       509            push acc
0762 7401       509            mov a, #1
0764 14         509            dec a
0765 120625     509            lcall ?Set_Cursor_1 ; Select column and row
0768 D0E0       509            pop acc
076A C083       510            push dph
076C C082       510            push dpl
076E C0E0       510            push acc
0770 90040C     510            mov dptr, #String_state4
0773 120618     510            lcall ?Send_Constant_String
0776 D0E0       510            pop acc
0778 D082       510            pop dpl
077A D083       510            pop dph
077C 020808     511       ljmp LCD_Update_Temp_Value
077F            512   
077F            513   LCD_Check_5: ; Reflow
077F B4051F     514       cjne a, #5, LCD_Check_6
0782 C0E0       515            push acc
0784 7401       515            mov a, #1
0786 14         515            dec a
0787 120625     515            lcall ?Set_Cursor_1 ; Select column and row
078A D0E0       515            pop acc
078C C083       516            push dph
078E C082       516            push dpl
0790 C0E0       516            push acc
0792 90041C     516            mov dptr, #String_state5
0795 120618     516            lcall ?Send_Constant_String
0798 D0E0       516            pop acc
079A D082       516            pop dpl
079C D083       516            pop dph
079E 020808     517       ljmp LCD_Update_Temp_Value
07A1            518   
07A1            519   LCD_Check_6: ; Cooling
07A1 B4061F     520       cjne a, #6, LCD_Check_7
07A4 C0E0       521            push acc
07A6 7401       521            mov a, #1
07A8 14         521            dec a
07A9 120625     521            lcall ?Set_Cursor_1 ; Select column and row
07AC D0E0       521            pop acc
07AE C083       522            push dph
07B0 C082       522            push dpl
07B2 C0E0       522            push acc
07B4 90042C     522            mov dptr, #String_state6
07B7 120618     522            lcall ?Send_Constant_String
07BA D0E0       522            pop acc
07BC D082       522            pop dpl
07BE D083       522            pop dph
07C0 020808     523       ljmp LCD_Update_Temp_Value
07C3            524   
07C3            525   LCD_Check_7: ; Done
07C3            526       ; [FIX] Check distance safe logic for State 7
07C3 B4071F     527       cjne a, #7, LCD_Done_Bridge ; If not 7, we are done
07C6 C0E0       528            push acc
07C8 7401       528            mov a, #1
07CA 14         528            dec a
07CB 120625     528            lcall ?Set_Cursor_1 ; Select column and row
07CE D0E0       528            pop acc
07D0 C083       529            push dph
07D2 C082       529            push dpl
07D4 C0E0       529            push acc
07D6 90043C     529            mov dptr, #String_state7
07D9 120618     529            lcall ?Send_Constant_String
07DC D0E0       529            pop acc
07DE D082       529            pop dpl
07E0 D083       529            pop dph
07E2 0207E5     530       ljmp LCD_Done_Bridge
07E5            531   
07E5            532   ; Local bridge to reach the far-away LCD_Done
07E5            533   LCD_Done_Bridge:
07E5 020869     534       ljmp LCD_Done
07E8            535   
07E8            536   ; ==========================================
07E8            537   ; PART 2: DYNAMIC VALUES (Temperature)
07E8            538   ; Runs every time 'one_second_flag' is set
07E8            539   ; ==========================================
07E8            540   Check_Live_Update:
07E8 3001FA     541       jnb one_second_flag, LCD_Done_Bridge
07EB C201       542       clr one_second_flag
07ED            543       
07ED            544       ; Only update temp for States 2, 3, 4, 5, 6
07ED E568       545       mov a, Control_FSM_state
07EF B40202     546       cjne a, #2, Check_St3
07F2 8014       547       sjmp LCD_Update_Temp_Value
07F4            548   Check_St3:
07F4 B40302     549       cjne a, #3, Check_St4
07F7 800F       550       sjmp LCD_Update_Temp_Value
07F9            551   Check_St4:
07F9 B40402     552       cjne a, #4, Check_St5
07FC 800A       553       sjmp LCD_Update_Temp_Value
07FE            554   Check_St5:
07FE B40502     555       cjne a, #5, Check_St6
0801 8005       556       sjmp LCD_Update_Temp_Value
0803            557   Check_St6:
0803 B40663     558       cjne a, #6, LCD_Done
0806 8000       559       sjmp LCD_Update_Temp_Value
0808            560   
0808            561   ; --- HELPER: Prints "XXX C" on Line 2 ---
0808            562   LCD_Update_Temp_Value:
0808 C0E0       563            push acc
080A 7401       563            mov a, #1
080C 14         563            dec a
080D 120623     563            lcall ?Set_Cursor_2 ; Select column and row
0810 D0E0       563            pop acc
0812            564       
0812            565       ; Convert current_temp to BCD
0812 853F32     566       mov x, current_temp
0815 854033     567       mov x+1, current_temp+1
0818 854134     568       mov x+2, current_temp+2
081B 854235     569       mov x+3, current_temp+3
081E 12002E     570       lcall hex2bcd
0821            571   
0821            572       ; Update HEX2-HEX0 with temperature
0821 12086C     573       lcall Update_HEX_Temp
0824            574       
0824            575       ; Print Hundreds
0824 E53B       576       mov a, bcd+1
0826 540F       577       anl a, #0x0F
0828 2430       578       add a, #0x30
082A 1205DB     579       lcall ?WriteData
082D            580       
082D            581       ; Print Tens
082D E53A       582       mov a, bcd+0
082F C4         583       swap a
0830 540F       584       anl a, #0x0F
0832 2430       585       add a, #0x30
0834 1205DB     586       lcall ?WriteData
0837            587       
0837            588       ; Print Ones
0837 E53A       589       mov a, bcd+0
0839 540F       590       anl a, #0x0F
083B 2430       591       add a, #0x30
083D 1205DB     592       lcall ?WriteData
0840            593       
0840            594       ; Print 'C'
0840 7443       595       mov a, #'C'
0842 1205DB     596       lcall ?WriteData
0845            597       
0845            598       ; Clear remaining line space (prevents garbage)
0845 7420       599       mov a, #' '
0847 1205DB     600       lcall ?WriteData
084A 1205DB     601       lcall ?WriteData
084D            602   
084D            603       ; Print time MM:SS at bottom right
084D C0E0       604            push acc
084F 740C       604            mov a, #12
0851 14         604            dec a
0852 120623     604            lcall ?Set_Cursor_2 ; Select column and row
0855 D0E0       604            pop acc
0857 E531       605       mov a, current_time_minute
0859 120695     606       lcall LCD_Print_2Digits
085C 743A       607       mov a, #':'
085E 1205DB     608       lcall ?WriteData
0861 E530       609       mov a, current_time_sec
0863 120695     610       lcall LCD_Print_2Digits
0866            611   
0866            612       ; Mirror temp to serial (PuTTY/screen)
0866 1204C5     613       lcall Serial_Send_Temp_Line
0869            614   
0869            615   LCD_Done:
0869 D0E0       616       pop acc
086B 22         617       ret
086C            618   ;---------------------------------------------------------
086C            619   
086C            620   ;-------------------------------------------------------------------------------
086C            621   ; Update HEX2-HEX0 with temperature (3 digits)
086C            622   ;-------------------------------------------------------------------------------
086C            623   Update_HEX_Temp:
086C 900640     624       mov dptr, #T_7seg
086F            625       ; Hundreds -> HEX2
086F E53B       626       mov a, bcd+1
0871 540F       627       anl a, #0x0F
0873 93         628       movc a, @a+dptr
0874 F593       629       mov HEX2, a
0876            630       ; Tens -> HEX1
0876 E53A       631       mov a, bcd+0
0878 C4         632       swap a
0879 540F       633       anl a, #0x0F
087B 93         634       movc a, @a+dptr
087C F592       635       mov HEX1, a
087E            636       ; Ones -> HEX0
087E E53A       637       mov a, bcd+0
0880 540F       638       anl a, #0x0F
0882 93         639       movc a, @a+dptr
0883 F591       640       mov HEX0, a
0885 22         641       ret
0886            642   
0886            643   KEY1_DEB:
0886            644   ;non-blocking state machine for KEY1 debounce
0886 E566       645       mov a, KEY1_DEB_state
0888            646   KEY1_DEB_state0:
0888 B4000A     647       cjne a, #0, KEY1_DEB_state1
088B 20F92D     648       jb KEY.1, KEY1_DEB_done
088E 756400     649       mov KEY1_DEB_timer, #0
0891 0566       650       inc KEY1_DEB_state
0893 8026       651       sjmp KEY1_DEB_done
0895            652   KEY1_DEB_state1:
0895 B40109     653       cjne a, #1, KEY1_DEB_state2
0898            654       ; this is the debounce state
0898 E564       655       mov a, KEY1_DEB_timer
089A B4321E     656       cjne a, #50, KEY1_DEB_done ; 50 ms passed?
089D 0566       657       inc KEY1_DEB_state
089F 801A       658       sjmp KEY1_DEB_done  
08A1            659   KEY1_DEB_state2:
08A1 B4020C     660       cjne a, #2, KEY1_DEB_state3
08A4 20F904     661       jb KEY.1, KEY1_DEB_state2b
08A7 0566       662       inc KEY1_DEB_state
08A9 8010       663       sjmp KEY1_DEB_done  
08AB            664   KEY1_DEB_state2b:
08AB 756600     665       mov KEY1_DEB_state, #0
08AE 800B       666       sjmp KEY1_DEB_done
08B0            667   KEY1_DEB_state3:
08B0 B40308     668       cjne a, #3, KEY1_DEB_done
08B3 30F905     669       jnb KEY.1, KEY1_DEB_done
08B6 D20D       670       setb Key1_flag ; Suscesfully detected a valid KEY1 press/release
08B8 756600     671       mov KEY1_DEB_state, #0  
08BB            672   KEY1_DEB_done:
08BB 22         673       ret
08BC            674   ; ------------------------------------------------------------------------------
08BC            675   ; Non-blocking FSM for the one second counter
08BC            676   ;-------------------------------------------------------------------------------
08BC            677   SEC_FSM:
08BC E567       678       mov a, SEC_FSM_state
08BE            679   SEC_FSM_state0:
08BE B4000C     680       cjne a, #0, SEC_FSM_state1
08C1 E565       681       mov a, SEC_FSM_timer
08C3 B4FA4B     682       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08C6 756500     683       mov SEC_FSM_timer, #0
08C9 0567       684       inc SEC_FSM_state
08CB 8044       685       sjmp SEC_FSM_done
08CD            686   SEC_FSM_state1: 
08CD B4010E     687       cjne a, #1, SEC_FSM_state2
08D0 D2E9       688       setb LEDRA.1
08D2 E565       689       mov a, SEC_FSM_timer
08D4 B4FA3A     690       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08D7 756500     691       mov SEC_FSM_timer, #0
08DA 0567       692       inc SEC_FSM_state
08DC 8033       693       sjmp SEC_FSM_done
08DE            694   SEC_FSM_state2: 
08DE B4020E     695       cjne a, #2, SEC_FSM_state3
08E1 D2EA       696       setb LEDRA.2
08E3 E565       697       mov a, SEC_FSM_timer
08E5 B4FA29     698       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08E8 756500     699       mov SEC_FSM_timer, #0
08EB 0567       700       inc SEC_FSM_state
08ED 8022       701       sjmp SEC_FSM_done
08EF            702   SEC_FSM_state3: 
08EF B4031F     703       cjne a, #3, SEC_FSM_done
08F2 D2EB       704       setb LEDRA.3
08F4 E565       705       mov a, SEC_FSM_timer
08F6 B4FA18     706       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08F9 756500     707       mov SEC_FSM_timer, #0
08FC 756700     708       mov SEC_FSM_state, #0
08FF            709       
08FF            710       ; --- 1 Second has passed! ---
08FF D201       711       setb one_second_flag
0901            712       
0901 E530       713       mov a, current_time_sec
0903 B43B07     714       cjne a, #59, IncCurrentTimeSec 
0906            715       
0906            716       ; --- FIX: 59s -> 0s AND Increment Minute ---
0906 753000     717       mov current_time_sec, #0
0909 0531       718       inc current_time_minute    ; <--- YOU WERE MISSING THIS!
090B            719       ; -------------------------------------------
090B            720       
090B 8004       721       sjmp SEC_FSM_done
090D            722   
090D            723   IncCurrentTimeSec:
090D 0530       724       inc current_time_sec
090F B2E8       725       cpl LEDRA.0 
0911            726   SEC_FSM_done:
0911 22         727       ret
0912            728   ;-------------------------------------------------------------------------------
0912            729   ; PWM
0912            730   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0912            731   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0912            732   ; ------------------------------------------------------------------------------
0912            733   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0912 100202     734       jbc one_ms_pwm_flag, pwm_wave_generator
0915 8071       735       sjmp end_pwm_generator
0917            736   
0917            737   pwm_wave_generator:
0917 C200       738       clr mf
0919            739       ; move pwm counter value into x for comparison purpose
0919 856032     740       mov x, pwm_counter
091C 856133     741       mov x+1, pwm_counter+1
091F 856234     742       mov x+2, pwm_counter+2
0922 856335     743       mov x+3, pwm_counter+3
0925            744   
0925 7536DB     745            mov y+0, #low (PWM_PERIOD % 0x10000) 
0928 753705     745            mov y+1, #high(PWM_PERIOD % 0x10000) 
092B 753800     745            mov y+2, #low (PWM_PERIOD / 0x10000) 
092E 753900     745            mov y+3, #high(PWM_PERIOD / 0x10000) 
0931            746   
0931            747       ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
0931            748       ; increase x by 1
0931 120152     749       lcall x_eq_y 
0934 20001D     750       jb mf, wrap_pwm_counter
0937            751       ; x not equal 1499, increment by 1
0937 753601     752            mov y+0, #low (1 % 0x10000) 
093A 753700     752            mov y+1, #high(1 % 0x10000) 
093D 753800     752            mov y+2, #low (1 / 0x10000) 
0940 753900     752            mov y+3, #high(1 / 0x10000) 
0943 1200D3     753       lcall add32
0946            754       ; update pwm_counter
0946 853260     755       mov pwm_counter, x
0949 853361     756       mov pwm_counter+1, x+1
094C 853462     757       mov pwm_counter+2, x+2
094F 853563     758       mov pwm_counter+3, x+3
0952 8018       759       sjmp set_pwm
0954            760   
0954            761   wrap_pwm_counter:
0954            762       ; x equal 1499, wrap to 0
0954 753200     763            mov x+0, #low (0 % 0x10000) 
0957 753300     763            mov x+1, #high(0 % 0x10000) 
095A 753400     763            mov x+2, #low (0 / 0x10000) 
095D 753500     763            mov x+3, #high(0 / 0x10000) 
0960 853260     764       mov pwm_counter, x
0963 853361     765       mov pwm_counter+1, x+1
0966 853462     766       mov pwm_counter+2, x+2
0969 853563     767       mov pwm_counter+3, x+3
096C            768   
096C            769   set_pwm:
096C            770       ; compare with power_output, if pwm counter smaller than power_output, 
096C            771       ; set pwm pin high; else set pwm pin low load y with power output value
096C 855C36     772       mov y, power_output
096F 855D37     773       mov y+1, power_output+1
0972 855E38     774       mov y+2, power_output+2
0975 855F39     775       mov y+3, power_output+3
0978            776   
0978            777       ; compare x(pwm counter) with y(power output)
0978 12011A     778       lcall x_lt_y
097B 200006     779       jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
097E            780       ;output set pwm pin low if pwm counter greater than power output
097E C293       781       clr PWM_OUT
0980 C2EC       782       clr LEDRA.4
0982 8004       783       sjmp end_pwm_generator
0984            784   
0984            785   set_pwm_high:
0984 D293       786       setb PWM_OUT
0986 D2EC       787       setb LEDRA.4
0988            788   
0988            789   end_pwm_generator:
0988 22         790       ret
0989            791   
0989            792   ;-------------------------------------------------------------------------------;
0989            793   ; Temp_Compare
0989            794   ; Checks if we have reached the user's target temperatures.
0989            795   ; Sets 'soak_temp_reached' if current_temp >= soak_temp
0989            796   ; Sets 'reflow_temp_reached' if current_temp >= reflow_temp
0989            797   ;-------------------------------------------------------------------------------;
0989            798   Temp_Compare:
0989            799       ; Reset flags initially
0989 C203       800       clr soak_temp_reached
098B C204       801       clr reflow_temp_reached
098D            802   
098D C0E0       803       push acc
098F C0D0       804       push psw
0991 C000       805       push AR0
0993 C001       806       push AR1
0995 C002       807       push AR2
0997            808       
0997            809       ; --- 1. CHECK SOAK TEMP ---
0997            810       ; Copy current_temp to X
0997 783F       811       mov R0, #current_temp
0999 7932       812       mov R1, #x
099B 120A0F     813       lcall Copy4_Bytes_R0_to_R1
099E            814   
099E            815       ; Copy soak_temp to Y
099E 7843       816       mov R0, #soak_temp
09A0 7936       817       mov R1, #y
09A2 120A0F     818       lcall Copy4_Bytes_R0_to_R1
09A5            819   
09A5            820       ; Compare: Is X (Current) < Y (Target)?
09A5 12011A     821       lcall x_lt_y
09A8 200002     822       jb mf, Check_Reflow_Threshold ; If Current < Target, jump (Flag stays 0)
09AB            823       
09AB            824       ; If we are here, Current >= Target
09AB D203       825       setb soak_temp_reached
09AD            826   
09AD            827   Check_Reflow_Threshold:
09AD            828       ; --- 2. CHECK REFLOW TEMP ---
09AD            829       ; Copy current_temp to X (Need to reload X because math32 destroys it)
09AD 783F       830       mov R0, #current_temp
09AF 7932       831       mov R1, #x
09B1 120A0F     832       lcall Copy4_Bytes_R0_to_R1
09B4            833   
09B4            834       ; Copy reflow_temp to Y
09B4 7847       835       mov R0, #reflow_temp
09B6 7936       836       mov R1, #y
09B8 120A0F     837       lcall Copy4_Bytes_R0_to_R1
09BB            838   
09BB            839       ; Compare
09BB 12011A     840       lcall x_lt_y
09BE 200002     841       jb mf, Temp_Compare_Done
09C1            842       
09C1            843       ; If Current >= Target
09C1 D204       844       setb reflow_temp_reached
09C3            845   
09C3            846   Temp_Compare_Done:
09C3 D002       847       pop AR2
09C5 D001       848       pop AR1
09C7 D000       849       pop AR0
09C9 D0D0       850       pop psw
09CB D0E0       851       pop acc
09CD 22         852       ret
09CE            853   ;-------------------------------------------------------------------------------;
09CE            854   ; Time_Compare
09CE            855   ;
09CE            856   ; PURPOSE:
09CE            857   ;   Compare the elapsed time against soak and reflow
09CE            858   ;   time limits.
09CE            859   ;
09CE            860   ; BEHAVIOR:
09CE            861   ;   - If current_time >= soak_time   if soak_time_reached    = 1
09CE            862   ;   - If current_time >= reflow_time if reflow_time_reached = 1
09CE            863   ;
09CE            864   ; NOTES:
09CE            865   ;   - Time values are treated as 32-bit UNSIGNED numbers
09CE            866   ;     (e.g., milliseconds or seconds).
09CE            867   ;   - Uses the SAME compare logic as Temp_Compare.
09CE            868   ;   - This routine ONLY SETS flags.
09CE            869   ;
09CE            870   ; EXPECTED VARIABLES:
09CE            871   ;   current_time[4], soak_time[4], reflow_time[4]
09CE            872   ;   x[4], y[4]
09CE            873   ;   mf, soak_time_reached, reflow_time_reached
09CE            874   ;-------------------------------------------------------------------------------;
09CE            875   Time_Compare:
09CE C0E0       876       push acc
09D0 C0D0       877       push psw
09D2 C000       878       push AR0
09D4 C001       879       push AR1
09D6 C002       880       push AR2
09D8            881   
09D8            882   ; Check: current_time >= soak_time ?
09D8            883       ; Copy current_time of x
09D8 7850       884       mov  R0, #current_time
09DA 7932       885       mov  R1, #x
09DC 120A0F     886       lcall Copy4_Bytes_R0_to_R1
09DF            887   
09DF            888       ; Copy soak_time of y
09DF 7854       889       mov  R0, #soak_time
09E1 7936       890       mov  R1, #y
09E3 120A0F     891       lcall Copy4_Bytes_R0_to_R1
09E6            892   
09E6            893       ; Compare elapsed time vs soak time
09E6 12011A     894       lcall x_lt_y
09E9 200002     895       jb   mf, Time_Soak_NotReached
09EC D206       896       setb soak_time_reached
09EE            897   
09EE            898   ; Check: current_time >= reflow_time ?
09EE            899   Time_Soak_NotReached:
09EE            900       ; Copy current_time of x
09EE 7850       901       mov  R0, #current_time
09F0 7932       902       mov  R1, #x
09F2 120A0F     903       lcall Copy4_Bytes_R0_to_R1
09F5            904   
09F5            905       ; Copy reflow_time of y
09F5 7858       906       mov  R0, #reflow_time
09F7 7936       907       mov  R1, #y
09F9 120A0F     908       lcall Copy4_Bytes_R0_to_R1
09FC            909   
09FC            910       ; Compare elapsed time vs reflow time
09FC 12011A     911       lcall x_lt_y
09FF 200002     912       jb   mf, Time_Reflow_NotReached
0A02 D207       913       setb reflow_time_reached
0A04            914   
0A04            915   Time_Reflow_NotReached:
0A04 D002       916       pop  AR2
0A06 D001       917       pop  AR1
0A08 D000       918       pop  AR0
0A0A D0D0       919       pop  psw
0A0C D0E0       920       pop  acc
0A0E 22         921       ret
0A0F            922   
0A0F            923   ;-------------------------------------------------------------------------------;
0A0F            924   ; Copy4_Bytes_R0_to_R1
0A0F            925   ;
0A0F            926   ; PURPOSE:
0A0F            927   ;   Utility routine to copy a 32-bit value (4 bytes)
0A0F            928   ;   from one memory location to another.
0A0F            929   ;
0A0F            930   ; INPUTS:
0A0F            931   ;   R0 st source address
0A0F            932   ;   R1 at destination address
0A0F            933   ;
0A0F            934   ; USES:
0A0F            935   ;   R2 as loop counter
0A0F            936   ;
0A0F            937   ; EXAMPLE:
0A0F            938   ;   mov R0, #current_temp
0A0F            939   ;   mov R1, #x
0A0F            940   ;   lcall Copy4_Bytes_R0_to_R1
0A0F            941   ;-------------------------------------------------------------------------------;
0A0F            942   Copy4_Bytes_R0_to_R1:
0A0F 7A04       943       mov  R2, #4
0A11            944   Copy4_Loop:
0A11 E6         945       mov  a, @R0
0A12 F7         946       mov  @R1, a
0A13 08         947       inc  R0
0A14 09         948       inc  R1
0A15 DAFA       949       djnz R2, Copy4_Loop
0A17 22         950       ret
0A18            951   
0A18            952   ;-------------------------------------------------------------------------------;
0A18            953   ; Abort condition safety check Temperature time
0A18            954   ;
0A18            955   ; PURPOSE:
0A18            956   ;   Automatic cycle termination on error:
0A18            957   ;   Abort if oven fails to reach at least 50C in first 60s.
0A18            958   ;
0A18            959   ; TRIP CONDITION:
0A18            960   ;   if (current_time >= 60s) AND (current_temp < 50C)
0A18            961   ;       -> set tc_missing_abort
0A18            962   ;       -> set stop_signal
0A18            963   ;
0A18            964   ; ASSUMPTIONS:
0A18            965   ;   - current_time is in SECONDS (32-bit, little-endian)
0A18            966   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
0A18            967   ;
0A18            968   ;   the Load_Y constants accordingly.
0A18            969   ;-------------------------------------------------------------------------------;
0A18            970   Safety_Check_TC:
0A18 C0E0       971       push acc
0A1A C0D0       972       push psw
0A1C C000       973       push AR0
0A1E C001       974       push AR1
0A20 C002       975       push AR2
0A22            976   
0A22            977       ; ---------------------------------------------------------
0A22            978       ; [FIX] GATEKEEPER: IGNORE UNLESS IN STATE 2 (RAMP TO SOAK)
0A22            979       ; ---------------------------------------------------------
0A22 E568       980       mov a, Control_FSM_state
0A24 B40202     981       cjne a, #2, Safety_TC_Exit_Bridge ; If State != 2, skip everything
0A27 8003       982       sjmp Safety_Logic_Proceed         ; If State == 2, do the check
0A29            983   
0A29            984       Safety_TC_Exit_Bridge:
0A29 020A77     985           ljmp Safety_TC_Done               ; Jump to the end
0A2C            986   
0A2C            987       Safety_Logic_Proceed:
0A2C            988           ; If already aborted or startup window closed, do nothing
0A2C 200E48     989           jb   tc_missing_abort, Safety_TC_Done
0A2F 300F45     990           jnb  tc_startup_window, Safety_TC_Done
0A32            991   
0A32            992       ; Check: current_time >= 60 ?
0A32 7850       993       mov  R0, #current_time
0A34 7932       994       mov  R1, #x
0A36 120A0F     995       lcall Copy4_Bytes_R0_to_R1
0A39            996   
0A39 75363C     997            mov y+0, #low (60 % 0x10000) 
0A3C 753700     997            mov y+1, #high(60 % 0x10000) 
0A3F 753800     997            mov y+2, #low (60 / 0x10000) 
0A42 753900     997            mov y+3, #high(60 / 0x10000) 
0A45 12011A     998       lcall x_lt_y
0A48 2000DE     999       jb   mf, Safety_TC_Exit_Bridge        ; still < 60s  keep waiting
0A4B           1000   
0A4B           1001       ; We reached 60s: close the startup window so it won't re-check later
0A4B C20F      1002       clr  tc_startup_window
0A4D           1003   
0A4D           1004       ; Now check: current_temp < 50 ?
0A4D 783F      1005       mov  R0, #current_temp
0A4F 7932      1006       mov  R1, #x
0A51 120A0F    1007       lcall Copy4_Bytes_R0_to_R1
0A54           1008   
0A54 753632    1009            mov y+0, #low (50 % 0x10000) 
0A57 753700    1009            mov y+1, #high(50 % 0x10000) 
0A5A 753800    1009            mov y+2, #low (50 / 0x10000) 
0A5D 753900    1009            mov y+3, #high(50 / 0x10000) 
0A60 12011A    1010       lcall x_lt_y
0A63 3000C3    1011       jnb  mf, Safety_TC_Exit_Bridge        ; temp >= 50  pass
0A66           1012   
0A66           1013       ; FAIL: at 60s, still below 50C  abort
0A66 C293      1014       clr  PWM_OUT
0A68 D20E      1015       setb tc_missing_abort
0A6A D209      1016       setb stop_signal
0A6C 120A8C    1017            lcall Beep_Ten
0A6F           1018       ; 3. Force FSM to State 0 (Welcome)
0A6F 756800    1019       mov Control_FSM_state, #0
0A72           1020       
0A72           1021       ; 4. Force UI to State 0 (Home Screen)
0A72 756900    1022       mov Current_State, #0
0A75           1023       
0A75           1024       ; 5. Trigger Screen Refresh
0A75 D20C      1025       setb state_change_signal ; Tell loop to redraw "Welcome"
0A77           1026   
0A77           1027   Safety_TC_Done:
0A77 D002      1028       pop  AR2
0A79 D001      1029       pop  AR1
0A7B D000      1030       pop  AR0
0A7D D0D0      1031       pop  psw
0A7F D0E0      1032       pop  acc
0A81 22        1033       ret
0A82           1034   
0A82           1035   ; ============================================================
0A82           1036   ; BUZZER STARTUP FUNCTIONS
0A82           1037   ; ============================================================
0A82           1038   
0A82           1039   Beep_Once:
0A82 757301    1040       mov beep_count, #1
0A85 800A      1041       sjmp Beep_Start
0A87           1042   
0A87           1043   Beep_Five:
0A87 757305    1044       mov beep_count, #5
0A8A 8005      1045       sjmp Beep_Start
0A8C           1046   
0A8C           1047   Beep_Ten:
0A8C 75730A    1048       mov beep_count, #10
0A8F 8000      1049       sjmp Beep_Start      ; [FIX] Added explicit jump for safety
0A91           1050   
0A91           1051   Beep_Start:
0A91 C28C      1052       clr TR0              ; [FIX] Stop timer briefly to reset cleanly
0A93 757401    1053       mov beep_state, #1   ; Set State to ON
0A96 757500    1054       mov beep_tmr, #0     ; Reset Timer High Byte
0A99 757600    1055       mov beep_tmr+1, #0   ; Reset Timer Low Byte
0A9C D2A9      1056       setb ET0             ; [FIX] Ensure Interrupt is enabled
0A9E D28C      1057       setb TR0             ; START the 2kHz tone
0AA0 22        1058       ret
0AA1           1059   ;============================================================
0AA1           1060   
0AA1           1061   ;============================================================
0AA1           1062   ; Buzzer beep Task 
0AA1           1063   ; Purpose: beeps, holds, stop
0AA1           1064   ; Buzzer task:
0AA1           1065   ; Beep once when state changes
0AA1           1066   ; Beep five times if finished
0AA1           1067   ; Beep ten times if meets error
0AA1           1068   ;============================================================
0AA1           1069   
0AA1           1070   Beep_Task:
0AA1 301335    1071       jnb one_ms_beep_flag, Beep_Done
0AA4 C213      1072       clr one_ms_beep_flag
0AA6           1073   
0AA6 E574      1074       mov a, beep_state
0AA8 602F      1075       jz Beep_Done
0AAA           1076   
0AAA           1077   ; ---- increment 16-bit timer ----
0AAA 0575      1078       inc beep_tmr
0AAC E575      1079       mov a, beep_tmr
0AAE 7002      1080       jnz Beep_Check
0AB0 0576      1081       inc beep_tmr+1
0AB2           1082   
0AB2           1083   Beep_Check:
0AB2           1084       ; [FIX] FUZZY TIMER CHECK
0AB2           1085       ; Check if High Byte is non-zero (Time >= 256ms)
0AB2 E576      1086       mov a, beep_tmr+1
0AB4 6023      1087       jz Beep_Done        ; If 0, keep beeping
0AB6           1088   
0AB6           1089       ; --- Time Limit Reached ---
0AB6 757500    1090       mov beep_tmr, #0    ; Reset timer
0AB9 757600    1091       mov beep_tmr+1, #0
0ABC           1092   
0ABC E574      1093       mov a, beep_state
0ABE B40106    1094       cjne a, #1, Beep_Off_State
0AC1           1095   
0AC1           1096       ; State was 1 (ON) -> Turn OFF
0AC1 C28C      1097       clr TR0             ; Hardware Silence
0AC3 757402    1098       mov beep_state, #2  ; Set State to OFF (Pause)
0AC6 22        1099       ret
0AC7           1100   
0AC7           1101   Beep_Off_State:
0AC7           1102   ; ---- OFF finished -> decrement count / next ON ----
0AC7 1573      1103       dec beep_count
0AC9 E573      1104       mov a, beep_count
0ACB 6006      1105       jz  Beep_Stop
0ACD           1106   
0ACD 757401    1107       mov beep_state, #1
0AD0 D28C      1108       setb TR0
0AD2 22        1109       ret
0AD3           1110   
0AD3           1111   Beep_Stop:
0AD3 C28C      1112       clr TR0
0AD5 757400    1113       mov beep_state, #0
0AD8 22        1114       ret
0AD9           1115   
0AD9           1116   Beep_Done:
0AD9 22        1117       ret
0ADA           1118   ;==================================================================
0ADA           1119   
0ADA           1120   ;-------------------------------------------------------------------------------;
0ADA           1121   ; Main Control FSM for the entire process
0ADA           1122   ;-------------------------------------------------------------------------------;
0ADA           1123   ;-------------------------------------------------------------------------------;
0ADA           1124   ; FSM LOGIC (Button Logic Fixed)
0ADA           1125   ;-------------------------------------------------------------------------------;
0ADA           1126   Control_FSM:
0ADA E568      1127       mov a, Control_FSM_state
0ADC 8005      1128       sjmp Control_FSM_state0
0ADE           1129   
0ADE           1130   Control_FSM_state0_a:
0ADE 756800    1131       mov Control_FSM_state, #0
0AE1 D20C      1132       setb state_change_signal
0AE3           1133            
0AE3           1134   Control_FSM_state0:
0AE3 B40015    1135       cjne a, #0, Control_FSM_state1
0AE6 209005    1136       jb P1.0, Control_FSM_done_bridge ; If Button High (Not Pressed), Exit
0AE9 121024    1137       lcall Wait_For_P1_0_Release      ; If Low (Pressed), Wait & Proceed
0AEC 8001      1138       sjmp Control_FSM_state1_a  
0AEE           1139       
0AEE           1140   Control_FSM_done_bridge:
0AEE 22        1141       ret
0AEF           1142   
0AEF           1143   Control_FSM_state1_a:
0AEF 0568      1144       inc Control_FSM_state
0AF1 756900    1145       mov Current_State, #0
0AF4 120F02    1146       lcall Update_Screen_Full 
0AF7 D20C      1147       setb state_change_signal
0AF9 E568      1148       mov a, Control_FSM_state
0AFB           1149       
0AFB           1150   Control_FSM_state1:
0AFB B40127    1151       cjne a, #1, Control_FSM_state2
0AFE 120D3A    1152       lcall Check_Buttons 
0B01 120D86    1153       lcall Check_Keypad
0B04           1154       
0B04           1155       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
0B04 209008    1156       jb P1.0, Control_FSM_state1_ret
0B07           1157       
0B07           1158       ; If we get here, Button is LOW (Pressed)
0B07 121024    1159       lcall Wait_For_P1_0_Release
0B0A 120CBE    1160       lcall Update_FSM_Variables
0B0D 8001      1161       sjmp Control_FSM_state2_a
0B0F           1162   Control_FSM_state1_ret:
0B0F 22        1163       ret
0B10           1164   
0B10           1165   ; --- STATE 2: RAMP TO SOAK ---
0B10           1166   Control_FSM_state2_a:
0B10 0568      1167       inc Control_FSM_state
0B12 E568      1168       mov a, Control_FSM_state   ; [FIX] RELOAD 'A' so it matches the new state!
0B14 D20C      1169       setb state_change_signal
0B16 120A82    1170       lcall Beep_Once
0B19           1171   
0B19 D20F      1172       setb tc_startup_window    ; OPEN the safety window
0B1B C20E      1173       clr tc_missing_abort      ; Clear any previous aborts
0B1D 753000    1174       mov current_time_sec, #0  ; Reset Seconds to 0
0B20 753100    1175       mov current_time_minute, #0 ; Reset Minutes to 0
0B23           1176       
0B23           1177       ; [FIX] CLEAR FLAG ON ENTRY
0B23           1178       ; Force the system to wait for at least one fresh temp reading
0B23           1179       ; before deciding we are done.
0B23 C203      1180       clr soak_temp_reached      
0B25           1181   
0B25           1182   Control_FSM_state2:
0B25 B4021F    1183       cjne a, #2, Control_FSM_state3
0B28 301205    1184       jnb PB2_flag, State2_Check
0B2B C212      1185       clr PB2_flag
0B2D 020B98    1186       ljmp Control_FSM_state6_a ; Pause
0B30           1187   
0B30           1188   State2_Check:
0B30 300313    1189       jnb soak_temp_reached, State2_Ret
0B33           1190       
0B33           1191       ; --- We reached Temp! Move to State 3 ---
0B33 C203      1192       clr soak_temp_reached
0B35 0568      1193       inc Control_FSM_state
0B37           1194       
0B37           1195       ; [FIX] RELOAD 'A' (Good practice)
0B37 E568      1196       mov a, Control_FSM_state   
0B39           1197       
0B39 D20C      1198       setb state_change_signal
0B3B 120A82    1199       lcall Beep_Once
0B3E           1200       
0B3E 753000    1201       mov current_time_sec, #0
0B41 753100    1202       mov current_time_minute, #0
0B44           1203       
0B44           1204       ; Ensure we start State 3 fresh
0B44 C206      1205       clr soak_time_reached 
0B46           1206   
0B46           1207   State2_Ret:
0B46 22        1208       ret
0B47           1209   
0B47           1210   ; --- STATE 3: SOAK PHASE ---
0B47           1211   Control_FSM_state3:
0B47 B40315    1212       cjne a, #3, Control_FSM_state4
0B4A 301205    1213       jnb PB2_flag, State3_Check
0B4D C212      1214       clr PB2_flag
0B4F 020B98    1215       ljmp Control_FSM_state6_a
0B52           1216   State3_Check:
0B52 300609    1217       jnb soak_time_reached, State3_Ret
0B55 C206      1218       clr soak_time_reached
0B57 0568      1219       inc Control_FSM_state      
0B59 D20C      1220       setb state_change_signal 
0B5B 120A82    1221            lcall Beep_Once
0B5E           1222   State3_Ret:
0B5E 22        1223       ret
0B5F           1224   
0B5F           1225   ; --- STATE 4: RAMP TO PEAK ---
0B5F           1226   Control_FSM_state4:
0B5F B4041D    1227       cjne a, #4, Control_FSM_state5
0B62 301205    1228       jnb PB2_flag, State4_Check
0B65 C212      1229       clr PB2_flag
0B67 020B98    1230       ljmp Control_FSM_state6_a
0B6A           1231   State4_Check:
0B6A 300411    1232       jnb reflow_temp_reached, State4_Ret
0B6D C204      1233       clr reflow_temp_reached
0B6F 0568      1234       inc Control_FSM_state
0B71 D20C      1235       setb state_change_signal
0B73 120A82    1236            lcall Beep_Once
0B76 753000    1237       mov current_time_sec, #0
0B79 753100    1238       mov current_time_minute, #0
0B7C           1239       ; --- ADD THIS LINE ---
0B7C C207      1240       clr reflow_time_reached ; Kill the ghost flag
0B7E           1241       ; ---------------------
0B7E           1242   State4_Ret:
0B7E 22        1243       ret
0B7F           1244   
0B7F           1245   ; --- STATE 5: REFLOW PHASE ---
0B7F           1246   Control_FSM_state5:
0B7F B40502    1247       cjne a, #5, Control_FSM_state6_trampoline
0B82 8003      1248       sjmp State5_Logic
0B84           1249   Control_FSM_state6_trampoline:
0B84 020B9F    1250       ljmp Control_FSM_state6
0B87           1251   
0B87           1252   State5_Logic:
0B87 301205    1253       jnb PB2_flag, State5_Check
0B8A C212      1254       clr PB2_flag
0B8C 020B98    1255       ljmp Control_FSM_state6_a
0B8F           1256   State5_Check:
0B8F 300705    1257       jnb reflow_time_reached, State5_Ret
0B92 C207      1258       clr reflow_time_reached
0B94 020B98    1259       ljmp Control_FSM_state6_a
0B97           1260   State5_Ret:
0B97 22        1261       ret
0B98           1262   
0B98           1263   ; --- STATE 6: COOLING ---
0B98           1264   Control_FSM_state6_a:
0B98 0568      1265       inc Control_FSM_state
0B9A D20C      1266       setb state_change_signal
0B9C 120A87    1267            lcall Beep_Five
0B9F           1268   Control_FSM_state6:
0B9F B4060A    1269       cjne a, #6, Control_FSM_state7
0BA2           1270       ; Wait for Cooling Temp Reached
0BA2 300506    1271       jnb cooling_temp_reached, State6_Ret
0BA5 C205      1272       clr cooling_temp_reached
0BA7 0568      1273       inc Control_FSM_state
0BA9 D20C      1274       setb state_change_signal
0BAB           1275   State6_Ret:
0BAB 22        1276       ret
0BAC           1277   
0BAC           1278   ; --- STATE 7: DONE ---
0BAC           1279   Control_FSM_state7:
0BAC B40711    1280       cjne a, #7, Control_FSM_done
0BAF           1281       
0BAF           1282       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
0BAF 201009    1283       jb PB0_flag, Control_FSM_Reset_Logic ; Wait, PB0_flag is software flag?
0BB2           1284       
0BB2           1285       ; Let's assume you meant the physical button P1.0 like State 0
0BB2 20900B    1286       jb P1.0, Control_FSM_done
0BB5           1287       
0BB5 121024    1288       lcall Wait_For_P1_0_Release
0BB8 020ADE    1289       ljmp Control_FSM_state0_a
0BBB           1290   
0BBB           1291   Control_FSM_Reset_Logic:
0BBB           1292       ; If using PB0_flag from ISR, handle here
0BBB C210      1293       clr PB0_flag
0BBD 020ADE    1294       ljmp Control_FSM_state0_a
0BC0           1295   
0BC0           1296   Control_FSM_done:
0BC0 22        1297       ret
0BC1           1298   ;-------------------------------------------------------------------------------;
0BC1           1299   ;         Main program.          
0BC1           1300   ;-------------------------------------------------------------------------------;
0BC1           1301   main:
0BC1           1302   
0BC1           1303       ; --------------------------------------------------------
0BC1           1304       ; 1. SAFETY SHUTDOWN
0BC1           1305       ; --------------------------------------------------------
0BC1 C2AF      1306       clr EA              ; FORCE Interrupts OFF immediately
0BC3 7581C0    1307       mov SP, #0xC0       ; Reset Stack Pointer to safe location
0BC6           1308       
0BC6           1309       ; --------------------------------------------------------
0BC6           1310       ; 2. THE "DIRTY DELAY" (Fixes Reset Garbage)
0BC6           1311       ; We burn ~100ms here using a raw loop. 
0BC6           1312       ; We cannot use timers yet because they aren't initialized.
0BC6           1313       ; --------------------------------------------------------
0BC6 78FA      1314       mov R0, #250
0BC8           1315   Reset_Delay_Outer:
0BC8 79FF      1316       mov R1, #255
0BCA           1317   Reset_Delay_Inner:
0BCA D9FE      1318       djnz R1, Reset_Delay_Inner
0BCC D8FA      1319       djnz R0, Reset_Delay_Outer
0BCE           1320       ; --------------------------------------------------------
0BCE           1321   
0BCE           1322       ; ... NOW continue with your normal Port Configuration ...
0BCE           1323       
0BCE           1324       ; --- PORT CONFIGURATION ---
0BCE 759AAA    1325       mov P0MOD, #0xAA
0BD1           1326   
0BD1           1327       ; P1: Mixed usage 
0BD1           1328       ; P1.7(LCD_RS), P1.6(Row3), P1.5(Sound), P1.4(Row2)
0BD1           1329       ; P1.3(PWM), P1.2(Row1), P1.1(LCD_E) -> All Outputs
0BD1           1330       ; P1.0 (Unused/RX) -> Input
0BD1           1331       ; Binary: 11111110 -> Hex: 0xFE
0BD1 759BFE    1332       mov P1MOD, #0xFE
0BD4           1333   
0BD4           1334       ; P2: Row4(Out), Cols(In)
0BD4           1335       ; P2.0 (Row4) is Out (1). P2.2, P2.4, P2.6 (Cols) are In (0).
0BD4           1336       ; Binary: 00000001 -> Hex: 0x01
0BD4 759C01    1337       mov P2MOD, #0x01
0BD7           1338   
0BD7           1339       ; P3: Col4(In)
0BD7           1340       ; P3.0 (Col4) is In (0).
0BD7 759D40    1341       mov P3MOD, #01000000B
0BDA           1342       ; Turn off all the LEDs
0BDA 75E800    1343       mov LEDRA, #0 ; LEDRA is bit addressable
0BDD 759500    1344       mov LEDRB, #0 ; LEDRB is NOT bit addresable
0BE0           1345   
0BE0           1346       ; Enable Global interrupts
0BE0 D2AF      1347       setb EA  
0BE2           1348   
0BE2           1349       ; FSM initial states
0BE2 756600    1350       mov KEY1_DEB_state, #0
0BE5 756700    1351       mov SEC_FSM_state, #0
0BE8 756800    1352       mov Control_FSM_state, #0
0BEB 756900    1353       mov Current_State, #0
0BEE           1354       
0BEE           1355       ; FSM timers initialization
0BEE 756400    1356       mov KEY1_DEB_timer, #0
0BF1 756500    1357       mov SEC_FSM_timer, #0
0BF4           1358       ; time counters initialization
0BF4 753000    1359       mov current_time_sec, #0
0BF7 753100    1360       mov current_time_minute, #0
0BFA           1361       ; Initialize counter to zero
0BFA 756000    1362       mov pwm_counter, #0
0BFD 756100    1363       mov pwm_counter+1, #0
0C00 756200    1364       mov pwm_counter+2, #0
0C03 756300    1365       mov pwm_counter+3, #0
0C06           1366       ; Initialize power output
0C06 755F00    1367       mov power_output+3, #0
0C09 755E00    1368       mov power_output+2, #0
0C0C 755D02    1369       mov power_output+1, #02H
0C0F 755CEE    1370       mov power_output, #0EEH ; (initilize to 750 for testing)
0C12           1371   
0C12           1372       ; Clear all the flags
0C12 C20E      1373       clr  tc_missing_abort
0C14 C209      1374       clr  stop_signal
0C16 C210      1375       clr PB0_flag
0C18 C211      1376       clr PB1_flag
0C1A C212      1377       clr PB2_flag
0C1C C201      1378       clr one_second_flag
0C1E C20B      1379       clr config_finish_signal
0C20 C203      1380       clr soak_temp_reached
0C22 C206      1381       clr soak_time_reached
0C24 C204      1382       clr reflow_temp_reached
0C26 C207      1383       clr reflow_time_reached
0C28 C205      1384       clr cooling_temp_reached
0C2A C20C      1385       clr state_change_signal
0C2C C21E      1386       clr one_millisecond_flag_servo
0C2E           1387       
0C2E D20C      1388       setb state_change_signal
0C30           1389   
0C30           1390       ; Set bit
0C30 D20F      1391       setb tc_startup_window
0C32           1392   
0C32           1393       ; --------------------------------------
0C32           1394       ; [FIX] ADD THIS BLOCK TO STOP STARTUP BEEP
0C32           1395       ; --------------------------------------
0C32 757400    1396       mov beep_state, #0
0C35 757300    1397       mov beep_count, #0
0C38 757500    1398       mov beep_tmr, #0
0C3B 757600    1399       mov beep_tmr+1, #0
0C3E C213      1400       clr one_ms_beep_flag
0C40 C28C      1401       clr TR0              ; Force buzzer hardware OFF
0C42           1402       ; --------------------------------------
0C42           1403   
0C42           1404   
0C42 12045D    1405       lcall Timer0_Init
0C45 120518    1406       lcall Timer2_Init
0C48 1205E5    1407       lcall ELCD_4BIT
0C4B           1408       ;----- Two new lines I added to initialize the UI
0C4B 120EAF    1409       lcall Init_All_Buffers
0C4E 120F02    1410       lcall Update_Screen_Full
0C51           1411       ;-----
0C51 120477    1412       lcall Initialize_Serial_Port
0C54           1413   ;-------------------------------------------------------------------------------;
0C54           1414   ; while(1) loop
0C54           1415   ;-------------------------------------------------------------------------------;
0C54           1416   loop:
0C54           1417       ; Full reset button on P3.7 (active-low to GND)
0C54 30B702    1418        jnb P3_7, Full_Reset_Trig
0C57 8003      1419       sjmp Full_Reset_Check_Done
0C59           1420   
0C59           1421   Full_Reset_Trig:
0C59 02102C    1422       ljmp Full_Reset
0C5C           1423   
0C5C           1424   Full_Reset_Check_Done:
0C5C           1425       ; Check the FSM for KEY1 debounce
0C5C 120886    1426       lcall KEY1_DEB
0C5F           1427       
0C5F           1428       ; Added to take temp readings
0C5F 121032    1429       lcall Read_Thermocouple
0C62           1430       
0C62           1431       ; 1. Check if we reached temp (Observer)
0C62 120989    1432       lcall Temp_Compare
0C65           1433       
0C65           1434       ; 2. Decide heater power based on flags (Driver)
0C65           1435       ;lcall Power_Control
0C65 121174    1436       lcall proportaional_power_control
0C68           1437   
0C68           1438       ; 3. [FIX] Calculate Total Seconds (Minutes * 60 + Seconds)
0C68           1439       ; ---------------------------------------------------------
0C68           1440       ; Load Minutes into X
0C68 853132    1441       mov x+0, current_time_minute
0C6B 753300    1442       mov x+1, #0
0C6E 753400    1443       mov x+2, #0
0C71 753500    1444       mov x+3, #0
0C74           1445       
0C74           1446       ; Multiply by 60 (Minutes -> Seconds)
0C74 75363C    1447            mov y+0, #low (60 % 0x10000) 
0C77 753700    1447            mov y+1, #high(60 % 0x10000) 
0C7A 753800    1447            mov y+2, #low (60 / 0x10000) 
0C7D 753900    1447            mov y+3, #high(60 / 0x10000) 
0C80 12018C    1448       lcall mul32
0C83           1449       
0C83           1450       ; Load Seconds into Y
0C83 853036    1451       mov y+0, current_time_sec
0C86 753700    1452       mov y+1, #0
0C89 753800    1453       mov y+2, #0
0C8C 753900    1454       mov y+3, #0
0C8F           1455       
0C8F           1456       ; Add them together (Total Seconds = X + Y)
0C8F 1200D3    1457       lcall add32
0C92           1458       
0C92           1459       ; Store Final Result into 'current_time'
0C92 853250    1460       mov current_time+0, x+0
0C95 853351    1461       mov current_time+1, x+1
0C98 853452    1462       mov current_time+2, x+2
0C9B 853553    1463       mov current_time+3, x+3
0C9E           1464       
0C9E 1209CE    1465       lcall Time_Compare
0CA1           1466       
0CA1 120A18    1467       lcall Safety_Check_TC
0CA4           1468   
0CA4           1469   
0CA4           1470       ; Check the FSM for one second counter
0CA4 1208BC    1471       lcall SEC_FSM
0CA7           1472   
0CA7           1473       ; Check the FSM for the overall control flow of the reflow process
0CA7 120ADA    1474       lcall Control_FSM
0CAA           1475   
0CAA           1476       ; Update the LCD display based on the current state
0CAA 1206AA    1477       lcall LCD_Display_Update_func
0CAD           1478   
0CAD 300202    1479       jnb one_ms_pwm_flag, Skip_Beep_Sync
0CB0 D213      1480       setb one_ms_beep_flag  ; Give the buzzer its own copy of the time tick
0CB2           1481   
0CB2           1482   Skip_Beep_Sync:
0CB2           1483       ; Update the pwm output for the ssr
0CB2 120912    1484       lcall PWM_Wave 
0CB5           1485            ; Update the Buzzer 
0CB5 120AA1    1486            lcall Beep_Task
0CB8           1487       ; Update the pwm output for the servo
0CB8 121107    1488       lcall call_servo_control
0CBB           1489       ; After initialization the program stays in this 'forever' loop
0CBB 020C54    1490       ljmp loop
0CBE           1491   ;-------------------------------------------------------------------------------;
0CBE           1492   
0CBE           1493   ; ================================================================
0CBE           1494   ; UI & HELPER SUBROUTINES
0CBE           1495   ; ================================================================
0CBE           1496   
0CBE           1497   ; ----------------------------------------------------------------
0CBE           1498   ; MODULE: BRIDGE (Text to Integer Conversion)
0CBE           1499   ; ----------------------------------------------------------------
0CBE           1500   Update_FSM_Variables:
0CBE           1501       ; --- 1. SOAK TEMP ---
0CBE 7880      1502       mov R0, #Buf_Soak_Temp
0CC0 120CFD    1503       lcall Parse_Temp_String
0CC3 8F43      1504       mov soak_temp+0, R7
0CC5 754400    1505       mov soak_temp+1, #0
0CC8 754500    1506       mov soak_temp+2, #0
0CCB 754600    1507       mov soak_temp+3, #0
0CCE           1508   
0CCE           1509       ; --- 2. REFLOW TEMP ---
0CCE 7889      1510       mov R0, #Buf_Refl_Temp
0CD0 120CFD    1511       lcall Parse_Temp_String
0CD3 8F47      1512       mov reflow_temp+0, R7
0CD5 754800    1513       mov reflow_temp+1, #0
0CD8 754900    1514       mov reflow_temp+2, #0
0CDB 754A00    1515       mov reflow_temp+3, #0
0CDE           1516   
0CDE           1517       ; --- 3. SOAK TIME ---
0CDE 7884      1518       mov R0, #Buf_Soak_Time
0CE0 120D11    1519       lcall Parse_Time_String
0CE3 8F54      1520       mov soak_time+0, R7
0CE5 8E55      1521       mov soak_time+1, R6
0CE7 755600    1522       mov soak_time+2, #0
0CEA 755700    1523       mov soak_time+3, #0
0CED           1524   
0CED           1525       ; --- 4. REFLOW TIME ---
0CED 788D      1526       mov R0, #Buf_Refl_Time
0CEF 120D11    1527       lcall Parse_Time_String
0CF2 8F58      1528       mov reflow_time+0, R7
0CF4 8E59      1529       mov reflow_time+1, R6
0CF6 755A00    1530       mov reflow_time+2, #0
0CF9 755B00    1531       mov reflow_time+3, #0
0CFC 22        1532       ret
0CFD           1533   
0CFD           1534   ; --- Helper: Parse "123" to Integer ---
0CFD           1535   Parse_Temp_String:
0CFD 7F00      1536       mov R7, #0              ; Clear Result
0CFF           1537   Parse_Temp_Loop:
0CFF E6        1538       mov A, @R0
0D00 600E      1539       jz Parse_Temp_Done      ; If Null, we are done
0D02           1540       
0D02           1541       ; Convert ASCII to Digit
0D02 C3        1542       clr C
0D03 9430      1543       subb A, #0x30
0D05 FD        1544       mov R5, A               ; R5 = New Digit
0D06           1545       
0D06           1546       ; Result = (Result * 10) + New Digit
0D06 EF        1547       mov A, R7
0D07 75F00A    1548       mov B, #10
0D0A A4        1549       mul AB
0D0B 2D        1550       add A, R5
0D0C FF        1551       mov R7, A
0D0D           1552       
0D0D 08        1553       inc R0
0D0E 80EF      1554       sjmp Parse_Temp_Loop
0D10           1555   Parse_Temp_Done:
0D10 22        1556       ret
0D11           1557   
0D11           1558   ; --- Helper: Parse "MMSS" to Seconds ---
0D11           1559   Parse_Time_String:
0D11           1560       ; 1. Minutes Tens
0D11 E6        1561       mov A, @R0
0D12 9430      1562       subb A, #0x30
0D14 75F00A    1563       mov B, #10
0D17 A4        1564       mul AB
0D18 FD        1565       mov R5, A
0D19 08        1566       inc R0
0D1A           1567       
0D1A           1568       ; 2. Minutes Ones
0D1A E6        1569       mov A, @R0
0D1B 9430      1570       subb A, #0x30
0D1D 2D        1571       add A, R5
0D1E FD        1572       mov R5, A               ; R5 = Total Minutes
0D1F 08        1573       inc R0
0D20           1574       
0D20           1575       ; 3. Seconds Tens
0D20 E6        1576       mov A, @R0
0D21 9430      1577       subb A, #0x30
0D23 75F00A    1578       mov B, #10
0D26 A4        1579       mul AB
0D27 FC        1580       mov R4, A
0D28 08        1581       inc R0
0D29           1582       
0D29           1583       ; 4. Seconds Ones
0D29 E6        1584       mov A, @R0
0D2A 9430      1585       subb A, #0x30
0D2C 2C        1586       add A, R4               ; R4 = Total Seconds
0D2D           1587       
0D2D           1588       ; 5. Calculate Total Seconds = (Mins * 60) + Secs
0D2D ED        1589       mov A, R5
0D2E 75F03C    1590       mov B, #60
0D31 A4        1591       mul AB
0D32 2C        1592       add A, R4
0D33 FF        1593       mov R7, A               ; Low Byte
0D34 E5F0      1594       mov A, B
0D36 3400      1595       addc A, #0
0D38 FE        1596       mov R6, A               ; High Byte
0D39 22        1597       ret
0D3A           1598   
0D3A           1599   ; ----------------------------------------------------------------
0D3A           1600   ; MODULE: BUTTON HANDLER (Mode Selection)
0D3A           1601   ; ----------------------------------------------------------------
0D3A           1602   Check_Buttons:
0D3A           1603       ; --- FORCE INPUT MODE ---
0D3A           1604       ; This clears any '0' the LCD library might have written to our buttons
0D3A 438055    1605       orl P0, #055H   ; Sets P0.0, P0.2, P0.4, and P0.6 to '1' (Input Mode)
0D3D           1606       ; ------------------------
0D3D           1607   
0D3D 30800A    1608       jnb BTN_SOAK_TEMP, Btn_Soak_Temp_Press
0D40 308212    1609       jnb BTN_SOAK_TIME, Btn_Soak_Time_Press
0D43 30841A    1610       jnb BTN_REFL_TEMP, Btn_Refl_Temp_Press
0D46 308622    1611       jnb BTN_REFL_TIME, Btn_Refl_Time_Press
0D49 22        1612       ret
0D4A           1613   
0D4A           1614   Btn_Soak_Temp_Press:
0D4A 120FF4    1615       lcall Wait_25ms_BLOCKING
0D4D 756901    1616       mov Current_State, #1
0D50 757200    1617       mov Cursor_Idx, #0
0D53 8021      1618       sjmp Redraw_Screen
0D55           1619   
0D55           1620   Btn_Soak_Time_Press:
0D55 120FF4    1621       lcall Wait_25ms_BLOCKING
0D58 756902    1622       mov Current_State, #2
0D5B 757200    1623       mov Cursor_Idx, #0
0D5E 8016      1624       sjmp Redraw_Screen
0D60           1625   
0D60           1626   Btn_Refl_Temp_Press:
0D60 120FF4    1627       lcall Wait_25ms_BLOCKING
0D63 756903    1628       mov Current_State, #3
0D66 757200    1629       mov Cursor_Idx, #0
0D69 800B      1630       sjmp Redraw_Screen
0D6B           1631   
0D6B           1632   Btn_Refl_Time_Press:
0D6B 120FF4    1633       lcall Wait_25ms_BLOCKING 
0D6E 756904    1634       mov Current_State, #4
0D71 757200    1635       mov Cursor_Idx, #0
0D74 8000      1636       sjmp Redraw_Screen
0D76           1637   
0D76           1638   Redraw_Screen:
0D76           1639       ; Wait for button release
0D76 3080FD    1640       jnb BTN_SOAK_TEMP, $
0D79 3082FD    1641       jnb BTN_SOAK_TIME, $
0D7C 3084FD    1642       jnb BTN_REFL_TEMP, $
0D7F 3086FD    1643       jnb BTN_REFL_TIME, $
0D82           1644   
0D82 120F02    1645       lcall Update_Screen_Full
0D85 22        1646       ret
0D86           1647   
0D86           1648   ; ----------------------------------------------------------------
0D86           1649   ; MODULE: KEYPAD HANDLER (Input Logic)
0D86           1650   ; ----------------------------------------------------------------
0D86           1651   Check_Keypad:
0D86           1652       ; If State is 0 (Home), ignore keypad
0D86 E569      1653       mov A, Current_State
0D88 6050      1654       jz Keypad_Exit
0D8A           1655       
0D8A 120DDB    1656       lcall Keypad_Scan
0D8D 504B      1657       jnc Keypad_Exit         ; Carry = 0 means no key pressed
0D8F           1658   
0D8F           1659       ; --- Check Special Keys ---
0D8F EF        1660       mov A, R7
0D90 B40E0A    1661       cjne A, #14, Check_Hash ; 14 is Star (*)
0D93           1662       
0D93           1663       ; Star Key Pressed: Reset Buffer
0D93 120EDF    1664       lcall Reset_Current_Buffer
0D96 120F02    1665       lcall Update_Screen_Full
0D99 757200    1666       mov Cursor_Idx, #0
0D9C 22        1667       ret
0D9D           1668   
0D9D           1669   Check_Hash:
0D9D EF        1670       mov A, R7
0D9E B40C01    1671       cjne A, #12, Check_Numeric ; 12 is Hash (#)
0DA1 22        1672       ret                     ; Ignore Hash key
0DA2           1673   
0DA2           1674   Check_Numeric:
0DA2           1675       ; Ensure key is 0-9
0DA2 EF        1676       mov A, R7
0DA3 C3        1677       clr C
0DA4 940A      1678       subb A, #10
0DA6 5031      1679       jnc Symbol_Key_Ignored
0DA8           1680       
0DA8           1681       ; Convert to ASCII
0DA8 EF        1682       mov A, R7
0DA9 2430      1683       add A, #0x30
0DAB FD        1684       mov R5, A
0DAC           1685   
0DAC           1686       ; Save to Buffer
0DAC 12100D    1687       lcall Get_Current_Buffer_Addr
0DAF E572      1688       mov A, Cursor_Idx
0DB1 28        1689       add A, R0
0DB2 F8        1690       mov R0, A
0DB3 ED        1691       mov A, R5
0DB4 F6        1692       mov @R0, A
0DB5 0572      1693       inc Cursor_Idx
0DB7           1694   
0DB7           1695       ; --- Check Cursor Limits ---
0DB7 E569      1696       mov A, Current_State
0DB9 B40102    1697       cjne A, #1, Check_Limit_Time_1
0DBC 8005      1698       sjmp Limit_Temp_3
0DBE           1699   
0DBE           1700   Check_Limit_Time_1:
0DBE B4030B    1701       cjne A, #3, Limit_Time_4
0DC1 8000      1702       sjmp Limit_Temp_3
0DC3           1703   
0DC3           1704   Limit_Temp_3:
0DC3 E572      1705       mov A, Cursor_Idx
0DC5 B4030D    1706       cjne A, #3, Do_Refresh
0DC8 1572      1707       dec Cursor_Idx          ; Stay at last digit
0DCA 8009      1708       sjmp Do_Refresh
0DCC           1709   
0DCC           1710   Limit_Time_4:
0DCC E572      1711       mov A, Cursor_Idx
0DCE B40404    1712       cjne A, #4, Do_Refresh
0DD1 1572      1713       dec Cursor_Idx          ; Stay at last digit
0DD3 8000      1714       sjmp Do_Refresh
0DD5           1715   
0DD5           1716   Do_Refresh:
0DD5 120F02    1717       lcall Update_Screen_Full
0DD8 22        1718       ret
0DD9           1719   
0DD9           1720   Symbol_Key_Ignored:
0DD9 22        1721       ret
0DDA           1722   Keypad_Exit:
0DDA 22        1723       ret
0DDB           1724   
0DDB           1725   ; ----------------------------------------------------------------
0DDB           1726   ; MODULE: HARDWARE SCANNER (Matrix Logic)
0DDB           1727   ; ----------------------------------------------------------------
0DDB           1728   Keypad_Scan:
0DDB           1729       ; Step 1: Check if ANY key is pressed (All Rows Low)
0DDB C292      1730       clr ROW1
0DDD C294      1731       clr ROW2
0DDF C296      1732       clr ROW3
0DE1 C2A0      1733       clr ROW4
0DE3 A2A2      1734       mov C, COL1
0DE5 82A4      1735       anl C, COL2
0DE7 82A6      1736       anl C, COL3
0DE9 82B0      1737       anl C, COL4
0DEB 5002      1738       jnc Keypad_Debounce
0DED C3        1739       clr C
0DEE 22        1740       ret
0DEF           1741   
0DEF           1742   Keypad_Debounce:
0DEF 120FF4    1743       lcall Wait_25ms_BLOCKING
0DF2 A2A2      1744       mov C, COL1
0DF4 82A4      1745       anl C, COL2
0DF6 82A6      1746       anl C, COL3
0DF8 82B0      1747       anl C, COL4
0DFA 5002      1748       jnc Keypad_Find_Row
0DFC C3        1749       clr C
0DFD 22        1750       ret
0DFE           1751   
0DFE           1752   Keypad_Find_Row:
0DFE D292      1753       setb ROW1
0E00 D294      1754       setb ROW2
0E02 D296      1755       setb ROW3
0E04 D2A0      1756       setb ROW4
0E06           1757   
0E06           1758       ; Row 1
0E06 C292      1759       clr ROW1
0E08 30A23D    1760       jnb COL1, Keypad_Key_1
0E0B 30A43E    1761       jnb COL2, Keypad_Key_2
0E0E 30A63F    1762       jnb COL3, Keypad_Key_3
0E11 30B040    1763       jnb COL4, Keypad_Key_A
0E14 D292      1764       setb ROW1
0E16           1765   
0E16           1766       ; Row 2
0E16 C294      1767       clr ROW2
0E18 30A23D    1768       jnb COL1, Keypad_Key_4
0E1B 30A43E    1769       jnb COL2, Keypad_Key_5
0E1E 30A63F    1770       jnb COL3, Keypad_Key_6
0E21 30B040    1771       jnb COL4, Keypad_Key_B
0E24 D294      1772       setb ROW2
0E26           1773   
0E26           1774       ; Row 3
0E26 C296      1775       clr ROW3
0E28 30A23D    1776       jnb COL1, Keypad_Key_7
0E2B 30A43E    1777       jnb COL2, Keypad_Key_8
0E2E 30A63F    1778       jnb COL3, Keypad_Key_9
0E31 30B040    1779       jnb COL4, Keypad_Key_C
0E34 D296      1780       setb ROW3
0E36           1781   
0E36           1782       ; Row 4
0E36 C2A0      1783       clr ROW4
0E38 30A23D    1784       jnb COL1, Keypad_Key_Star
0E3B 30A43E    1785       jnb COL2, Keypad_Key_0
0E3E 30A63F    1786       jnb COL3, Keypad_Key_Hash
0E41 30B040    1787       jnb COL4, Keypad_Key_D
0E44 D2A0      1788       setb ROW4
0E46 C3        1789       clr C
0E47 22        1790       ret
0E48           1791   
0E48           1792   ; Key Mapping (Renamed to avoid conflicts)
0E48 7F01      1793   Keypad_Key_1: mov R7, #1
0E4A 803C      1794          sjmp Wait_Release
0E4C 7F02      1795   Keypad_Key_2: mov R7, #2
0E4E 8038      1796          sjmp Wait_Release
0E50 7F03      1797   Keypad_Key_3: mov R7, #3
0E52 8034      1798          sjmp Wait_Release
0E54 7F0A      1799   Keypad_Key_A: mov R7, #10
0E56 8030      1800          sjmp Wait_Release
0E58 7F04      1801   Keypad_Key_4: mov R7, #4
0E5A 802C      1802          sjmp Wait_Release
0E5C 7F05      1803   Keypad_Key_5: mov R7, #5
0E5E 8028      1804          sjmp Wait_Release
0E60 7F06      1805   Keypad_Key_6: mov R7, #6
0E62 8024      1806          sjmp Wait_Release
0E64 7F0B      1807   Keypad_Key_B: mov R7, #11
0E66 8020      1808          sjmp Wait_Release
0E68 7F07      1809   Keypad_Key_7: mov R7, #7
0E6A 801C      1810          sjmp Wait_Release
0E6C 7F08      1811   Keypad_Key_8: mov R7, #8
0E6E 8018      1812          sjmp Wait_Release
0E70 7F09      1813   Keypad_Key_9: mov R7, #9
0E72 8014      1814          sjmp Wait_Release
0E74 7F0D      1815   Keypad_Key_C: mov R7, #13
0E76 8010      1816          sjmp Wait_Release
0E78 7F0E      1817   Keypad_Key_Star: mov R7, #14
0E7A 800C      1818          sjmp Wait_Release
0E7C 7F00      1819   Keypad_Key_0: mov R7, #0
0E7E 8008      1820          sjmp Wait_Release
0E80 7F0C      1821   Keypad_Key_Hash: mov R7, #12
0E82 8004      1822          sjmp Wait_Release
0E84 7F0F      1823   Keypad_Key_D: mov R7, #15
0E86 8000      1824          sjmp Wait_Release
0E88           1825   
0E88           1826   Wait_Release:
0E88 A2A2      1827       mov C, COL1
0E8A 82A4      1828       anl C, COL2
0E8C 82A6      1829       anl C, COL3
0E8E 82B0      1830       anl C, COL4
0E90 50F6      1831       jnc Wait_Release
0E92 D3        1832       setb C
0E93 D292      1833       setb ROW1
0E95 D294      1834       setb ROW2
0E97 D296      1835       setb ROW3
0E99 D2A0      1836       setb ROW4
0E9B 22        1837       ret
0E9C           1838   
0E9C           1839   Wait_25ms:
0E9C           1840       ; 1. Check if we are already waiting
0E9C 20140E    1841       jb wait25_active, Check_Timer_Status
0E9F           1842       
0E9F           1843       ; 2. Check if we just finished
0E9F 301504    1844       jnb wait25_done, Start_New_Timer
0EA2           1845       
0EA2           1846       ; 3. Timer is DONE! Reset flags and return True
0EA2 C215      1847       clr wait25_done
0EA4 D3        1848       setb C          ; Carry = 1 means "Done"
0EA5 22        1849       ret
0EA6           1850   
0EA6           1851   Start_New_Timer:
0EA6           1852       ; 4. Start a new 25ms wait
0EA6 754F00    1853       mov wait25_count, #0
0EA9 D214      1854       setb wait25_active
0EAB C3        1855       clr C           ; Carry = 0 means "Not Done Yet"
0EAC 22        1856       ret
0EAD           1857   
0EAD           1858   Check_Timer_Status:
0EAD           1859       ; 5. Still waiting... return False immediately
0EAD C3        1860       clr C           ; Carry = 0 means "Not Done Yet"
0EAE 22        1861       ret
0EAF           1862   
0EAF           1863   ; ----------------------------------------------------------------
0EAF           1864   ; MODULE: BUFFER INIT (Reset Logic)
0EAF           1865   ; ----------------------------------------------------------------
0EAF           1866   Init_All_Buffers:
0EAF 7880      1867       mov R0, #Buf_Soak_Temp
0EB1 120EC4    1868       lcall Init_Temp_Template
0EB4 7889      1869       mov R0, #Buf_Refl_Temp
0EB6 120EC4    1870       lcall Init_Temp_Template
0EB9 7884      1871       mov R0, #Buf_Soak_Time
0EBB 120ED0    1872       lcall Init_Time_Template
0EBE 788D      1873       mov R0, #Buf_Refl_Time
0EC0 120ED0    1874       lcall Init_Time_Template
0EC3 22        1875       ret
0EC4           1876   
0EC4           1877   Init_Temp_Template:
0EC4 7630      1878       mov @R0, #'0'
0EC6 08        1879       inc R0
0EC7 7630      1880       mov @R0, #'0'
0EC9 08        1881       inc R0
0ECA 7630      1882       mov @R0, #'0'
0ECC 08        1883       inc R0
0ECD 7600      1884       mov @R0, #0
0ECF 22        1885       ret
0ED0           1886   
0ED0           1887   Init_Time_Template:
0ED0 7630      1888       mov @R0, #'0'
0ED2 08        1889       inc R0
0ED3 7630      1890       mov @R0, #'0'
0ED5 08        1891       inc R0
0ED6 7630      1892       mov @R0, #'0'
0ED8 08        1893       inc R0
0ED9 7630      1894       mov @R0, #'0'
0EDB 08        1895       inc R0
0EDC 7600      1896       mov @R0, #0
0EDE 22        1897       ret
0EDF           1898   
0EDF           1899   Reset_Current_Buffer:
0EDF E569      1900       mov A, Current_State
0EE1 B40106    1901       cjne A, #1, Reset_Chk_2
0EE4 7880      1902       mov R0, #Buf_Soak_Temp
0EE6 120EC4    1903       lcall Init_Temp_Template
0EE9 22        1904       ret
0EEA           1905   Reset_Chk_2:
0EEA B40206    1906       cjne A, #2, Reset_Chk_3
0EED 7884      1907       mov R0, #Buf_Soak_Time
0EEF 120ED0    1908       lcall Init_Time_Template
0EF2 22        1909       ret
0EF3           1910   Reset_Chk_3:
0EF3 B40306    1911       cjne A, #3, Reset_Chk_4
0EF6 7889      1912       mov R0, #Buf_Refl_Temp
0EF8 120EC4    1913       lcall Init_Temp_Template
0EFB 22        1914       ret
0EFC           1915   Reset_Chk_4:
0EFC 788D      1916       mov R0, #Buf_Refl_Time
0EFE 120ED0    1917       lcall Init_Time_Template
0F01 22        1918       ret
0F02           1919   
0F02           1920   ; ----------------------------------------------------------------
0F02           1921   ; MODULE: SCREEN UPDATE (Visual Logic)
0F02           1922   ; ----------------------------------------------------------------
0F02           1923   Update_Screen_Full:
0F02 120FFA    1924       lcall Clear_Screen_Func
0F05 C0E0      1925            push acc
0F07 7401      1925            mov a, #1
0F09 14        1925            dec a
0F0A 120625    1925            lcall ?Set_Cursor_1 ; Select column and row
0F0D D0E0      1925            pop acc
0F0F           1926   
0F0F           1927       ; --- Draw Line 1 (Titles) ---
0F0F E569      1928       mov A, Current_State
0F11 B40013    1929       cjne A, #0, Update_State_1
0F14 C083      1930            push dph
0F16 C082      1930            push dpl
0F18 C0E0      1930            push acc
0F1A 900350    1930            mov dptr, #Txt_Home
0F1D 120618    1930            lcall ?Send_Constant_String
0F20 D0E0      1930            pop acc
0F22 D082      1930            pop dpl
0F24 D083      1930            pop dph
0F26 22        1931       ret 
0F27           1932   Update_State_1:
0F27 B40114    1933       cjne A, #1, Update_State_2
0F2A C083      1934            push dph
0F2C C082      1934            push dpl
0F2E C0E0      1934            push acc
0F30 900361    1934            mov dptr, #Txt_SoakT
0F33 120618    1934            lcall ?Send_Constant_String
0F36 D0E0      1934            pop acc
0F38 D082      1934            pop dpl
0F3A D083      1934            pop dph
0F3C 8042      1935       sjmp Draw_Temp_Format
0F3E           1936   Update_State_2:
0F3E B40214    1937       cjne A, #2, Update_State_3
0F41 C083      1938            push dph
0F43 C082      1938            push dpl
0F45 C0E0      1938            push acc
0F47 900372    1938            mov dptr, #Txt_SoakTime
0F4A 120618    1938            lcall ?Send_Constant_String
0F4D D0E0      1938            pop acc
0F4F D082      1938            pop dpl
0F51 D083      1938            pop dph
0F53 8042      1939       sjmp Draw_Time_Format
0F55           1940   Update_State_3:
0F55 B40314    1941       cjne A, #3, Update_State_4
0F58 C083      1942            push dph
0F5A C082      1942            push dpl
0F5C C0E0      1942            push acc
0F5E 900383    1942            mov dptr, #Txt_ReflT
0F61 120618    1942            lcall ?Send_Constant_String
0F64 D0E0      1942            pop acc
0F66 D082      1942            pop dpl
0F68 D083      1942            pop dph
0F6A 8014      1943       sjmp Draw_Temp_Format
0F6C           1944   Update_State_4:
0F6C C083      1945            push dph
0F6E C082      1945            push dpl
0F70 C0E0      1945            push acc
0F72 900394    1945            mov dptr, #Txt_ReflTime
0F75 120618    1945            lcall ?Send_Constant_String
0F78 D0E0      1945            pop acc
0F7A D082      1945            pop dpl
0F7C D083      1945            pop dph
0F7E 8017      1946       sjmp Draw_Time_Format
0F80           1947   
0F80           1948   ; --- Draw Line 2 (Values) ---
0F80           1949   Draw_Temp_Format:
0F80 C0E0      1950            push acc
0F82 7401      1950            mov a, #1
0F84 14        1950            dec a
0F85 120623    1950            lcall ?Set_Cursor_2 ; Select column and row
0F88 D0E0      1950            pop acc
0F8A 12100D    1951       lcall Get_Current_Buffer_Addr
0F8D 120FEA    1952       lcall Print_String_RAM
0F90 7443      1953       mov A, #'C'
0F92 1205DB    1954       lcall ?WriteData
0F95 8027      1955       sjmp Restore_Cursor
0F97           1956   
0F97           1957   Draw_Time_Format:
0F97 C0E0      1958            push acc
0F99 7401      1958            mov a, #1
0F9B 14        1958            dec a
0F9C 120623    1958            lcall ?Set_Cursor_2 ; Select column and row
0F9F D0E0      1958            pop acc
0FA1 12100D    1959       lcall Get_Current_Buffer_Addr
0FA4           1960       ; MM
0FA4 E6        1961       mov A, @R0
0FA5 1205DB    1962       lcall ?WriteData
0FA8 08        1963       inc R0
0FA9 E6        1964       mov A, @R0
0FAA 1205DB    1965       lcall ?WriteData
0FAD 08        1966       inc R0
0FAE           1967       ; Colon
0FAE 743A      1968       mov A, #':'
0FB0 1205DB    1969       lcall ?WriteData
0FB3           1970       ; SS
0FB3 E6        1971       mov A, @R0
0FB4 1205DB    1972       lcall ?WriteData
0FB7 08        1973       inc R0
0FB8 E6        1974       mov A, @R0
0FB9 1205DB    1975       lcall ?WriteData
0FBC           1976       ; Unit
0FBC           1977       ;got rid of the "s"
0FBC           1978       ;mov A, #'s'
0FBC           1979       ;lcall ?WriteData
0FBC 8000      1980       sjmp Restore_Cursor
0FBE           1981   
0FBE           1982   ; --- Restore Cursor Position ---
0FBE           1983   Restore_Cursor:
0FBE E569      1984       mov A, Current_State
0FC0 B40202    1985       cjne A, #2, RC_Check_State_4  
0FC3 800D      1986       sjmp Adjust_Cursor_Time
0FC5           1987   RC_Check_State_4:             
0FC5 B40402    1988       cjne A, #4, Normal_Cursor
0FC8 8008      1989       sjmp Adjust_Cursor_Time
0FCA           1990   
0FCA           1991   Normal_Cursor:
0FCA E572      1992       mov A, Cursor_Idx
0FCC 24C0      1993       add A, #0xC0
0FCE 1205E0    1994       lcall ?WriteCommand
0FD1 22        1995       ret
0FD2           1996   
0FD2           1997   Adjust_Cursor_Time:
0FD2           1998       ; Skip the colon index (2)
0FD2 E572      1999       mov A, Cursor_Idx
0FD4 B40201    2000       cjne A, #2, No_Skip
0FD7 04        2001       inc A 
0FD8           2002   No_Skip:
0FD8           2003       ; Add 1 if past the colon
0FD8 C3        2004       clr C
0FD9 9402      2005       subb A, #2
0FDB 4005      2006       jc No_Add
0FDD E572      2007       mov A, Cursor_Idx
0FDF 04        2008       inc A
0FE0 8002      2009       sjmp Final_Cursor_Set
0FE2           2010   No_Add:
0FE2 E572      2011       mov A, Cursor_Idx
0FE4           2012   Final_Cursor_Set:
0FE4 24C0      2013       add A, #0xC0
0FE6 1205E0    2014       lcall ?WriteCommand
0FE9 22        2015       ret
0FEA           2016   
0FEA           2017   Print_String_RAM:
0FEA E6        2018       mov A, @R0
0FEB 6006      2019       jz Print_String_Done
0FED 1205DB    2020       lcall ?WriteData
0FF0 08        2021       inc R0
0FF1 80F7      2022       sjmp Print_String_RAM
0FF3           2023   Print_String_Done:
0FF3 22        2024       ret
0FF4           2025   
0FF4           2026   ; Blocking wrapper for LCD clear (keeps old behavior just for this)
0FF4           2027   Wait_25ms_BLOCKING:
0FF4 120E9C    2028       lcall Wait_25ms
0FF7 50FB      2029       jnc Wait_25ms_BLOCKING ; Keep jumping back until Done (C=1)
0FF9 22        2030       ret
0FFA           2031   
0FFA           2032   Clear_Screen_Func:
0FFA 7401      2033       mov A, #0x01
0FFC 1205E0    2034       lcall ?WriteCommand
0FFF           2035       
0FFF           2036       ; --- FIX: HARDWARE DELAY LOOP (MAX STRENGTH) ---
0FFF           2037       ; The LCD needs ~2ms to clear. 
0FFF           2038       ; We use R0=255 to guarantee ~5ms+ delay.
0FFF           2039       ; This ensures the LCD is 100% ready before we send "Ramp to Soak".
0FFF 78FF      2040       mov R0, #255
1001           2041   Clear_Delay_Loop_Outer:
1001 79FF      2042       mov R1, #255
1003           2043   Clear_Delay_Loop_Inner:
1003 D9FE      2044       djnz R1, Clear_Delay_Loop_Inner
1005 D8FA      2045       djnz R0, Clear_Delay_Loop_Outer
1007           2046       ; -----------------------------------------------
1007           2047   
1007 740C      2048       mov A, #0x0C  ; Display ON, Cursor OFF
1009 1205E0    2049       lcall ?WriteCommand
100C 22        2050       ret
100D           2051   
100D           2052   Get_Current_Buffer_Addr:
100D E569      2053       mov A, Current_State
100F B40103    2054       cjne A, #1, Get_Buf_2
1012 7880      2055       mov R0, #Buf_Soak_Temp
1014 22        2056       ret
1015           2057   Get_Buf_2:
1015 B40203    2058       cjne A, #2, Get_Buf_3
1018 7884      2059       mov R0, #Buf_Soak_Time
101A 22        2060       ret
101B           2061   Get_Buf_3:
101B B40303    2062       cjne A, #3, Get_Buf_4
101E 7889      2063       mov R0, #Buf_Refl_Temp
1020 22        2064       ret
1021           2065   Get_Buf_4:
1021 788D      2066       mov R0, #Buf_Refl_Time
1023 22        2067       ret
1024           2068       
1024           2069   ; --- Helper to prevent "Machine Gun" button presses ---
1024           2070   Wait_For_P1_0_Release:
1024 3090FD    2071       jnb P1.0, $    ; Wait here while the button is still pressed (0)
1027 22        2072       ret
1028           2073   
1028           2074   ; --- Full reset helper for P3.7 (active-low) ---
1028           2075   Wait_For_P3_7_Release:
1028 30B7FD    2076       jnb P3_7, $    ; Wait here while the button is still pressed (0)
102B 22        2077       ret
102C           2078   
102C           2079   Full_Reset:
102C 121028    2080       lcall Wait_For_P3_7_Release
102F 020BC1    2081       ljmp main
1032           2082   
1032           2083   ; ================================================================
1032           2084   ; MODULE: THERMOCOUPLE ADC DRIVER (WITH NOISE SUPPRESSION & JUMP FIX)
1032           2085   ; ================================================================
1032           2086   Read_Thermocouple:
1032           2087       ; 1. Check Non-Blocking Timer
1032 120E9C    2088       lcall Wait_25ms
1035           2089       
1035           2090       ; [FIX] TRAMPOLINE JUMP
1035           2091       ; "jnc" cannot jump to the end because the code is too long.
1035           2092       ; We invert logic: If Carry=1 (Time is up), Jump NEARBY.
1035 4001      2093       jc Proceed_Reading
1037 22        2094       ret  ; If Carry=0, Return immediately.
1038           2095   
1038           2096   Proceed_Reading:
1038           2097       ; --- 25ms Passed! Time to Read ---
1038           2098   
1038           2099       ; [FIX] SILENCE THE BUZZER (Noise Suppression)
1038           2100       ; Save buzzer state and force it OFF during the sensitive read
1038 E588      2101       mov A, TCON      
103A 5410      2102       anl A, #0x10     ; Isolate TR0 bit
103C C0E0      2103       push acc         ; Save it
103E C28C      2104       clr TR0          ; STOP NOISE
1040           2105   
1040           2106       ; 2. Initialize / Trigger ADC
1040 75A180    2107       mov ADC_C, #0x80    ; Reset
1043 00        2108       nop
1044 00        2109       nop
1045 75A101    2110       mov ADC_C, #0x01    ; Start Channel 0
1048           2111       
1048           2112       ; 3. Settle Delay
1048 7DFA      2113       mov R5, #250
104A           2114   ADC_Settle_Loop:
104A 00        2115       nop
104B 00        2116       nop
104C DDFC      2117       djnz R5, ADC_Settle_Loop
104E           2118       
104E           2119       ; 4. Read Raw Data
104E 85A232    2120       mov x+0, ADC_L
1051 85A333    2121       mov x+1, ADC_H
1054 753400    2122       mov x+2, #0
1057 753500    2123       mov x+3, #0
105A           2124       
105A           2125       ; 5. Mask Data
105A E533      2126       mov a, x+1
105C 540F      2127       anl a, #0x0F
105E F533      2128       mov x+1, a
1060           2129       
1060           2130       ; [FIX] RESTORE THE BUZZER
1060 D0E0      2131       pop acc          ; Get previous state
1062 6002      2132       jz Skip_Restore  ; If it was OFF, keep it OFF
1064 D28C      2133       setb TR0         ; If it was ON, turn it back ON
1066           2134   Skip_Restore:
1066           2135   
1066           2136       ; 6. Math Conversions
1066 753616    2137            mov y+0, #low (4118 % 0x10000) 
1069 753710    2137            mov y+1, #high(4118 % 0x10000) 
106C 753800    2137            mov y+2, #low (4118 / 0x10000) 
106F 753900    2137            mov y+3, #high(4118 / 0x10000) 
1072 12018C    2138       lcall mul32       
1075           2139   
1075 75A104    2140       mov ADC_C, #0x04    ; Read LM4040
1078 85A236    2141       mov y+0, ADC_L      
107B 85A337    2142       mov y+1, ADC_H      
107E 753800    2143       mov y+2, #0
1081 753900    2144       mov y+3, #0
1084 75A100    2145       mov ADC_C, #0x00    ; Reset
1087           2146       
1087 120280    2147       lcall div32         
108A 753664    2148            mov y+0, #low (100 % 0x10000) 
108D 753700    2148            mov y+1, #high(100 % 0x10000) 
1090 753800    2148            mov y+2, #low (100 / 0x10000) 
1093 753900    2148            mov y+3, #high(100 / 0x10000) 
1096 12018C    2149       lcall mul32
1099 75362B    2150            mov y+0, #low (1323 % 0x10000) 
109C 753705    2150            mov y+1, #high(1323 % 0x10000) 
109F 753800    2150            mov y+2, #low (1323 / 0x10000) 
10A2 753900    2150            mov y+3, #high(1323 / 0x10000)         
10A5 120280    2151       lcall div32    
10A8 753614    2152            mov y+0, #low (COLD_JUNCTION_TEMP % 0x10000) 
10AB 753700    2152            mov y+1, #high(COLD_JUNCTION_TEMP % 0x10000) 
10AE 753800    2152            mov y+2, #low (COLD_JUNCTION_TEMP / 0x10000) 
10B1 753900    2152            mov y+3, #high(COLD_JUNCTION_TEMP / 0x10000) 
10B4 1200D3    2153       lcall add32     
10B7           2154       
10B7           2155       ; 8. Store Result
10B7 85323F    2156       mov current_temp+0, x+0
10BA 853340    2157       mov current_temp+1, x+1
10BD 853441    2158       mov current_temp+2, x+2
10C0 853542    2159       mov current_temp+3, x+3
10C3           2160   
10C3 22        2161       ret
10C4           2162       
10C4           2163   ; ================================================================
10C4           2164   ; MODULE: POWER CONTROLLER (The Brain)
10C4           2165   ; ================================================================
10C4           2166   Power_Control:
10C4           2167       ; Default: Turn Heat OFF (Safety)
10C4 755C00    2168       mov power_output+0, #0
10C7 755D00    2169       mov power_output+1, #0
10CA 755E00    2170       mov power_output+2, #0
10CD 755F00    2171       mov power_output+3, #0
10D0           2172   
10D0 E568      2173       mov a, Control_FSM_state
10D2           2174   
10D2           2175       ; --- State 2: RAMP TO SOAK ---
10D2 B40202    2176       cjne a, #2, PC_Check_Soak
10D5           2177       ; Mode: Full Speed Ahead
10D5 8016      2178       sjmp Set_Max_Power
10D7           2179   
10D7           2180   PC_Check_Soak:
10D7           2181       ; --- State 3: SOAK PHASE ---
10D7 B40305    2182       cjne a, #3, PC_Check_Ramp_Reflow
10DA           2183       ; Mode: Maintenance (Low Power)
10DA           2184       ; If Temp > Target, OFF. If Temp < Target, 20% Power.
10DA 20030F    2185       jb soak_temp_reached, PC_Done ; If hot enough, stay OFF
10DD 801B      2186       sjmp Set_20_Percent_Power     ; If cold, use 20%
10DF           2187   
10DF           2188   PC_Check_Ramp_Reflow:
10DF           2189       ; --- State 4: RAMP TO REFLOW ---
10DF B40402    2190       cjne a, #4, PC_Check_Reflow
10E2           2191       ; Mode: Full Speed Ahead
10E2 8009      2192       sjmp Set_Max_Power
10E4           2193   
10E4           2194   PC_Check_Reflow:
10E4           2195       ; --- State 5: REFLOW PHASE ---
10E4 B40505    2196       cjne a, #5, PC_Done
10E7           2197       ; Mode: Maintenance (Low Power)
10E7 200402    2198       jb reflow_temp_reached, PC_Done
10EA 800E      2199       sjmp Set_20_Percent_Power
10EC           2200   
10EC           2201   PC_Done:
10EC 22        2202       ret
10ED           2203   
10ED           2204   ; --- Power Helpers ---
10ED           2205   
10ED           2206   Set_Max_Power:
10ED           2207       ; Load 1500 (0x05DC) = 100% Duty Cycle
10ED 755CDC    2208       mov power_output+0, #0xDC
10F0 755D05    2209       mov power_output+1, #0x05
10F3 755E00    2210       mov power_output+2, #0
10F6 755F00    2211       mov power_output+3, #0
10F9 22        2212       ret
10FA           2213   
10FA           2214   Set_20_Percent_Power:
10FA           2215       ; Load 300 (0x012C) = 20% Duty Cycle
10FA 755C2C    2216       mov power_output+0, #0x2C
10FD 755D01    2217       mov power_output+1, #0x01
1100 755E00    2218       mov power_output+2, #0
1103 755F00    2219       mov power_output+3, #0
1106 22        2220       ret
1107           2221   
1107           2222   
1107           2223   ;--------------------------------------------------------------
1107           2224   ; set servo angle according to the state
1107           2225   ; call servo control function every 1ms
1107           2226   ;--------------------------------------------------------------
1107           2227   call_servo_control:
1107           2228            ; check current state and change servo angle
1107 E568      2229            mov a, Control_FSM_state
1109           2230            
1109           2231            ; handle state 0
1109 B40004    2232            cjne a, #0, servo_state1
110C C21F      2233            clr servo_angle_zero ; close door at state 0
110E 802C      2234            sjmp check_servo_flag
1110           2235   
1110           2236            ; handle state 1
1110           2237            servo_state1:
1110 B40104    2238            cjne a, #1, servo_state2
1113 D21F      2239            setb servo_angle_zero ; open door at state 1
1115 8025      2240            sjmp check_servo_flag
1117           2241   
1117           2242            ; handle state 2
1117           2243            servo_state2:
1117 B40204    2244            cjne a, #2, servo_state3
111A C21F      2245            clr servo_angle_zero ; close door at state 2
111C 801E      2246            sjmp check_servo_flag
111E           2247   
111E           2248            ; handle state 3
111E           2249            servo_state3:
111E B40304    2250            cjne a, #3, servo_state4
1121 C21F      2251            clr servo_angle_zero ; close door at state 3
1123 8017      2252            sjmp check_servo_flag
1125           2253   
1125           2254            ; handle state 4
1125           2255            servo_state4:
1125 B40404    2256            cjne a, #4, servo_state5
1128 C21F      2257            clr servo_angle_zero ; close door at state 4
112A 8010      2258            sjmp check_servo_flag
112C           2259   
112C           2260            ; handle state 5
112C           2261            servo_state5:
112C B40504    2262            cjne a, #5, servo_state6
112F C21F      2263            clr servo_angle_zero ; close door at state 5
1131 8009      2264            sjmp check_servo_flag
1133           2265   
1133           2266            ; handle state 6
1133           2267            servo_state6:
1133 B40604    2268            cjne a, #6, servo_state7
1136 C21F      2269            clr servo_angle_zero ; close door at state 6
1138 8002      2270            sjmp check_servo_flag
113A           2271   
113A           2272            ; handle state 7
113A           2273            servo_state7:
113A D21F      2274            setb servo_angle_zero ; open door at state 7
113C           2275   
113C           2276   check_servo_flag:
113C           2277            ; check 1 ms flag
113C 101E01    2278            jbc one_millisecond_flag_servo, run_servo_control
113F 22        2279            ret
1140           2280   
1140           2281   run_servo_control:
1140 121144    2282            lcall servo_control
1143 22        2283            ret
1144           2284   
1144           2285   
1144           2286   ;---------------------------------------------------------------
1144           2287   ; servo control
1144           2288   ; generate a 20 ms period pwm signal to control the servo motor
1144           2289   ; able to make the servo motor stay at 0 degree and 180 degree
1144           2290   ;---------------------------------------------------------------
1144           2291   servo_control:
1144 D2ED      2292       setb LEDRA.5
1146 C0E0      2293            push acc
1148 C0D0      2294            push psw
114A E577      2295            mov a, servo_pwm_counter ; move servo counter to accumulator
114C 04        2296            inc A ; a += 1
114D B41402    2297            cjne a, #SERVO_PERIOD, servo_pwm_angle_compare ; jump if wrapup not needed
1150 7400      2298            mov a, #0
1152           2299   
1152           2300   servo_pwm_angle_compare: ; read target angle
1152 F577      2301            mov servo_pwm_counter, A
1154 201F09    2302            jb servo_angle_zero, set_zero_degree ; set servo motor to 0 degree
1157           2303            ; set servo motor to 180 degrees
1157 E577      2304            mov a, servo_pwm_counter
1159 C3        2305            clr c
115A 9402      2306            subb a, #SERVO_180
115C 400B      2307            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 180 degrees duty cycle
115E 800D      2308            sjmp servo_pwm_set_low ; set low if greater
1160           2309   
1160           2310   set_zero_degree:
1160           2311            ; set servo motor to 0 degree
1160 E577      2312            mov a, servo_pwm_counter
1162 C3        2313            clr c
1163 9401      2314            subb a, #SERVO_0
1165 4002      2315            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 0 degrees duty cycle
1167 8004      2316            sjmp servo_pwm_set_low ; set low if greater
1169           2317   
1169           2318   servo_pwm_set_high:
1169           2319            ; set pwm pin high
1169 D2B6      2320            setb SERVO_OUT
116B 8002      2321            sjmp servo_control_done
116D           2322   
116D           2323   servo_pwm_set_low:
116D           2324            ; set pwm pin low
116D C2B6      2325            clr SERVO_OUT
116F           2326   
116F           2327   servo_control_done:
116F D0D0      2328            pop psw
1171 D0E0      2329            pop acc
1173 22        2330            ret
1174           2331   
1174           2332   ;-------------------------------------------------------------------------------
1174           2333   ; power_control
1174           2334   ;-------------------------------------------------------------------------------
1174           2335   ; Determine the power output based on current state and current temperature 
1174           2336   ; input parameter: Control_FSM_state
1174           2337   ;-------------------------------------------------------------------------------
1174           2338   
1174           2339   proportaional_power_control:
1174 E568      2340            mov a, Control_FSM_state
1176           2341   
1176           2342   state0_power_control:
1176           2343            ; idle
1176           2344            ; 0% power
1176 B4000F    2345            cjne a, #0, state1_power_control
1179 755C00    2346            mov power_output, #low(NO_POWER)
117C 755D00    2347            mov power_output+1, #low(NO_POWER)
117F 755E00    2348            mov power_output+2, #0
1182 755F00    2349            mov power_output+3, #0
1185 021320    2350            ljmp power_control_done
1188           2351   
1188           2352   state1_power_control:
1188           2353            ; idle
1188           2354            ; 0% power
1188 B4010F    2355            cjne a, #1, state2_power_control
118B 755C00    2356            mov power_output, #low(NO_POWER)
118E 755D00    2357            mov power_output+1, #low(NO_POWER)
1191 755E00    2358            mov power_output+2, #0
1194 755F00    2359            mov power_output+3, #0
1197 021320    2360            ljmp power_control_done
119A           2361            
119A           2362   state2_power_control:
119A           2363            ; ramp to soak, ramp to ~150C
119A           2364            ; 100% power
119A B4020F    2365            cjne a, #2, state3_power_control
119D 755CDC    2366            mov power_output, #low(MAX_POWER)
11A0 755D05    2367            mov power_output+1, #high(MAX_POWER)
11A3 755E00    2368            mov power_output+2, #0
11A6 755F00    2369            mov power_output+3, #0
11A9 021320    2370            ljmp power_control_done
11AC           2371   
11AC           2372   state3_power_control:
11AC           2373            ; soak period, hold at 150C
11AC           2374            ; 20% base power + proportional calculated power
11AC B40302    2375            cjne a, #3, jump_state4_power_control
11AF 8003      2376            sjmp state3_power_control_calculation
11B1           2377   
11B1           2378   jump_state4_power_control:
11B1 0212DE    2379            ljmp state4_power_control
11B4           2380   
11B4           2381   state3_power_control_calculation:
11B4           2382            ; move soak_temp to x
11B4 854332    2383            mov x, soak_temp
11B7 854433    2384            mov x+1, soak_temp+1
11BA 854534    2385            mov x+2, soak_temp+2
11BD 854635    2386            mov x+3, soak_temp+3
11C0           2387            ; move current_temp to y
11C0 853F36    2388            mov y, current_temp
11C3 854037    2389            mov y+1, current_temp+1
11C6 854138    2390            mov y+2, current_temp+2
11C9 854239    2391            mov y+3, current_temp+3
11CC           2392   
11CC           2393            ; compare between soak_temp and current_temp
11CC C200      2394            clr mf
11CE 120178    2395            lcall x_gteq_y
11D1 10002B    2396            jbc mf, st_sub_ct
11D4           2397            ; current_temp - soak_temp if st < ct
11D4 C220      2398            clr soak_temp_greater
11D6           2399            ; move current_temp to y
11D6 854336    2400            mov y, soak_temp
11D9 854437    2401            mov y+1, soak_temp+1
11DC 854538    2402            mov y+2, soak_temp+2
11DF 854639    2403            mov y+3, soak_temp+3
11E2           2404            ; move current_temp to x
11E2 853F32    2405            mov x, current_temp
11E5 854033    2406            mov x+1, current_temp+1
11E8 854134    2407            mov x+2, current_temp+2
11EB 854235    2408            mov x+3, current_temp+3
11EE 1200F6    2409            lcall sub32
11F1 85326A    2410            mov soak_temp_diff, x
11F4 85336B    2411            mov soak_temp_diff+1, x+1
11F7 85346C    2412            mov soak_temp_diff+2, x+2
11FA 85356D    2413            mov soak_temp_diff+3, x+3
11FD 8011      2414            sjmp proportional_input_soak
11FF           2415   
11FF           2416   st_sub_ct:
11FF           2417            ; soak_temp - current_temp
11FF D220      2418            setb soak_temp_greater
1201 1200F6    2419            lcall sub32
1204 85326A    2420            mov soak_temp_diff, x
1207 85336B    2421            mov soak_temp_diff+1, x+1
120A 85346C    2422            mov soak_temp_diff+2, x+2
120D 85356D    2423            mov soak_temp_diff+3, x+3
1210           2424   
1210           2425   proportional_input_soak:
1210           2426            ; proportaional block calculation       
1210           2427            ; move soak_temp_diff to x
1210 856A32    2428            mov x, soak_temp_diff
1213 856B33    2429            mov x+1, soak_temp_diff+1
1216 856C34    2430            mov x+2, soak_temp_diff+2
1219 856D35    2431            mov x+3, soak_temp_diff+3
121C           2432            ; move proportional gain to y
121C 753605    2433            mov y+0, #low (KP % 0x10000) 
121F 753700    2433            mov y+1, #high(KP % 0x10000) 
1222 753800    2433            mov y+2, #low (KP / 0x10000) 
1225 753900    2433            mov y+3, #high(KP / 0x10000) 
1228 12018C    2434            lcall mul32 ; proportional_output = proportional_gain * difference
122B           2435            
122B 85326E    2436            mov proportional_gain_var, x
122E 85336F    2437            mov proportional_gain_var+1, x+1
1231 853470    2438            mov proportional_gain_var+2, x+2
1234 853571    2439            mov proportional_gain_var+3, x+3
1237           2440   
1237           2441            ; base_power + soak_power when soak_temp > current_temp
1237 302029    2442            jnb soak_temp_greater, sub_proportional_soak
123A 856E32    2443            mov x, proportional_gain_var
123D 856F33    2444            mov x+1, proportional_gain_var+1
1240 857034    2445            mov x+2, proportional_gain_var+2
1243 857135    2446            mov x+3, proportional_gain_var+3
1246 75362C    2447            mov y+0, #low (BASE_POWER % 0x10000) 
1249 753701    2447            mov y+1, #high(BASE_POWER % 0x10000) 
124C 753800    2447            mov y+2, #low (BASE_POWER / 0x10000) 
124F 753900    2447            mov y+3, #high(BASE_POWER / 0x10000) 
1252 1200D3    2448            lcall add32
1255           2449            ; x now holds the power output before the saturator
1255 85326E    2450            mov proportional_gain_var, x
1258 85336F    2451            mov proportional_gain_var+1, x+1
125B 853470    2452            mov proportional_gain_var+2, x+2
125E 853571    2453            mov proportional_gain_var+3, x+3
1261 803D      2454            sjmp saturator_soak
1263           2455   
1263           2456   sub_proportional_soak:
1263           2457            ; base_power - soak_power when soak_temp <= current_temp
1263 75322C    2458            mov x+0, #low (BASE_POWER % 0x10000) 
1266 753301    2458            mov x+1, #high(BASE_POWER % 0x10000) 
1269 753400    2458            mov x+2, #low (BASE_POWER / 0x10000) 
126C 753500    2458            mov x+3, #high(BASE_POWER / 0x10000) 
126F 856E36    2459            mov y, proportional_gain_var
1272 856F37    2460            mov y+1, proportional_gain_var+1
1275 857038    2461            mov y+2, proportional_gain_var+2
1278 857139    2462            mov y+3, proportional_gain_var+3
127B           2463   
127B           2464            ; compare whether base_power < proportional_gain_var
127B C200      2465            clr mf
127D 12011A    2466            lcall x_lt_y ; set mf to 1 if base_power < proportional_gain_var, clamp output to 0
1280 30000E    2467            jnb mf, bp_gteq_pgv
1283 756E00    2468            mov proportional_gain_var, #low(NO_POWER)
1286 756F00    2469            mov proportional_gain_var+1, #high(NO_POWER)
1289 757000    2470            mov proportional_gain_var+2, #0
128C 757100    2471            mov proportional_gain_var+3, #0
128F 800F      2472            sjmp saturator_soak
1291           2473   
1291           2474   bp_gteq_pgv:
1291           2475            ; calculate subtracted gain
1291 1200F6    2476            lcall sub32
1294           2477            ; x now holds the power output before the saturator
1294 85326E    2478            mov proportional_gain_var, x
1297 85336F    2479            mov proportional_gain_var+1, x+1
129A 853470    2480            mov proportional_gain_var+2, x+2
129D 853571    2481            mov proportional_gain_var+3, x+3
12A0           2482   
12A0           2483   saturator_soak:
12A0           2484            ; proportional_gain_var now holds the power output before the saturator
12A0           2485            ; saturate power output to max power
12A0 856E32    2486            mov x, proportional_gain_var
12A3 856F33    2487            mov x+1, proportional_gain_var+1
12A6 857034    2488            mov x+2, proportional_gain_var+2
12A9 857135    2489            mov x+3, proportional_gain_var+3
12AC           2490   
12AC 7536DC    2491            mov y+0, #low (MAX_POWER % 0x10000) 
12AF 753705    2491            mov y+1, #high(MAX_POWER % 0x10000) 
12B2 753800    2491            mov y+2, #low (MAX_POWER / 0x10000) 
12B5 753900    2491            mov y+3, #high(MAX_POWER / 0x10000) 
12B8           2492   
12B8 C200      2493            clr mf
12BA 120136    2494            lcall x_gt_y ; set mf to 1 if calculated power output greater than max power
12BD 20000F    2495            jb mf, saturated_soak
12C0           2496            ; set power_output to calculated power if not saturated
12C0 856E5C    2497            mov power_output, proportional_gain_var
12C3 856F5D    2498            mov power_output+1, proportional_gain_var+1
12C6 85705E    2499            mov power_output+2, proportional_gain_var+2
12C9 85715F    2500            mov power_output+3, proportional_gain_var+3
12CC 021320    2501            ljmp power_control_done
12CF           2502   
12CF           2503   saturated_soak:
12CF 755CDC    2504            mov power_output, #low(MAX_POWER)
12D2 755D05    2505            mov power_output+1, #high(MAX_POWER)
12D5 755E00    2506            mov power_output+2, #0
12D8 755F00    2507            mov power_output+3, #0
12DB 021320    2508            ljmp power_control_done
12DE           2509   
12DE           2510   
12DE           2511   state4_power_control:
12DE           2512            ; ramp to reflow, max power
12DE B4040F    2513            cjne a, #4, state5_power_control
12E1 755CDC    2514            mov power_output, #low(MAX_POWER)
12E4 755D05    2515            mov power_output+1, #high(MAX_POWER)
12E7 755E00    2516            mov power_output+2, #0
12EA 755F00    2517            mov power_output+3, #0
12ED 021320    2518            ljmp power_control_done
12F0           2519   
12F0           2520   state5_power_control:
12F0           2521            ; reflow 20% base power
12F0 B4050F    2522            cjne a, #5, state6_power_control
12F3 755C2C    2523            mov power_output, #low(BASE_POWER)  
12F6 755D01    2524            mov power_output+1, #high(BASE_POWER)
12F9 755E00    2525            mov power_output+2, #0
12FC 755F00    2526            mov power_output+3, #0
12FF 021320    2527            ljmp power_control_done
1302           2528   
1302           2529   state6_power_control:
1302           2530            ; cooling 0% power
1302 B4060F    2531            cjne a, #6, state_7_power_control
1305 755C00    2532            mov power_output, #low(NO_POWER)
1308 755D00    2533            mov power_output+1, #high(NO_POWER)
130B 755E00    2534            mov power_output+2, #0
130E 755F00    2535            mov power_output+3, #0
1311 021320    2536            ljmp power_control_done
1314           2537   
1314           2538   state_7_power_control:
1314           2539            ; idle 0% power
1314 755C00    2540            mov power_output, #low(NO_POWER)
1317 755D00    2541            mov power_output+1, #high(NO_POWER)
131A 755E00    2542            mov power_output+2, #0
131D 755F00    2543            mov power_output+3, #0
1320           2544   
1320           2545   power_control_done:
1320 22        2546            ret
1321           2547   
1321           2548   END
>>>>>>> main
