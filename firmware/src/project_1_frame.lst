0000              1   ; Project 1
0000              2   ; CV-8052 microcontroller in DE10-Lite board
0000              3   ;-------------------------------------------------------------------------------
0000              4   ; Reset vector
0000              5   org 0x0000
0000 020BC1       6       ljmp main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9       reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 02046E      12       ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15       reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18       reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 32          21       reti
0024             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
002B 02052E      24       ljmp Timer2_ISR
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 32   $LIST
0320             34   ; ----------------------------------------------------------------------------------------------;
0320             35   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             36   dseg at 0x30
0030             37   current_time_sec:     ds 1
0031             38   current_time_minute:  ds 1
0032             39   ; math32 buffer variables
0032             40   x:      ds  4
0036             41   y:      ds  4
003A             42   bcd:    ds  5
003F             43   
003F             44   current_temp: ds 4 ;
0043             45   soak_temp:    ds 4 ;
0047             46   reflow_temp:  ds 4 ;
004B             47   
004B             48   wait25_btn_cnt:    ds 1
004C             49   wait25_keypad_cnt: ds 1
004D             50   wait25_adc_cnt:    ds 1
004E             51   wait25_lcd_cnt:    ds 1
004F             52   wait25_count: ds 1  
0050             53   
0050             54   current_time: ds 4 ;
0054             55   soak_time:    ds 4 ;
0058             56   reflow_time:  ds 4 ;
005C             57   
005C             58   power_output:  ds 4 ;
0060             59   pwm_counter: ds 4 ; counter for pwm (0-1500)
0064             60   
0064             61   KEY1_DEB_timer: ds 1
0065             62   SEC_FSM_timer:  ds 1
0066             63   KEY1_DEB_state:    ds 1
0067             64   SEC_FSM_state:     ds 1
0068             65   Control_FSM_state: ds 1 
0069             66   
0069             67   Current_State:     ds 1
006A             68   soak_temp_diff: ds 4 ; temperature difference between target soak temp and current oven temp 
006E             69   proportional_gain_var: ds 4 ; power gain calculated from the proportional block
0072             70   Cursor_Idx: ds 1 ; UI buffers I added
0073             71   
0073             72   ; Buzzer state
0073             73   beep_count:  ds 1      ; remaining beeps
0074             74   beep_state:  ds 1      ; 0=idle, 1=ON, 2=OFF
0075             75   beep_tmr:    ds 2      ; 16-bit ms timer (needs to reach 500)
0077             76   
0077             77   servo_pwm_counter: ds 1 ; counter for the servo pwm signal
0078             78   
0080             79   iseg at 0x80
0080             80   Buf_Soak_Temp: ds 4   
0084             81   Buf_Soak_Time: ds 5   
0089             82   Buf_Refl_Temp: ds 4   
008D             83   Buf_Refl_Time: ds 5
0092             84   ; 46d bytes used
0092             85   ;-------------------------------------------------------------------------------
0092             86   ; bit operation setb, clr, jb, and jnb
0000             87   bseg
0000             88   mf:     dbit 1 ; math32 sign
0001             89   one_second_flag: dbit 1
0002             90   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003             91   
0003             92   soak_temp_reached: dbit 1
0004             93   reflow_temp_reached: dbit 1
0005             94   cooling_temp_reached: dbit 1
0006             95   
0006             96   soak_time_reached: dbit 1
0007             97   reflow_time_reached: dbit 1
0008             98   
0008             99   reset_signal: dbit 1
0009            100   stop_signal: dbit 1
000A            101   start_signal: dbit 1
000B            102   config_finish_signal: dbit 1
000C            103   
000C            104   state_change_signal: dbit 1
000D            105   
000D            106   Key1_flag: dbit 1
000E            107   
000E            108   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
000F            109   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0010            110   PB0_flag: dbit 1 ; start entire program
0011            111   PB1_flag: dbit 1 ; start soak
0012            112   PB2_flag: dbit 1 ; pause process
0013            113   
0013            114   ;buzzer beep
0013            115   one_ms_beep_flag: dbit 1
0014            116   
0014            117   ; BSEG (Bit Segment)
0014            118   wait25_active: dbit 1 ; 1 = We are currently waiting
0015            119   wait25_done:   dbit 1 ; 1 = The 25ms has finished
0016            120   wait25_btn_active:    dbit 1
0017            121   wait25_btn_done:      dbit 1
0018            122   wait25_keypad_active: dbit 1
0019            123   wait25_keypad_done:   dbit 1
001A            124   wait25_adc_active:    dbit 1
001B            125   wait25_adc_done:      dbit 1
001C            126   wait25_lcd_active:    dbit 1
001D            127   wait25_lcd_done:      dbit 1
001E            128   
001E            129   one_millisecond_flag_servo: dbit 1 ; set the one millsiecond flag for servo pwm signal generation
001F            130   servo_angle_zero: dbit 1 ; flag for indicating whether the servo angle should be at 0 or not: 1 -> 0; 0 -> 180
0020            131   soak_temp_greater: dbit 1 ; target soak_temp greater than current_temp
0021            132   ; 11 bits used
0021            133   ;-------------------------------------------------------------------------------
0320            134   cseg
0320            135   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            136   BAUD           EQU 57600
0320            137   
0320            138   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            139   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            140   ; is always 12 unlike the N76E003 where is selectable.
0320            141   
0320            142   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            143   
0320            144   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            145   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            146   
0320            147   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            148   
0320            149   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            150   
0320            151   PWM_OUT        EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            152   
0320            153   ; These 'equ' must match the wiring between the DE10Lite board and the LCD
0320            154   ; P0 is in connector JPIO.
0320            155   ;Added correct I/O definitions
0320            156   ;-- LCD Pins ---
0320            157   ELCD_RS equ P1.7
0320            158   ELCD_E  equ P1.1
0320            159   ELCD_D4 equ P0.7
0320            160   ELCD_D5 equ P0.5
0320            161   ELCD_D6 equ P0.3
0320            162   ELCD_D7 equ P0.1
0320            163   
0320            164   ; -- Buttons --
0320            165   BTN_SOAK_TEMP equ P0.0
0320            166   BTN_SOAK_TIME equ P0.2
0320            167   BTN_REFL_TEMP equ P0.4
0320            168   BTN_REFL_TIME equ P0.6
0320            169   
0320            170   ; --- KEYPAD ---
0320            171   ROW1 equ P1.2
0320            172   ROW2 equ P1.4
0320            173   ROW3 equ P1.6
0320            174   ROW4 equ P2.0
0320            175   COL1 equ P2.2
0320            176   COL2 equ P2.4
0320            177   COL3 equ P2.6
0320            178   COL4 equ P3.0
0320            179   
0320            180   SERVO_OUT      EQU p3.6 ; servo pin
0320            181   LED_LEFT       EQU P3.4 ; left LED (PB3.4)
0320            182   LED_MID        EQU P3.3 ; middle LED (PB3.3)
0320            183   LED_RIGHT      EQU P3.2 ; right LED (PB3.2)
0320            184   
0320            185   SERVO_PERIOD   EQU 20 ; pwm signal period for the servo motor (20 ms)
0320            186   SERVO_0        EQU 1 ; pwm high time for the servo motor to stay at 0 degree
0320            187   SERVO_180      EQU 2 ; pwm high time for the servo motor to stay at 180 degrees
0320            188   
0320            189   COLD_JUNCTION_TEMP equ 22
0320            190   MAX_POWER           EQU 1500 ; max oven power
0320            191   NO_POWER            EQU 0    ; no power
0320            192   BASE_POWER     EQU (MAX_POWER/5) ; 20% base power for state 2, 4
0320            193   HALF_POWER     EQU (MAX_POWER/2) ; 50% power indicator
0320            194   KP                          EQU 5 ; proportional gain
0320            195   
0320            196   ;1234567890123456 <-- 16 characters per line LCD
0320 696E6974   197   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   198   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   199   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            200   
0350            201   ;UI STRINGS (REQUIRED FOR KEYPAD LOGIC), <- I can fix if duplicates
0350 53656C65   202   Txt_Home:     db 'Select Mode:    ', 0
     6374204D
     6F64653A
     20202020
     00
0361 53657420   203   Txt_SoakT:    db 'Set Soak Temp   ', 0
     536F616B
     2054656D
     70202020
     00
0372 53657420   204   Txt_SoakTime: db 'Set Soak Time   ', 0
     536F616B
     2054696D
     65202020
     00
0383 53657420   205   Txt_ReflT:    db 'Set Reflow Temp ', 0
     5265666C
     6F772054
     656D7020
     00
0394 53657420   206   Txt_ReflTime: db 'Set Reflow Time ', 0
     5265666C
     6F772054
     696D6520
     00
03A5            207   
03A5            208   ; 1234567890123456
03A5 53657420   209   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
03B5 536F616B   210   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
03C0 5265666C   211   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
03CD 536F616B   212   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
03D8 5265666C   213   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03E5            214   
03E5 54656D70   215   String_temp_line:  db 'Temp: ', 0
     3A2000
03EC            216   
03EC            217   ; 1234567890123456
03EC 52616D70   218   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03FC 536F616B   219   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
040C 52616D70   220   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
041C 5265666C   221   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
042C 436F6F6C   222   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
043C 50726F63   223   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
044C            224   
044C 20202020   225   String_Blank:    db '                ', 0
     20202020
     20202020
     20202020
     00
045D            226   
045D            227   ;-------------------------------------------------------------------------------
045D            228   ; Timers Setting:
045D            229   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
045D            230   ;   Timer 1: Serial port baud rate 57600 generator
045D            231   ;   Timer 2: 1ms interrupt for BCD counter increment/decrement
045D            232   ;-------------------------------------------------------------------------------
045D            233   ; Routine to initialize the ISR for Timer 0 ;
045D            234   Timer0_Init:
045D E589       235       mov a, TMOD
045F 54F0       236       anl a, #0xf0 ; Clear the bits for timer 0
0461 4401       237       orl a, #0x01 ; Configure timer 0 as 16-timer
0463 F589       238       mov TMOD, a
0465 758CFD     239       mov TH0, #high(TIMER0_RELOAD)
0468 758A5A     240       mov TL0, #low(TIMER0_RELOAD)
046B            241       ; Enable the timer and interrupts
046B D2A9       242       setb ET0  ; Enable timer 0 interrupt
046D            243       ; setb TR0  (no need to open at first)
046D 22         244       ret
046E            245   ; ISR for timer 0.  Set to execute every 1/4096Hz 
046E            246   ; to generate a 2048 Hz square wave at pin P1.5 
046E            247   Timer0_ISR:
046E            248       ;clr TF0  ; According to the data sheet this is done for us already.
046E 758CFD     249       mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
0471 758A5A     250       mov TL0, #low(TIMER0_RELOAD)
0474 B295       251       cpl SOUND_OUT ; Connect speaker to P1.5
0476 32         252       reti
0477            253   ; -----------------------------------------------------------------------------------------------;
0477            254   
0477            255   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
0477            256   Initialize_Serial_Port:
0477            257       ; Configure serial port and baud rate
0477 C28E       258       clr TR1 ; Disable timer 1
0479 53890F     259       anl TMOD, #0x0f ; Mask the bits for timer 1
047C 438920     260       orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
047F 438780     261       orl PCON, #80H ; Set SMOD to 1
0482 758DFD     262       mov TH1, #low(TIMER_1_RELOAD)
0485 758BFD     263       mov TL1, #low(TIMER_1_RELOAD) 
0488 D28E       264       setb TR1 ; Enable timer 1
048A 759852     265       mov SCON, #52H
048D 22         266       ret
048E            267   
048E            268   ; uart sending functions
048E            269   putchar:
048E 109902     270       jbc TI, putchar_L1
0491 80FB       271       sjmp putchar
0493            272   putchar_L1:
0493 F599       273       mov SBUF,a
0495 22         274       ret
0496            275   
0496            276   SendString:
0496 E4         277       clr a
0497 93         278       movc a, @a+dptr
0498 6006       279       jz SendString_L1
049A 12048E     280       lcall putchar
049D A3         281       inc dptr
049E 80F6       282       sjmp SendString  
04A0            283   SendString_L1:
04A0 22         284       ret
04A1            285   
04A1            286   ;-------------------------------------------------------------------------------
04A1            287   ; serial debugging
04A1            288   ; send a four byte number via serial to laptop
04A1            289   ; need to be used with python script
04A1            290   ; content needed to be sent should be stored in the varaible x
04A1            291   ;-------------------------------------------------------------------------------
04A1            292   Send32:
04A1            293       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
04A1 74AA       294       mov A, #0AAH
04A3 12048E     295       lcall putchar
04A6 7455       296       mov A, #055H
04A8 12048E     297       lcall putchar
04AB            298   
04AB E535       299       mov A, x+3
04AD 12048E     300       lcall putchar
04B0 E534       301       mov A, x+2
04B2 12048E     302       lcall putchar
04B5 E533       303       mov A, x+1
04B7 12048E     304       lcall putchar
04BA E532       305       mov A, x+0
04BC 12048E     306       lcall putchar
04BF            307   
04BF 740A       308       mov A, #0AH
04C1 12048E     309       lcall putchar
04C4 22         310       ret
04C5            311   ;-------------------------------------------------------------------------------
04C5            312   ; Serial temperature line for PuTTY/screen
04C5            313   ; Outputs: "Temp: XXXC\r\n"
04C5            314   ;-------------------------------------------------------------------------------
04C5            315   Serial_Send_Temp_Line:
04C5 9003E5     316       mov dptr, #String_temp_line
04C8 120496     317       lcall SendString
04CB            318   
04CB            319       ; Convert current_temp to BCD (same as LCD)
04CB 853F32     320       mov x, current_temp
04CE 854033     321       mov x+1, current_temp+1
04D1 854134     322       mov x+2, current_temp+2
04D4 854235     323       mov x+3, current_temp+3
04D7 12002E     324       lcall hex2bcd
04DA            325   
04DA 7F00       326       mov R7, #0          ; printed_flag = 0
04DC            327   
04DC            328       ; Print Hundreds (if non-zero)
04DC E53B       329       mov a, bcd+1
04DE 540F       330       anl a, #0x0F
04E0 6007       331       jz Serial_Skip_Hundreds
04E2 2430       332       add a, #0x30
04E4 12048E     333       lcall putchar
04E7 7F01       334       mov R7, #1
04E9            335   Serial_Skip_Hundreds:
04E9            336   
04E9            337       ; Print Tens (if non-zero or if hundreds already printed)
04E9 E53A       338       mov a, bcd+0
04EB C4         339       swap a
04EC 540F       340       anl a, #0x0F
04EE 7003       341       jnz Serial_Print_Tens
04F0 EF         342       mov a, R7
04F1 600C       343       jz Serial_Skip_Tens
04F3            344   Serial_Print_Tens:
04F3 E53A       345       mov a, bcd+0
04F5 C4         346       swap a
04F6 540F       347       anl a, #0x0F
04F8 2430       348       add a, #0x30
04FA 12048E     349       lcall putchar
04FD 7F01       350       mov R7, #1
04FF            351   Serial_Skip_Tens:
04FF            352   
04FF            353       ; Print Ones (always)
04FF E53A       354       mov a, bcd+0
0501 540F       355       anl a, #0x0F
0503 2430       356       add a, #0x30
0505 12048E     357       lcall putchar
0508            358   
0508            359       ; Print 'C' and newline
0508 7443       360       mov a, #'C'
050A 12048E     361       lcall putchar
050D 740D       362       mov a, #0DH     ; CR
050F 12048E     363       lcall putchar
0512 740A       364       mov a, #0AH     ; LF
0514 12048E     365       lcall putchar
0517 22         366       ret
0518            367   ;-------------------------------------------------------------------------------
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
0518              1   ;-------------------------------------------------------------------------------
0518              2   ; Timer2_ISR.inc
0518              3   ; Contains Initialization and ISR for the 1ms System Timer
0518              4   ;-------------------------------------------------------------------------------
0518              5   
0518              6   ;-------------------------------------------------------------------------------
0518              7   ; Routine to initialize the ISR for timer 2
0518              8   ;-------------------------------------------------------------------------------
0518              9   Timer2_Init:
0518 75C800      10       mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
051B 75CDF5      11       mov TH2, #high(TIMER2_RELOAD)
051E 75CC27      12       mov TL2, #low(TIMER2_RELOAD)
0521             13       ; Set the reload value
0521 75CBF5      14       mov RCAP2H, #high(TIMER2_RELOAD)
0524 75CA27      15       mov RCAP2L, #low(TIMER2_RELOAD)
0527             16       
0527 C2CF        17       clr TF2       ; Clear flag just in case
0529             18       ; Enable the timer and interrupts
0529 D2AD        19       setb ET2      ; Enable timer 2 interrupt
052B D2CA        20       setb TR2      ; Enable timer 2
052D 22          21       ret
052E             22   
052E             23   ;-------------------------------------------------------------------------------
052E             24   ; ISR for timer 2.  Runs every 1 ms
052E             25   ;-------------------------------------------------------------------------------
052E             26   Timer2_ISR:
052E C0E0        27       push acc
0530 C0D0        28       push psw
0532             29       
0532 C2CF        30       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
0534             31   
0534             32       ; --- 1. Existing FSM Timers ---
0534 0564        33       inc KEY1_DEB_timer
0536 0565        34       inc SEC_FSM_timer
0538 D202        35       setb one_ms_pwm_flag 
053A D213        36       setb one_ms_beep_flag
053C D21E        37       setb one_millisecond_flag_servo
053E             38   
053E             39       ; --- 2. NEW: Non-Blocking Delay Counters ---
053E             40       
053E             41       ; A. BUTTON DELAY
053E 30160B      42       jnb wait25_btn_active, T2_Check_Keypad
0541 054B        43       inc wait25_btn_cnt
0543 E54B        44       mov a, wait25_btn_cnt
0545 B41904      45       cjne a, #25, T2_Check_Keypad
0548 D217        46       setb wait25_btn_done
054A C216        47       clr wait25_btn_active
054C             48       
054C             49       ; B. KEYPAD DELAY
054C             50   T2_Check_Keypad:
054C 30180B      51       jnb wait25_keypad_active, T2_Check_ADC
054F 054C        52       inc wait25_keypad_cnt
0551 E54C        53       mov a, wait25_keypad_cnt
0553 B41904      54       cjne a, #25, T2_Check_ADC
0556 D219        55       setb wait25_keypad_done
0558 C218        56       clr wait25_keypad_active
055A             57   
055A             58       ; C. ADC DELAY (Thermocouple)
055A             59   T2_Check_ADC:
055A 301A0B      60       jnb wait25_adc_active, T2_Check_LCD
055D 054D        61       inc wait25_adc_cnt
055F E54D        62       mov a, wait25_adc_cnt
0561 B41904      63       cjne a, #25, T2_Check_LCD
0564 D21B        64       setb wait25_adc_done
0566 C21A        65       clr wait25_adc_active
0568             66   
0568             67       ; D. LCD DELAY
0568             68   T2_Check_LCD:
0568 301C0B      69       jnb wait25_lcd_active, T2_Check_Generic
056B 054E        70       inc wait25_lcd_cnt
056D E54E        71       mov a, wait25_lcd_cnt
056F B41904      72       cjne a, #25, T2_Check_Generic
0572 D21D        73       setb wait25_lcd_done
0574 C21C        74       clr wait25_lcd_active
0576             75   
0576             76       ; E. GENERIC DELAY (Used by Wait_25ms in Main)
0576             77   T2_Check_Generic:
0576 30140B      78       jnb wait25_active, Timer2_ISR_done
0579 054F        79       inc wait25_count
057B E54F        80       mov a, wait25_count
057D B41904      81       cjne a, #25, Timer2_ISR_done
0580 D215        82       setb wait25_done      ; Tells Wait_25ms that we are finished
0582 C214        83       clr wait25_active     ; Stop counting
0584             84   
0584             85   Timer2_ISR_done:
0584 D0D0        86       pop psw
0586 D0E0        87       pop acc
0588 32          88       reti
0589             89            
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
0589              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
0589              2   cseg
0589              3   
0589              4   ; When using a 33.333333MHz crystal clock
0589              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
0589              6   
0589              7   ;---------------------------------;
0589              8   ; Wait 40 microseconds            ;
0589              9   ;---------------------------------;
0589             10   Wait40uSec:
0589 C000        11            push AR0
058B 78BE        12            mov R0, #190
058D             13   L0: 
058D 00          14            nop
058E 00          15            nop
058F 00          16            nop
0590 00          17            nop
0591 D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
0593 D000        19            pop AR0
0595 22          20       ret
0596             21   
0596             22   ;---------------------------------;
0596             23   ; Wait 'R2' milliseconds          ;
0596             24   ;---------------------------------;
                 25   Wait_Milli_Seconds mac
                 26   	push AR2
                 27   	mov R2, %0
                 28   	lcall ?Wait_Milli_Seconds
                 29   	pop AR2
                 30   endmac
0596             31   
0596             32   ?Wait_Milli_Seconds:
0596 C000        33            push AR0
0598 C001        34            push AR1
059A 7932        35   L3: mov R1, #50
059C 78DF        36   L2: mov R0, #223
059E D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
05A0 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
05A2 DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
05A4 D001        40       pop AR1
05A6 D000        41       pop AR0
05A8 22          42       ret
05A9             43            
05A9             44   ;---------------------------------;
05A9             45   ; Toggles the 'E' pin in the LCD  ;
05A9             46   ;---------------------------------;
05A9             47   ELCD_pulse:
05A9 D291        48            setb ELCD_E
05AB 120589      49            lcall Wait40uSec
05AE C291        50            clr ELCD_E
05B0 120589      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
05B3 22          52       ret
05B4             53   
05B4             54   ;---------------------------------;
05B4             55   ; Writes acc to LCD in 4-bit mode ;
05B4             56   ;---------------------------------;
05B4             57   ELCD_byte:
05B4             58            ; Write high 4 bits first
05B4 A2E7        59            mov c, ACC.7
05B6 9281        60            mov ELCD_D7, c
05B8 A2E6        61            mov c, ACC.6
05BA 9283        62            mov ELCD_D6, c
05BC A2E5        63            mov c, ACC.5
05BE 9285        64            mov ELCD_D5, c
05C0 A2E4        65            mov c, ACC.4
05C2 9287        66            mov ELCD_D4, c
05C4 1205A9      67       lcall ELCD_pulse
05C7             68            ; Write low 4 bits next
05C7 A2E3        69            mov c, ACC.3
05C9 9281        70            mov ELCD_D7, c
05CB A2E2        71            mov c, ACC.2
05CD 9283        72            mov ELCD_D6, c
05CF A2E1        73            mov c, ACC.1
05D1 9285        74            mov ELCD_D5, c
05D3 A2E0        75            mov c, ACC.0
05D5 9287        76            mov ELCD_D4, c
05D7 1205A9      77       lcall ELCD_pulse
05DA 22          78            ret
05DB             79   
05DB             80   ;---------------------------------;
05DB             81   ; Write data to LCD               ;
05DB             82   ;---------------------------------;
                 83   WriteData mac
                 84   	mov a, %0
                 85   	lcall ?WriteData
                 86   endmac
05DB             87            
05DB             88   ?WriteData:
05DB D297        89            setb ELCD_RS
05DD 0205B4      90            ljmp ELCD_byte
05E0             91   
05E0             92   ;---------------------------------;
05E0             93   ; Write command to LCD            ;
05E0             94   ;---------------------------------;
                 95   WriteCommand mac
                 96   	mov a, %0
                 97   	lcall ?WriteCommand
                 98   endmac
05E0             99   
05E0            100   ?WriteCommand:
05E0 C297       101            clr ELCD_RS
05E2 0205B4     102            ljmp ELCD_byte
05E5            103   
05E5            104   ;---------------------------------;
05E5            105   ; Configure LCD in 4-bit mode     ;
05E5            106   ;---------------------------------;
05E5            107   ELCD_4BIT:
05E5 C291       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
05E7            109            ;clr ELCD_RW  ; RW forced to zero
05E7            110            
05E7            111            ; After power on, let the LCD start up before initializing
05E7 C002       112            push AR2
05E9 7A28       112            mov R2, #40
05EB 120596     112            lcall ?Wait_Milli_Seconds
05EE D002       112            pop AR2
05F0            113            
05F0            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
05F0 7433       115            mov a, #0x33
05F2 1205E0     115            lcall ?WriteCommand
05F5 7433       116            mov a, #0x33
05F7 1205E0     116            lcall ?WriteCommand
05FA 7432       117            mov a, #0x32
05FC 1205E0     117            lcall ?WriteCommand ; change to 4-bit mode
05FF            118   
05FF            119            ; Configure the LCD
05FF 7428       120            mov a, #0x28
0601 1205E0     120            lcall ?WriteCommand
0604 740C       121            mov a, #0x0c
0606 1205E0     121            lcall ?WriteCommand
0609 7401       122            mov a, #0x01
060B 1205E0     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
060E            123   
060E            124       ;Wait for the clear screen command to finish.
060E C002       125            push AR2
0610 7A02       125            mov R2, #2
0612 120596     125            lcall ?Wait_Milli_Seconds
0615 D002       125            pop AR2
0617 22         126       ret
0618            127   
0618            128   ;---------------------------------;
0618            129   ; Send a constant string to LCD   ;
0618            130   ;---------------------------------;
                131   Send_Constant_String mac
                132   	push dph
                133   	push dpl
                134   	push acc
                135   	mov dptr, %0
                136   	lcall ?Send_Constant_String
                137   	pop acc
                138   	pop dpl
                139   	pop dph
                140   endmac
0618            141   
0618            142   ?Send_Constant_String:
0618 E4         143       clr a
0619 93         144       movc a, @a+dptr
061A 6006       145       jz ?Send_Constant_String_Done
061C 1205DB     146       lcall ?WriteData
061F A3         147       inc dptr
0620 80F6       148       sjmp ?Send_Constant_String
0622            149   ?Send_Constant_String_Done:
0622 22         150       ret  
0623            151   
0623            152   ;---------------------------------;
0623            153   ; Set LCD cursor at row, column   ;
0623            154   ;---------------------------------;
                155   Set_Cursor mac
                156   	push acc
                157   	mov a, #%1
                158   	dec a
                159   	lcall ?Set_Cursor_%0 ; Select column and row
                160   	pop acc
                161   endmac
0623            162   
0623            163   ?Set_Cursor_2:
0623 4440       164            orl a, #01000000B
0625            165   ?Set_Cursor_1:
0625 4480       166            orl a, #10000000B
0627 0205E0     167            ljmp ?WriteCommand ; Select column and row
062A            168   
062A            169   ;---------------------------------;
062A            170   ; Display a BCD number in the LCD ;
062A            171   ;---------------------------------;
                172   Display_BCD mac
                173   	push ar0
                174   	mov r0, %0
                175   	lcall ?Display_BCD
                176   	pop ar0
                177   endmac
062A            178   
062A            179   ?Display_BCD:
062A C0E0       180            push acc
062C            181            ; Write most significant digit
062C E8         182            mov a, r0
062D C4         183            swap a
062E 540F       184            anl a, #0fh
0630 4430       185            orl a, #30h
0632 1205DB     186            lcall ?WriteData
0635            187            ; write least significant digit
0635 E8         188            mov a, r0
0636 540F       189            anl a, #0fh
0638 4430       190            orl a, #30h
063A 1205DB     191            lcall ?WriteData
063D D0E0       192            pop acc
063F 22         193            ret
0640            194   
0640            195   ;------------------------------------;
0640            196   ; Display a char in the LCD          ;
0640            197   ;------------------------------------;
                198   Display_char mac
                199   	push acc
                200   	mov a, %0
                201   	lcall ?WriteData
                202   	pop acc
                203   endmac
0640            204   
0640            370            ;-------------------------------------------------------------------------------
0640            371   ; Display Function for 7-segment displays       
0640            372   ;-------------------------------------------------------------------------------
0640            373   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
0640            374   T_7seg:
0640 C0F9A4B0   375       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
0645 9282F880   376       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
064A 8883C6A1   377       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
0650            378   
0650            379   ; Displays a BCD number pased in R0 in HEX5-HEX0
0650            380   Display_BCD_7_Seg_HEX10:
0650 900640     381       mov dptr, #T_7seg
0653 E8         382       mov a, R0
0654 C4         383       swap a
0655 540F       384       anl a, #0FH
0657 93         385       movc a, @a+dptr
0658 F592       386       mov HEX1, a
065A E8         387       mov a, R0
065B 540F       388       anl a, #0FH
065D 93         389       movc a, @a+dptr
065E F591       390       mov HEX0, a
0660 22         391       ret
0661            392   
0661            393   Display_BCD_7_Seg_HEX32:
0661 900640     394       mov dptr, #T_7seg
0664 E8         395       mov a, R0
0665 C4         396       swap a
0666 540F       397       anl a, #0FH
0668 93         398       movc a, @a+dptr
0669 F594       399       mov HEX3, a
066B E8         400       mov a, R0
066C 540F       401       anl a, #0FH
066E 93         402       movc a, @a+dptr
066F F593       403       mov HEX2, a
0671 22         404       ret
0672            405   
0672            406   Display_BCD_7_Seg_HEX54:
0672 900640     407       mov dptr, #T_7seg
0675 E8         408       mov a, R0
0676 C4         409       swap a
0677 540F       410       anl a, #0FH
0679 93         411       movc a, @a+dptr
067A F58F       412       mov HEX5, a
067C E8         413       mov a, R0
067D 540F       414       anl a, #0FH
067F 93         415       movc a, @a+dptr
0680 F58E       416       mov HEX4, a
0682 22         417       ret
0683            418   
0683            419   ; The 8-bit hex number passed in the accumulator is converted to
0683            420   ; BCD and stored in [R1, R0]
0683            421   Hex_to_bcd_8bit:
0683 75F064     422       mov b, #100
0686 84         423       div ab
0687 F9         424       mov R1, a   ; After dividing, a has the 100s
0688 E5F0       425       mov a, b    ; Remainder is in register b
068A 75F00A     426       mov b, #10
068D 84         427       div ab ; The tens are stored in a, the units are stored in b 
068E C4         428       swap a
068F 54F0       429       anl a, #0xf0
0691 45F0       430       orl a, b
0693 F8         431       mov R0, a
0694 22         432       ret
0695            433   ;-------------------------------------------------------------------------------
0695            434   ; Display Function for LCD                      
0695            435   ;-------------------------------------------------------------------------------
0695            436   LCD_Print_2Digits:
0695 120683     437       lcall Hex_to_bcd_8bit
0698 E8         438       mov a, R0
0699 C4         439       swap a
069A 540F       440       anl a, #0x0F
069C 2430       441       add a, #0x30
069E 1205DB     442       lcall ?WriteData
06A1 E8         443       mov a, R0
06A2 540F       444       anl a, #0x0F
06A4 2430       445       add a, #0x30
06A6 1205DB     446       lcall ?WriteData
06A9 22         447       ret
06AA            448   
06AA            449   LCD_Display_Update_func:
06AA C0E0       450       push acc
06AC            451       
06AC            452   ;-------------------------------------------------------------------------------
06AC            453   ; static text
06AC            454   ; runs only when the state changes
06AC            455   ;-------------------------------------------------------------------------------
06AC 200C03     456       jb state_change_signal, Do_Static_Update
06AF 0207E8     457       ljmp Check_Live_Update
06B2            458   
06B2            459   Do_Static_Update:
06B2 C20C       460       clr state_change_signal
06B4            461       
06B4            462       ; State Changed: Clear Screen and Write Title
06B4 121000     463       lcall Clear_Screen_Func
06B7 E568       464       mov a, Control_FSM_state
06B9            465       
06B9            466       ; State 0: Welcome
06B9 B4003B     467       cjne a, #0, LCD_Check_1
06BC C0E0       468            push acc
06BE 7401       468            mov a, #1
06C0 14         468            dec a
06C1 120625     468            lcall ?Set_Cursor_1 ; Select column and row
06C4 D0E0       468            pop acc
06C6 C083       469            push dph
06C8 C082       469            push dpl
06CA C0E0       469            push acc
06CC 900330     469            mov dptr, #String_state0_1
06CF 120618     469            lcall ?Send_Constant_String
06D2 D0E0       469            pop acc
06D4 D082       469            pop dpl
06D6 D083       469            pop dph
06D8 C0E0       470            push acc
06DA 7401       470            mov a, #1
06DC 14         470            dec a
06DD 120623     470            lcall ?Set_Cursor_2 ; Select column and row
06E0 D0E0       470            pop acc
06E2 C083       471            push dph
06E4 C082       471            push dpl
06E6 C0E0       471            push acc
06E8 900340     471            mov dptr, #String_state0_2
06EB 120618     471            lcall ?Send_Constant_String
06EE D0E0       471            pop acc
06F0 D082       471            pop dpl
06F2 D083       471            pop dph
06F4 0207E5     472       ljmp LCD_Done_Bridge ; Exit
06F7            473   
06F7            474   LCD_Check_1: ; Setup
06F7 B4011F     475       cjne a, #1, LCD_Check_2
06FA C0E0       476            push acc
06FC 7401       476            mov a, #1
06FE 14         476            dec a
06FF 120625     476            lcall ?Set_Cursor_1 ; Select column and row
0702 D0E0       476            pop acc
0704 C083       477            push dph
0706 C082       477            push dpl
0708 C0E0       477            push acc
070A 9003A5     477            mov dptr, #String_state1
070D 120618     477            lcall ?Send_Constant_String
0710 D0E0       477            pop acc
0712 D082       477            pop dpl
0714 D083       477            pop dph
0716 0207E5     478       ljmp LCD_Done_Bridge
0719            479   
0719            480   LCD_Check_2: ; Ramp to Soak
0719 B4021F     481       cjne a, #2, LCD_Check_3
071C C0E0       482            push acc
071E 7401       482            mov a, #1
0720 14         482            dec a
0721 120625     482            lcall ?Set_Cursor_1 ; Select column and row
0724 D0E0       482            pop acc
0726 C083       483            push dph
0728 C082       483            push dpl
072A C0E0       483            push acc
072C 9003EC     483            mov dptr, #String_state2
072F 120618     483            lcall ?Send_Constant_String
0732 D0E0       483            pop acc
0734 D082       483            pop dpl
0736 D083       483            pop dph
0738 020808     484       ljmp LCD_Update_Temp_Value
073B            485   
073B            486   LCD_Check_3: ; Soak
073B B4031F     487       cjne a, #3, LCD_Check_4
073E C0E0       488            push acc
0740 7401       488            mov a, #1
0742 14         488            dec a
0743 120625     488            lcall ?Set_Cursor_1 ; Select column and row
0746 D0E0       488            pop acc
0748 C083       489            push dph
074A C082       489            push dpl
074C C0E0       489            push acc
074E 9003FC     489            mov dptr, #String_state3
0751 120618     489            lcall ?Send_Constant_String
0754 D0E0       489            pop acc
0756 D082       489            pop dpl
0758 D083       489            pop dph
075A 020808     490       ljmp LCD_Update_Temp_Value
075D            491   
075D            492   LCD_Check_4: ; Ramp to Peak
075D B4041F     493       cjne a, #4, LCD_Check_5
0760 C0E0       494            push acc
0762 7401       494            mov a, #1
0764 14         494            dec a
0765 120625     494            lcall ?Set_Cursor_1 ; Select column and row
0768 D0E0       494            pop acc
076A C083       495            push dph
076C C082       495            push dpl
076E C0E0       495            push acc
0770 90040C     495            mov dptr, #String_state4
0773 120618     495            lcall ?Send_Constant_String
0776 D0E0       495            pop acc
0778 D082       495            pop dpl
077A D083       495            pop dph
077C 020808     496       ljmp LCD_Update_Temp_Value
077F            497   
077F            498   LCD_Check_5: ; Reflow
077F B4051F     499       cjne a, #5, LCD_Check_6
0782 C0E0       500            push acc
0784 7401       500            mov a, #1
0786 14         500            dec a
0787 120625     500            lcall ?Set_Cursor_1 ; Select column and row
078A D0E0       500            pop acc
078C C083       501            push dph
078E C082       501            push dpl
0790 C0E0       501            push acc
0792 90041C     501            mov dptr, #String_state5
0795 120618     501            lcall ?Send_Constant_String
0798 D0E0       501            pop acc
079A D082       501            pop dpl
079C D083       501            pop dph
079E 020808     502       ljmp LCD_Update_Temp_Value
07A1            503   
07A1            504   LCD_Check_6: ; Cooling
07A1 B4061F     505       cjne a, #6, LCD_Check_7
07A4 C0E0       506            push acc
07A6 7401       506            mov a, #1
07A8 14         506            dec a
07A9 120625     506            lcall ?Set_Cursor_1 ; Select column and row
07AC D0E0       506            pop acc
07AE C083       507            push dph
07B0 C082       507            push dpl
07B2 C0E0       507            push acc
07B4 90042C     507            mov dptr, #String_state6
07B7 120618     507            lcall ?Send_Constant_String
07BA D0E0       507            pop acc
07BC D082       507            pop dpl
07BE D083       507            pop dph
07C0 020808     508       ljmp LCD_Update_Temp_Value
07C3            509   
07C3            510   LCD_Check_7: ; Done
07C3 B4071F     511       cjne a, #7, LCD_Done_Bridge ; If not 7, we are done
07C6 C0E0       512            push acc
07C8 7401       512            mov a, #1
07CA 14         512            dec a
07CB 120625     512            lcall ?Set_Cursor_1 ; Select column and row
07CE D0E0       512            pop acc
07D0 C083       513            push dph
07D2 C082       513            push dpl
07D4 C0E0       513            push acc
07D6 90043C     513            mov dptr, #String_state7
07D9 120618     513            lcall ?Send_Constant_String
07DC D0E0       513            pop acc
07DE D082       513            pop dpl
07E0 D083       513            pop dph
07E2 0207E5     514       ljmp LCD_Done_Bridge
07E5            515   
07E5            516   ; Local bridge to reach the far-away LCD_Done
07E5            517   LCD_Done_Bridge:
07E5 020869     518       ljmp LCD_Done
07E8            519   
07E8            520   ;-------------------------------------------------------------------------------
07E8            521   ; PART 2: dyanmic for temp
07E8            522   ; runs every time 'one_second_flag' is set
07E8            523   ;-------------------------------------------------------------------------------
07E8            524   Check_Live_Update:
07E8 3001FA     525       jnb one_second_flag, LCD_Done_Bridge
07EB C201       526       clr one_second_flag
07ED            527       
07ED            528       ; Only update temp for States 2, 3, 4, 5, 6
07ED E568       529       mov a, Control_FSM_state
07EF B40202     530       cjne a, #2, Check_St3
07F2 8014       531       sjmp LCD_Update_Temp_Value
07F4            532   Check_St3:
07F4 B40302     533       cjne a, #3, Check_St4
07F7 800F       534       sjmp LCD_Update_Temp_Value
07F9            535   Check_St4:
07F9 B40402     536       cjne a, #4, Check_St5
07FC 800A       537       sjmp LCD_Update_Temp_Value
07FE            538   Check_St5:
07FE B40502     539       cjne a, #5, Check_St6
0801 8005       540       sjmp LCD_Update_Temp_Value
0803            541   Check_St6:
0803 B40663     542       cjne a, #6, LCD_Done
0806 8000       543       sjmp LCD_Update_Temp_Value
0808            544   
0808            545   LCD_Update_Temp_Value:
0808 C0E0       546            push acc
080A 7401       546            mov a, #1
080C 14         546            dec a
080D 120623     546            lcall ?Set_Cursor_2 ; Select column and row
0810 D0E0       546            pop acc
0812 853F32     547       mov x, current_temp
0815 854033     548       mov x+1, current_temp+1
0818 854134     549       mov x+2, current_temp+2
081B 854235     550       mov x+3, current_temp+3
081E 12002E     551       lcall hex2bcd
0821 12086C     552       lcall Update_HEX_Temp 
0824 E53B       553       mov a, bcd+1
0826 540F       554       anl a, #0x0F
0828 2430       555       add a, #0x30
082A 1205DB     556       lcall ?WriteData
082D E53A       557       mov a, bcd+0
082F C4         558       swap a
0830 540F       559       anl a, #0x0F
0832 2430       560       add a, #0x30
0834 1205DB     561       lcall ?WriteData
0837 E53A       562       mov a, bcd+0
0839 540F       563       anl a, #0x0F
083B 2430       564       add a, #0x30
083D 1205DB     565       lcall ?WriteData
0840 7443       566       mov a, #'C'
0842 1205DB     567       lcall ?WriteData
0845 7420       568       mov a, #' '
0847 1205DB     569       lcall ?WriteData
084A 1205DB     570       lcall ?WriteData
084D C0E0       571            push acc
084F 740C       571            mov a, #12
0851 14         571            dec a
0852 120623     571            lcall ?Set_Cursor_2 ; Select column and row
0855 D0E0       571            pop acc
0857 E531       572       mov a, current_time_minute
0859 120695     573       lcall LCD_Print_2Digits
085C 743A       574       mov a, #':'
085E 1205DB     575       lcall ?WriteData
0861 E530       576       mov a, current_time_sec
0863 120695     577       lcall LCD_Print_2Digits
0866 1204C5     578       lcall Serial_Send_Temp_Line
0869            579   
0869            580   LCD_Done:
0869 D0E0       581       pop acc
086B 22         582       ret
086C            583   ;-------------------------------------------------------------------------------
086C            584   ; Update HEX2-HEX0 with temperature (3 digits)
086C            585   ;-------------------------------------------------------------------------------
086C            586   Update_HEX_Temp:
086C 900640     587       mov dptr, #T_7seg
086F            588       ; Hundreds -> HEX2
086F E53B       589       mov a, bcd+1
0871 540F       590       anl a, #0x0F
0873 93         591       movc a, @a+dptr
0874 F593       592       mov HEX2, a
0876            593       ; Tens -> HEX1
0876 E53A       594       mov a, bcd+0
0878 C4         595       swap a
0879 540F       596       anl a, #0x0F
087B 93         597       movc a, @a+dptr
087C F592       598       mov HEX1, a
087E            599       ; Ones -> HEX0
087E E53A       600       mov a, bcd+0
0880 540F       601       anl a, #0x0F
0882 93         602       movc a, @a+dptr
0883 F591       603       mov HEX0, a
0885 22         604       ret
0886            605   
0886            606   KEY1_DEB:
0886            607   ;non-blocking state machine for KEY1 debounce
0886 E566       608       mov a, KEY1_DEB_state
0888            609   KEY1_DEB_state0:
0888 B4000A     610       cjne a, #0, KEY1_DEB_state1
088B 20F92D     611       jb KEY.1, KEY1_DEB_done
088E 756400     612       mov KEY1_DEB_timer, #0
0891 0566       613       inc KEY1_DEB_state
0893 8026       614       sjmp KEY1_DEB_done
0895            615   KEY1_DEB_state1:
0895 B40109     616       cjne a, #1, KEY1_DEB_state2
0898            617       ; this is the debounce state
0898 E564       618       mov a, KEY1_DEB_timer
089A B4321E     619       cjne a, #50, KEY1_DEB_done ; 50 ms passed?
089D 0566       620       inc KEY1_DEB_state
089F 801A       621       sjmp KEY1_DEB_done  
08A1            622   KEY1_DEB_state2:
08A1 B4020C     623       cjne a, #2, KEY1_DEB_state3
08A4 20F904     624       jb KEY.1, KEY1_DEB_state2b
08A7 0566       625       inc KEY1_DEB_state
08A9 8010       626       sjmp KEY1_DEB_done  
08AB            627   KEY1_DEB_state2b:
08AB 756600     628       mov KEY1_DEB_state, #0
08AE 800B       629       sjmp KEY1_DEB_done
08B0            630   KEY1_DEB_state3:
08B0 B40308     631       cjne a, #3, KEY1_DEB_done
08B3 30F905     632       jnb KEY.1, KEY1_DEB_done
08B6 D20D       633       setb Key1_flag ; Suscesfully detected a valid KEY1 press/release
08B8 756600     634       mov KEY1_DEB_state, #0  
08BB            635   KEY1_DEB_done:
08BB 22         636       ret
08BC            637   ;-------------------------------------------------------------------------------
08BC            638   ; Non-blocking FSM for the one second counter
08BC            639   ;-------------------------------------------------------------------------------
08BC            640   SEC_FSM:
08BC E567       641       mov a, SEC_FSM_state
08BE            642   SEC_FSM_state0:
08BE B4000C     643       cjne a, #0, SEC_FSM_state1
08C1 E565       644       mov a, SEC_FSM_timer
08C3 B4FA4B     645       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08C6 756500     646       mov SEC_FSM_timer, #0
08C9 0567       647       inc SEC_FSM_state
08CB 8044       648       sjmp SEC_FSM_done
08CD            649   SEC_FSM_state1: 
08CD B4010E     650       cjne a, #1, SEC_FSM_state2
08D0 D2E9       651       setb LEDRA.1
08D2 E565       652       mov a, SEC_FSM_timer
08D4 B4FA3A     653       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08D7 756500     654       mov SEC_FSM_timer, #0
08DA 0567       655       inc SEC_FSM_state
08DC 8033       656       sjmp SEC_FSM_done
08DE            657   SEC_FSM_state2: 
08DE B4020E     658       cjne a, #2, SEC_FSM_state3
08E1 D2EA       659       setb LEDRA.2
08E3 E565       660       mov a, SEC_FSM_timer
08E5 B4FA29     661       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08E8 756500     662       mov SEC_FSM_timer, #0
08EB 0567       663       inc SEC_FSM_state
08ED 8022       664       sjmp SEC_FSM_done
08EF            665   SEC_FSM_state3: 
08EF B4031F     666       cjne a, #3, SEC_FSM_done
08F2 D2EB       667       setb LEDRA.3
08F4 E565       668       mov a, SEC_FSM_timer
08F6 B4FA18     669       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08F9 756500     670       mov SEC_FSM_timer, #0
08FC 756700     671       mov SEC_FSM_state, #0
08FF D201       672       setb one_second_flag
0901 E530       673       mov a, current_time_sec
0903 B43B07     674       cjne a, #59, IncCurrentTimeSec 
0906 753000     675       mov current_time_sec, #0
0909 0531       676       inc current_time_minute 
090B            677       
090B 8004       678       sjmp SEC_FSM_done
090D            679   
090D            680   IncCurrentTimeSec:
090D 0530       681       inc current_time_sec
090F B2E8       682       cpl LEDRA.0 
0911            683   SEC_FSM_done:
0911 22         684       ret
0912            685   ;-------------------------------------------------------------------------------
0912            686   ; PWM
0912            687   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0912            688   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0912            689   ; ------------------------------------------------------------------------------
0912            690   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0912 100202     691       jbc one_ms_pwm_flag, pwm_wave_generator
0915 8071       692       sjmp end_pwm_generator
0917            693   
0917            694   pwm_wave_generator:
0917 C200       695       clr mf
0919            696       ; move pwm counter value into x for comparison purpose
0919 856032     697       mov x, pwm_counter
091C 856133     698       mov x+1, pwm_counter+1
091F 856234     699       mov x+2, pwm_counter+2
0922 856335     700       mov x+3, pwm_counter+3
0925            701   
0925 7536DB     702            mov y+0, #low (PWM_PERIOD % 0x10000) 
0928 753705     702            mov y+1, #high(PWM_PERIOD % 0x10000) 
092B 753800     702            mov y+2, #low (PWM_PERIOD / 0x10000) 
092E 753900     702            mov y+3, #high(PWM_PERIOD / 0x10000) 
0931            703   
0931            704       ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
0931            705       ; increase x by 1
0931 120152     706       lcall x_eq_y 
0934 20001D     707       jb mf, wrap_pwm_counter
0937            708       ; x not equal 1499, increment by 1
0937 753601     709            mov y+0, #low (1 % 0x10000) 
093A 753700     709            mov y+1, #high(1 % 0x10000) 
093D 753800     709            mov y+2, #low (1 / 0x10000) 
0940 753900     709            mov y+3, #high(1 / 0x10000) 
0943 1200D3     710       lcall add32
0946            711       ; update pwm_counter
0946 853260     712       mov pwm_counter, x
0949 853361     713       mov pwm_counter+1, x+1
094C 853462     714       mov pwm_counter+2, x+2
094F 853563     715       mov pwm_counter+3, x+3
0952 8018       716       sjmp set_pwm
0954            717   
0954            718   wrap_pwm_counter:
0954            719       ; x equal 1499, wrap to 0
0954 753200     720            mov x+0, #low (0 % 0x10000) 
0957 753300     720            mov x+1, #high(0 % 0x10000) 
095A 753400     720            mov x+2, #low (0 / 0x10000) 
095D 753500     720            mov x+3, #high(0 / 0x10000) 
0960 853260     721       mov pwm_counter, x
0963 853361     722       mov pwm_counter+1, x+1
0966 853462     723       mov pwm_counter+2, x+2
0969 853563     724       mov pwm_counter+3, x+3
096C            725   
096C            726   set_pwm:
096C            727       ; compare with power_output, if pwm counter smaller than power_output, 
096C            728       ; set pwm pin high; else set pwm pin low load y with power output value
096C 855C36     729       mov y, power_output
096F 855D37     730       mov y+1, power_output+1
0972 855E38     731       mov y+2, power_output+2
0975 855F39     732       mov y+3, power_output+3
0978            733   
0978            734       ; compare x(pwm counter) with y(power output)
0978 12011A     735       lcall x_lt_y
097B 200006     736       jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
097E            737       ;output set pwm pin low if pwm counter greater than power output
097E C293       738       clr PWM_OUT
0980 C2EC       739       clr LEDRA.4
0982 8004       740       sjmp end_pwm_generator
0984            741   
0984            742   set_pwm_high:
0984 D293       743       setb PWM_OUT
0986 D2EC       744       setb LEDRA.4
0988            745   
0988            746   end_pwm_generator:
0988 22         747       ret
0989            748   ;-------------------------------------------------------------------------------;
0989            749   ; Temp_Compare
0989            750   ; Checks if we have reached the user's target temperatures.
0989            751   ; Sets 'soak_temp_reached' if current_temp >= soak_temp
0989            752   ; Sets 'reflow_temp_reached' if current_temp >= reflow_temp
0989            753   ;-------------------------------------------------------------------------------;
0989            754   Temp_Compare:
0989            755       ; Reset flags initially
0989 C203       756       clr soak_temp_reached
098B C204       757       clr reflow_temp_reached
098D            758   
098D C0E0       759       push acc
098F C0D0       760       push psw
0991 C000       761       push AR0
0993 C001       762       push AR1
0995 C002       763       push AR2
0997            764       
0997            765       ; --- 1. CHECK SOAK TEMP ---
0997            766       ; Copy current_temp to X
0997 783F       767       mov R0, #current_temp
0999 7932       768       mov R1, #x
099B 120A0F     769       lcall Copy4_Bytes_R0_to_R1
099E            770   
099E            771       ; Copy soak_temp to Y
099E 7843       772       mov R0, #soak_temp
09A0 7936       773       mov R1, #y
09A2 120A0F     774       lcall Copy4_Bytes_R0_to_R1
09A5            775   
09A5            776       ; Compare: Is X (Current) < Y (Target)?
09A5 12011A     777       lcall x_lt_y
09A8 200002     778       jb mf, Check_Reflow_Threshold ; If Current < Target, jump (Flag stays 0)
09AB            779       
09AB            780       ; If we are here, Current >= Target
09AB D203       781       setb soak_temp_reached
09AD            782   
09AD            783   Check_Reflow_Threshold:
09AD            784       ; --- 2. CHECK REFLOW TEMP ---
09AD            785       ; Copy current_temp to X (Need to reload X because math32 destroys it)
09AD 783F       786       mov R0, #current_temp
09AF 7932       787       mov R1, #x
09B1 120A0F     788       lcall Copy4_Bytes_R0_to_R1
09B4            789   
09B4            790       ; Copy reflow_temp to Y
09B4 7847       791       mov R0, #reflow_temp
09B6 7936       792       mov R1, #y
09B8 120A0F     793       lcall Copy4_Bytes_R0_to_R1
09BB            794   
09BB            795       ; Compare
09BB 12011A     796       lcall x_lt_y
09BE 200002     797       jb mf, Temp_Compare_Done
09C1            798       
09C1            799       ; If Current >= Target
09C1 D204       800       setb reflow_temp_reached
09C3            801   
09C3            802   Temp_Compare_Done:
09C3 D002       803       pop AR2
09C5 D001       804       pop AR1
09C7 D000       805       pop AR0
09C9 D0D0       806       pop psw
09CB D0E0       807       pop acc
09CD 22         808       ret
09CE            809   ;-------------------------------------------------------------------------------;
09CE            810   ; Time_Compare
09CE            811   ;
09CE            812   ; PURPOSE:
09CE            813   ;   Compare the elapsed time against soak and reflow
09CE            814   ;   time limits.
09CE            815   ;
09CE            816   ; BEHAVIOR:
09CE            817   ;   - If current_time >= soak_time   if soak_time_reached    = 1
09CE            818   ;   - If current_time >= reflow_time if reflow_time_reached = 1
09CE            819   ;
09CE            820   ; NOTES:
09CE            821   ;   - Time values are treated as 32-bit UNSIGNED numbers
09CE            822   ;     (e.g., milliseconds or seconds).
09CE            823   ;   - Uses the SAME compare logic as Temp_Compare.
09CE            824   ;   - This routine ONLY SETS flags.
09CE            825   ;
09CE            826   ; EXPECTED VARIABLES:
09CE            827   ;   current_time[4], soak_time[4], reflow_time[4]
09CE            828   ;   x[4], y[4]
09CE            829   ;   mf, soak_time_reached, reflow_time_reached
09CE            830   ;-------------------------------------------------------------------------------;
09CE            831   Time_Compare:
09CE C0E0       832       push acc
09D0 C0D0       833       push psw
09D2 C000       834       push AR0
09D4 C001       835       push AR1
09D6 C002       836       push AR2
09D8            837   
09D8            838   ; Check: current_time >= soak_time ?
09D8            839       ; Copy current_time of x
09D8 7850       840       mov  R0, #current_time
09DA 7932       841       mov  R1, #x
09DC 120A0F     842       lcall Copy4_Bytes_R0_to_R1
09DF            843   
09DF            844       ; Copy soak_time of y
09DF 7854       845       mov  R0, #soak_time
09E1 7936       846       mov  R1, #y
09E3 120A0F     847       lcall Copy4_Bytes_R0_to_R1
09E6            848   
09E6            849       ; Compare elapsed time vs soak time
09E6 12011A     850       lcall x_lt_y
09E9 200002     851       jb   mf, Time_Soak_NotReached
09EC D206       852       setb soak_time_reached
09EE            853   
09EE            854   ; Check: current_time >= reflow_time ?
09EE            855   Time_Soak_NotReached:
09EE            856       ; Copy current_time of x
09EE 7850       857       mov  R0, #current_time
09F0 7932       858       mov  R1, #x
09F2 120A0F     859       lcall Copy4_Bytes_R0_to_R1
09F5            860   
09F5            861       ; Copy reflow_time of y
09F5 7858       862       mov  R0, #reflow_time
09F7 7936       863       mov  R1, #y
09F9 120A0F     864       lcall Copy4_Bytes_R0_to_R1
09FC            865   
09FC            866       ; Compare elapsed time vs reflow time
09FC 12011A     867       lcall x_lt_y
09FF 200002     868       jb   mf, Time_Reflow_NotReached
0A02 D207       869       setb reflow_time_reached
0A04            870   
0A04            871   Time_Reflow_NotReached:
0A04 D002       872       pop  AR2
0A06 D001       873       pop  AR1
0A08 D000       874       pop  AR0
0A0A D0D0       875       pop  psw
0A0C D0E0       876       pop  acc
0A0E 22         877       ret
0A0F            878   
0A0F            879   ;-------------------------------------------------------------------------------;
0A0F            880   ; Copy4_Bytes_R0_to_R1
0A0F            881   ;
0A0F            882   ; PURPOSE:
0A0F            883   ;   Utility routine to copy a 32-bit value (4 bytes)
0A0F            884   ;   from one memory location to another.
0A0F            885   ;
0A0F            886   ; INPUTS:
0A0F            887   ;   R0 st source address
0A0F            888   ;   R1 at destination address
0A0F            889   ;
0A0F            890   ; USES:
0A0F            891   ;   R2 as loop counter
0A0F            892   ;
0A0F            893   ; EXAMPLE:
0A0F            894   ;   mov R0, #current_temp
0A0F            895   ;   mov R1, #x
0A0F            896   ;   lcall Copy4_Bytes_R0_to_R1
0A0F            897   ;-------------------------------------------------------------------------------;
0A0F            898   Copy4_Bytes_R0_to_R1:
0A0F 7A04       899       mov  R2, #4
0A11            900   Copy4_Loop:
0A11 E6         901       mov  a, @R0
0A12 F7         902       mov  @R1, a
0A13 08         903       inc  R0
0A14 09         904       inc  R1
0A15 DAFA       905       djnz R2, Copy4_Loop
0A17 22         906       ret
0A18            907   
0A18            908   ;-------------------------------------------------------------------------------;
0A18            909   ; Abort condition safety check Temperature time
0A18            910   ;
0A18            911   ; PURPOSE:
0A18            912   ;   Automatic cycle termination on error:
0A18            913   ;   Abort if oven fails to reach at least 50C in first 60s.
0A18            914   ;
0A18            915   ; TRIP CONDITION:
0A18            916   ;   if (current_time >= 60s) AND (current_temp < 50C)
0A18            917   ;       -> set tc_missing_abort
0A18            918   ;       -> set stop_signal
0A18            919   ;
0A18            920   ; ASSUMPTIONS:
0A18            921   ;   - current_time is in SECONDS (32-bit, little-endian)
0A18            922   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
0A18            923   ;
0A18            924   ;   the Load_Y constants accordingly.
0A18            925   ;-------------------------------------------------------------------------------;
0A18            926   Safety_Check_TC:
0A18 C0E0       927       push acc
0A1A C0D0       928       push psw
0A1C C000       929       push AR0
0A1E C001       930       push AR1
0A20 C002       931       push AR2
0A22            932   
0A22            933       ; ---------------------------------------------------------
0A22            934       ; [FIX] GATEKEEPER: IGNORE UNLESS IN STATE 2 (RAMP TO SOAK)
0A22            935       ; ---------------------------------------------------------
0A22 E568       936       mov a, Control_FSM_state
0A24 B40202     937       cjne a, #2, Safety_TC_Exit_Bridge ; If State != 2, skip everything
0A27 8003       938       sjmp Safety_Logic_Proceed         ; If State == 2, do the check
0A29            939   
0A29            940       Safety_TC_Exit_Bridge:
0A29 020A77     941           ljmp Safety_TC_Done               ; Jump to the end
0A2C            942   
0A2C            943       Safety_Logic_Proceed:
0A2C            944           ; If already aborted or startup window closed, do nothing
0A2C 200E48     945           jb   tc_missing_abort, Safety_TC_Done
0A2F 300F45     946           jnb  tc_startup_window, Safety_TC_Done
0A32            947   
0A32            948       ; Check: current_time >= 60 ?
0A32 7850       949       mov  R0, #current_time
0A34 7932       950       mov  R1, #x
0A36 120A0F     951       lcall Copy4_Bytes_R0_to_R1
0A39            952   
0A39 75363C     953            mov y+0, #low (60 % 0x10000) 
0A3C 753700     953            mov y+1, #high(60 % 0x10000) 
0A3F 753800     953            mov y+2, #low (60 / 0x10000) 
0A42 753900     953            mov y+3, #high(60 / 0x10000) 
0A45 12011A     954       lcall x_lt_y
0A48 2000DE     955       jb   mf, Safety_TC_Exit_Bridge        ; still < 60s  keep waiting
0A4B            956   
0A4B            957       ; We reached 60s: close the startup window so it won't re-check later
0A4B C20F       958       clr  tc_startup_window
0A4D            959   
0A4D            960       ; Now check: current_temp < 50 ?
0A4D 783F       961       mov  R0, #current_temp
0A4F 7932       962       mov  R1, #x
0A51 120A0F     963       lcall Copy4_Bytes_R0_to_R1
0A54            964   
0A54 753632     965            mov y+0, #low (50 % 0x10000) 
0A57 753700     965            mov y+1, #high(50 % 0x10000) 
0A5A 753800     965            mov y+2, #low (50 / 0x10000) 
0A5D 753900     965            mov y+3, #high(50 / 0x10000) 
0A60 12011A     966       lcall x_lt_y
0A63 3000C3     967       jnb  mf, Safety_TC_Exit_Bridge        ; temp >= 50  pass
0A66            968   
0A66            969       ; FAIL: at 60s, still below 50C  abort
0A66 C293       970       clr  PWM_OUT
0A68 D20E       971       setb tc_missing_abort
0A6A D209       972       setb stop_signal
0A6C 120A8C     973            lcall Beep_Ten
0A6F            974       ; 3. Force FSM to State 0 (Welcome)
0A6F 756800     975       mov Control_FSM_state, #0
0A72            976       
0A72            977       ; 4. Force UI to State 0 (Home Screen)
0A72 756900     978       mov Current_State, #0
0A75            979       
0A75            980       ; 5. Trigger Screen Refresh
0A75 D20C       981       setb state_change_signal ; Tell loop to redraw "Welcome"
0A77            982   
0A77            983   Safety_TC_Done:
0A77 D002       984       pop  AR2
0A79 D001       985       pop  AR1
0A7B D000       986       pop  AR0
0A7D D0D0       987       pop  psw
0A7F D0E0       988       pop  acc
0A81 22         989       ret
0A82            990   
0A82            991   ; ============================================================
0A82            992   ; BUZZER STARTUP FUNCTIONS
0A82            993   ; ============================================================
0A82            994   
0A82            995   Beep_Once:
0A82 757301     996       mov beep_count, #1
0A85 800A       997       sjmp Beep_Start
0A87            998   
0A87            999   Beep_Five:
0A87 757305    1000       mov beep_count, #5
0A8A 8005      1001       sjmp Beep_Start
0A8C           1002   
0A8C           1003   Beep_Ten:
0A8C 75730A    1004       mov beep_count, #10
0A8F 8000      1005       sjmp Beep_Start      ; [FIX] Added explicit jump for safety
0A91           1006   
0A91           1007   Beep_Start:
0A91 C28C      1008       clr TR0              ; [FIX] Stop timer briefly to reset cleanly
0A93 757401    1009       mov beep_state, #1   ; Set State to ON
0A96 757500    1010       mov beep_tmr, #0     ; Reset Timer High Byte
0A99 757600    1011       mov beep_tmr+1, #0   ; Reset Timer Low Byte
0A9C D2A9      1012       setb ET0             ; [FIX] Ensure Interrupt is enabled
0A9E D28C      1013       setb TR0             ; START the 2kHz tone
0AA0 22        1014       ret
0AA1           1015   ;-------------------------------------------------------------------------------
0AA1           1016   ; Buzzer beep Task 
0AA1           1017   ; Purpose: beeps, holds, stop
0AA1           1018   ; Buzzer task:
0AA1           1019   ; Beep once when state changes
0AA1           1020   ; Beep five times if finished
0AA1           1021   ; Beep ten times if meets error
0AA1           1022   ;-------------------------------------------------------------------------------
0AA1           1023   Beep_Task:
0AA1 301335    1024       jnb one_ms_beep_flag, Beep_Done
0AA4 C213      1025       clr one_ms_beep_flag
0AA6           1026   
0AA6 E574      1027       mov a, beep_state
0AA8 602F      1028       jz Beep_Done
0AAA           1029   
0AAA           1030   ; ---- increment 16-bit timer ----
0AAA 0575      1031       inc beep_tmr
0AAC E575      1032       mov a, beep_tmr
0AAE 7002      1033       jnz Beep_Check
0AB0 0576      1034       inc beep_tmr+1
0AB2           1035   
0AB2           1036   Beep_Check:
0AB2           1037       ; FUZZY TIMER CHECK
0AB2           1038       ; Check if High Byte is non-zero (Time >= 256ms)
0AB2 E576      1039       mov a, beep_tmr+1
0AB4 6023      1040       jz Beep_Done        ; If 0, keep beeping
0AB6           1041   
0AB6           1042       ; --- Time Limit Reached ---
0AB6 757500    1043       mov beep_tmr, #0    ; Reset timer
0AB9 757600    1044       mov beep_tmr+1, #0
0ABC           1045   
0ABC E574      1046       mov a, beep_state
0ABE B40106    1047       cjne a, #1, Beep_Off_State
0AC1           1048   
0AC1           1049       ; State was 1 (ON) -> Turn OFF
0AC1 C28C      1050       clr TR0             ; Hardware Silence
0AC3 757402    1051       mov beep_state, #2  ; Set State to OFF (Pause)
0AC6 22        1052       ret
0AC7           1053   
0AC7           1054   Beep_Off_State:
0AC7           1055   ; ---- OFF finished -> decrement count / next ON ----
0AC7 1573      1056       dec beep_count
0AC9 E573      1057       mov a, beep_count
0ACB 6006      1058       jz  Beep_Stop
0ACD           1059   
0ACD 757401    1060       mov beep_state, #1
0AD0 D28C      1061       setb TR0
0AD2 22        1062       ret
0AD3           1063   
0AD3           1064   Beep_Stop:
0AD3 C28C      1065       clr TR0
0AD5 757400    1066       mov beep_state, #0
0AD8 22        1067       ret
0AD9           1068   
0AD9           1069   Beep_Done:
0AD9 22        1070       ret
0ADA           1071   ;-------------------------------------------------------------------------------;
0ADA           1072   ; Main Control FSM for the entire process
0ADA           1073   ;-------------------------------------------------------------------------------;
0ADA           1074   Control_FSM:
0ADA E568      1075       mov a, Control_FSM_state
0ADC 8005      1076       sjmp Control_FSM_state0
0ADE           1077   
0ADE           1078   Control_FSM_state0_a:
0ADE 756800    1079       mov Control_FSM_state, #0
0AE1 D20C      1080       setb state_change_signal
0AE3           1081            
0AE3           1082   Control_FSM_state0:
0AE3 B40015    1083       cjne a, #0, Control_FSM_state1
0AE6 209005    1084       jb P1.0, Control_FSM_done_bridge ; If Button High (Not Pressed), Exit
0AE9 12102A    1085       lcall Wait_For_P1_0_Release      ; If Low (Pressed), Wait & Proceed
0AEC 8001      1086       sjmp Control_FSM_state1_a  
0AEE           1087       
0AEE           1088   Control_FSM_done_bridge:
0AEE 22        1089       ret
0AEF           1090   
0AEF           1091   Control_FSM_state1_a:
0AEF 0568      1092       inc Control_FSM_state
0AF1 756900    1093       mov Current_State, #0
0AF4 120F08    1094       lcall Update_Screen_Full 
0AF7 D20C      1095       setb state_change_signal
0AF9 E568      1096       mov a, Control_FSM_state
0AFB           1097       
0AFB           1098   Control_FSM_state1:
0AFB B40127    1099       cjne a, #1, Control_FSM_state2
0AFE 120D40    1100       lcall Check_Buttons 
0B01 120D8C    1101       lcall Check_Keypad
0B04           1102       
0B04           1103       ; Check if Button is HIGH (Not Pressed). If so, exit.
0B04 209008    1104       jb P1.0, Control_FSM_state1_ret
0B07           1105       
0B07           1106       ; If we get here, Button is LOW (Pressed)
0B07 12102A    1107       lcall Wait_For_P1_0_Release
0B0A 120CC4    1108       lcall Update_FSM_Variables
0B0D 8001      1109       sjmp Control_FSM_state2_a
0B0F           1110   Control_FSM_state1_ret:
0B0F 22        1111       ret
0B10           1112   
0B10           1113   ; --- STATE 2: RAMP TO SOAK ---
0B10           1114   Control_FSM_state2_a:
0B10 0568      1115       inc Control_FSM_state
0B12 E568      1116       mov a, Control_FSM_state   ; RELOAD 'A' so it matches the new state!
0B14 D20C      1117       setb state_change_signal
0B16 120A82    1118       lcall Beep_Once
0B19           1119   
0B19 D20F      1120       setb tc_startup_window    ; OPEN the safety window
0B1B C20E      1121       clr tc_missing_abort      ; Clear any previous aborts
0B1D 753000    1122       mov current_time_sec, #0  ; Reset Seconds to 0
0B20 753100    1123       mov current_time_minute, #0 ; Reset Minutes to 0
0B23           1124       
0B23           1125       ; CLEAR FLAG ON ENTRY
0B23           1126       ; Force the system to wait for at least one fresh temp reading
0B23           1127       ; before deciding we are done.
0B23 C203      1128       clr soak_temp_reached      
0B25           1129   
0B25           1130   Control_FSM_state2:
0B25 B4021F    1131       cjne a, #2, Control_FSM_state3
0B28 301205    1132       jnb PB2_flag, State2_Check
0B2B C212      1133       clr PB2_flag
0B2D 020B98    1134       ljmp Control_FSM_state6_a ; Pause
0B30           1135   
0B30           1136   State2_Check:
0B30 300313    1137       jnb soak_temp_reached, State2_Ret
0B33           1138       
0B33           1139       ; --- Move to State 3 ---
0B33 C203      1140       clr soak_temp_reached
0B35 0568      1141       inc Control_FSM_state
0B37           1142       
0B37           1143       ; RELOAD 'A'
0B37 E568      1144       mov a, Control_FSM_state   
0B39           1145       
0B39 D20C      1146       setb state_change_signal
0B3B 120A82    1147       lcall Beep_Once
0B3E           1148       
0B3E 753000    1149       mov current_time_sec, #0
0B41 753100    1150       mov current_time_minute, #0
0B44           1151       
0B44           1152       ; Ensure we start State 3 fresh
0B44 C206      1153       clr soak_time_reached 
0B46           1154   
0B46           1155   State2_Ret:
0B46 22        1156       ret
0B47           1157   
0B47           1158   ; --- STATE 3: SOAK PHASE ---
0B47           1159   Control_FSM_state3:
0B47 B40315    1160       cjne a, #3, Control_FSM_state4
0B4A 301205    1161       jnb PB2_flag, State3_Check
0B4D C212      1162       clr PB2_flag
0B4F 020B98    1163       ljmp Control_FSM_state6_a
0B52           1164   State3_Check:
0B52 300609    1165       jnb soak_time_reached, State3_Ret
0B55 C206      1166       clr soak_time_reached
0B57 0568      1167       inc Control_FSM_state      
0B59 D20C      1168       setb state_change_signal 
0B5B 120A82    1169            lcall Beep_Once
0B5E           1170   State3_Ret:
0B5E 22        1171       ret
0B5F           1172   
0B5F           1173   ; --- STATE 4: RAMP TO PEAK ---
0B5F           1174   Control_FSM_state4:
0B5F B4041D    1175       cjne a, #4, Control_FSM_state5
0B62 301205    1176       jnb PB2_flag, State4_Check
0B65 C212      1177       clr PB2_flag
0B67 020B98    1178       ljmp Control_FSM_state6_a
0B6A           1179   State4_Check:
0B6A 300411    1180       jnb reflow_temp_reached, State4_Ret
0B6D C204      1181       clr reflow_temp_reached
0B6F 0568      1182       inc Control_FSM_state
0B71 D20C      1183       setb state_change_signal
0B73 120A82    1184            lcall Beep_Once
0B76 753000    1185       mov current_time_sec, #0
0B79 753100    1186       mov current_time_minute, #0
0B7C C207      1187       clr reflow_time_reached ; Kill the ghost flag
0B7E           1188   State4_Ret:
0B7E 22        1189       ret
0B7F           1190   
0B7F           1191   ; --- STATE 5: REFLOW PHASE ---
0B7F           1192   Control_FSM_state5:
0B7F B40502    1193       cjne a, #5, Control_FSM_state6_trampoline
0B82 8003      1194       sjmp State5_Logic
0B84           1195   Control_FSM_state6_trampoline:
0B84 020B9F    1196       ljmp Control_FSM_state6
0B87           1197   
0B87           1198   State5_Logic:
0B87 301205    1199       jnb PB2_flag, State5_Check
0B8A C212      1200       clr PB2_flag
0B8C 020B98    1201       ljmp Control_FSM_state6_a
0B8F           1202   State5_Check:
0B8F 300705    1203       jnb reflow_time_reached, State5_Ret
0B92 C207      1204       clr reflow_time_reached
0B94 020B98    1205       ljmp Control_FSM_state6_a
0B97           1206   State5_Ret:
0B97 22        1207       ret
0B98           1208   
0B98           1209   ; --- STATE 6: COOLING ---
0B98           1210   Control_FSM_state6_a:
0B98 0568      1211       inc Control_FSM_state
0B9A D20C      1212       setb state_change_signal
0B9C 120A87    1213            lcall Beep_Five
0B9F           1214   Control_FSM_state6:
0B9F B4060A    1215       cjne a, #6, Control_FSM_state7
0BA2           1216       ; Wait for Cooling Temp Reached
0BA2 300506    1217       jnb cooling_temp_reached, State6_Ret
0BA5 C205      1218       clr cooling_temp_reached
0BA7 0568      1219       inc Control_FSM_state
0BA9 D20C      1220       setb state_change_signal
0BAB           1221   State6_Ret:
0BAB 22        1222       ret
0BAC           1223   
0BAC           1224   ; --- STATE 7: DONE ---
0BAC           1225   Control_FSM_state7:
0BAC B40711    1226       cjne a, #7, Control_FSM_done
0BAF           1227       
0BAF 201009    1228       jb PB0_flag, Control_FSM_Reset_Logic
0BB2           1229       
0BB2 20900B    1230       jb P1.0, Control_FSM_done
0BB5           1231       
0BB5 12102A    1232       lcall Wait_For_P1_0_Release
0BB8 020ADE    1233       ljmp Control_FSM_state0_a
0BBB           1234   
0BBB           1235   Control_FSM_Reset_Logic:
0BBB C210      1236       clr PB0_flag
0BBD 020ADE    1237       ljmp Control_FSM_state0_a
0BC0           1238   
0BC0           1239   Control_FSM_done:
0BC0 22        1240       ret
0BC1           1241   ;-------------------------------------------------------------------------------
0BC1           1242   ; Main program.          
0BC1           1243   ;-------------------------------------------------------------------------------;
0BC1           1244   main:
0BC1           1245   
0BC1 C2AF      1246       clr EA              ; FORCE Interrupts OFF immediately
0BC3 7581C0    1247       mov SP, #0xC0       ; Reset Stack Pointer to safe location
0BC6           1248       
0BC6 78FA      1249       mov R0, #250
0BC8           1250   Reset_Delay_Outer:
0BC8 79FF      1251       mov R1, #255
0BCA           1252   Reset_Delay_Inner:
0BCA D9FE      1253       djnz R1, Reset_Delay_Inner
0BCC D8FA      1254       djnz R0, Reset_Delay_Outer
0BCE           1255       
0BCE           1256       ; --- port config ---
0BCE 759AAA    1257       mov P0MOD, #0xAA
0BD1           1258   
0BD1           1259       ; P1: Mixed usage 
0BD1           1260       ; P1.7(LCD_RS), P1.6(Row3), P1.5(Sound), P1.4(Row2)
0BD1           1261       ; P1.3(PWM), P1.2(Row1), P1.1(LCD_E) -> All Outputs
0BD1           1262       ; P1.0 (Unused/RX) -> Input
0BD1           1263       ; Binary: 11111110 -> Hex: 0xFE
0BD1 759BFE    1264       mov P1MOD, #0xFE
0BD4           1265   
0BD4           1266       ; P2: Row4(Out), Cols(In)
0BD4           1267       ; P2.0 (Row4) is Out (1). P2.2, P2.4, P2.6 (Cols) are In (0).
0BD4           1268       ; Binary: 00000001 -> Hex: 0x01
0BD4 759C01    1269       mov P2MOD, #0x01
0BD7           1270   
0BD7           1271       ; P3: Col4(In), Servo + LED outputs
0BD7           1272       ; P3.0 (Col4) is In (0). P3.6 (Servo) is Out (1).
0BD7           1273       ; P3.4/3.3/3.2 (LEDs) are Out (1).
0BD7           1274       ; Binary: 01011100 -> Hex: 0x5C
0BD7 759D5C    1275       mov P3MOD, #01011100B
0BDA           1276       ; Turn off all the LEDs
0BDA 75E800    1277       mov LEDRA, #0 ; LEDRA is bit addressable
0BDD 759500    1278       mov LEDRB, #0 ; LEDRB is NOT bit addresable
0BE0           1279   
0BE0           1280       ; Enable Global interrupts
0BE0 D2AF      1281       setb EA  
0BE2           1282   
0BE2           1283       ; FSM initial states
0BE2 756600    1284       mov KEY1_DEB_state, #0
0BE5 756700    1285       mov SEC_FSM_state, #0
0BE8 756800    1286       mov Control_FSM_state, #0
0BEB 756900    1287       mov Current_State, #0
0BEE           1288       
0BEE           1289       ; FSM timers initialization
0BEE 756400    1290       mov KEY1_DEB_timer, #0
0BF1 756500    1291       mov SEC_FSM_timer, #0
0BF4           1292       ; time counters initialization
0BF4 753000    1293       mov current_time_sec, #0
0BF7 753100    1294       mov current_time_minute, #0
0BFA           1295       ; Initialize counter to zero
0BFA 756000    1296       mov pwm_counter, #0
0BFD 756100    1297       mov pwm_counter+1, #0
0C00 756200    1298       mov pwm_counter+2, #0
0C03 756300    1299       mov pwm_counter+3, #0
0C06           1300       ; Initialize power output
0C06 755F00    1301       mov power_output+3, #0
0C09 755E00    1302       mov power_output+2, #0
0C0C 755D02    1303       mov power_output+1, #02H
0C0F 755CEE    1304       mov power_output, #0EEH ; (initilize to 750 for testing)
0C12           1305   
0C12           1306       ; Clear all the flags
0C12 C20E      1307       clr  tc_missing_abort
0C14 C209      1308       clr  stop_signal
0C16 C210      1309       clr PB0_flag
0C18 C211      1310       clr PB1_flag
0C1A C212      1311       clr PB2_flag
0C1C C201      1312       clr one_second_flag
0C1E C20B      1313       clr config_finish_signal
0C20 C203      1314       clr soak_temp_reached
0C22 C206      1315       clr soak_time_reached
0C24 C204      1316       clr reflow_temp_reached
0C26 C207      1317       clr reflow_time_reached
0C28 C205      1318       clr cooling_temp_reached
0C2A C20C      1319       clr state_change_signal
0C2C C21E      1320       clr one_millisecond_flag_servo
0C2E           1321       
0C2E D20C      1322       setb state_change_signal
0C30           1323   
0C30           1324       ; Set bit
0C30 D20F      1325       setb tc_startup_window
0C32 757400    1326       mov beep_state, #0
0C35 757300    1327       mov beep_count, #0
0C38 757500    1328       mov beep_tmr, #0
0C3B 757600    1329       mov beep_tmr+1, #0
0C3E C213      1330       clr one_ms_beep_flag
0C40 C28C      1331       clr TR0              ; Force buzzer hardware OFF
0C42           1332   
0C42 12045D    1333       lcall Timer0_Init
0C45 120518    1334       lcall Timer2_Init
0C48 1205E5    1335       lcall ELCD_4BIT
0C4B           1336       ;----- Two new lines I added to initialize the UI
0C4B 120EB5    1337       lcall Init_All_Buffers
0C4E 120F08    1338       lcall Update_Screen_Full
0C51           1339       ;-----
0C51 120477    1340       lcall Initialize_Serial_Port
0C54           1341   
0C54 121378    1342       lcall music ; boot up music
0C57           1343   ;-------------------------------------------------------------------------------;
0C57           1344   ; while(1) loop
0C57           1345   ;-------------------------------------------------------------------------------;
0C57           1346   loop:
0C57           1347       ; Full reset button on P3.7 (active-low to GND)
0C57 30B702    1348        jnb P3_7, Full_Reset_Trig
0C5A 8003      1349       sjmp Full_Reset_Check_Done
0C5C           1350   
0C5C           1351   Full_Reset_Trig:
0C5C 021032    1352       ljmp Full_Reset
0C5F           1353   
0C5F           1354   Full_Reset_Check_Done:
0C5F           1355       ; Check the FSM for KEY1 debounce
0C5F 120886    1356       lcall KEY1_DEB
0C62           1357       
0C62           1358       ; Added to take temp readings
0C62 121038    1359       lcall Read_Thermocouple
0C65           1360       
0C65           1361       ; 1. Check if we reached temp (Observer)
0C65 120989    1362       lcall Temp_Compare
0C68           1363       
0C68           1364       ; 2. Decide heater power based on flags (Driver)
0C68           1365       ;lcall Power_Control
0C68 1211CB    1366       lcall proportional_power_control
0C6B           1367       ; 2b. Update LED power indicators (PB3.4/3.3/3.2)
0C6B 12117A    1368       lcall Update_Power_LEDs
0C6E           1369   
0C6E 853132    1370       mov x+0, current_time_minute
0C71 753300    1371       mov x+1, #0
0C74 753400    1372       mov x+2, #0
0C77 753500    1373       mov x+3, #0
0C7A           1374       
0C7A           1375       ; Multiply by 60 (Minutes -> Seconds)
0C7A 75363C    1376            mov y+0, #low (60 % 0x10000) 
0C7D 753700    1376            mov y+1, #high(60 % 0x10000) 
0C80 753800    1376            mov y+2, #low (60 / 0x10000) 
0C83 753900    1376            mov y+3, #high(60 / 0x10000) 
0C86 12018C    1377       lcall mul32
0C89           1378       
0C89           1379       ; Load Seconds into Y
0C89 853036    1380       mov y+0, current_time_sec
0C8C 753700    1381       mov y+1, #0
0C8F 753800    1382       mov y+2, #0
0C92 753900    1383       mov y+3, #0
0C95           1384       
0C95           1385       ; Add them together (Total Seconds = X + Y)
0C95 1200D3    1386       lcall add32
0C98           1387       
0C98           1388       ; Store Final Result into 'current_time'
0C98 853250    1389       mov current_time+0, x+0
0C9B 853351    1390       mov current_time+1, x+1
0C9E 853452    1391       mov current_time+2, x+2
0CA1 853553    1392       mov current_time+3, x+3
0CA4           1393       
0CA4 1209CE    1394       lcall Time_Compare
0CA7           1395       
0CA7 120A18    1396       lcall Safety_Check_TC
0CAA           1397   
0CAA           1398       ; Check the FSM for one second counter
0CAA 1208BC    1399       lcall SEC_FSM
0CAD           1400   
0CAD           1401       ; Check the FSM for the overall control flow of the reflow process
0CAD 120ADA    1402       lcall Control_FSM
0CB0           1403   
0CB0           1404       ; Update the LCD display based on the current state
0CB0 1206AA    1405       lcall LCD_Display_Update_func
0CB3           1406   
0CB3 300202    1407       jnb one_ms_pwm_flag, Skip_Beep_Sync
0CB6 D213      1408       setb one_ms_beep_flag  ; Give the buzzer its own copy of the time tick
0CB8           1409   
0CB8           1410   Skip_Beep_Sync:
0CB8           1411       ; Update the pwm output for the ssr
0CB8 120912    1412       lcall PWM_Wave 
0CBB           1413            ; Update the Buzzer 
0CBB 120AA1    1414            lcall Beep_Task
0CBE           1415       ; Update the pwm output for the servo
0CBE 12110D    1416       lcall call_servo_control
0CC1           1417       ; After initialization the program stays in this 'forever' loop
0CC1 020C57    1418       ljmp loop
0CC4           1419   ;-------------------------------------------------------------------------------;
0CC4           1420   Update_FSM_Variables:
0CC4           1421       ; --- 1. SOAK TEMP ---
0CC4 7880      1422       mov R0, #Buf_Soak_Temp
0CC6 120D03    1423       lcall Parse_Temp_String
0CC9 8F43      1424       mov soak_temp+0, R7
0CCB 754400    1425       mov soak_temp+1, #0
0CCE 754500    1426       mov soak_temp+2, #0
0CD1 754600    1427       mov soak_temp+3, #0
0CD4           1428   
0CD4           1429       ; --- 2. REFLOW TEMP ---
0CD4 7889      1430       mov R0, #Buf_Refl_Temp
0CD6 120D03    1431       lcall Parse_Temp_String
0CD9 8F47      1432       mov reflow_temp+0, R7
0CDB 754800    1433       mov reflow_temp+1, #0
0CDE 754900    1434       mov reflow_temp+2, #0
0CE1 754A00    1435       mov reflow_temp+3, #0
0CE4           1436   
0CE4           1437       ; --- 3. SOAK TIME ---
0CE4 7884      1438       mov R0, #Buf_Soak_Time
0CE6 120D17    1439       lcall Parse_Time_String
0CE9 8F54      1440       mov soak_time+0, R7
0CEB 8E55      1441       mov soak_time+1, R6
0CED 755600    1442       mov soak_time+2, #0
0CF0 755700    1443       mov soak_time+3, #0
0CF3           1444   
0CF3           1445       ; --- 4. REFLOW TIME ---
0CF3 788D      1446       mov R0, #Buf_Refl_Time
0CF5 120D17    1447       lcall Parse_Time_String
0CF8 8F58      1448       mov reflow_time+0, R7
0CFA 8E59      1449       mov reflow_time+1, R6
0CFC 755A00    1450       mov reflow_time+2, #0
0CFF 755B00    1451       mov reflow_time+3, #0
0D02 22        1452       ret
0D03           1453   
0D03           1454   ; --- Helper: Parse "123" to Integer ---
0D03           1455   Parse_Temp_String:
0D03 7F00      1456       mov R7, #0              ; Clear Result
0D05           1457   Parse_Temp_Loop:
0D05 E6        1458       mov A, @R0
0D06 600E      1459       jz Parse_Temp_Done      ; If Null, we are done
0D08           1460       
0D08           1461       ; Convert ASCII to Digit
0D08 C3        1462       clr C
0D09 9430      1463       subb A, #0x30
0D0B FD        1464       mov R5, A               ; R5 = New Digit
0D0C           1465       
0D0C           1466       ; Result = (Result * 10) + New Digit
0D0C EF        1467       mov A, R7
0D0D 75F00A    1468       mov B, #10
0D10 A4        1469       mul AB
0D11 2D        1470       add A, R5
0D12 FF        1471       mov R7, A
0D13           1472       
0D13 08        1473       inc R0
0D14 80EF      1474       sjmp Parse_Temp_Loop
0D16           1475   Parse_Temp_Done:
0D16 22        1476       ret
0D17           1477   
0D17           1478   ; --- Parse "MMSS" to ceconds ---
0D17           1479   Parse_Time_String:
0D17           1480       ; 1. minutes tens
0D17 E6        1481       mov A, @R0
0D18 9430      1482       subb A, #0x30
0D1A 75F00A    1483       mov B, #10
0D1D A4        1484       mul AB
0D1E FD        1485       mov R5, A
0D1F 08        1486       inc R0
0D20           1487       
0D20           1488       ;2. minutes ones
0D20 E6        1489       mov A, @R0
0D21 9430      1490       subb A, #0x30
0D23 2D        1491       add A, R5
0D24 FD        1492       mov R5, A        
0D25 08        1493       inc R0
0D26           1494       
0D26           1495       ; 3. seconds tens
0D26 E6        1496       mov A, @R0
0D27 9430      1497       subb A, #0x30
0D29 75F00A    1498       mov B, #10
0D2C A4        1499       mul AB
0D2D FC        1500       mov R4, A
0D2E 08        1501       inc R0
0D2F           1502       
0D2F           1503       ;4. seconds ones
0D2F E6        1504       mov A, @R0
0D30 9430      1505       subb A, #0x30
0D32 2C        1506       add A, R4            
0D33           1507       
0D33           1508       ; 5. calc total seconds = (Mins * 60) + Secs
0D33 ED        1509       mov A, R5
0D34 75F03C    1510       mov B, #60
0D37 A4        1511       mul AB
0D38 2C        1512       add A, R4
0D39 FF        1513       mov R7, A          
0D3A E5F0      1514       mov A, B
0D3C 3400      1515       addc A, #0
0D3E FE        1516       mov R6, A     
0D3F 22        1517       ret
0D40           1518   
0D40           1519   ;-------------------------------------------------------------------------------
0D40           1520   ; mode selection
0D40           1521   ;-------------------------------------------------------------------------------
0D40           1522   Check_Buttons:
0D40           1523       ; This clears any '0' the LCD library might have written to our buttons
0D40 438055    1524       orl P0, #055H   ;ets P0.0, P0.2, P0.4, and P0.6 to '1' (Input Mode)
0D43           1525   
0D43 30800A    1526       jnb BTN_SOAK_TEMP, Btn_Soak_Temp_Press
0D46 308212    1527       jnb BTN_SOAK_TIME, Btn_Soak_Time_Press
0D49 30841A    1528       jnb BTN_REFL_TEMP, Btn_Refl_Temp_Press
0D4C 308622    1529       jnb BTN_REFL_TIME, Btn_Refl_Time_Press
0D4F 22        1530       ret
0D50           1531   
0D50           1532   Btn_Soak_Temp_Press:
0D50 120FFA    1533       lcall Wait_25ms_BLOCKING
0D53 756901    1534       mov Current_State, #1
0D56 757200    1535       mov Cursor_Idx, #0
0D59 8021      1536       sjmp Redraw_Screen
0D5B           1537   
0D5B           1538   Btn_Soak_Time_Press:
0D5B 120FFA    1539       lcall Wait_25ms_BLOCKING
0D5E 756902    1540       mov Current_State, #2
0D61 757200    1541       mov Cursor_Idx, #0
0D64 8016      1542       sjmp Redraw_Screen
0D66           1543   
0D66           1544   Btn_Refl_Temp_Press:
0D66 120FFA    1545       lcall Wait_25ms_BLOCKING
0D69 756903    1546       mov Current_State, #3
0D6C 757200    1547       mov Cursor_Idx, #0
0D6F 800B      1548       sjmp Redraw_Screen
0D71           1549   
0D71           1550   Btn_Refl_Time_Press:
0D71 120FFA    1551       lcall Wait_25ms_BLOCKING 
0D74 756904    1552       mov Current_State, #4
0D77 757200    1553       mov Cursor_Idx, #0
0D7A 8000      1554       sjmp Redraw_Screen
0D7C           1555   
0D7C           1556   Redraw_Screen:
0D7C           1557       ; Wait for button release
0D7C 3080FD    1558       jnb BTN_SOAK_TEMP, $
0D7F 3082FD    1559       jnb BTN_SOAK_TIME, $
0D82 3084FD    1560       jnb BTN_REFL_TEMP, $
0D85 3086FD    1561       jnb BTN_REFL_TIME, $
0D88           1562   
0D88 120F08    1563       lcall Update_Screen_Full
0D8B 22        1564       ret
0D8C           1565   ; ----------------------------------------------------------------
0D8C           1566   ; MODULE: KEYPAD HANDLER (Input Logic)
0D8C           1567   ; ----------------------------------------------------------------
0D8C           1568   Check_Keypad:
0D8C           1569       ; If State is 0 (Home), ignore keypad
0D8C E569      1570       mov A, Current_State
0D8E 6050      1571       jz Keypad_Exit
0D90           1572       
0D90 120DE1    1573       lcall Keypad_Scan
0D93 504B      1574       jnc Keypad_Exit         ; Carry = 0 means no key pressed
0D95           1575   
0D95 EF        1576       mov A, R7
0D96 B40E0A    1577       cjne A, #14, Check_Hash ; 14 is Star (*)
0D99           1578       
0D99 120EE5    1579       lcall Reset_Current_Buffer
0D9C 120F08    1580       lcall Update_Screen_Full
0D9F 757200    1581       mov Cursor_Idx, #0
0DA2 22        1582       ret
0DA3           1583   
0DA3           1584   Check_Hash:
0DA3 EF        1585       mov A, R7
0DA4 B40C01    1586       cjne A, #12, Check_Numeric 
0DA7 22        1587       ret                
0DA8           1588   
0DA8           1589   Check_Numeric:
0DA8           1590       ; Ensure key is 0-9
0DA8 EF        1591       mov A, R7
0DA9 C3        1592       clr C
0DAA 940A      1593       subb A, #10
0DAC 5031      1594       jnc Symbol_Key_Ignored
0DAE           1595       
0DAE           1596       ; Convert to ASCII
0DAE EF        1597       mov A, R7
0DAF 2430      1598       add A, #0x30
0DB1 FD        1599       mov R5, A
0DB2           1600   
0DB2           1601       ;save to Buffer
0DB2 121013    1602       lcall Get_Current_Buffer_Addr
0DB5 E572      1603       mov A, Cursor_Idx
0DB7 28        1604       add A, R0
0DB8 F8        1605       mov R0, A
0DB9 ED        1606       mov A, R5
0DBA F6        1607       mov @R0, A
0DBB 0572      1608       inc Cursor_Idx
0DBD           1609   
0DBD           1610       ;Check cursor limits ---
0DBD E569      1611       mov A, Current_State
0DBF B40102    1612       cjne A, #1, Check_Limit_Time_1
0DC2 8005      1613       sjmp Limit_Temp_3
0DC4           1614   
0DC4           1615   Check_Limit_Time_1:
0DC4 B4030B    1616       cjne A, #3, Limit_Time_4
0DC7 8000      1617       sjmp Limit_Temp_3
0DC9           1618   
0DC9           1619   Limit_Temp_3:
0DC9 E572      1620       mov A, Cursor_Idx
0DCB B4030D    1621       cjne A, #3, Do_Refresh
0DCE 1572      1622       dec Cursor_Idx          
0DD0 8009      1623       sjmp Do_Refresh
0DD2           1624   
0DD2           1625   Limit_Time_4:
0DD2 E572      1626       mov A, Cursor_Idx
0DD4 B40404    1627       cjne A, #4, Do_Refresh
0DD7 1572      1628       dec Cursor_Idx         
0DD9 8000      1629       sjmp Do_Refresh
0DDB           1630   
0DDB           1631   Do_Refresh:
0DDB 120F08    1632       lcall Update_Screen_Full
0DDE 22        1633       ret
0DDF           1634   
0DDF           1635   Symbol_Key_Ignored:
0DDF 22        1636       ret
0DE0           1637   Keypad_Exit:
0DE0 22        1638       ret
0DE1           1639   
0DE1           1640   ;-------------------------------------------------------------------------------
0DE1           1641   ; hardware
0DE1           1642   ;-------------------------------------------------------------------------------
0DE1           1643   Keypad_Scan:
0DE1 C292      1644       clr ROW1
0DE3 C294      1645       clr ROW2
0DE5 C296      1646       clr ROW3
0DE7 C2A0      1647       clr ROW4
0DE9 A2A2      1648       mov C, COL1
0DEB 82A4      1649       anl C, COL2
0DED 82A6      1650       anl C, COL3
0DEF 82B0      1651       anl C, COL4
0DF1 5002      1652       jnc Keypad_Debounce
0DF3 C3        1653       clr C
0DF4 22        1654       ret
0DF5           1655   
0DF5           1656   Keypad_Debounce:
0DF5 120FFA    1657       lcall Wait_25ms_BLOCKING
0DF8 A2A2      1658       mov C, COL1
0DFA 82A4      1659       anl C, COL2
0DFC 82A6      1660       anl C, COL3
0DFE 82B0      1661       anl C, COL4
0E00 5002      1662       jnc Keypad_Find_Row
0E02 C3        1663       clr C
0E03 22        1664       ret
0E04           1665   
0E04           1666   Keypad_Find_Row:
0E04 D292      1667       setb ROW1
0E06 D294      1668       setb ROW2
0E08 D296      1669       setb ROW3
0E0A D2A0      1670       setb ROW4
0E0C           1671   
0E0C           1672       ; Row 1
0E0C C292      1673       clr ROW1
0E0E 30A23D    1674       jnb COL1, Keypad_Key_1
0E11 30A43E    1675       jnb COL2, Keypad_Key_2
0E14 30A63F    1676       jnb COL3, Keypad_Key_3
0E17 30B040    1677       jnb COL4, Keypad_Key_A
0E1A D292      1678       setb ROW1
0E1C           1679   
0E1C           1680       ; Row 2
0E1C C294      1681       clr ROW2
0E1E 30A23D    1682       jnb COL1, Keypad_Key_4
0E21 30A43E    1683       jnb COL2, Keypad_Key_5
0E24 30A63F    1684       jnb COL3, Keypad_Key_6
0E27 30B040    1685       jnb COL4, Keypad_Key_B
0E2A D294      1686       setb ROW2
0E2C           1687   
0E2C           1688       ; Row 3
0E2C C296      1689       clr ROW3
0E2E 30A23D    1690       jnb COL1, Keypad_Key_7
0E31 30A43E    1691       jnb COL2, Keypad_Key_8
0E34 30A63F    1692       jnb COL3, Keypad_Key_9
0E37 30B040    1693       jnb COL4, Keypad_Key_C
0E3A D296      1694       setb ROW3
0E3C           1695   
0E3C           1696       ; Row 4
0E3C C2A0      1697       clr ROW4
0E3E 30A23D    1698       jnb COL1, Keypad_Key_Star
0E41 30A43E    1699       jnb COL2, Keypad_Key_0
0E44 30A63F    1700       jnb COL3, Keypad_Key_Hash
0E47 30B040    1701       jnb COL4, Keypad_Key_D
0E4A D2A0      1702       setb ROW4
0E4C C3        1703       clr C
0E4D 22        1704       ret
0E4E           1705   
0E4E           1706   ; Key Mapping
0E4E 7F01      1707   Keypad_Key_1: mov R7, #1
0E50 803C      1708          sjmp Wait_Release
0E52 7F02      1709   Keypad_Key_2: mov R7, #2
0E54 8038      1710          sjmp Wait_Release
0E56 7F03      1711   Keypad_Key_3: mov R7, #3
0E58 8034      1712          sjmp Wait_Release
0E5A 7F0A      1713   Keypad_Key_A: mov R7, #10
0E5C 8030      1714          sjmp Wait_Release
0E5E 7F04      1715   Keypad_Key_4: mov R7, #4
0E60 802C      1716          sjmp Wait_Release
0E62 7F05      1717   Keypad_Key_5: mov R7, #5
0E64 8028      1718          sjmp Wait_Release
0E66 7F06      1719   Keypad_Key_6: mov R7, #6
0E68 8024      1720          sjmp Wait_Release
0E6A 7F0B      1721   Keypad_Key_B: mov R7, #11
0E6C 8020      1722          sjmp Wait_Release
0E6E 7F07      1723   Keypad_Key_7: mov R7, #7
0E70 801C      1724          sjmp Wait_Release
0E72 7F08      1725   Keypad_Key_8: mov R7, #8
0E74 8018      1726          sjmp Wait_Release
0E76 7F09      1727   Keypad_Key_9: mov R7, #9
0E78 8014      1728          sjmp Wait_Release
0E7A 7F0D      1729   Keypad_Key_C: mov R7, #13
0E7C 8010      1730          sjmp Wait_Release
0E7E 7F0E      1731   Keypad_Key_Star: mov R7, #14
0E80 800C      1732          sjmp Wait_Release
0E82 7F00      1733   Keypad_Key_0: mov R7, #0
0E84 8008      1734          sjmp Wait_Release
0E86 7F0C      1735   Keypad_Key_Hash: mov R7, #12
0E88 8004      1736          sjmp Wait_Release
0E8A 7F0F      1737   Keypad_Key_D: mov R7, #15
0E8C 8000      1738          sjmp Wait_Release
0E8E           1739   
0E8E           1740   Wait_Release:
0E8E A2A2      1741       mov C, COL1
0E90 82A4      1742       anl C, COL2
0E92 82A6      1743       anl C, COL3
0E94 82B0      1744       anl C, COL4
0E96 50F6      1745       jnc Wait_Release
0E98 D3        1746       setb C
0E99 D292      1747       setb ROW1
0E9B D294      1748       setb ROW2
0E9D D296      1749       setb ROW3
0E9F D2A0      1750       setb ROW4
0EA1 22        1751       ret
0EA2           1752   
0EA2           1753   Wait_25ms:
0EA2           1754       ; 1. Check if we are already waiting
0EA2 20140E    1755       jb wait25_active, Check_Timer_Status
0EA5           1756       
0EA5           1757       ; 2. Check if we just finished
0EA5 301504    1758       jnb wait25_done, Start_New_Timer
0EA8           1759       
0EA8           1760       ; 3. Timer is done
0EA8 C215      1761       clr wait25_done
0EAA D3        1762       setb C          ; Carry = 1 means done
0EAB 22        1763       ret
0EAC           1764   
0EAC           1765   Start_New_Timer:
0EAC           1766       ; 4. Start a new 25ms wait
0EAC 754F00    1767       mov wait25_count, #0
0EAF D214      1768       setb wait25_active
0EB1 C3        1769       clr C           ; Carry = 0 means not yet
0EB2 22        1770       ret
0EB3           1771   
0EB3           1772   Check_Timer_Status:
0EB3           1773       ; 5. Still waiting... return False immediately
0EB3 C3        1774       clr C           ; Carry = 0 means "Not Done Yet"
0EB4 22        1775       ret
0EB5           1776   
0EB5           1777   ;-------------------------------------------------------------------------------
0EB5           1778   ; reset logic
0EB5           1779   ;-------------------------------------------------------------------------------
0EB5           1780   Init_All_Buffers:
0EB5 7880      1781       mov R0, #Buf_Soak_Temp
0EB7 120ECA    1782       lcall Init_Temp_Template
0EBA 7889      1783       mov R0, #Buf_Refl_Temp
0EBC 120ECA    1784       lcall Init_Temp_Template
0EBF 7884      1785       mov R0, #Buf_Soak_Time
0EC1 120ED6    1786       lcall Init_Time_Template
0EC4 788D      1787       mov R0, #Buf_Refl_Time
0EC6 120ED6    1788       lcall Init_Time_Template
0EC9 22        1789       ret
0ECA           1790   
0ECA           1791   Init_Temp_Template:
0ECA 7630      1792       mov @R0, #'0'
0ECC 08        1793       inc R0
0ECD 7630      1794       mov @R0, #'0'
0ECF 08        1795       inc R0
0ED0 7630      1796       mov @R0, #'0'
0ED2 08        1797       inc R0
0ED3 7600      1798       mov @R0, #0
0ED5 22        1799       ret
0ED6           1800   
0ED6           1801   Init_Time_Template:
0ED6 7630      1802       mov @R0, #'0'
0ED8 08        1803       inc R0
0ED9 7630      1804       mov @R0, #'0'
0EDB 08        1805       inc R0
0EDC 7630      1806       mov @R0, #'0'
0EDE 08        1807       inc R0
0EDF 7630      1808       mov @R0, #'0'
0EE1 08        1809       inc R0
0EE2 7600      1810       mov @R0, #0
0EE4 22        1811       ret
0EE5           1812   
0EE5           1813   Reset_Current_Buffer:
0EE5 E569      1814       mov A, Current_State
0EE7 B40106    1815       cjne A, #1, Reset_Chk_2
0EEA 7880      1816       mov R0, #Buf_Soak_Temp
0EEC 120ECA    1817       lcall Init_Temp_Template
0EEF 22        1818       ret
0EF0           1819   Reset_Chk_2:
0EF0 B40206    1820       cjne A, #2, Reset_Chk_3
0EF3 7884      1821       mov R0, #Buf_Soak_Time
0EF5 120ED6    1822       lcall Init_Time_Template
0EF8 22        1823       ret
0EF9           1824   Reset_Chk_3:
0EF9 B40306    1825       cjne A, #3, Reset_Chk_4
0EFC 7889      1826       mov R0, #Buf_Refl_Temp
0EFE 120ECA    1827       lcall Init_Temp_Template
0F01 22        1828       ret
0F02           1829   Reset_Chk_4:
0F02 788D      1830       mov R0, #Buf_Refl_Time
0F04 120ED6    1831       lcall Init_Time_Template
0F07 22        1832       ret
0F08           1833   
0F08           1834   ; ----------------------------------------------------------------
0F08           1835   ; screen update 
0F08           1836   ; ----------------------------------------------------------------
0F08           1837   Update_Screen_Full:
0F08 121000    1838       lcall Clear_Screen_Func
0F0B C0E0      1839            push acc
0F0D 7401      1839            mov a, #1
0F0F 14        1839            dec a
0F10 120625    1839            lcall ?Set_Cursor_1 ; Select column and row
0F13 D0E0      1839            pop acc
0F15           1840   
0F15 E569      1841       mov A, Current_State
0F17 B40013    1842       cjne A, #0, Update_State_1
0F1A C083      1843            push dph
0F1C C082      1843            push dpl
0F1E C0E0      1843            push acc
0F20 900350    1843            mov dptr, #Txt_Home
0F23 120618    1843            lcall ?Send_Constant_String
0F26 D0E0      1843            pop acc
0F28 D082      1843            pop dpl
0F2A D083      1843            pop dph
0F2C 22        1844       ret 
0F2D           1845   Update_State_1:
0F2D B40114    1846       cjne A, #1, Update_State_2
0F30 C083      1847            push dph
0F32 C082      1847            push dpl
0F34 C0E0      1847            push acc
0F36 900361    1847            mov dptr, #Txt_SoakT
0F39 120618    1847            lcall ?Send_Constant_String
0F3C D0E0      1847            pop acc
0F3E D082      1847            pop dpl
0F40 D083      1847            pop dph
0F42 8042      1848       sjmp Draw_Temp_Format
0F44           1849   Update_State_2:
0F44 B40214    1850       cjne A, #2, Update_State_3
0F47 C083      1851            push dph
0F49 C082      1851            push dpl
0F4B C0E0      1851            push acc
0F4D 900372    1851            mov dptr, #Txt_SoakTime
0F50 120618    1851            lcall ?Send_Constant_String
0F53 D0E0      1851            pop acc
0F55 D082      1851            pop dpl
0F57 D083      1851            pop dph
0F59 8042      1852       sjmp Draw_Time_Format
0F5B           1853   Update_State_3:
0F5B B40314    1854       cjne A, #3, Update_State_4
0F5E C083      1855            push dph
0F60 C082      1855            push dpl
0F62 C0E0      1855            push acc
0F64 900383    1855            mov dptr, #Txt_ReflT
0F67 120618    1855            lcall ?Send_Constant_String
0F6A D0E0      1855            pop acc
0F6C D082      1855            pop dpl
0F6E D083      1855            pop dph
0F70 8014      1856       sjmp Draw_Temp_Format
0F72           1857   Update_State_4:
0F72 C083      1858            push dph
0F74 C082      1858            push dpl
0F76 C0E0      1858            push acc
0F78 900394    1858            mov dptr, #Txt_ReflTime
0F7B 120618    1858            lcall ?Send_Constant_String
0F7E D0E0      1858            pop acc
0F80 D082      1858            pop dpl
0F82 D083      1858            pop dph
0F84 8017      1859       sjmp Draw_Time_Format
0F86           1860   
0F86           1861   Draw_Temp_Format:
0F86 C0E0      1862            push acc
0F88 7401      1862            mov a, #1
0F8A 14        1862            dec a
0F8B 120623    1862            lcall ?Set_Cursor_2 ; Select column and row
0F8E D0E0      1862            pop acc
0F90 121013    1863       lcall Get_Current_Buffer_Addr
0F93 120FF0    1864       lcall Print_String_RAM
0F96 7443      1865       mov A, #'C'
0F98 1205DB    1866       lcall ?WriteData
0F9B 8027      1867       sjmp Restore_Cursor
0F9D           1868   
0F9D           1869   Draw_Time_Format:
0F9D C0E0      1870            push acc
0F9F 7401      1870            mov a, #1
0FA1 14        1870            dec a
0FA2 120623    1870            lcall ?Set_Cursor_2 ; Select column and row
0FA5 D0E0      1870            pop acc
0FA7 121013    1871       lcall Get_Current_Buffer_Addr
0FAA E6        1872       mov A, @R0
0FAB 1205DB    1873       lcall ?WriteData
0FAE 08        1874       inc R0
0FAF E6        1875       mov A, @R0
0FB0 1205DB    1876       lcall ?WriteData
0FB3 08        1877       inc R0
0FB4 743A      1878       mov A, #':'
0FB6 1205DB    1879       lcall ?WriteData
0FB9 E6        1880       mov A, @R0
0FBA 1205DB    1881       lcall ?WriteData
0FBD 08        1882       inc R0
0FBE E6        1883       mov A, @R0
0FBF 1205DB    1884       lcall ?WriteData
0FC2 8000      1885       sjmp Restore_Cursor
0FC4           1886   
0FC4           1887   Restore_Cursor:
0FC4 E569      1888       mov A, Current_State
0FC6 B40202    1889       cjne A, #2, RC_Check_State_4  
0FC9 800D      1890       sjmp Adjust_Cursor_Time
0FCB           1891   RC_Check_State_4:             
0FCB B40402    1892       cjne A, #4, Normal_Cursor
0FCE 8008      1893       sjmp Adjust_Cursor_Time
0FD0           1894   
0FD0           1895   Normal_Cursor:
0FD0 E572      1896       mov A, Cursor_Idx
0FD2 24C0      1897       add A, #0xC0
0FD4 1205E0    1898       lcall ?WriteCommand
0FD7 22        1899       ret
0FD8           1900   
0FD8           1901   Adjust_Cursor_Time:
0FD8           1902       ; Skip the colon index (2)
0FD8 E572      1903       mov A, Cursor_Idx
0FDA B40201    1904       cjne A, #2, No_Skip
0FDD 04        1905       inc A 
0FDE           1906   No_Skip:
0FDE C3        1907       clr C
0FDF 9402      1908       subb A, #2
0FE1 4005      1909       jc No_Add
0FE3 E572      1910       mov A, Cursor_Idx
0FE5 04        1911       inc A
0FE6 8002      1912       sjmp Final_Cursor_Set
0FE8           1913   No_Add:
0FE8 E572      1914       mov A, Cursor_Idx
0FEA           1915   Final_Cursor_Set:
0FEA 24C0      1916       add A, #0xC0
0FEC 1205E0    1917       lcall ?WriteCommand
0FEF 22        1918       ret
0FF0           1919   
0FF0           1920   Print_String_RAM:
0FF0 E6        1921       mov A, @R0
0FF1 6006      1922       jz Print_String_Done
0FF3 1205DB    1923       lcall ?WriteData
0FF6 08        1924       inc R0
0FF7 80F7      1925       sjmp Print_String_RAM
0FF9           1926   Print_String_Done:
0FF9 22        1927       ret
0FFA           1928   
0FFA           1929   Wait_25ms_BLOCKING:
0FFA 120EA2    1930       lcall Wait_25ms
0FFD 50FB      1931       jnc Wait_25ms_BLOCKING ; Keep jumping back until Done (C=1)
0FFF 22        1932       ret
1000           1933   
1000           1934   Clear_Screen_Func:
1000 7401      1935       mov A, #0x01
1002 1205E0    1936       lcall ?WriteCommand
1005 78FF      1937       mov R0, #255
1007           1938   Clear_Delay_Loop_Outer:
1007 79FF      1939       mov R1, #255
1009           1940   Clear_Delay_Loop_Inner:
1009 D9FE      1941       djnz R1, Clear_Delay_Loop_Inner
100B D8FA      1942       djnz R0, Clear_Delay_Loop_Outer
100D           1943   
100D 740C      1944       mov A, #0x0C  ; Display ON, Cursor OFF
100F 1205E0    1945       lcall ?WriteCommand
1012 22        1946       ret
1013           1947   
1013           1948   Get_Current_Buffer_Addr:
1013 E569      1949       mov A, Current_State
1015 B40103    1950       cjne A, #1, Get_Buf_2
1018 7880      1951       mov R0, #Buf_Soak_Temp
101A 22        1952       ret
101B           1953   Get_Buf_2:
101B B40203    1954       cjne A, #2, Get_Buf_3
101E 7884      1955       mov R0, #Buf_Soak_Time
1020 22        1956       ret
1021           1957   Get_Buf_3:
1021 B40303    1958       cjne A, #3, Get_Buf_4
1024 7889      1959       mov R0, #Buf_Refl_Temp
1026 22        1960       ret
1027           1961   Get_Buf_4:
1027 788D      1962       mov R0, #Buf_Refl_Time
1029 22        1963       ret
102A           1964       
102A           1965   ; --- Helper to prevent "Machine Gun" button presses ---
102A           1966   Wait_For_P1_0_Release:
102A 3090FD    1967       jnb P1.0, $    ; Wait here while the button is still pressed (0)
102D 22        1968       ret
102E           1969   
102E           1970   ; --- Full reset helper for P3.7 (active-low) ---
102E           1971   Wait_For_P3_7_Release:
102E 30B7FD    1972       jnb P3_7, $    ; Wait here while the button is still pressed (0)
1031 22        1973       ret
1032           1974   
1032           1975   Full_Reset:
1032 12102E    1976       lcall Wait_For_P3_7_Release
1035 020BC1    1977       ljmp main
1038           1978   
1038           1979   ;-------------------------------------------------------------------------------
1038           1980   ; thermocouple
1038           1981   ;-------------------------------------------------------------------------------
1038           1982   Read_Thermocouple:
1038 120EA2    1983       lcall Wait_25ms
103B 4001      1984       jc Proceed_Reading
103D 22        1985       ret 
103E           1986   
103E           1987   Proceed_Reading:
103E E588      1988       mov A, TCON      
1040 5410      1989       anl A, #0x10    
1042 C0E0      1990       push acc         
1044 C28C      1991       clr TR0         
1046           1992   
1046 75A180    1993       mov ADC_C, #0x80    
1049 00        1994       nop
104A 00        1995       nop
104B 75A101    1996       mov ADC_C, #0x01   
104E           1997       
104E 7DFA      1998       mov R5, #250
1050           1999   ADC_Settle_Loop:
1050 00        2000       nop
1051 00        2001       nop
1052 DDFC      2002       djnz R5, ADC_Settle_Loop
1054           2003       
1054 85A232    2004       mov x+0, ADC_L
1057 85A333    2005       mov x+1, ADC_H
105A 753400    2006       mov x+2, #0
105D 753500    2007       mov x+3, #0
1060           2008       
1060 E533      2009       mov a, x+1
1062 540F      2010       anl a, #0x0F
1064 F533      2011       mov x+1, a
1066           2012       
1066 D0E0      2013       pop acc         
1068 6002      2014       jz Skip_Restore 
106A D28C      2015       setb TR0       
106C           2016   Skip_Restore:
106C           2017   
106C           2018            ; as per our volatge reference (measured using the DMM)
106C 753616    2019            mov y+0, #low (4118 % 0x10000) 
106F 753710    2019            mov y+1, #high(4118 % 0x10000) 
1072 753800    2019            mov y+2, #low (4118 / 0x10000) 
1075 753900    2019            mov y+3, #high(4118 / 0x10000) 
1078 12018C    2020       lcall mul32       
107B           2021   
107B 75A104    2022       mov ADC_C, #0x04   
107E 85A236    2023       mov y+0, ADC_L      
1081 85A337    2024       mov y+1, ADC_H      
1084 753800    2025       mov y+2, #0
1087 753900    2026       mov y+3, #0
108A 75A100    2027       mov ADC_C, #0x00   
108D           2028       
108D 120280    2029       lcall div32         
1090 753664    2030            mov y+0, #low (100 % 0x10000) 
1093 753700    2030            mov y+1, #high(100 % 0x10000) 
1096 753800    2030            mov y+2, #low (100 / 0x10000) 
1099 753900    2030            mov y+3, #high(100 / 0x10000) 
109C 12018C    2031       lcall mul32
109F 75362B    2032            mov y+0, #low (1323 % 0x10000) 
10A2 753705    2032            mov y+1, #high(1323 % 0x10000) 
10A5 753800    2032            mov y+2, #low (1323 / 0x10000) 
10A8 753900    2032            mov y+3, #high(1323 / 0x10000)  ;using our amplifiers resistance ratio and 41uV   
10AB 120280    2033       lcall div32    
10AE 753616    2034            mov y+0, #low (COLD_JUNCTION_TEMP % 0x10000) 
10B1 753700    2034            mov y+1, #high(COLD_JUNCTION_TEMP % 0x10000) 
10B4 753800    2034            mov y+2, #low (COLD_JUNCTION_TEMP / 0x10000) 
10B7 753900    2034            mov y+3, #high(COLD_JUNCTION_TEMP / 0x10000) 
10BA 1200D3    2035       lcall add32     
10BD           2036       
10BD 85323F    2037       mov current_temp+0, x+0
10C0 853340    2038       mov current_temp+1, x+1
10C3 853441    2039       mov current_temp+2, x+2
10C6 853542    2040       mov current_temp+3, x+3
10C9           2041   
10C9 22        2042       ret
10CA           2043       
10CA           2044   ;-------------------------------------------------------------------------------
10CA           2045   ; power control
10CA           2046   ;-------------------------------------------------------------------------------
10CA           2047   Power_Control:
10CA 755C00    2048       mov power_output+0, #0
10CD 755D00    2049       mov power_output+1, #0
10D0 755E00    2050       mov power_output+2, #0
10D3 755F00    2051       mov power_output+3, #0
10D6           2052   
10D6 E568      2053       mov a, Control_FSM_state
10D8           2054   
10D8           2055       ; --- State 2: RAMP TO SOAK ---
10D8 B40202    2056       cjne a, #2, PC_Check_Soak
10DB 8016      2057       sjmp Set_Max_Power
10DD           2058   
10DD           2059   PC_Check_Soak:
10DD           2060       ; --- State 3: SOAK PHASE ---
10DD B40305    2061       cjne a, #3, PC_Check_Ramp_Reflow
10E0 20030F    2062       jb soak_temp_reached, PC_Done 
10E3 801B      2063       sjmp Set_20_Percent_Power     
10E5           2064   
10E5           2065   PC_Check_Ramp_Reflow:
10E5           2066       ; --- State 4: RAMP TO REFLOW ---
10E5 B40402    2067       cjne a, #4, PC_Check_Reflow
10E8 8009      2068       sjmp Set_Max_Power
10EA           2069   
10EA           2070   PC_Check_Reflow:
10EA           2071       ; --- State 5: REFLOW PHASE ---
10EA B40505    2072       cjne a, #5, PC_Done
10ED 200402    2073       jb reflow_temp_reached, PC_Done
10F0 800E      2074       sjmp Set_20_Percent_Power
10F2           2075   
10F2           2076   PC_Done:
10F2 22        2077       ret
10F3           2078   
10F3           2079   Set_Max_Power:
10F3           2080       ; Load 1500 (0x05DC) = 100% Duty Cycle
10F3 755CDC    2081       mov power_output+0, #0xDC
10F6 755D05    2082       mov power_output+1, #0x05
10F9 755E00    2083       mov power_output+2, #0
10FC 755F00    2084       mov power_output+3, #0
10FF 22        2085       ret
1100           2086   
1100           2087   Set_20_Percent_Power:
1100           2088       ; Load 300 (0x012C) = 20% Duty Cycle
1100 755C2C    2089       mov power_output+0, #0x2C
1103 755D01    2090       mov power_output+1, #0x01
1106 755E00    2091       mov power_output+2, #0
1109 755F00    2092       mov power_output+3, #0
110C 22        2093       ret
110D           2094   ;--------------------------------------------------------------
110D           2095   ; set servo angle according to the state
110D           2096   ; call servo control function every 1ms
110D           2097   ;--------------------------------------------------------------
110D           2098   call_servo_control:
110D           2099            ; check current state and change servo angle
110D E568      2100            mov a, Control_FSM_state
110F           2101            
110F           2102            ; handle state 0
110F B40004    2103            cjne a, #0, servo_state1
1112 C21F      2104            clr servo_angle_zero ; close door at state 0
1114 802C      2105            sjmp check_servo_flag
1116           2106   
1116           2107            ; handle state 1
1116           2108            servo_state1:
1116 B40104    2109            cjne a, #1, servo_state2
1119 D21F      2110            setb servo_angle_zero ; open door at state 1
111B 8025      2111            sjmp check_servo_flag
111D           2112   
111D           2113            ; handle state 2
111D           2114            servo_state2:
111D B40204    2115            cjne a, #2, servo_state3
1120 C21F      2116            clr servo_angle_zero ; close door at state 2
1122 801E      2117            sjmp check_servo_flag
1124           2118   
1124           2119            ; handle state 3
1124           2120            servo_state3:
1124 B40304    2121            cjne a, #3, servo_state4
1127 C21F      2122            clr servo_angle_zero ; close door at state 3
1129 8017      2123            sjmp check_servo_flag
112B           2124   
112B           2125            ; handle state 4
112B           2126            servo_state4:
112B B40404    2127            cjne a, #4, servo_state5
112E C21F      2128            clr servo_angle_zero ; close door at state 4
1130 8010      2129            sjmp check_servo_flag
1132           2130   
1132           2131            ; handle state 5
1132           2132            servo_state5:
1132 B40504    2133            cjne a, #5, servo_state6
1135 C21F      2134            clr servo_angle_zero ; close door at state 5
1137 8009      2135            sjmp check_servo_flag
1139           2136   
1139           2137            ; handle state 6
1139           2138            servo_state6:
1139 B40604    2139            cjne a, #6, servo_state7
113C C21F      2140            clr servo_angle_zero ; close door at state 6
113E 8002      2141            sjmp check_servo_flag
1140           2142   
1140           2143            ; handle state 7
1140           2144            servo_state7:
1140 D21F      2145            setb servo_angle_zero ; open door at state 7
1142           2146   
1142           2147   check_servo_flag:
1142           2148            ; check 1 ms flag
1142 101E01    2149            jbc one_millisecond_flag_servo, run_servo_control
1145 22        2150            ret
1146           2151   
1146           2152   run_servo_control:
1146 12114A    2153            lcall servo_control
1149 22        2154            ret
114A           2155   
114A           2156   ;---------------------------------------------------------------
114A           2157   ; servo control
114A           2158   ; generate a 20 ms period pwm signal to control the servo motor
114A           2159   ; able to make the servo motor stay at 0 degree and 180 degree
114A           2160   ;---------------------------------------------------------------
114A           2161   servo_control:
114A D2ED      2162       setb LEDRA.5
114C C0E0      2163            push acc
114E C0D0      2164            push psw
1150 E577      2165            mov a, servo_pwm_counter ; move servo counter to accumulator
1152 04        2166            inc A ; a += 1
1153 B41402    2167            cjne a, #SERVO_PERIOD, servo_pwm_angle_compare ; jump if wrapup not needed
1156 7400      2168            mov a, #0
1158           2169   
1158           2170   servo_pwm_angle_compare: ; read target angle
1158 F577      2171            mov servo_pwm_counter, A
115A 201F09    2172            jb servo_angle_zero, set_zero_degree ; set servo motor to 0 degree
115D           2173            ; set servo motor to 180 degrees
115D E577      2174            mov a, servo_pwm_counter
115F C3        2175            clr c
1160 9402      2176            subb a, #SERVO_180
1162 400B      2177            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 180 degrees duty cycle
1164 800D      2178            sjmp servo_pwm_set_low ; set low if greater
1166           2179   
1166           2180   set_zero_degree:
1166           2181            ; set servo motor to 0 degree
1166 E577      2182            mov a, servo_pwm_counter
1168 C3        2183            clr c
1169 9401      2184            subb a, #SERVO_0
116B 4002      2185            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 0 degrees duty cycle
116D 8004      2186            sjmp servo_pwm_set_low ; set low if greater
116F           2187   
116F           2188   servo_pwm_set_high:
116F           2189            ; set pwm pin high
116F D2B6      2190            setb SERVO_OUT
1171 8002      2191            sjmp servo_control_done
1173           2192   
1173           2193   servo_pwm_set_low:
1173           2194            ; set pwm pin low
1173 C2B6      2195            clr SERVO_OUT
1175           2196   
1175           2197   servo_control_done:
1175 D0D0      2198            pop psw
1177 D0E0      2199            pop acc
1179 22        2200            ret
117A           2201   
117A           2202   ;-------------------------------------------------------------------------------
117A           2203   ; power_control
117A           2204   ;-------------------------------------------------------------------------------
117A           2205   ; Determine the power output based on current state and current temperature 
117A           2206   ; input parameter: Control_FSM_state
117A           2207   ;-------------------------------------------------------------------------------
117A           2208   ; Update LED indicators based on power_output
117A           2209   ; 0%  -> all off
117A           2210   ; <50% -> LED_LEFT on
117A           2211   ; 50%-99% -> LED_LEFT + LED_MID on
117A           2212   ; >=100% -> LED_LEFT + LED_MID + LED_RIGHT on
117A           2213   Update_Power_LEDs:
117A           2214       ; Check for exact 0 (all bytes zero)
117A E55C      2215       mov a, power_output
117C 455D      2216       orl a, power_output+1
117E 455E      2217       orl a, power_output+2
1180 455F      2218       orl a, power_output+3
1182 6032      2219       jz power_leds_low
1184           2220   
1184 855C32    2221       mov x, power_output
1187 855D33    2222       mov x+1, power_output+1
118A 855E34    2223       mov x+2, power_output+2
118D 855F35    2224       mov x+3, power_output+3
1190           2225   
1190 7536EE    2226            mov y+0, #low (HALF_POWER % 0x10000) 
1193 753702    2226            mov y+1, #high(HALF_POWER % 0x10000) 
1196 753800    2226            mov y+2, #low (HALF_POWER / 0x10000) 
1199 753900    2226            mov y+3, #high(HALF_POWER / 0x10000) 
119C 12011A    2227       lcall x_lt_y
119F 200014    2228       jb mf, power_leds_low
11A2           2229   
11A2 7536DC    2230            mov y+0, #low (MAX_POWER % 0x10000) 
11A5 753705    2230            mov y+1, #high(MAX_POWER % 0x10000) 
11A8 753800    2230            mov y+2, #low (MAX_POWER / 0x10000) 
11AB 753900    2230            mov y+3, #high(MAX_POWER / 0x10000) 
11AE 12011A    2231       lcall x_lt_y
11B1 200009    2232       jb mf, power_leds_mid
11B4           2233   
11B4 800E      2234       sjmp power_leds_high
11B6           2235   
11B6           2236   power_leds_low:
11B6 C2B4      2237       clr  LED_LEFT
11B8 C2B3      2238       clr  LED_MID
11BA C2B2      2239       clr  LED_RIGHT
11BC 22        2240       ret
11BD           2241   
11BD           2242   power_leds_mid:
11BD D2B4      2243       setb LED_LEFT
11BF D2B3      2244       setb LED_MID
11C1 C2B2      2245       clr  LED_RIGHT
11C3 22        2246       ret
11C4           2247   
11C4           2248   power_leds_high:
11C4 D2B4      2249       setb LED_LEFT
11C6 D2B3      2250       setb LED_MID
11C8 D2B2      2251       setb LED_RIGHT
11CA 22        2252       ret
11CB           2253   
11CB           2254   proportional_power_control:
11CB E568      2255            mov a, Control_FSM_state
11CD           2256   
11CD           2257   state0_power_control:
11CD           2258            ; idle
11CD           2259            ; 0% power
11CD B4000F    2260            cjne a, #0, state1_power_control
11D0 755C00    2261            mov power_output, #low(NO_POWER)
11D3 755D00    2262            mov power_output+1, #low(NO_POWER)
11D6 755E00    2263            mov power_output+2, #0
11D9 755F00    2264            mov power_output+3, #0
11DC 021377    2265            ljmp power_control_done
11DF           2266   
11DF           2267   state1_power_control:
11DF           2268            ; idle
11DF           2269            ; 0% power
11DF B4010F    2270            cjne a, #1, state2_power_control
11E2 755C00    2271            mov power_output, #low(NO_POWER)
11E5 755D00    2272            mov power_output+1, #low(NO_POWER)
11E8 755E00    2273            mov power_output+2, #0
11EB 755F00    2274            mov power_output+3, #0
11EE 021377    2275            ljmp power_control_done
11F1           2276            
11F1           2277   state2_power_control:
11F1           2278            ; ramp to soak, ramp to ~150C
11F1           2279            ; 100% power
11F1 B4020F    2280            cjne a, #2, state3_power_control
11F4 755CDC    2281            mov power_output, #low(MAX_POWER)
11F7 755D05    2282            mov power_output+1, #high(MAX_POWER)
11FA 755E00    2283            mov power_output+2, #0
11FD 755F00    2284            mov power_output+3, #0
1200 021377    2285            ljmp power_control_done
1203           2286   
1203           2287   state3_power_control:
1203           2288            ; soak period, hold at 150C
1203           2289            ; 20% base power + proportional calculated power
1203 B40302    2290            cjne a, #3, jump_state4_power_control
1206 8003      2291            sjmp state3_power_control_calculation
1208           2292   
1208           2293   jump_state4_power_control:
1208 021335    2294            ljmp state4_power_control
120B           2295   
120B           2296   state3_power_control_calculation:
120B           2297            ; move soak_temp to x
120B 854332    2298            mov x, soak_temp
120E 854433    2299            mov x+1, soak_temp+1
1211 854534    2300            mov x+2, soak_temp+2
1214 854635    2301            mov x+3, soak_temp+3
1217           2302            ; move current_temp to y
1217 853F36    2303            mov y, current_temp
121A 854037    2304            mov y+1, current_temp+1
121D 854138    2305            mov y+2, current_temp+2
1220 854239    2306            mov y+3, current_temp+3
1223           2307   
1223           2308            ; compare between soak_temp and current_temp
1223 C200      2309            clr mf
1225 120178    2310            lcall x_gteq_y
1228 10002B    2311            jbc mf, st_sub_ct
122B           2312            ; current_temp - soak_temp if st < ct
122B C220      2313            clr soak_temp_greater
122D           2314            ; move current_temp to y
122D 854336    2315            mov y, soak_temp
1230 854437    2316            mov y+1, soak_temp+1
1233 854538    2317            mov y+2, soak_temp+2
1236 854639    2318            mov y+3, soak_temp+3
1239           2319            ; move current_temp to x
1239 853F32    2320            mov x, current_temp
123C 854033    2321            mov x+1, current_temp+1
123F 854134    2322            mov x+2, current_temp+2
1242 854235    2323            mov x+3, current_temp+3
1245 1200F6    2324            lcall sub32
1248 85326A    2325            mov soak_temp_diff, x
124B 85336B    2326            mov soak_temp_diff+1, x+1
124E 85346C    2327            mov soak_temp_diff+2, x+2
1251 85356D    2328            mov soak_temp_diff+3, x+3
1254 8011      2329            sjmp proportional_input_soak
1256           2330   
1256           2331   st_sub_ct:
1256           2332            ; soak_temp - current_temp
1256 D220      2333            setb soak_temp_greater
1258 1200F6    2334            lcall sub32
125B 85326A    2335            mov soak_temp_diff, x
125E 85336B    2336            mov soak_temp_diff+1, x+1
1261 85346C    2337            mov soak_temp_diff+2, x+2
1264 85356D    2338            mov soak_temp_diff+3, x+3
1267           2339   
1267           2340   proportional_input_soak:
1267           2341            ; proportaional block calculation       
1267           2342            ; move soak_temp_diff to x
1267 856A32    2343            mov x, soak_temp_diff
126A 856B33    2344            mov x+1, soak_temp_diff+1
126D 856C34    2345            mov x+2, soak_temp_diff+2
1270 856D35    2346            mov x+3, soak_temp_diff+3
1273           2347            ; move proportional gain to y
1273 753605    2348            mov y+0, #low (KP % 0x10000) 
1276 753700    2348            mov y+1, #high(KP % 0x10000) 
1279 753800    2348            mov y+2, #low (KP / 0x10000) 
127C 753900    2348            mov y+3, #high(KP / 0x10000) 
127F 12018C    2349            lcall mul32 ; proportional_output = proportional_gain * difference
1282           2350            
1282 85326E    2351            mov proportional_gain_var, x
1285 85336F    2352            mov proportional_gain_var+1, x+1
1288 853470    2353            mov proportional_gain_var+2, x+2
128B 853571    2354            mov proportional_gain_var+3, x+3
128E           2355   
128E           2356            ; base_power + soak_power when soak_temp > current_temp
128E 302029    2357            jnb soak_temp_greater, sub_proportional_soak
1291 856E32    2358            mov x, proportional_gain_var
1294 856F33    2359            mov x+1, proportional_gain_var+1
1297 857034    2360            mov x+2, proportional_gain_var+2
129A 857135    2361            mov x+3, proportional_gain_var+3
129D 75362C    2362            mov y+0, #low (BASE_POWER % 0x10000) 
12A0 753701    2362            mov y+1, #high(BASE_POWER % 0x10000) 
12A3 753800    2362            mov y+2, #low (BASE_POWER / 0x10000) 
12A6 753900    2362            mov y+3, #high(BASE_POWER / 0x10000) 
12A9 1200D3    2363            lcall add32
12AC           2364            ; x now holds the power output before the saturator
12AC 85326E    2365            mov proportional_gain_var, x
12AF 85336F    2366            mov proportional_gain_var+1, x+1
12B2 853470    2367            mov proportional_gain_var+2, x+2
12B5 853571    2368            mov proportional_gain_var+3, x+3
12B8 803D      2369            sjmp saturator_soak
12BA           2370   
12BA           2371   sub_proportional_soak:
12BA           2372            ; base_power - soak_power when soak_temp <= current_temp
12BA 75322C    2373            mov x+0, #low (BASE_POWER % 0x10000) 
12BD 753301    2373            mov x+1, #high(BASE_POWER % 0x10000) 
12C0 753400    2373            mov x+2, #low (BASE_POWER / 0x10000) 
12C3 753500    2373            mov x+3, #high(BASE_POWER / 0x10000) 
12C6 856E36    2374            mov y, proportional_gain_var
12C9 856F37    2375            mov y+1, proportional_gain_var+1
12CC 857038    2376            mov y+2, proportional_gain_var+2
12CF 857139    2377            mov y+3, proportional_gain_var+3
12D2           2378   
12D2           2379            ; compare whether base_power < proportional_gain_var
12D2 C200      2380            clr mf
12D4 12011A    2381            lcall x_lt_y ; set mf to 1 if base_power < proportional_gain_var, clamp output to 0
12D7 30000E    2382            jnb mf, bp_gteq_pgv
12DA 756E00    2383            mov proportional_gain_var, #low(NO_POWER)
12DD 756F00    2384            mov proportional_gain_var+1, #high(NO_POWER)
12E0 757000    2385            mov proportional_gain_var+2, #0
12E3 757100    2386            mov proportional_gain_var+3, #0
12E6 800F      2387            sjmp saturator_soak
12E8           2388   
12E8           2389   bp_gteq_pgv:
12E8           2390            ; calculate subtracted gain
12E8 1200F6    2391            lcall sub32
12EB           2392            ; x now holds the power output before the saturator
12EB 85326E    2393            mov proportional_gain_var, x
12EE 85336F    2394            mov proportional_gain_var+1, x+1
12F1 853470    2395            mov proportional_gain_var+2, x+2
12F4 853571    2396            mov proportional_gain_var+3, x+3
12F7           2397   
12F7           2398   saturator_soak:
12F7           2399            ; proportional_gain_var now holds the power output before the saturator
12F7           2400            ; saturate power output to max power
12F7 856E32    2401            mov x, proportional_gain_var
12FA 856F33    2402            mov x+1, proportional_gain_var+1
12FD 857034    2403            mov x+2, proportional_gain_var+2
1300 857135    2404            mov x+3, proportional_gain_var+3
1303           2405   
1303 7536DC    2406            mov y+0, #low (MAX_POWER % 0x10000) 
1306 753705    2406            mov y+1, #high(MAX_POWER % 0x10000) 
1309 753800    2406            mov y+2, #low (MAX_POWER / 0x10000) 
130C 753900    2406            mov y+3, #high(MAX_POWER / 0x10000) 
130F           2407   
130F C200      2408            clr mf
1311 120136    2409            lcall x_gt_y ; set mf to 1 if calculated power output greater than max power
1314 20000F    2410            jb mf, saturated_soak
1317           2411            ; set power_output to calculated power if not saturated
1317 856E5C    2412            mov power_output, proportional_gain_var
131A 856F5D    2413            mov power_output+1, proportional_gain_var+1
131D 85705E    2414            mov power_output+2, proportional_gain_var+2
1320 85715F    2415            mov power_output+3, proportional_gain_var+3
1323 021377    2416            ljmp power_control_done
1326           2417   
1326           2418   saturated_soak:
1326 755CDC    2419            mov power_output, #low(MAX_POWER)
1329 755D05    2420            mov power_output+1, #high(MAX_POWER)
132C 755E00    2421            mov power_output+2, #0
132F 755F00    2422            mov power_output+3, #0
1332 021377    2423            ljmp power_control_done
1335           2424   
1335           2425   
1335           2426   state4_power_control:
1335           2427            ; ramp to reflow, max power
1335 B4040F    2428            cjne a, #4, state5_power_control
1338 755CDC    2429            mov power_output, #low(MAX_POWER)
133B 755D05    2430            mov power_output+1, #high(MAX_POWER)
133E 755E00    2431            mov power_output+2, #0
1341 755F00    2432            mov power_output+3, #0
1344 021377    2433            ljmp power_control_done
1347           2434   
1347           2435   state5_power_control:
1347           2436            ; reflow 20% base power
1347 B4050F    2437            cjne a, #5, state6_power_control
134A 755C2C    2438            mov power_output, #low(BASE_POWER)  
134D 755D01    2439            mov power_output+1, #high(BASE_POWER)
1350 755E00    2440            mov power_output+2, #0
1353 755F00    2441            mov power_output+3, #0
1356 021377    2442            ljmp power_control_done
1359           2443   
1359           2444   state6_power_control:
1359           2445            ; cooling 0% power
1359 B4060F    2446            cjne a, #6, state_7_power_control
135C 755C00    2447            mov power_output, #low(NO_POWER)
135F 755D00    2448            mov power_output+1, #high(NO_POWER)
1362 755E00    2449            mov power_output+2, #0
1365 755F00    2450            mov power_output+3, #0
1368 021377    2451            ljmp power_control_done
136B           2452   
136B           2453   state_7_power_control:
136B           2454            ; idle 0% power
136B 755C00    2455            mov power_output, #low(NO_POWER)
136E 755D00    2456            mov power_output+1, #high(NO_POWER)
1371 755E00    2457            mov power_output+2, #0
1374 755F00    2458            mov power_output+3, #0
1377           2459   
1377           2460   power_control_done:
1377 22        2461            ret
1378           2462   
1378           2463   ; function for playing the boot up music
1378           2464   music:
1378           2465            ; 1
1378 1213D0    2466            lcall playC
137B 121460    2467            lcall delayHalfSec
137E           2468            ; 1
137E 1213D0    2469            lcall playC
1381 121460    2470            lcall delayHalfSec
1384           2471            ; 5
1384 1213E8    2472            lcall playG
1387 121460    2473            lcall delayHalfSec
138A           2474            ; 5
138A 1213E8    2475            lcall playG
138D 121460    2476            lcall delayHalfSec
1390           2477            ; 6
1390 121400    2478            lcall PlayA
1393 121460    2479            lcall delayHalfSec
1396           2480            ; 6
1396 121400    2481            lcall PlayA
1399 121460    2482            lcall delayHalfSec
139C           2483            ; 5
139C 1213E8    2484            lcall playG
139F 121460    2485            lcall delayHalfSec
13A2           2486            ; 4
13A2 121418    2487            lcall playF
13A5 121460    2488            lcall delayHalfSec
13A8           2489   
13A8           2490            ; 4
13A8 121418    2491            lcall playF
13AB 121460    2492            lcall delayHalfSec
13AE           2493            ; 3
13AE 121430    2494            lcall playE
13B1 121460    2495            lcall delayHalfSec
13B4           2496   
13B4           2497            ; 3
13B4 121430    2498            lcall playE
13B7 121460    2499            lcall delayHalfSec
13BA           2500   
13BA           2501            ; 2
13BA 121448    2502            lcall playD
13BD 121460    2503            lcall delayHalfSec
13C0           2504   
13C0           2505            ; 2
13C0 121448    2506            lcall playD
13C3 121460    2507            lcall delayHalfSec
13C6           2508            ; 1
13C6 1213D0    2509            lcall playC
13C9 121460    2510            lcall delayHalfSec
13CC           2511            
13CC 121460    2512            lcall delayHalfSec
13CF 22        2513            ret
13D0           2514   
13D0           2515   ;------------------------------------
13D0           2516   ; Play_C_0p5s
13D0           2517   ; Plays ~523 Hz on P1.7 for 0.5 seconds
13D0           2518   ;------------------------------------
13D0           2519   playC:
13D0 7F14      2520       MOV R7, #20        ; outer loop counter
13D2           2521   
13D2           2522   OUTER_LOOP:
13D2 7E1A      2523       MOV R6, #26        ; inner loop counter
13D4           2524   
13D4           2525   INNER_LOOP:
13D4 B295      2526       CPL SOUND_OUT           ; toggle buzzer pin
13D6 1213E0    2527       LCALL Delay_C      ; ~960 s delay
13D9 DEF9      2528       DJNZ R6, INNER_LOOP
13DB           2529   
13DB DFF5      2530       DJNZ R7, OUTER_LOOP
13DD           2531   
13DD C295      2532       CLR SOUND_OUT           ; stop sound (pin low)
13DF 22        2533       RET
13E0           2534       
13E0           2535   Delay_C:
13E0 7D18      2536       MOV R5, #24        ; 24  40 s = 960 s
13E2           2537   DELAY_LOOP:
13E2 120589    2538       LCALL Wait40uSec
13E5 DDFB      2539       DJNZ R5, DELAY_LOOP
13E7 22        2540       RET
13E8           2541       
13E8           2542   
13E8           2543   ;------------------------------------
13E8           2544   ; Play_G_0p5s
13E8           2545   ; Plays ~784 Hz on P1.7 for 0.5 seconds
13E8           2546   ;------------------------------------
13E8           2547   playG:
13E8 7F1F      2548       MOV R7, #31        ; outer loop
13EA           2549   
13EA           2550   OUTER_G:
13EA 7E19      2551       MOV R6, #25        ; inner loop 31  25 = 775 toggles
13EC           2552   
13EC           2553   INNER_G:
13EC B295      2554       CPL SOUND_OUT           ; toggle buzzer pin
13EE 1213F8    2555       LCALL Delay_G      ; ~640 s delay
13F1 DEF9      2556       DJNZ R6, INNER_G
13F3           2557   
13F3 DFF5      2558       DJNZ R7, OUTER_G
13F5           2559   
13F5 C295      2560       CLR SOUND_OUT           ; stop sound
13F7 22        2561       RET
13F8           2562       
13F8           2563   Delay_G:
13F8 7D10      2564       MOV R5, #16        ; 16  40 s = 640 s
13FA           2565   DELAY_G_LOOP:
13FA 120589    2566       LCALL Wait40uSec
13FD DDFB      2567       DJNZ R5, DELAY_G_LOOP
13FF 22        2568       RET
1400           2569            
1400           2570    
1400           2571    ;------------------------------------
1400           2572   ; Play_A_0p5s
1400           2573   ; Plays ~880 Hz on P1.7 for 0.5 seconds
1400           2574   ;------------------------------------
1400           2575   playA:
1400 7F22      2576       MOV R7, #34        ; outer loop counter
1402           2577   
1402           2578   OUTER_A:
1402 7E1A      2579       MOV R6, #26        ; inner loop ? 34  26 = 884 toggles
1404           2580   
1404           2581   INNER_A:
1404 B295      2582       CPL SOUND_OUT           ; toggle buzzer pin
1406 121410    2583       LCALL Delay_A      ; ~560 s delay
1409 DEF9      2584       DJNZ R6, INNER_A
140B           2585   
140B DFF5      2586       DJNZ R7, OUTER_A
140D           2587   
140D C295      2588       CLR SOUND_OUT          ; stop sound
140F 22        2589       RET
1410           2590   
1410           2591   Delay_A:
1410 7D0E      2592       MOV R5, #14        ; 14  40 s = 560 s
1412           2593   DELAY_A_LOOP:
1412 120589    2594       LCALL Wait40uSec
1415 DDFB      2595       DJNZ R5, DELAY_A_LOOP
1417 22        2596       RET
1418           2597   
1418           2598   ;------------------------------------
1418           2599   ; Play_F_0p5s
1418           2600   ; Plays ~698 Hz on P1.7 for 0.5 seconds
1418           2601   ;------------------------------------
1418           2602   playF:
1418 7F1A      2603       MOV R7, #26        ; outer loop
141A           2604   
141A           2605   OUTER_F:
141A 7E1B      2606       MOV R6, #27        ; inner loop ? 26  27 = 702 toggles
141C           2607   
141C           2608   INNER_F:
141C B295      2609       CPL SOUND_OUT          ; toggle buzzer pin
141E 121428    2610       LCALL Delay_F      ; ~720 s delay
1421 DEF9      2611       DJNZ R6, INNER_F
1423           2612   
1423 DFF5      2613       DJNZ R7, OUTER_F
1425           2614   
1425 C295      2615       CLR SOUND_OUT           ; stop sound
1427 22        2616       RET
1428           2617   
1428           2618   Delay_F:
1428 7D12      2619       MOV R5, #18        ; 18  40 s = 720 s
142A           2620   DELAY_F_LOOP:
142A 120589    2621       LCALL Wait40uSec
142D DDFB      2622       DJNZ R5, DELAY_F_LOOP
142F 22        2623       RET
1430           2624   
1430           2625   
1430           2626   ;------------------------------------
1430           2627   ; Play_E_0p5s
1430           2628   ; Plays ~659 Hz on P1.7 for 0.5 seconds
1430           2629   ;------------------------------------
1430           2630   playE:
1430 7F1A      2631       MOV R7, #26        ; outer loop
1432           2632   
1432           2633   OUTER_E:
1432 7E19      2634       MOV R6, #25        ; inner loop ? 26  25 = 650 toggles
1434           2635   
1434           2636   INNER_E:
1434 B295      2637       CPL SOUND_OUT           ; toggle buzzer pin
1436 121440    2638       LCALL Delay_E      ; ~760 s delay
1439 DEF9      2639       DJNZ R6, INNER_E
143B           2640   
143B DFF5      2641       DJNZ R7, OUTER_E
143D           2642   
143D C295      2643       CLR SOUND_OUT          ; stop sound
143F 22        2644       RET
1440           2645       
1440           2646   Delay_E:
1440 7D13      2647       MOV R5, #19        ; 19  40 s = 760 s
1442           2648   DELAY_E_LOOP:
1442 120589    2649       LCALL Wait40uSec
1445 DDFB      2650       DJNZ R5, DELAY_E_LOOP
1447 22        2651       RET
1448           2652   
1448           2653   
1448           2654   ;------------------------------------
1448           2655   ; Play_D_0p5s
1448           2656   ; Plays ~587 Hz on P1.7 for 0.5 seconds
1448           2657   ;------------------------------------
1448           2658   playD:
1448 7F19      2659       MOV R7, #25        ; outer loop
144A           2660   
144A           2661   OUTER_D:
144A 7E18      2662       MOV R6, #24        ; inner loop ? 25  24 = 600 toggles
144C           2663   
144C           2664   INNER_D:
144C B295      2665       CPL SOUND_OUT          ; toggle buzzer pin
144E 121458    2666       LCALL Delay_D      ; ~840 s delay
1451 DEF9      2667       DJNZ R6, INNER_D
1453           2668   
1453 DFF5      2669       DJNZ R7, OUTER_D
1455           2670   
1455 C295      2671       CLR SOUND_OUT         ; stop sound
1457 22        2672       RET
1458           2673       
1458           2674   Delay_D:
1458 7D15      2675       MOV R5, #21        ; 21  40 s = 840 s
145A           2676   DELAY_D_LOOP:
145A 120589    2677       LCALL Wait40uSec
145D DDFB      2678       DJNZ R5, DELAY_D_LOOP
145F 22        2679       RET
1460           2680   
1460           2681   delayHalfSec:
1460 7AFA      2682            mov     R2, #250
1462 121466    2683            lcall WaitmilliSec
1465           2684            ;lcall WaitmilliSec
1465 22        2685            ret
1466           2686   
1466           2687   ;---------------------------------;
1466           2688   ; Wait 'R2' milliseconds, blocking;
1466           2689   ;---------------------------------;
1466           2690   WaitmilliSec:
1466 C000      2691       push AR0
1468 C001      2692       push AR1
146A 7928      2693   loop3: mov R1, #40
146C 7868      2694   loop2: mov R0, #104
146E D8FE      2695   loop1: djnz R0, loop1 ; 4 cycles->4*60.24ns*104=25.0us
1470 D9FA      2696       djnz R1, loop2 ; 25us*40=1.0ms
1472 DAF6      2697       djnz R2, loop3 ; number of millisecons to wait passed in R2
1474 D001      2698       pop AR1
1476 D000      2699       pop AR0
1478 22        2700       ret
1479           2701   ;-------------------------------------------------------------------------------
1479           2702   END
