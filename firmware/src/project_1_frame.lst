0000              1   ; Project 1
0000              2   ; CV-8052 microcontroller in DE10-Lite board
0000              3   ;-------------------------------------------------------------------------------
0000              4   ; Reset vector
0000              5   org 0x0000
0000 020BC6       6       ljmp main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9       reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 02046E      12       ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15       reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18       reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 02132C      21       ljmp Serial_ISR
0026             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
002B 020534      24       ljmp Timer2_ISR
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 32   $LIST
0320             34   ; ----------------------------------------------------------------------------------------------;
0320             35   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             36   dseg at 0x30
0030             37   current_time_sec:     ds 1
0031             38   current_time_minute:  ds 1
0032             39   ; math32 buffer variables
0032             40   x:      ds  4
0036             41   y:      ds  4
003A             42   bcd:    ds  5
003F             43   
003F             44   current_temp: ds 4 ;
0043             45   soak_temp:    ds 4 ;
0047             46   reflow_temp:  ds 4 ;
004B             47   
004B             48   wait25_btn_cnt:    ds 1
004C             49   wait25_keypad_cnt: ds 1
004D             50   wait25_adc_cnt:    ds 1
004E             51   wait25_lcd_cnt:    ds 1
004F             52   wait25_count: ds 1  
0050             53   
0050             54   current_time: ds 4 ;
0054             55   soak_time:    ds 4 ;
0058             56   reflow_time:  ds 4 ;
005C             57   
005C             58   power_output:  ds 4 ;
0060             59   pwm_counter: ds 4 ; counter for pwm (0-1500)
0064             60   
0064             61   KEY1_DEB_timer: ds 1
0065             62   SEC_FSM_timer:  ds 1
0066             63   KEY1_DEB_state:    ds 1
0067             64   SEC_FSM_state:     ds 1
0068             65   Control_FSM_state: ds 1 
0069             66   
0069             67   Current_State:     ds 1
006A             68   soak_temp_diff: ds 4 ; temperature difference between target soak temp and current oven temp 
006E             69   proportional_gain_var: ds 4 ; power gain calculated from the proportional block
0072             70   ;-- UI buffers I added (ayaan)
0072             71   Cursor_Idx: ds 1
0073             72   
0073             73   ; These hold the TEXT (ASCII) safely
0073             74   ; Digits Only + Null Terminator, got rid of C,:, and s 
0073             75   
0073             76   ; Buzzer state
0073             77   beep_count:  ds 1      ; remaining beeps
0074             78   beep_state:  ds 1      ; 0=idle, 1=ON, 2=OFF
0075             79   beep_tmr:    ds 2      ; 16-bit ms timer (needs to reach 500)
0077             80   
0077             81   servo_pwm_counter: ds 1 ; counter for the servo pwm signal
0078             82   
0078             83   ; --- ADD THIS FOR GUI ---
0078             84   rx_buffer:    ds 8    ; Stores "S:150"
0080             85   rx_index:     ds 1    ; Current char index
0081             86   cmd_received: ds 1    ; Flag: 1 = Command ready
0082             87   
0080             88   iseg at 0x80
0080             89   Buf_Soak_Temp: ds 4   
0084             90   Buf_Soak_Time: ds 5   
0089             91   Buf_Refl_Temp: ds 4   
008D             92   Buf_Refl_Time: ds 5
0092             93   
0092             94   
0092             95   
0092             96   ; 46d bytes used
0092             97   
0092             98   ;-------------------------------------------------------------------------------
0092             99   ; bit operation setb, clr, jb, and jnb
0000            100   bseg
0000            101   mf:     dbit 1 ; math32 sign
0001            102   one_second_flag: dbit 1
0002            103   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003            104   
0003            105   soak_temp_reached: dbit 1
0004            106   reflow_temp_reached: dbit 1
0005            107   cooling_temp_reached: dbit 1
0006            108   
0006            109   soak_time_reached: dbit 1
0007            110   reflow_time_reached: dbit 1
0008            111   
0008            112   reset_signal: dbit 1
0009            113   stop_signal: dbit 1
000A            114   start_signal: dbit 1
000B            115   config_finish_signal: dbit 1
000C            116   
000C            117   state_change_signal: dbit 1
000D            118   
000D            119   Key1_flag: dbit 1
000E            120   
000E            121   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
000F            122   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0010            123   PB0_flag: dbit 1 ; start entire program
0011            124   PB1_flag: dbit 1 ; start soak
0012            125   PB2_flag: dbit 1 ; pause process
0013            126   
0013            127   ;buzzer beep
0013            128   one_ms_beep_flag: dbit 1
0014            129   
0014            130   ; BSEG (Bit Segment)
0014            131   wait25_active: dbit 1 ; 1 = We are currently waiting
0015            132   wait25_done:   dbit 1 ; 1 = The 25ms has finished
0016            133   wait25_btn_active:    dbit 1
0017            134   wait25_btn_done:      dbit 1
0018            135   wait25_keypad_active: dbit 1
0019            136   wait25_keypad_done:   dbit 1
001A            137   wait25_adc_active:    dbit 1
001B            138   wait25_adc_done:      dbit 1
001C            139   wait25_lcd_active:    dbit 1
001D            140   wait25_lcd_done:      dbit 1
001E            141   
001E            142   one_millisecond_flag_servo: dbit 1 ; set the one millsiecond flag for servo pwm signal generation
001F            143   servo_angle_zero: dbit 1 ; flag for indicating whether the servo angle should be at 0 or not: 1 -> 0; 0 -> 180
0020            144   soak_temp_greater: dbit 1 ; target soak_temp greater than current_temp
0021            145   ; 11 bits used
0021            146   
0021            147   ;-------------------------------------------------------------------------------
0320            148   cseg
0320            149   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            150   BAUD           EQU 57600
0320            151   
0320            152   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            153   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            154   ; is always 12 unlike the N76E003 where is selectable.
0320            155   
0320            156   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            157   
0320            158   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            159   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            160   
0320            161   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            162   
0320            163   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            164   
0320            165   PWM_OUT        EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            166   
0320            167   ; These 'equ' must match the wiring between the DE10Lite board and the LCD!
0320            168   ; P0 is in connector JPIO.
0320            169   
0320            170   ;Added correct I/O definitions
0320            171   ;-- LCD Pins ---
0320            172   ELCD_RS equ P1.7
0320            173   ELCD_E  equ P1.1
0320            174   ELCD_D4 equ P0.7
0320            175   ELCD_D5 equ P0.5
0320            176   ELCD_D6 equ P0.3
0320            177   ELCD_D7 equ P0.1
0320            178   
0320            179   ; -- Buttons --
0320            180   BTN_SOAK_TEMP equ P0.0
0320            181   BTN_SOAK_TIME equ P0.2
0320            182   BTN_REFL_TEMP equ P0.4
0320            183   BTN_REFL_TIME equ P0.6
0320            184   
0320            185   ; --- KEYPAD ---
0320            186   ROW1 equ P1.2
0320            187   ROW2 equ P1.4
0320            188   ROW3 equ P1.6
0320            189   ROW4 equ P2.0
0320            190   COL1 equ P2.2
0320            191   COL2 equ P2.4
0320            192   COL3 equ P2.6
0320            193   COL4 equ P3.0
0320            194   
0320            195   SERVO_OUT      EQU p3.6 ; servo pin
0320            196   
0320            197   SERVO_PERIOD   EQU 20 ; pwm signal period for the servo motor (20 ms)
0320            198   SERVO_0        EQU 1 ; pwm high time for the servo motor to stay at 0 degree
0320            199   SERVO_180      EQU 2 ; pwm high time for the servo motor to stay at 180 degrees
0320            200   
0320            201   COLD_JUNCTION_TEMP equ 20
0320            202   MAX_POWER           EQU 1500 ; max oven power
0320            203   NO_POWER            EQU 0    ; no power
0320            204   BASE_POWER     EQU (MAX_POWER/5) ; 20% base power for state 2, 4
0320            205   KP                          EQU 5 ; proportional gain
0320            206   
0320            207   ;                     1234567890123456 <-- 16 characters per line LCD
0320 696E6974   208   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   209   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   210   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            211   
0350            212   ; --- UI STRINGS (REQUIRED FOR KEYPAD LOGIC), <- I can fix if duplicates
0350 53656C65   213   Txt_Home:     db 'Select Mode:    ', 0
     6374204D
     6F64653A
     20202020
     00
0361 53657420   214   Txt_SoakT:    db 'Set Soak Temp   ', 0
     536F616B
     2054656D
     70202020
     00
0372 53657420   215   Txt_SoakTime: db 'Set Soak Time   ', 0
     536F616B
     2054696D
     65202020
     00
0383 53657420   216   Txt_ReflT:    db 'Set Reflow Temp ', 0
     5265666C
     6F772054
     656D7020
     00
0394 53657420   217   Txt_ReflTime: db 'Set Reflow Time ', 0
     5265666C
     6F772054
     696D6520
     00
03A5            218   
03A5            219   ;                       1234567890123456
03A5 53657420   220   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
03B5 536F616B   221   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
03C0 5265666C   222   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
03CD 536F616B   223   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
03D8 5265666C   224   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03E5            225   
03E5 54656D70   226   String_temp_line:  db 'Temp: ', 0
     3A2000
03EC            227   
03EC            228   ;                     1234567890123456
03EC 52616D70   229   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03FC 536F616B   230   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
040C 52616D70   231   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
041C 5265666C   232   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
042C 436F6F6C   233   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
043C 50726F63   234   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
044C            235   
044C 20202020   236   String_Blank:    db '                ', 0
     20202020
     20202020
     20202020
     00
045D            237   
045D            238   ;-------------------------------------------------------------------------------
045D            239   ; Timers Setting:
045D            240   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
045D            241   ;   Timer 1: Serial port baud rate 57600 generator
045D            242   ;   Timer 2: 1ms interrupt for BCD counter increment/decrement
045D            243   ;-------------------------------------------------------------------------------
045D            244   ; Routine to initialize the ISR for Timer 0 ;
045D            245   Timer0_Init:
045D E589       246       mov a, TMOD
045F 54F0       247       anl a, #0xf0 ; Clear the bits for timer 0
0461 4401       248       orl a, #0x01 ; Configure timer 0 as 16-timer
0463 F589       249       mov TMOD, a
0465 758CFD     250       mov TH0, #high(TIMER0_RELOAD)
0468 758A5A     251       mov TL0, #low(TIMER0_RELOAD)
046B            252       ; Enable the timer and interrupts
046B D2A9       253       setb ET0  ; Enable timer 0 interrupt
046D            254       ; setb TR0  (no need to open at first)
046D 22         255       ret
046E            256   ; ISR for timer 0.  Set to execute every 1/4096Hz 
046E            257   ; to generate a 2048 Hz square wave at pin P1.5 
046E            258   Timer0_ISR:
046E            259       ;clr TF0  ; According to the data sheet this is done for us already.
046E 758CFD     260       mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
0471 758A5A     261       mov TL0, #low(TIMER0_RELOAD)
0474 B295       262       cpl SOUND_OUT ; Connect speaker to P1.5
0476 32         263       reti
0477            264   ; -----------------------------------------------------------------------------------------------;
0477            265   
0477            266   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
0477            267   Initialize_Serial_Port:
0477 C28E       268       clr TR1             ; Disable timer 1
0479 53890F     269       anl TMOD, #0x0f     ; Mask the bits for timer 1
047C 438920     270       orl TMOD, #0x20     ; Set timer 1 in 8-bit auto reload mode
047F 438780     271       orl PCON, #80H      ; Set SMOD to 1
0482 758DFD     272       mov TH1, #low(TIMER_1_RELOAD)
0485 758BFD     273       mov TL1, #low(TIMER_1_RELOAD) 
0488 D28E       274       setb TR1            ; Enable timer 1
048A 759850     275       mov SCON, #50H      ; <--- CHANGED (Mode 1, REN=1, TI=0, RI=0)
048D D2AC       276       setb ES
048F 22         277       ret
0490            278   
0490            279   ; uart sending functions
0490            280   putchar:
0490 C2AC       281       clr ES        ; 1. Turn OFF Serial Interrupts (Silence!)
0492 F599       282       mov SBUF, a   ; 2. Load the data to send
0494 3099FD     283       jnb TI, $     ; 3. Wait here until hardware says "Done" (Blocking)
0497 C299       284       clr TI        ; 4. Clear the flag manually
0499 D2AC       285       setb ES       ; 5. Turn ON Serial Interrupts again (Listen for Python)
049B 22         286       ret
049C            287   
049C            288   SendString:
049C E4         289       clr a
049D 93         290       movc a, @a+dptr
049E 6006       291       jz SendString_L1
04A0 120490     292       lcall putchar
04A3 A3         293       inc dptr
04A4 80F6       294       sjmp SendString  
04A6            295   SendString_L1:
04A6 22         296       ret
04A7            297   
04A7            298   ;-------------------------------------------------------------------------------
04A7            299   ; serial debugging
04A7            300   ; send a four byte number via serial to laptop
04A7            301   ; need to be used with python script
04A7            302   ; content needed to be sent should be stored in the varaible x
04A7            303   ;-------------------------------------------------------------------------------
04A7            304   Send32:
04A7            305       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
04A7 74AA       306       mov A, #0AAH
04A9 120490     307       lcall putchar
04AC 7455       308       mov A, #055H
04AE 120490     309       lcall putchar
04B1            310   
04B1 E535       311       mov A, x+3
04B3 120490     312       lcall putchar
04B6 E534       313       mov A, x+2
04B8 120490     314       lcall putchar
04BB E533       315       mov A, x+1
04BD 120490     316       lcall putchar
04C0 E532       317       mov A, x+0
04C2 120490     318       lcall putchar
04C5            319   
04C5 740A       320       mov A, #0AH
04C7 120490     321       lcall putchar
04CA 22         322       ret
04CB            323   ; -----------------------------------------------------------------------------------------------;
04CB            324   
04CB            325   ;-------------------------------------------------------------------------------
04CB            326   ; Serial temperature line for PuTTY/screen
04CB            327   ; Outputs: "Temp: XXXC\r\n"
04CB            328   ;-------------------------------------------------------------------------------
04CB            329   Serial_Send_Temp_Line:
04CB 9003E5     330       mov dptr, #String_temp_line
04CE 12049C     331       lcall SendString
04D1            332   
04D1            333       ; Convert current_temp to BCD (same as LCD)
04D1 853F32     334       mov x, current_temp
04D4 854033     335       mov x+1, current_temp+1
04D7 854134     336       mov x+2, current_temp+2
04DA 854235     337       mov x+3, current_temp+3
04DD 12002E     338       lcall hex2bcd
04E0            339   
04E0 7F00       340       mov R7, #0          ; printed_flag = 0
04E2            341   
04E2            342       ; Print Hundreds (if non-zero)
04E2 E53B       343       mov a, bcd+1
04E4 540F       344       anl a, #0x0F
04E6 6007       345       jz Serial_Skip_Hundreds
04E8 2430       346       add a, #0x30
04EA 120490     347       lcall putchar
04ED 7F01       348       mov R7, #1
04EF            349   Serial_Skip_Hundreds:
04EF            350   
04EF            351       ; Print Tens (if non-zero or if hundreds already printed)
04EF E53A       352       mov a, bcd+0
04F1 C4         353       swap a
04F2 540F       354       anl a, #0x0F
04F4 7003       355       jnz Serial_Print_Tens
04F6 EF         356       mov a, R7
04F7 600C       357       jz Serial_Skip_Tens
04F9            358   Serial_Print_Tens:
04F9 E53A       359       mov a, bcd+0
04FB C4         360       swap a
04FC 540F       361       anl a, #0x0F
04FE 2430       362       add a, #0x30
0500 120490     363       lcall putchar
0503 7F01       364       mov R7, #1
0505            365   Serial_Skip_Tens:
0505            366   
0505            367       ; Print Ones (always)
0505 E53A       368       mov a, bcd+0
0507 540F       369       anl a, #0x0F
0509 2430       370       add a, #0x30
050B 120490     371       lcall putchar
050E            372   
050E            373       ; Print 'C' and newline
050E 7443       374       mov a, #'C'
0510 120490     375       lcall putchar
0513 740D       376       mov a, #0DH     ; CR
0515 120490     377       lcall putchar
0518 740A       378       mov a, #0AH     ; LF
051A 120490     379       lcall putchar
051D 22         380       ret
051E            381   
051E            382   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
051E              1   ;-------------------------------------------------------------------------------
051E              2   ; Timer2_ISR.inc
051E              3   ; Contains Initialization and ISR for the 1ms System Timer
051E              4   ;-------------------------------------------------------------------------------
051E              5   
051E              6   ;-------------------------------------------------------------------------------
051E              7   ; Routine to initialize the ISR for timer 2
051E              8   ;-------------------------------------------------------------------------------
051E              9   Timer2_Init:
051E 75C800      10       mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
0521 75CDF5      11       mov TH2, #high(TIMER2_RELOAD)
0524 75CC27      12       mov TL2, #low(TIMER2_RELOAD)
0527             13       ; Set the reload value
0527 75CBF5      14       mov RCAP2H, #high(TIMER2_RELOAD)
052A 75CA27      15       mov RCAP2L, #low(TIMER2_RELOAD)
052D             16       
052D C2CF        17       clr TF2       ; Clear flag just in case
052F             18       ; Enable the timer and interrupts
052F D2AD        19       setb ET2      ; Enable timer 2 interrupt
0531 D2CA        20       setb TR2      ; Enable timer 2
0533 22          21       ret
0534             22   
0534             23   ;-------------------------------------------------------------------------------
0534             24   ; ISR for timer 2.  Runs every 1 ms
0534             25   ;-------------------------------------------------------------------------------
0534             26   Timer2_ISR:
0534 C0E0        27       push acc
0536 C0D0        28       push psw
0538             29       
0538 C2CF        30       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
053A             31   
053A             32       ; --- 1. Existing FSM Timers ---
053A 0564        33       inc KEY1_DEB_timer
053C 0565        34       inc SEC_FSM_timer
053E D202        35       setb one_ms_pwm_flag 
0540 D213        36       setb one_ms_beep_flag
0542 D21E        37       setb one_millisecond_flag_servo
0544             38   
0544             39       ; --- 2. NEW: Non-Blocking Delay Counters ---
0544             40       
0544             41       ; A. BUTTON DELAY
0544 30160B      42       jnb wait25_btn_active, T2_Check_Keypad
0547 054B        43       inc wait25_btn_cnt
0549 E54B        44       mov a, wait25_btn_cnt
054B B41904      45       cjne a, #25, T2_Check_Keypad
054E D217        46       setb wait25_btn_done
0550 C216        47       clr wait25_btn_active
0552             48       
0552             49       ; B. KEYPAD DELAY
0552             50   T2_Check_Keypad:
0552 30180B      51       jnb wait25_keypad_active, T2_Check_ADC
0555 054C        52       inc wait25_keypad_cnt
0557 E54C        53       mov a, wait25_keypad_cnt
0559 B41904      54       cjne a, #25, T2_Check_ADC
055C D219        55       setb wait25_keypad_done
055E C218        56       clr wait25_keypad_active
0560             57   
0560             58       ; C. ADC DELAY (Thermocouple)
0560             59   T2_Check_ADC:
0560 301A0B      60       jnb wait25_adc_active, T2_Check_LCD
0563 054D        61       inc wait25_adc_cnt
0565 E54D        62       mov a, wait25_adc_cnt
0567 B41904      63       cjne a, #25, T2_Check_LCD
056A D21B        64       setb wait25_adc_done
056C C21A        65       clr wait25_adc_active
056E             66   
056E             67       ; D. LCD DELAY
056E             68   T2_Check_LCD:
056E 301C0B      69       jnb wait25_lcd_active, T2_Check_Generic
0571 054E        70       inc wait25_lcd_cnt
0573 E54E        71       mov a, wait25_lcd_cnt
0575 B41904      72       cjne a, #25, T2_Check_Generic
0578 D21D        73       setb wait25_lcd_done
057A C21C        74       clr wait25_lcd_active
057C             75   
057C             76       ; E. GENERIC DELAY (Used by Wait_25ms in Main)
057C             77   T2_Check_Generic:
057C 30140B      78       jnb wait25_active, Timer2_ISR_done
057F 054F        79       inc wait25_count
0581 E54F        80       mov a, wait25_count
0583 B41904      81       cjne a, #25, Timer2_ISR_done
0586 D215        82       setb wait25_done      ; Tells Wait_25ms that we are finished
0588 C214        83       clr wait25_active     ; Stop counting
058A             84   
058A             85   Timer2_ISR_done:
058A D0D0        86       pop psw
058C D0E0        87       pop acc
058E 32          88       reti
058F             89            
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
058F              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
058F              2   cseg
058F              3   
058F              4   ; When using a 33.333333MHz crystal clock
058F              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
058F              6   
058F              7   ;---------------------------------;
058F              8   ; Wait 40 microseconds            ;
058F              9   ;---------------------------------;
058F             10   Wait40uSec:
058F C000        11            push AR0
0591 78BE        12            mov R0, #190
0593             13   L0: 
0593 00          14            nop
0594 00          15            nop
0595 00          16            nop
0596 00          17            nop
0597 D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
0599 D000        19            pop AR0
059B 22          20       ret
059C             21   
059C             22   ;---------------------------------;
059C             23   ; Wait 'R2' milliseconds          ;
059C             24   ;---------------------------------;
                 25   Wait_Milli_Seconds mac
                 26   	push AR2
                 27   	mov R2, %0
                 28   	lcall ?Wait_Milli_Seconds
                 29   	pop AR2
                 30   endmac
059C             31   
059C             32   ?Wait_Milli_Seconds:
059C C000        33            push AR0
059E C001        34            push AR1
05A0 7932        35   L3: mov R1, #50
05A2 78DF        36   L2: mov R0, #223
05A4 D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
05A6 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
05A8 DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
05AA D001        40       pop AR1
05AC D000        41       pop AR0
05AE 22          42       ret
05AF             43            
05AF             44   ;---------------------------------;
05AF             45   ; Toggles the 'E' pin in the LCD  ;
05AF             46   ;---------------------------------;
05AF             47   ELCD_pulse:
05AF D291        48            setb ELCD_E
05B1 12058F      49            lcall Wait40uSec
05B4 C291        50            clr ELCD_E
05B6 12058F      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
05B9 22          52       ret
05BA             53   
05BA             54   ;---------------------------------;
05BA             55   ; Writes acc to LCD in 4-bit mode ;
05BA             56   ;---------------------------------;
05BA             57   ELCD_byte:
05BA             58            ; Write high 4 bits first
05BA A2E7        59            mov c, ACC.7
05BC 9281        60            mov ELCD_D7, c
05BE A2E6        61            mov c, ACC.6
05C0 9283        62            mov ELCD_D6, c
05C2 A2E5        63            mov c, ACC.5
05C4 9285        64            mov ELCD_D5, c
05C6 A2E4        65            mov c, ACC.4
05C8 9287        66            mov ELCD_D4, c
05CA 1205AF      67       lcall ELCD_pulse
05CD             68            ; Write low 4 bits next
05CD A2E3        69            mov c, ACC.3
05CF 9281        70            mov ELCD_D7, c
05D1 A2E2        71            mov c, ACC.2
05D3 9283        72            mov ELCD_D6, c
05D5 A2E1        73            mov c, ACC.1
05D7 9285        74            mov ELCD_D5, c
05D9 A2E0        75            mov c, ACC.0
05DB 9287        76            mov ELCD_D4, c
05DD 1205AF      77       lcall ELCD_pulse
05E0 22          78            ret
05E1             79   
05E1             80   ;---------------------------------;
05E1             81   ; Write data to LCD               ;
05E1             82   ;---------------------------------;
                 83   WriteData mac
                 84   	mov a, %0
                 85   	lcall ?WriteData
                 86   endmac
05E1             87            
05E1             88   ?WriteData:
05E1 D297        89            setb ELCD_RS
05E3 0205BA      90            ljmp ELCD_byte
05E6             91   
05E6             92   ;---------------------------------;
05E6             93   ; Write command to LCD            ;
05E6             94   ;---------------------------------;
                 95   WriteCommand mac
                 96   	mov a, %0
                 97   	lcall ?WriteCommand
                 98   endmac
05E6             99   
05E6            100   ?WriteCommand:
05E6 C297       101            clr ELCD_RS
05E8 0205BA     102            ljmp ELCD_byte
05EB            103   
05EB            104   ;---------------------------------;
05EB            105   ; Configure LCD in 4-bit mode     ;
05EB            106   ;---------------------------------;
05EB            107   ELCD_4BIT:
05EB C291       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
05ED            109            ;clr ELCD_RW  ; RW forced to zero
05ED            110            
05ED            111            ; After power on, let the LCD start up before initializing
05ED C002       112            push AR2
05EF 7A28       112            mov R2, #40
05F1 12059C     112            lcall ?Wait_Milli_Seconds
05F4 D002       112            pop AR2
05F6            113            
05F6            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
05F6 7433       115            mov a, #0x33
05F8 1205E6     115            lcall ?WriteCommand
05FB 7433       116            mov a, #0x33
05FD 1205E6     116            lcall ?WriteCommand
0600 7432       117            mov a, #0x32
0602 1205E6     117            lcall ?WriteCommand ; change to 4-bit mode
0605            118   
0605            119            ; Configure the LCD
0605 7428       120            mov a, #0x28
0607 1205E6     120            lcall ?WriteCommand
060A 740C       121            mov a, #0x0c
060C 1205E6     121            lcall ?WriteCommand
060F 7401       122            mov a, #0x01
0611 1205E6     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
0614            123   
0614            124       ;Wait for the clear screen command to finish.
0614 C002       125            push AR2
0616 7A02       125            mov R2, #2
0618 12059C     125            lcall ?Wait_Milli_Seconds
061B D002       125            pop AR2
061D 22         126       ret
061E            127   
061E            128   ;---------------------------------;
061E            129   ; Send a constant string to LCD   ;
061E            130   ;---------------------------------;
                131   Send_Constant_String mac
                132   	push dph
                133   	push dpl
                134   	push acc
                135   	mov dptr, %0
                136   	lcall ?Send_Constant_String
                137   	pop acc
                138   	pop dpl
                139   	pop dph
                140   endmac
061E            141   
061E            142   ?Send_Constant_String:
061E E4         143       clr a
061F 93         144       movc a, @a+dptr
0620 6006       145       jz ?Send_Constant_String_Done
0622 1205E1     146       lcall ?WriteData
0625 A3         147       inc dptr
0626 80F6       148       sjmp ?Send_Constant_String
0628            149   ?Send_Constant_String_Done:
0628 22         150       ret  
0629            151   
0629            152   ;---------------------------------;
0629            153   ; Set LCD cursor at row, column   ;
0629            154   ;---------------------------------;
                155   Set_Cursor mac
                156   	push acc
                157   	mov a, #%1
                158   	dec a
                159   	lcall ?Set_Cursor_%0 ; Select column and row
                160   	pop acc
                161   endmac
0629            162   
0629            163   ?Set_Cursor_2:
0629 4440       164            orl a, #01000000B
062B            165   ?Set_Cursor_1:
062B 4480       166            orl a, #10000000B
062D 0205E6     167            ljmp ?WriteCommand ; Select column and row
0630            168   
0630            169   ;---------------------------------;
0630            170   ; Display a BCD number in the LCD ;
0630            171   ;---------------------------------;
                172   Display_BCD mac
                173   	push ar0
                174   	mov r0, %0
                175   	lcall ?Display_BCD
                176   	pop ar0
                177   endmac
0630            178   
0630            179   ?Display_BCD:
0630 C0E0       180            push acc
0632            181            ; Write most significant digit
0632 E8         182            mov a, r0
0633 C4         183            swap a
0634 540F       184            anl a, #0fh
0636 4430       185            orl a, #30h
0638 1205E1     186            lcall ?WriteData
063B            187            ; write least significant digit
063B E8         188            mov a, r0
063C 540F       189            anl a, #0fh
063E 4430       190            orl a, #30h
0640 1205E1     191            lcall ?WriteData
0643 D0E0       192            pop acc
0645 22         193            ret
0646            194   
0646            195   ;------------------------------------;
0646            196   ; Display a char in the LCD          ;
0646            197   ;------------------------------------;
                198   Display_char mac
                199   	push acc
                200   	mov a, %0
                201   	lcall ?WriteData
                202   	pop acc
                203   endmac
0646            204   
0646            385            ;-----------------------------------------------------------------------------------------------;
0646            386   
0646            387   ;-------------------------------------------------------------------------------
0646            388   ; Display Function for 7-segment displays       
0646            389   ;-------------------------------------------------------------------------------
0646            390   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
0646            391   T_7seg:
0646 C0F9A4B0   392       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
064B 9282F880   393       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
0650 8883C6A1   394       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
0656            395   
0656            396   ; Displays a BCD number pased in R0 in HEX5-HEX0
0656            397   Display_BCD_7_Seg_HEX10:
0656 900646     398       mov dptr, #T_7seg
0659 E8         399       mov a, R0
065A C4         400       swap a
065B 540F       401       anl a, #0FH
065D 93         402       movc a, @a+dptr
065E F592       403       mov HEX1, a
0660 E8         404       mov a, R0
0661 540F       405       anl a, #0FH
0663 93         406       movc a, @a+dptr
0664 F591       407       mov HEX0, a
0666 22         408       ret
0667            409   
0667            410   Display_BCD_7_Seg_HEX32:
0667 900646     411       mov dptr, #T_7seg
066A E8         412       mov a, R0
066B C4         413       swap a
066C 540F       414       anl a, #0FH
066E 93         415       movc a, @a+dptr
066F F594       416       mov HEX3, a
0671 E8         417       mov a, R0
0672 540F       418       anl a, #0FH
0674 93         419       movc a, @a+dptr
0675 F593       420       mov HEX2, a
0677 22         421       ret
0678            422   
0678            423   Display_BCD_7_Seg_HEX54:
0678 900646     424       mov dptr, #T_7seg
067B E8         425       mov a, R0
067C C4         426       swap a
067D 540F       427       anl a, #0FH
067F 93         428       movc a, @a+dptr
0680 F58F       429       mov HEX5, a
0682 E8         430       mov a, R0
0683 540F       431       anl a, #0FH
0685 93         432       movc a, @a+dptr
0686 F58E       433       mov HEX4, a
0688 22         434       ret
0689            435   
0689            436   ; The 8-bit hex number passed in the accumulator is converted to
0689            437   ; BCD and stored in [R1, R0]
0689            438   Hex_to_bcd_8bit:
0689 75F064     439       mov b, #100
068C 84         440       div ab
068D F9         441       mov R1, a   ; After dividing, a has the 100s
068E E5F0       442       mov a, b    ; Remainder is in register b
0690 75F00A     443       mov b, #10
0693 84         444       div ab ; The tens are stored in a, the units are stored in b 
0694 C4         445       swap a
0695 54F0       446       anl a, #0xf0
0697 45F0       447       orl a, b
0699 F8         448       mov R0, a
069A 22         449       ret
069B            450   ;-------------------------------------------------------------------------------
069B            451   ; Display Function for LCD                      
069B            452   ;-------------------------------------------------------------------------------
069B            453   LCD_Print_2Digits:
069B 120689     454       lcall Hex_to_bcd_8bit
069E E8         455       mov a, R0
069F C4         456       swap a
06A0 540F       457       anl a, #0x0F
06A2 2430       458       add a, #0x30
06A4 1205E1     459       lcall ?WriteData
06A7 E8         460       mov a, R0
06A8 540F       461       anl a, #0x0F
06AA 2430       462       add a, #0x30
06AC 1205E1     463       lcall ?WriteData
06AF 22         464       ret
06B0            465   
06B0            466   LCD_Display_Update_func:
06B0 C0E0       467       push acc
06B2            468       
06B2            469       ; ==========================================
06B2            470       ; PART 1: STATIC TEXT (Title)
06B2            471       ; Runs ONLY when the state changes
06B2            472       ; ==========================================
06B2            473       
06B2            474       ; [FIX] "Trampoline" logic for long distance jump
06B2            475       ; If signal is SET (1), we stay here and update.
06B2            476       ; If signal is CLEAR (0), we Long Jump to the Live Update section.
06B2 200C03     477       jb state_change_signal, Do_Static_Update
06B5 0207EE     478       ljmp Check_Live_Update
06B8            479   
06B8            480   Do_Static_Update:
06B8 C20C       481       clr state_change_signal
06BA            482       
06BA            483       ; State Changed: Clear Screen and Write Title
06BA 121005     484       lcall Clear_Screen_Func
06BD E568       485       mov a, Control_FSM_state
06BF            486       
06BF            487       ; State 0: Welcome
06BF B4003B     488       cjne a, #0, LCD_Check_1
06C2 C0E0       489            push acc
06C4 7401       489            mov a, #1
06C6 14         489            dec a
06C7 12062B     489            lcall ?Set_Cursor_1 ; Select column and row
06CA D0E0       489            pop acc
06CC C083       490            push dph
06CE C082       490            push dpl
06D0 C0E0       490            push acc
06D2 900330     490            mov dptr, #String_state0_1
06D5 12061E     490            lcall ?Send_Constant_String
06D8 D0E0       490            pop acc
06DA D082       490            pop dpl
06DC D083       490            pop dph
06DE C0E0       491            push acc
06E0 7401       491            mov a, #1
06E2 14         491            dec a
06E3 120629     491            lcall ?Set_Cursor_2 ; Select column and row
06E6 D0E0       491            pop acc
06E8 C083       492            push dph
06EA C082       492            push dpl
06EC C0E0       492            push acc
06EE 900340     492            mov dptr, #String_state0_2
06F1 12061E     492            lcall ?Send_Constant_String
06F4 D0E0       492            pop acc
06F6 D082       492            pop dpl
06F8 D083       492            pop dph
06FA 0207EB     493       ljmp LCD_Done_Bridge ; Exit
06FD            494   
06FD            495   LCD_Check_1: ; Setup
06FD B4011F     496       cjne a, #1, LCD_Check_2
0700 C0E0       497            push acc
0702 7401       497            mov a, #1
0704 14         497            dec a
0705 12062B     497            lcall ?Set_Cursor_1 ; Select column and row
0708 D0E0       497            pop acc
070A C083       498            push dph
070C C082       498            push dpl
070E C0E0       498            push acc
0710 9003A5     498            mov dptr, #String_state1
0713 12061E     498            lcall ?Send_Constant_String
0716 D0E0       498            pop acc
0718 D082       498            pop dpl
071A D083       498            pop dph
071C 0207EB     499       ljmp LCD_Done_Bridge
071F            500   
071F            501   LCD_Check_2: ; Ramp to Soak
071F B4021F     502       cjne a, #2, LCD_Check_3
0722 C0E0       503            push acc
0724 7401       503            mov a, #1
0726 14         503            dec a
0727 12062B     503            lcall ?Set_Cursor_1 ; Select column and row
072A D0E0       503            pop acc
072C C083       504            push dph
072E C082       504            push dpl
0730 C0E0       504            push acc
0732 9003EC     504            mov dptr, #String_state2
0735 12061E     504            lcall ?Send_Constant_String
0738 D0E0       504            pop acc
073A D082       504            pop dpl
073C D083       504            pop dph
073E 02080E     505       ljmp LCD_Update_Temp_Value ; Draw Temp immediately!
0741            506   
0741            507   LCD_Check_3: ; Soak
0741 B4031F     508       cjne a, #3, LCD_Check_4
0744 C0E0       509            push acc
0746 7401       509            mov a, #1
0748 14         509            dec a
0749 12062B     509            lcall ?Set_Cursor_1 ; Select column and row
074C D0E0       509            pop acc
074E C083       510            push dph
0750 C082       510            push dpl
0752 C0E0       510            push acc
0754 9003FC     510            mov dptr, #String_state3
0757 12061E     510            lcall ?Send_Constant_String
075A D0E0       510            pop acc
075C D082       510            pop dpl
075E D083       510            pop dph
0760 02080E     511       ljmp LCD_Update_Temp_Value
0763            512   
0763            513   LCD_Check_4: ; Ramp to Peak
0763 B4041F     514       cjne a, #4, LCD_Check_5
0766 C0E0       515            push acc
0768 7401       515            mov a, #1
076A 14         515            dec a
076B 12062B     515            lcall ?Set_Cursor_1 ; Select column and row
076E D0E0       515            pop acc
0770 C083       516            push dph
0772 C082       516            push dpl
0774 C0E0       516            push acc
0776 90040C     516            mov dptr, #String_state4
0779 12061E     516            lcall ?Send_Constant_String
077C D0E0       516            pop acc
077E D082       516            pop dpl
0780 D083       516            pop dph
0782 02080E     517       ljmp LCD_Update_Temp_Value
0785            518   
0785            519   LCD_Check_5: ; Reflow
0785 B4051F     520       cjne a, #5, LCD_Check_6
0788 C0E0       521            push acc
078A 7401       521            mov a, #1
078C 14         521            dec a
078D 12062B     521            lcall ?Set_Cursor_1 ; Select column and row
0790 D0E0       521            pop acc
0792 C083       522            push dph
0794 C082       522            push dpl
0796 C0E0       522            push acc
0798 90041C     522            mov dptr, #String_state5
079B 12061E     522            lcall ?Send_Constant_String
079E D0E0       522            pop acc
07A0 D082       522            pop dpl
07A2 D083       522            pop dph
07A4 02080E     523       ljmp LCD_Update_Temp_Value
07A7            524   
07A7            525   LCD_Check_6: ; Cooling
07A7 B4061F     526       cjne a, #6, LCD_Check_7
07AA C0E0       527            push acc
07AC 7401       527            mov a, #1
07AE 14         527            dec a
07AF 12062B     527            lcall ?Set_Cursor_1 ; Select column and row
07B2 D0E0       527            pop acc
07B4 C083       528            push dph
07B6 C082       528            push dpl
07B8 C0E0       528            push acc
07BA 90042C     528            mov dptr, #String_state6
07BD 12061E     528            lcall ?Send_Constant_String
07C0 D0E0       528            pop acc
07C2 D082       528            pop dpl
07C4 D083       528            pop dph
07C6 02080E     529       ljmp LCD_Update_Temp_Value
07C9            530   
07C9            531   LCD_Check_7: ; Done
07C9            532       ; [FIX] Check distance safe logic for State 7
07C9 B4071F     533       cjne a, #7, LCD_Done_Bridge ; If not 7, we are done
07CC C0E0       534            push acc
07CE 7401       534            mov a, #1
07D0 14         534            dec a
07D1 12062B     534            lcall ?Set_Cursor_1 ; Select column and row
07D4 D0E0       534            pop acc
07D6 C083       535            push dph
07D8 C082       535            push dpl
07DA C0E0       535            push acc
07DC 90043C     535            mov dptr, #String_state7
07DF 12061E     535            lcall ?Send_Constant_String
07E2 D0E0       535            pop acc
07E4 D082       535            pop dpl
07E6 D083       535            pop dph
07E8 0207EB     536       ljmp LCD_Done_Bridge
07EB            537   
07EB            538   ; Local bridge to reach the far-away LCD_Done
07EB            539   LCD_Done_Bridge:
07EB 02086F     540       ljmp LCD_Done
07EE            541   
07EE            542   ; ==========================================
07EE            543   ; PART 2: DYNAMIC VALUES (Temperature)
07EE            544   ; Runs every time 'one_second_flag' is set
07EE            545   ; ==========================================
07EE            546   Check_Live_Update:
07EE 3001FA     547       jnb one_second_flag, LCD_Done_Bridge
07F1 C201       548       clr one_second_flag
07F3            549       
07F3            550       ; Only update temp for States 2, 3, 4, 5, 6
07F3 E568       551       mov a, Control_FSM_state
07F5 B40202     552       cjne a, #2, Check_St3
07F8 8014       553       sjmp LCD_Update_Temp_Value
07FA            554   Check_St3:
07FA B40302     555       cjne a, #3, Check_St4
07FD 800F       556       sjmp LCD_Update_Temp_Value
07FF            557   Check_St4:
07FF B40402     558       cjne a, #4, Check_St5
0802 800A       559       sjmp LCD_Update_Temp_Value
0804            560   Check_St5:
0804 B40502     561       cjne a, #5, Check_St6
0807 8005       562       sjmp LCD_Update_Temp_Value
0809            563   Check_St6:
0809 B40663     564       cjne a, #6, LCD_Done
080C 8000       565       sjmp LCD_Update_Temp_Value
080E            566   
080E            567   ; --- HELPER: Prints "XXX C" on Line 2 ---
080E            568   LCD_Update_Temp_Value:
080E C0E0       569            push acc
0810 7401       569            mov a, #1
0812 14         569            dec a
0813 120629     569            lcall ?Set_Cursor_2 ; Select column and row
0816 D0E0       569            pop acc
0818            570       
0818            571       ; Convert current_temp to BCD
0818 853F32     572       mov x, current_temp
081B 854033     573       mov x+1, current_temp+1
081E 854134     574       mov x+2, current_temp+2
0821 854235     575       mov x+3, current_temp+3
0824 12002E     576       lcall hex2bcd
0827            577   
0827            578       ; Update HEX2-HEX0 with temperature
0827 120872     579       lcall Update_HEX_Temp
082A            580       
082A            581       ; Print Hundreds
082A E53B       582       mov a, bcd+1
082C 540F       583       anl a, #0x0F
082E 2430       584       add a, #0x30
0830 1205E1     585       lcall ?WriteData
0833            586       
0833            587       ; Print Tens
0833 E53A       588       mov a, bcd+0
0835 C4         589       swap a
0836 540F       590       anl a, #0x0F
0838 2430       591       add a, #0x30
083A 1205E1     592       lcall ?WriteData
083D            593       
083D            594       ; Print Ones
083D E53A       595       mov a, bcd+0
083F 540F       596       anl a, #0x0F
0841 2430       597       add a, #0x30
0843 1205E1     598       lcall ?WriteData
0846            599       
0846            600       ; Print 'C'
0846 7443       601       mov a, #'C'
0848 1205E1     602       lcall ?WriteData
084B            603       
084B            604       ; Clear remaining line space (prevents garbage)
084B 7420       605       mov a, #' '
084D 1205E1     606       lcall ?WriteData
0850 1205E1     607       lcall ?WriteData
0853            608   
0853            609       ; Print time MM:SS at bottom right
0853 C0E0       610            push acc
0855 740C       610            mov a, #12
0857 14         610            dec a
0858 120629     610            lcall ?Set_Cursor_2 ; Select column and row
085B D0E0       610            pop acc
085D E531       611       mov a, current_time_minute
085F 12069B     612       lcall LCD_Print_2Digits
0862 743A       613       mov a, #':'
0864 1205E1     614       lcall ?WriteData
0867 E530       615       mov a, current_time_sec
0869 12069B     616       lcall LCD_Print_2Digits
086C            617   
086C            618       ; Mirror temp to serial (PuTTY/screen)
086C 1204CB     619       lcall Serial_Send_Temp_Line
086F            620   
086F            621   LCD_Done:
086F D0E0       622       pop acc
0871 22         623       ret
0872            624   ;---------------------------------------------------------
0872            625   
0872            626   ;-------------------------------------------------------------------------------
0872            627   ; Update HEX2-HEX0 with temperature (3 digits)
0872            628   ;-------------------------------------------------------------------------------
0872            629   Update_HEX_Temp:
0872 900646     630       mov dptr, #T_7seg
0875            631       ; Hundreds -> HEX2
0875 E53B       632       mov a, bcd+1
0877 540F       633       anl a, #0x0F
0879 93         634       movc a, @a+dptr
087A F593       635       mov HEX2, a
087C            636       ; Tens -> HEX1
087C E53A       637       mov a, bcd+0
087E C4         638       swap a
087F 540F       639       anl a, #0x0F
0881 93         640       movc a, @a+dptr
0882 F592       641       mov HEX1, a
0884            642       ; Ones -> HEX0
0884 E53A       643       mov a, bcd+0
0886 540F       644       anl a, #0x0F
0888 93         645       movc a, @a+dptr
0889 F591       646       mov HEX0, a
088B 22         647       ret
088C            648   
088C            649   KEY1_DEB:
088C            650   ;non-blocking state machine for KEY1 debounce
088C E566       651       mov a, KEY1_DEB_state
088E            652   KEY1_DEB_state0:
088E B4000A     653       cjne a, #0, KEY1_DEB_state1
0891 20F92D     654       jb KEY.1, KEY1_DEB_done
0894 756400     655       mov KEY1_DEB_timer, #0
0897 0566       656       inc KEY1_DEB_state
0899 8026       657       sjmp KEY1_DEB_done
089B            658   KEY1_DEB_state1:
089B B40109     659       cjne a, #1, KEY1_DEB_state2
089E            660       ; this is the debounce state
089E E564       661       mov a, KEY1_DEB_timer
08A0 B4321E     662       cjne a, #50, KEY1_DEB_done ; 50 ms passed?
08A3 0566       663       inc KEY1_DEB_state
08A5 801A       664       sjmp KEY1_DEB_done  
08A7            665   KEY1_DEB_state2:
08A7 B4020C     666       cjne a, #2, KEY1_DEB_state3
08AA 20F904     667       jb KEY.1, KEY1_DEB_state2b
08AD 0566       668       inc KEY1_DEB_state
08AF 8010       669       sjmp KEY1_DEB_done  
08B1            670   KEY1_DEB_state2b:
08B1 756600     671       mov KEY1_DEB_state, #0
08B4 800B       672       sjmp KEY1_DEB_done
08B6            673   KEY1_DEB_state3:
08B6 B40308     674       cjne a, #3, KEY1_DEB_done
08B9 30F905     675       jnb KEY.1, KEY1_DEB_done
08BC D20D       676       setb Key1_flag ; Suscesfully detected a valid KEY1 press/release
08BE 756600     677       mov KEY1_DEB_state, #0  
08C1            678   KEY1_DEB_done:
08C1 22         679       ret
08C2            680   ; ------------------------------------------------------------------------------
08C2            681   ; Non-blocking FSM for the one second counter
08C2            682   ;-------------------------------------------------------------------------------
08C2            683   SEC_FSM:
08C2 E567       684       mov a, SEC_FSM_state
08C4            685   SEC_FSM_state0:
08C4 B4000C     686       cjne a, #0, SEC_FSM_state1
08C7 E565       687       mov a, SEC_FSM_timer
08C9 B4FA4B     688       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08CC 756500     689       mov SEC_FSM_timer, #0
08CF 0567       690       inc SEC_FSM_state
08D1 8044       691       sjmp SEC_FSM_done
08D3            692   SEC_FSM_state1: 
08D3 B4010E     693       cjne a, #1, SEC_FSM_state2
08D6 D2E9       694       setb LEDRA.1
08D8 E565       695       mov a, SEC_FSM_timer
08DA B4FA3A     696       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08DD 756500     697       mov SEC_FSM_timer, #0
08E0 0567       698       inc SEC_FSM_state
08E2 8033       699       sjmp SEC_FSM_done
08E4            700   SEC_FSM_state2: 
08E4 B4020E     701       cjne a, #2, SEC_FSM_state3
08E7 D2EA       702       setb LEDRA.2
08E9 E565       703       mov a, SEC_FSM_timer
08EB B4FA29     704       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08EE 756500     705       mov SEC_FSM_timer, #0
08F1 0567       706       inc SEC_FSM_state
08F3 8022       707       sjmp SEC_FSM_done
08F5            708   SEC_FSM_state3: 
08F5 B4031F     709       cjne a, #3, SEC_FSM_done
08F8 D2EB       710       setb LEDRA.3
08FA E565       711       mov a, SEC_FSM_timer
08FC B4FA18     712       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08FF 756500     713       mov SEC_FSM_timer, #0
0902 756700     714       mov SEC_FSM_state, #0
0905            715       
0905            716       ; --- 1 Second has passed! ---
0905 D201       717       setb one_second_flag
0907            718       
0907 E530       719       mov a, current_time_sec
0909 B43B07     720       cjne a, #59, IncCurrentTimeSec 
090C            721       
090C            722       ; --- FIX: 59s -> 0s AND Increment Minute ---
090C 753000     723       mov current_time_sec, #0
090F 0531       724       inc current_time_minute    ; <--- YOU WERE MISSING THIS!
0911            725       ; -------------------------------------------
0911            726       
0911 8004       727       sjmp SEC_FSM_done
0913            728   
0913            729   IncCurrentTimeSec:
0913 0530       730       inc current_time_sec
0915 B2E8       731       cpl LEDRA.0 
0917            732   SEC_FSM_done:
0917 22         733       ret
0918            734   ;-------------------------------------------------------------------------------
0918            735   ; PWM
0918            736   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0918            737   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0918            738   ; ------------------------------------------------------------------------------
0918            739   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0918 100202     740       jbc one_ms_pwm_flag, pwm_wave_generator
091B 8071       741       sjmp end_pwm_generator
091D            742   
091D            743   pwm_wave_generator:
091D C200       744       clr mf
091F            745       ; move pwm counter value into x for comparison purpose
091F 856032     746       mov x, pwm_counter
0922 856133     747       mov x+1, pwm_counter+1
0925 856234     748       mov x+2, pwm_counter+2
0928 856335     749       mov x+3, pwm_counter+3
092B            750   
092B 7536DB     751            mov y+0, #low (PWM_PERIOD % 0x10000) 
092E 753705     751            mov y+1, #high(PWM_PERIOD % 0x10000) 
0931 753800     751            mov y+2, #low (PWM_PERIOD / 0x10000) 
0934 753900     751            mov y+3, #high(PWM_PERIOD / 0x10000) 
0937            752   
0937            753       ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
0937            754       ; increase x by 1
0937 120152     755       lcall x_eq_y 
093A 20001D     756       jb mf, wrap_pwm_counter
093D            757       ; x not equal 1499, increment by 1
093D 753601     758            mov y+0, #low (1 % 0x10000) 
0940 753700     758            mov y+1, #high(1 % 0x10000) 
0943 753800     758            mov y+2, #low (1 / 0x10000) 
0946 753900     758            mov y+3, #high(1 / 0x10000) 
0949 1200D3     759       lcall add32
094C            760       ; update pwm_counter
094C 853260     761       mov pwm_counter, x
094F 853361     762       mov pwm_counter+1, x+1
0952 853462     763       mov pwm_counter+2, x+2
0955 853563     764       mov pwm_counter+3, x+3
0958 8018       765       sjmp set_pwm
095A            766   
095A            767   wrap_pwm_counter:
095A            768       ; x equal 1499, wrap to 0
095A 753200     769            mov x+0, #low (0 % 0x10000) 
095D 753300     769            mov x+1, #high(0 % 0x10000) 
0960 753400     769            mov x+2, #low (0 / 0x10000) 
0963 753500     769            mov x+3, #high(0 / 0x10000) 
0966 853260     770       mov pwm_counter, x
0969 853361     771       mov pwm_counter+1, x+1
096C 853462     772       mov pwm_counter+2, x+2
096F 853563     773       mov pwm_counter+3, x+3
0972            774   
0972            775   set_pwm:
0972            776       ; compare with power_output, if pwm counter smaller than power_output, 
0972            777       ; set pwm pin high; else set pwm pin low load y with power output value
0972 855C36     778       mov y, power_output
0975 855D37     779       mov y+1, power_output+1
0978 855E38     780       mov y+2, power_output+2
097B 855F39     781       mov y+3, power_output+3
097E            782   
097E            783       ; compare x(pwm counter) with y(power output)
097E 12011A     784       lcall x_lt_y
0981 200006     785       jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
0984            786       ;output set pwm pin low if pwm counter greater than power output
0984 C293       787       clr PWM_OUT
0986 C2EC       788       clr LEDRA.4
0988 8004       789       sjmp end_pwm_generator
098A            790   
098A            791   set_pwm_high:
098A D293       792       setb PWM_OUT
098C D2EC       793       setb LEDRA.4
098E            794   
098E            795   end_pwm_generator:
098E 22         796       ret
098F            797   
098F            798   ;-------------------------------------------------------------------------------;
098F            799   ; Temp_Compare
098F            800   ; Checks if we have reached the user's target temperatures.
098F            801   ; Sets 'soak_temp_reached' if current_temp >= soak_temp
098F            802   ; Sets 'reflow_temp_reached' if current_temp >= reflow_temp
098F            803   ;-------------------------------------------------------------------------------;
098F            804   Temp_Compare:
098F            805       ; Reset flags initially
098F C203       806       clr soak_temp_reached
0991 C204       807       clr reflow_temp_reached
0993            808   
0993 C0E0       809       push acc
0995 C0D0       810       push psw
0997 C000       811       push AR0
0999 C001       812       push AR1
099B C002       813       push AR2
099D            814       
099D            815       ; --- 1. CHECK SOAK TEMP ---
099D            816       ; Copy current_temp to X
099D 783F       817       mov R0, #current_temp
099F 7932       818       mov R1, #x
09A1 120A15     819       lcall Copy4_Bytes_R0_to_R1
09A4            820   
09A4            821       ; Copy soak_temp to Y
09A4 7843       822       mov R0, #soak_temp
09A6 7936       823       mov R1, #y
09A8 120A15     824       lcall Copy4_Bytes_R0_to_R1
09AB            825   
09AB            826       ; Compare: Is X (Current) < Y (Target)?
09AB 12011A     827       lcall x_lt_y
09AE 200002     828       jb mf, Check_Reflow_Threshold ; If Current < Target, jump (Flag stays 0)
09B1            829       
09B1            830       ; If we are here, Current >= Target
09B1 D203       831       setb soak_temp_reached
09B3            832   
09B3            833   Check_Reflow_Threshold:
09B3            834       ; --- 2. CHECK REFLOW TEMP ---
09B3            835       ; Copy current_temp to X (Need to reload X because math32 destroys it)
09B3 783F       836       mov R0, #current_temp
09B5 7932       837       mov R1, #x
09B7 120A15     838       lcall Copy4_Bytes_R0_to_R1
09BA            839   
09BA            840       ; Copy reflow_temp to Y
09BA 7847       841       mov R0, #reflow_temp
09BC 7936       842       mov R1, #y
09BE 120A15     843       lcall Copy4_Bytes_R0_to_R1
09C1            844   
09C1            845       ; Compare
09C1 12011A     846       lcall x_lt_y
09C4 200002     847       jb mf, Temp_Compare_Done
09C7            848       
09C7            849       ; If Current >= Target
09C7 D204       850       setb reflow_temp_reached
09C9            851   
09C9            852   Temp_Compare_Done:
09C9 D002       853       pop AR2
09CB D001       854       pop AR1
09CD D000       855       pop AR0
09CF D0D0       856       pop psw
09D1 D0E0       857       pop acc
09D3 22         858       ret
09D4            859   ;-------------------------------------------------------------------------------;
09D4            860   ; Time_Compare
09D4            861   ;
09D4            862   ; PURPOSE:
09D4            863   ;   Compare the elapsed time against soak and reflow
09D4            864   ;   time limits.
09D4            865   ;
09D4            866   ; BEHAVIOR:
09D4            867   ;   - If current_time >= soak_time   if soak_time_reached    = 1
09D4            868   ;   - If current_time >= reflow_time if reflow_time_reached = 1
09D4            869   ;
09D4            870   ; NOTES:
09D4            871   ;   - Time values are treated as 32-bit UNSIGNED numbers
09D4            872   ;     (e.g., milliseconds or seconds).
09D4            873   ;   - Uses the SAME compare logic as Temp_Compare.
09D4            874   ;   - This routine ONLY SETS flags.
09D4            875   ;
09D4            876   ; EXPECTED VARIABLES:
09D4            877   ;   current_time[4], soak_time[4], reflow_time[4]
09D4            878   ;   x[4], y[4]
09D4            879   ;   mf, soak_time_reached, reflow_time_reached
09D4            880   ;-------------------------------------------------------------------------------;
09D4            881   Time_Compare:
09D4 C0E0       882       push acc
09D6 C0D0       883       push psw
09D8 C000       884       push AR0
09DA C001       885       push AR1
09DC C002       886       push AR2
09DE            887   
09DE            888   ; Check: current_time >= soak_time ?
09DE            889       ; Copy current_time of x
09DE 7850       890       mov  R0, #current_time
09E0 7932       891       mov  R1, #x
09E2 120A15     892       lcall Copy4_Bytes_R0_to_R1
09E5            893   
09E5            894       ; Copy soak_time of y
09E5 7854       895       mov  R0, #soak_time
09E7 7936       896       mov  R1, #y
09E9 120A15     897       lcall Copy4_Bytes_R0_to_R1
09EC            898   
09EC            899       ; Compare elapsed time vs soak time
09EC 12011A     900       lcall x_lt_y
09EF 200002     901       jb   mf, Time_Soak_NotReached
09F2 D206       902       setb soak_time_reached
09F4            903   
09F4            904   ; Check: current_time >= reflow_time ?
09F4            905   Time_Soak_NotReached:
09F4            906       ; Copy current_time of x
09F4 7850       907       mov  R0, #current_time
09F6 7932       908       mov  R1, #x
09F8 120A15     909       lcall Copy4_Bytes_R0_to_R1
09FB            910   
09FB            911       ; Copy reflow_time of y
09FB 7858       912       mov  R0, #reflow_time
09FD 7936       913       mov  R1, #y
09FF 120A15     914       lcall Copy4_Bytes_R0_to_R1
0A02            915   
0A02            916       ; Compare elapsed time vs reflow time
0A02 12011A     917       lcall x_lt_y
0A05 200002     918       jb   mf, Time_Reflow_NotReached
0A08 D207       919       setb reflow_time_reached
0A0A            920   
0A0A            921   Time_Reflow_NotReached:
0A0A D002       922       pop  AR2
0A0C D001       923       pop  AR1
0A0E D000       924       pop  AR0
0A10 D0D0       925       pop  psw
0A12 D0E0       926       pop  acc
0A14 22         927       ret
0A15            928   
0A15            929   ;-------------------------------------------------------------------------------;
0A15            930   ; Copy4_Bytes_R0_to_R1
0A15            931   ;
0A15            932   ; PURPOSE:
0A15            933   ;   Utility routine to copy a 32-bit value (4 bytes)
0A15            934   ;   from one memory location to another.
0A15            935   ;
0A15            936   ; INPUTS:
0A15            937   ;   R0 st source address
0A15            938   ;   R1 at destination address
0A15            939   ;
0A15            940   ; USES:
0A15            941   ;   R2 as loop counter
0A15            942   ;
0A15            943   ; EXAMPLE:
0A15            944   ;   mov R0, #current_temp
0A15            945   ;   mov R1, #x
0A15            946   ;   lcall Copy4_Bytes_R0_to_R1
0A15            947   ;-------------------------------------------------------------------------------;
0A15            948   Copy4_Bytes_R0_to_R1:
0A15 7A04       949       mov  R2, #4
0A17            950   Copy4_Loop:
0A17 E6         951       mov  a, @R0
0A18 F7         952       mov  @R1, a
0A19 08         953       inc  R0
0A1A 09         954       inc  R1
0A1B DAFA       955       djnz R2, Copy4_Loop
0A1D 22         956       ret
0A1E            957   
0A1E            958   ;-------------------------------------------------------------------------------;
0A1E            959   ; Abort condition safety check Temperature time
0A1E            960   ;
0A1E            961   ; PURPOSE:
0A1E            962   ;   Automatic cycle termination on error:
0A1E            963   ;   Abort if oven fails to reach at least 50C in first 60s.
0A1E            964   ;
0A1E            965   ; TRIP CONDITION:
0A1E            966   ;   if (current_time >= 60s) AND (current_temp < 50C)
0A1E            967   ;       -> set tc_missing_abort
0A1E            968   ;       -> set stop_signal
0A1E            969   ;
0A1E            970   ; ASSUMPTIONS:
0A1E            971   ;   - current_time is in SECONDS (32-bit, little-endian)
0A1E            972   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
0A1E            973   ;
0A1E            974   ;   the Load_Y constants accordingly.
0A1E            975   ;-------------------------------------------------------------------------------;
0A1E            976   Safety_Check_TC:
0A1E C0E0       977       push acc
0A20 C0D0       978       push psw
0A22 C000       979       push AR0
0A24 C001       980       push AR1
0A26 C002       981       push AR2
0A28            982   
0A28            983       ; ---------------------------------------------------------
0A28            984       ; [FIX] GATEKEEPER: IGNORE UNLESS IN STATE 2 (RAMP TO SOAK)
0A28            985       ; ---------------------------------------------------------
0A28 E568       986       mov a, Control_FSM_state
0A2A B40202     987       cjne a, #2, Safety_TC_Exit_Bridge ; If State != 2, skip everything
0A2D 8003       988       sjmp Safety_Logic_Proceed         ; If State == 2, do the check
0A2F            989   
0A2F            990       Safety_TC_Exit_Bridge:
0A2F 020A7D     991           ljmp Safety_TC_Done               ; Jump to the end
0A32            992   
0A32            993       Safety_Logic_Proceed:
0A32            994           ; If already aborted or startup window closed, do nothing
0A32 200E48     995           jb   tc_missing_abort, Safety_TC_Done
0A35 300F45     996           jnb  tc_startup_window, Safety_TC_Done
0A38            997   
0A38            998       ; Check: current_time >= 60 ?
0A38 7850       999       mov  R0, #current_time
0A3A 7932      1000       mov  R1, #x
0A3C 120A15    1001       lcall Copy4_Bytes_R0_to_R1
0A3F           1002   
0A3F 75363C    1003            mov y+0, #low (60 % 0x10000) 
0A42 753700    1003            mov y+1, #high(60 % 0x10000) 
0A45 753800    1003            mov y+2, #low (60 / 0x10000) 
0A48 753900    1003            mov y+3, #high(60 / 0x10000) 
0A4B 12011A    1004       lcall x_lt_y
0A4E 2000DE    1005       jb   mf, Safety_TC_Exit_Bridge        ; still < 60s  keep waiting
0A51           1006   
0A51           1007       ; We reached 60s: close the startup window so it won't re-check later
0A51 C20F      1008       clr  tc_startup_window
0A53           1009   
0A53           1010       ; Now check: current_temp < 50 ?
0A53 783F      1011       mov  R0, #current_temp
0A55 7932      1012       mov  R1, #x
0A57 120A15    1013       lcall Copy4_Bytes_R0_to_R1
0A5A           1014   
0A5A 753632    1015            mov y+0, #low (50 % 0x10000) 
0A5D 753700    1015            mov y+1, #high(50 % 0x10000) 
0A60 753800    1015            mov y+2, #low (50 / 0x10000) 
0A63 753900    1015            mov y+3, #high(50 / 0x10000) 
0A66 12011A    1016       lcall x_lt_y
0A69 3000C3    1017       jnb  mf, Safety_TC_Exit_Bridge        ; temp >= 50  pass
0A6C           1018   
0A6C           1019       ; FAIL: at 60s, still below 50C  abort
0A6C C293      1020       clr  PWM_OUT
0A6E D20E      1021       setb tc_missing_abort
0A70 D209      1022       setb stop_signal
0A72 120A92    1023            lcall Beep_Ten
0A75           1024       ; 3. Force FSM to State 0 (Welcome)
0A75 756800    1025       mov Control_FSM_state, #0
0A78           1026       
0A78           1027       ; 4. Force UI to State 0 (Home Screen)
0A78 756900    1028       mov Current_State, #0
0A7B           1029       
0A7B           1030       ; 5. Trigger Screen Refresh
0A7B D20C      1031       setb state_change_signal ; Tell loop to redraw "Welcome"
0A7D           1032   
0A7D           1033   Safety_TC_Done:
0A7D D002      1034       pop  AR2
0A7F D001      1035       pop  AR1
0A81 D000      1036       pop  AR0
0A83 D0D0      1037       pop  psw
0A85 D0E0      1038       pop  acc
0A87 22        1039       ret
0A88           1040   
0A88           1041   ; ============================================================
0A88           1042   ; BUZZER STARTUP FUNCTIONS
0A88           1043   ; ============================================================
0A88           1044   
0A88           1045   Beep_Once:
0A88 757301    1046       mov beep_count, #1
0A8B 800A      1047       sjmp Beep_Start
0A8D           1048   
0A8D           1049   Beep_Five:
0A8D 757305    1050       mov beep_count, #5
0A90 8005      1051       sjmp Beep_Start
0A92           1052   
0A92           1053   Beep_Ten:
0A92 75730A    1054       mov beep_count, #10
0A95 8000      1055       sjmp Beep_Start      ; [FIX] Added explicit jump for safety
0A97           1056   
0A97           1057   Beep_Start:
0A97 C28C      1058       clr TR0              ; [FIX] Stop timer briefly to reset cleanly
0A99 757401    1059       mov beep_state, #1   ; Set State to ON
0A9C 757500    1060       mov beep_tmr, #0     ; Reset Timer High Byte
0A9F 757600    1061       mov beep_tmr+1, #0   ; Reset Timer Low Byte
0AA2 D2A9      1062       setb ET0             ; [FIX] Ensure Interrupt is enabled
0AA4 D28C      1063       setb TR0             ; START the 2kHz tone
0AA6 22        1064       ret
0AA7           1065   ;============================================================
0AA7           1066   
0AA7           1067   ;============================================================
0AA7           1068   ; Buzzer beep Task 
0AA7           1069   ; Purpose: beeps, holds, stop
0AA7           1070   ; Buzzer task:
0AA7           1071   ; Beep once when state changes
0AA7           1072   ; Beep five times if finished
0AA7           1073   ; Beep ten times if meets error
0AA7           1074   ;============================================================
0AA7           1075   
0AA7           1076   Beep_Task:
0AA7 301335    1077       jnb one_ms_beep_flag, Beep_Done
0AAA C213      1078       clr one_ms_beep_flag
0AAC           1079   
0AAC E574      1080       mov a, beep_state
0AAE 602F      1081       jz Beep_Done
0AB0           1082   
0AB0           1083   ; ---- increment 16-bit timer ----
0AB0 0575      1084       inc beep_tmr
0AB2 E575      1085       mov a, beep_tmr
0AB4 7002      1086       jnz Beep_Check
0AB6 0576      1087       inc beep_tmr+1
0AB8           1088   
0AB8           1089   Beep_Check:
0AB8           1090       ; [FIX] FUZZY TIMER CHECK
0AB8           1091       ; Check if High Byte is non-zero (Time >= 256ms)
0AB8 E576      1092       mov a, beep_tmr+1
0ABA 6023      1093       jz Beep_Done        ; If 0, keep beeping
0ABC           1094   
0ABC           1095       ; --- Time Limit Reached ---
0ABC 757500    1096       mov beep_tmr, #0    ; Reset timer
0ABF 757600    1097       mov beep_tmr+1, #0
0AC2           1098   
0AC2 E574      1099       mov a, beep_state
0AC4 B40106    1100       cjne a, #1, Beep_Off_State
0AC7           1101   
0AC7           1102       ; State was 1 (ON) -> Turn OFF
0AC7 C28C      1103       clr TR0             ; Hardware Silence
0AC9 757402    1104       mov beep_state, #2  ; Set State to OFF (Pause)
0ACC 22        1105       ret
0ACD           1106   
0ACD           1107   Beep_Off_State:
0ACD           1108   ; ---- OFF finished -> decrement count / next ON ----
0ACD 1573      1109       dec beep_count
0ACF E573      1110       mov a, beep_count
0AD1 6006      1111       jz  Beep_Stop
0AD3           1112   
0AD3 757401    1113       mov beep_state, #1
0AD6 D28C      1114       setb TR0
0AD8 22        1115       ret
0AD9           1116   
0AD9           1117   Beep_Stop:
0AD9 C28C      1118       clr TR0
0ADB 757400    1119       mov beep_state, #0
0ADE 22        1120       ret
0ADF           1121   
0ADF           1122   Beep_Done:
0ADF 22        1123       ret
0AE0           1124   ;==================================================================
0AE0           1125   
0AE0           1126   ;-------------------------------------------------------------------------------;
0AE0           1127   ; Main Control FSM for the entire process
0AE0           1128   ;-------------------------------------------------------------------------------;
0AE0           1129   ;-------------------------------------------------------------------------------;
0AE0           1130   ; FSM LOGIC (Button Logic Fixed)
0AE0           1131   ;-------------------------------------------------------------------------------;
0AE0           1132   Control_FSM:
0AE0 E568      1133       mov a, Control_FSM_state
0AE2 8005      1134       sjmp Control_FSM_state0
0AE4           1135   
0AE4           1136   Control_FSM_state0_a:
0AE4 756800    1137       mov Control_FSM_state, #0
0AE7 D20C      1138       setb state_change_signal
0AE9           1139            
0AE9           1140   Control_FSM_state0:
0AE9 B40014    1141       cjne a, #0, Control_FSM_state1
0AEC           1142   
0AEC 300D04    1143       jnb Key1_flag, Control_FSM_done_bridge ; If Key1 not pressed, exit
0AEF C20D      1144       clr Key1_flag                          ; Clear the flag
0AF1 8001      1145       sjmp Control_FSM_state1_a              ; Jump to Start Oven
0AF3           1146       
0AF3           1147   Control_FSM_done_bridge:
0AF3 22        1148       ret
0AF4           1149   
0AF4           1150   Control_FSM_state1_a:
0AF4 0568      1151       inc Control_FSM_state
0AF6 756900    1152       mov Current_State, #0
0AF9 120F0D    1153       lcall Update_Screen_Full 
0AFC D20C      1154       setb state_change_signal
0AFE E568      1155       mov a, Control_FSM_state
0B00           1156       
0B00           1157   Control_FSM_state1:
0B00 B40127    1158       cjne a, #1, Control_FSM_state2
0B03 120D45    1159       lcall Check_Buttons 
0B06 120D91    1160       lcall Check_Keypad
0B09           1161       
0B09           1162       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
0B09 209008    1163       jb P1.0, Control_FSM_state1_ret
0B0C           1164       
0B0C           1165       ; If we get here, Button is LOW (Pressed)
0B0C 12102F    1166       lcall Wait_For_P1_0_Release
0B0F 120CC9    1167       lcall Update_FSM_Variables
0B12 8001      1168       sjmp Control_FSM_state2_a
0B14           1169   Control_FSM_state1_ret:
0B14 22        1170       ret
0B15           1171   
0B15           1172   ; --- STATE 2: RAMP TO SOAK ---
0B15           1173   Control_FSM_state2_a:
0B15 0568      1174       inc Control_FSM_state
0B17 E568      1175       mov a, Control_FSM_state   ; [FIX] RELOAD 'A' so it matches the new state!
0B19 D20C      1176       setb state_change_signal
0B1B 120A88    1177       lcall Beep_Once
0B1E           1178   
0B1E D20F      1179       setb tc_startup_window    ; OPEN the safety window
0B20 C20E      1180       clr tc_missing_abort      ; Clear any previous aborts
0B22 753000    1181       mov current_time_sec, #0  ; Reset Seconds to 0
0B25 753100    1182       mov current_time_minute, #0 ; Reset Minutes to 0
0B28           1183       
0B28           1184       ; [FIX] CLEAR FLAG ON ENTRY
0B28           1185       ; Force the system to wait for at least one fresh temp reading
0B28           1186       ; before deciding we are done.
0B28 C203      1187       clr soak_temp_reached      
0B2A           1188   
0B2A           1189   Control_FSM_state2:
0B2A B4021F    1190       cjne a, #2, Control_FSM_state3
0B2D 301205    1191       jnb PB2_flag, State2_Check
0B30 C212      1192       clr PB2_flag
0B32 020B9D    1193       ljmp Control_FSM_state6_a ; Pause
0B35           1194   
0B35           1195   State2_Check:
0B35 300313    1196       jnb soak_temp_reached, State2_Ret
0B38           1197       
0B38           1198       ; --- We reached Temp! Move to State 3 ---
0B38 C203      1199       clr soak_temp_reached
0B3A 0568      1200       inc Control_FSM_state
0B3C           1201       
0B3C           1202       ; [FIX] RELOAD 'A' (Good practice)
0B3C E568      1203       mov a, Control_FSM_state   
0B3E           1204       
0B3E D20C      1205       setb state_change_signal
0B40 120A88    1206       lcall Beep_Once
0B43           1207       
0B43 753000    1208       mov current_time_sec, #0
0B46 753100    1209       mov current_time_minute, #0
0B49           1210       
0B49           1211       ; Ensure we start State 3 fresh
0B49 C206      1212       clr soak_time_reached 
0B4B           1213   
0B4B           1214   State2_Ret:
0B4B 22        1215       ret
0B4C           1216   
0B4C           1217   ; --- STATE 3: SOAK PHASE ---
0B4C           1218   Control_FSM_state3:
0B4C B40315    1219       cjne a, #3, Control_FSM_state4
0B4F 301205    1220       jnb PB2_flag, State3_Check
0B52 C212      1221       clr PB2_flag
0B54 020B9D    1222       ljmp Control_FSM_state6_a
0B57           1223   State3_Check:
0B57 300609    1224       jnb soak_time_reached, State3_Ret
0B5A C206      1225       clr soak_time_reached
0B5C 0568      1226       inc Control_FSM_state      
0B5E D20C      1227       setb state_change_signal 
0B60 120A88    1228            lcall Beep_Once
0B63           1229   State3_Ret:
0B63 22        1230       ret
0B64           1231   
0B64           1232   ; --- STATE 4: RAMP TO PEAK ---
0B64           1233   Control_FSM_state4:
0B64 B4041D    1234       cjne a, #4, Control_FSM_state5
0B67 301205    1235       jnb PB2_flag, State4_Check
0B6A C212      1236       clr PB2_flag
0B6C 020B9D    1237       ljmp Control_FSM_state6_a
0B6F           1238   State4_Check:
0B6F 300411    1239       jnb reflow_temp_reached, State4_Ret
0B72 C204      1240       clr reflow_temp_reached
0B74 0568      1241       inc Control_FSM_state
0B76 D20C      1242       setb state_change_signal
0B78 120A88    1243            lcall Beep_Once
0B7B 753000    1244       mov current_time_sec, #0
0B7E 753100    1245       mov current_time_minute, #0
0B81           1246       ; --- ADD THIS LINE ---
0B81 C207      1247       clr reflow_time_reached ; Kill the ghost flag
0B83           1248       ; ---------------------
0B83           1249   State4_Ret:
0B83 22        1250       ret
0B84           1251   
0B84           1252   ; --- STATE 5: REFLOW PHASE ---
0B84           1253   Control_FSM_state5:
0B84 B40502    1254       cjne a, #5, Control_FSM_state6_trampoline
0B87 8003      1255       sjmp State5_Logic
0B89           1256   Control_FSM_state6_trampoline:
0B89 020BA4    1257       ljmp Control_FSM_state6
0B8C           1258   
0B8C           1259   State5_Logic:
0B8C 301205    1260       jnb PB2_flag, State5_Check
0B8F C212      1261       clr PB2_flag
0B91 020B9D    1262       ljmp Control_FSM_state6_a
0B94           1263   State5_Check:
0B94 300705    1264       jnb reflow_time_reached, State5_Ret
0B97 C207      1265       clr reflow_time_reached
0B99 020B9D    1266       ljmp Control_FSM_state6_a
0B9C           1267   State5_Ret:
0B9C 22        1268       ret
0B9D           1269   
0B9D           1270   ; --- STATE 6: COOLING ---
0B9D           1271   Control_FSM_state6_a:
0B9D 0568      1272       inc Control_FSM_state
0B9F D20C      1273       setb state_change_signal
0BA1 120A8D    1274            lcall Beep_Five
0BA4           1275   Control_FSM_state6:
0BA4 B4060A    1276       cjne a, #6, Control_FSM_state7
0BA7           1277       ; Wait for Cooling Temp Reached
0BA7 300506    1278       jnb cooling_temp_reached, State6_Ret
0BAA C205      1279       clr cooling_temp_reached
0BAC 0568      1280       inc Control_FSM_state
0BAE D20C      1281       setb state_change_signal
0BB0           1282   State6_Ret:
0BB0 22        1283       ret
0BB1           1284   
0BB1           1285   ; --- STATE 7: DONE ---
0BB1           1286   Control_FSM_state7:
0BB1 B40711    1287       cjne a, #7, Control_FSM_done
0BB4           1288       
0BB4           1289       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
0BB4 201009    1290       jb PB0_flag, Control_FSM_Reset_Logic ; Wait, PB0_flag is software flag?
0BB7           1291       
0BB7           1292       ; Let's assume you meant the physical button P1.0 like State 0
0BB7 20900B    1293       jb P1.0, Control_FSM_done
0BBA           1294       
0BBA 12102F    1295       lcall Wait_For_P1_0_Release
0BBD 020AE4    1296       ljmp Control_FSM_state0_a
0BC0           1297   
0BC0           1298   Control_FSM_Reset_Logic:
0BC0           1299       ; If using PB0_flag from ISR, handle here
0BC0 C210      1300       clr PB0_flag
0BC2 020AE4    1301       ljmp Control_FSM_state0_a
0BC5           1302   
0BC5           1303   Control_FSM_done:
0BC5 22        1304       ret
0BC6           1305   ;-------------------------------------------------------------------------------;
0BC6           1306   ;         Main program.          
0BC6           1307   ;-------------------------------------------------------------------------------;
0BC6           1308   main:
0BC6           1309   
0BC6           1310       ; --------------------------------------------------------
0BC6           1311       ; 1. SAFETY SHUTDOWN
0BC6           1312       ; --------------------------------------------------------
0BC6 C2AF      1313       clr EA              ; FORCE Interrupts OFF immediately
0BC8 7581C0    1314       mov SP, #0xC0       ; Reset Stack Pointer to safe location
0BCB           1315       
0BCB           1316       ; --------------------------------------------------------
0BCB           1317       ; 2. THE "DIRTY DELAY" (Fixes Reset Garbage)
0BCB           1318       ; We burn ~100ms here using a raw loop. 
0BCB           1319       ; We cannot use timers yet because they aren't initialized.
0BCB           1320       ; --------------------------------------------------------
0BCB 78FA      1321       mov R0, #250
0BCD           1322   Reset_Delay_Outer:
0BCD 79FF      1323       mov R1, #255
0BCF           1324   Reset_Delay_Inner:
0BCF D9FE      1325       djnz R1, Reset_Delay_Inner
0BD1 D8FA      1326       djnz R0, Reset_Delay_Outer
0BD3           1327       ; --------------------------------------------------------
0BD3           1328   
0BD3           1329       ; ... NOW continue with your normal Port Configuration ...
0BD3           1330       
0BD3           1331       ; --- PORT CONFIGURATION ---
0BD3 759AAA    1332       mov P0MOD, #0xAA
0BD6           1333   
0BD6           1334       ; P1: Mixed usage 
0BD6           1335       ; P1.7(LCD_RS), P1.6(Row3), P1.5(Sound), P1.4(Row2)
0BD6           1336       ; P1.3(PWM), P1.2(Row1), P1.1(LCD_E) -> All Outputs
0BD6           1337       ; P1.0 (Unused/RX) -> Input
0BD6           1338       ; Binary: 11111110 -> Hex: 0xFE
0BD6 759BFE    1339       mov P1MOD, #0xFE
0BD9           1340   
0BD9           1341       ; P2: Row4(Out), Cols(In)
0BD9           1342       ; P2.0 (Row4) is Out (1). P2.2, P2.4, P2.6 (Cols) are In (0).
0BD9           1343       ; Binary: 00000001 -> Hex: 0x01
0BD9 759C01    1344       mov P2MOD, #0x01
0BDC           1345   
0BDC           1346       ; P3: Col4(In)
0BDC           1347       ; P3.0 (Col4) is In (0).
0BDC 759D40    1348       mov P3MOD, #01000000B
0BDF           1349       ; Turn off all the LEDs
0BDF 75E800    1350       mov LEDRA, #0 ; LEDRA is bit addressable
0BE2 759500    1351       mov LEDRB, #0 ; LEDRB is NOT bit addresable
0BE5           1352   
0BE5           1353       ; FSM initial states
0BE5 756600    1354       mov KEY1_DEB_state, #0
0BE8 756700    1355       mov SEC_FSM_state, #0
0BEB 756800    1356       mov Control_FSM_state, #0
0BEE 756900    1357       mov Current_State, #0
0BF1           1358       
0BF1           1359       ; FSM timers initialization
0BF1 756400    1360       mov KEY1_DEB_timer, #0
0BF4 756500    1361       mov SEC_FSM_timer, #0
0BF7           1362       ; time counters initialization
0BF7 753000    1363       mov current_time_sec, #0
0BFA 753100    1364       mov current_time_minute, #0
0BFD           1365       ; Initialize counter to zero
0BFD 756000    1366       mov pwm_counter, #0
0C00 756100    1367       mov pwm_counter+1, #0
0C03 756200    1368       mov pwm_counter+2, #0
0C06 756300    1369       mov pwm_counter+3, #0
0C09           1370       ; Initialize power output
0C09 755F00    1371       mov power_output+3, #0
0C0C 755E00    1372       mov power_output+2, #0
0C0F 755D02    1373       mov power_output+1, #02H
0C12 755CEE    1374       mov power_output, #0EEH ; (initilize to 750 for testing)
0C15           1375   
0C15           1376       ; --- ADD THIS TO CLEAN SERIAL VARIABLES ---
0C15 758000    1377       mov rx_index, #0
0C18 758100    1378       mov cmd_received, #0
0C1B           1379   
0C1B           1380       ; Clear all the flags
0C1B C20E      1381       clr  tc_missing_abort
0C1D C209      1382       clr  stop_signal
0C1F C210      1383       clr PB0_flag
0C21 C211      1384       clr PB1_flag
0C23 C212      1385       clr PB2_flag
0C25 C201      1386       clr one_second_flag
0C27 C20B      1387       clr config_finish_signal
0C29 C203      1388       clr soak_temp_reached
0C2B C206      1389       clr soak_time_reached
0C2D C204      1390       clr reflow_temp_reached
0C2F C207      1391       clr reflow_time_reached
0C31 C205      1392       clr cooling_temp_reached
0C33 C20C      1393       clr state_change_signal
0C35 C21E      1394       clr one_millisecond_flag_servo
0C37           1395       
0C37 D20C      1396       setb state_change_signal
0C39           1397   
0C39           1398       ; Set bit
0C39 D20F      1399       setb tc_startup_window
0C3B           1400   
0C3B           1401       ; --------------------------------------
0C3B           1402       ; [FIX] ADD THIS BLOCK TO STOP STARTUP BEEP
0C3B           1403       ; --------------------------------------
0C3B 757400    1404       mov beep_state, #0
0C3E 757300    1405       mov beep_count, #0
0C41 757500    1406       mov beep_tmr, #0
0C44 757600    1407       mov beep_tmr+1, #0
0C47 C213      1408       clr one_ms_beep_flag
0C49 C28C      1409       clr TR0              ; Force buzzer hardware OFF
0C4B           1410       ; --------------------------------------
0C4B           1411   
0C4B           1412   
0C4B 12045D    1413       lcall Timer0_Init
0C4E 12051E    1414       lcall Timer2_Init
0C51 1205EB    1415       lcall ELCD_4BIT
0C54           1416       ;----- Two new lines I added to initialize the UI
0C54 120EBA    1417       lcall Init_All_Buffers
0C57           1418       ;lcall Update_Screen_Full
0C57           1419       ;-----
0C57 120477    1420       lcall Initialize_Serial_Port
0C5A           1421   
0C5A           1422       ; Enable Global interrupts
0C5A D2AF      1423       setb EA  
0C5C           1424   ;-------------------------------------------------------------------------------;
0C5C           1425   ; while(1) loop
0C5C           1426   ;-------------------------------------------------------------------------------;
0C5C           1427   loop:
0C5C           1428       ; Full reset button on P3.7 (active-low to GND)
0C5C 30B702    1429        jnb P3_7, Full_Reset_Trig
0C5F 8003      1430       sjmp Full_Reset_Check_Done
0C61           1431   
0C61           1432   Full_Reset_Trig:
0C61 021037    1433       ljmp Full_Reset
0C64           1434   
0C64           1435   Full_Reset_Check_Done:
0C64           1436   
0C64 121371    1437       lcall Process_Serial_Command
0C67           1438   
0C67           1439       ; Check the FSM for KEY1 debounce
0C67 12088C    1440       lcall KEY1_DEB
0C6A           1441       
0C6A           1442       ; Added to take temp readings
0C6A 12103D    1443       lcall Read_Thermocouple
0C6D           1444       
0C6D           1445       ; 1. Check if we reached temp (Observer)
0C6D 12098F    1446       lcall Temp_Compare
0C70           1447       
0C70           1448       ; 2. Decide heater power based on flags (Driver)
0C70           1449       ;lcall Power_Control
0C70 12117F    1450       lcall proportional_power_control
0C73           1451   
0C73           1452       ; 3. [FIX] Calculate Total Seconds (Minutes * 60 + Seconds)
0C73           1453       ; ---------------------------------------------------------
0C73           1454       ; Load Minutes into X
0C73 853132    1455       mov x+0, current_time_minute
0C76 753300    1456       mov x+1, #0
0C79 753400    1457       mov x+2, #0
0C7C 753500    1458       mov x+3, #0
0C7F           1459       
0C7F           1460       ; Multiply by 60 (Minutes -> Seconds)
0C7F 75363C    1461            mov y+0, #low (60 % 0x10000) 
0C82 753700    1461            mov y+1, #high(60 % 0x10000) 
0C85 753800    1461            mov y+2, #low (60 / 0x10000) 
0C88 753900    1461            mov y+3, #high(60 / 0x10000) 
0C8B 12018C    1462       lcall mul32
0C8E           1463       
0C8E           1464       ; Load Seconds into Y
0C8E 853036    1465       mov y+0, current_time_sec
0C91 753700    1466       mov y+1, #0
0C94 753800    1467       mov y+2, #0
0C97 753900    1468       mov y+3, #0
0C9A           1469       
0C9A           1470       ; Add them together (Total Seconds = X + Y)
0C9A 1200D3    1471       lcall add32
0C9D           1472       
0C9D           1473       ; Store Final Result into 'current_time'
0C9D 853250    1474       mov current_time+0, x+0
0CA0 853351    1475       mov current_time+1, x+1
0CA3 853452    1476       mov current_time+2, x+2
0CA6 853553    1477       mov current_time+3, x+3
0CA9           1478       
0CA9 1209D4    1479       lcall Time_Compare
0CAC           1480       
0CAC 120A1E    1481       lcall Safety_Check_TC
0CAF           1482   
0CAF           1483   
0CAF           1484       ; Check the FSM for one second counter
0CAF 1208C2    1485       lcall SEC_FSM
0CB2           1486   
0CB2           1487       ; Check the FSM for the overall control flow of the reflow process
0CB2 120AE0    1488       lcall Control_FSM
0CB5           1489   
0CB5           1490       ; Update the LCD display based on the current state
0CB5 1206B0    1491       lcall LCD_Display_Update_func
0CB8           1492   
0CB8 300202    1493       jnb one_ms_pwm_flag, Skip_Beep_Sync
0CBB D213      1494       setb one_ms_beep_flag  ; Give the buzzer its own copy of the time tick
0CBD           1495   
0CBD           1496   Skip_Beep_Sync:
0CBD           1497       ; Update the pwm output for the ssr
0CBD 120918    1498       lcall PWM_Wave 
0CC0           1499            ; Update the Buzzer 
0CC0 120AA7    1500            lcall Beep_Task
0CC3           1501       ; Update the pwm output for the servo
0CC3 121112    1502       lcall call_servo_control
0CC6           1503       ; After initialization the program stays in this 'forever' loop
0CC6 020C5C    1504       ljmp loop
0CC9           1505   ;-------------------------------------------------------------------------------;
0CC9           1506   
0CC9           1507   ; ================================================================
0CC9           1508   ; UI & HELPER SUBROUTINES
0CC9           1509   ; ================================================================
0CC9           1510   
0CC9           1511   ; ----------------------------------------------------------------
0CC9           1512   ; MODULE: BRIDGE (Text to Integer Conversion)
0CC9           1513   ; ----------------------------------------------------------------
0CC9           1514   Update_FSM_Variables:
0CC9           1515       ; --- 1. SOAK TEMP ---
0CC9 7880      1516       mov R0, #Buf_Soak_Temp
0CCB 120D08    1517       lcall Parse_Temp_String
0CCE 8F43      1518       mov soak_temp+0, R7
0CD0 754400    1519       mov soak_temp+1, #0
0CD3 754500    1520       mov soak_temp+2, #0
0CD6 754600    1521       mov soak_temp+3, #0
0CD9           1522   
0CD9           1523       ; --- 2. REFLOW TEMP ---
0CD9 7889      1524       mov R0, #Buf_Refl_Temp
0CDB 120D08    1525       lcall Parse_Temp_String
0CDE 8F47      1526       mov reflow_temp+0, R7
0CE0 754800    1527       mov reflow_temp+1, #0
0CE3 754900    1528       mov reflow_temp+2, #0
0CE6 754A00    1529       mov reflow_temp+3, #0
0CE9           1530   
0CE9           1531       ; --- 3. SOAK TIME ---
0CE9 7884      1532       mov R0, #Buf_Soak_Time
0CEB 120D1C    1533       lcall Parse_Time_String
0CEE 8F54      1534       mov soak_time+0, R7
0CF0 8E55      1535       mov soak_time+1, R6
0CF2 755600    1536       mov soak_time+2, #0
0CF5 755700    1537       mov soak_time+3, #0
0CF8           1538   
0CF8           1539       ; --- 4. REFLOW TIME ---
0CF8 788D      1540       mov R0, #Buf_Refl_Time
0CFA 120D1C    1541       lcall Parse_Time_String
0CFD 8F58      1542       mov reflow_time+0, R7
0CFF 8E59      1543       mov reflow_time+1, R6
0D01 755A00    1544       mov reflow_time+2, #0
0D04 755B00    1545       mov reflow_time+3, #0
0D07 22        1546       ret
0D08           1547   
0D08           1548   ; --- Helper: Parse "123" to Integer ---
0D08           1549   Parse_Temp_String:
0D08 7F00      1550       mov R7, #0              ; Clear Result
0D0A           1551   Parse_Temp_Loop:
0D0A E6        1552       mov A, @R0
0D0B 600E      1553       jz Parse_Temp_Done      ; If Null, we are done
0D0D           1554       
0D0D           1555       ; Convert ASCII to Digit
0D0D C3        1556       clr C
0D0E 9430      1557       subb A, #0x30
0D10 FD        1558       mov R5, A               ; R5 = New Digit
0D11           1559       
0D11           1560       ; Result = (Result * 10) + New Digit
0D11 EF        1561       mov A, R7
0D12 75F00A    1562       mov B, #10
0D15 A4        1563       mul AB
0D16 2D        1564       add A, R5
0D17 FF        1565       mov R7, A
0D18           1566       
0D18 08        1567       inc R0
0D19 80EF      1568       sjmp Parse_Temp_Loop
0D1B           1569   Parse_Temp_Done:
0D1B 22        1570       ret
0D1C           1571   
0D1C           1572   ; --- Helper: Parse "MMSS" to Seconds ---
0D1C           1573   Parse_Time_String:
0D1C           1574       ; 1. Minutes Tens
0D1C E6        1575       mov A, @R0
0D1D 9430      1576       subb A, #0x30
0D1F 75F00A    1577       mov B, #10
0D22 A4        1578       mul AB
0D23 FD        1579       mov R5, A
0D24 08        1580       inc R0
0D25           1581       
0D25           1582       ; 2. Minutes Ones
0D25 E6        1583       mov A, @R0
0D26 9430      1584       subb A, #0x30
0D28 2D        1585       add A, R5
0D29 FD        1586       mov R5, A               ; R5 = Total Minutes
0D2A 08        1587       inc R0
0D2B           1588       
0D2B           1589       ; 3. Seconds Tens
0D2B E6        1590       mov A, @R0
0D2C 9430      1591       subb A, #0x30
0D2E 75F00A    1592       mov B, #10
0D31 A4        1593       mul AB
0D32 FC        1594       mov R4, A
0D33 08        1595       inc R0
0D34           1596       
0D34           1597       ; 4. Seconds Ones
0D34 E6        1598       mov A, @R0
0D35 9430      1599       subb A, #0x30
0D37 2C        1600       add A, R4               ; R4 = Total Seconds
0D38           1601       
0D38           1602       ; 5. Calculate Total Seconds = (Mins * 60) + Secs
0D38 ED        1603       mov A, R5
0D39 75F03C    1604       mov B, #60
0D3C A4        1605       mul AB
0D3D 2C        1606       add A, R4
0D3E FF        1607       mov R7, A               ; Low Byte
0D3F E5F0      1608       mov A, B
0D41 3400      1609       addc A, #0
0D43 FE        1610       mov R6, A               ; High Byte
0D44 22        1611       ret
0D45           1612   
0D45           1613   ; ----------------------------------------------------------------
0D45           1614   ; MODULE: BUTTON HANDLER (Mode Selection)
0D45           1615   ; ----------------------------------------------------------------
0D45           1616   Check_Buttons:
0D45           1617       ; --- FORCE INPUT MODE ---
0D45           1618       ; This clears any '0' the LCD library might have written to our buttons
0D45 438055    1619       orl P0, #055H   ; Sets P0.0, P0.2, P0.4, and P0.6 to '1' (Input Mode)
0D48           1620       ; ------------------------
0D48           1621   
0D48 30800A    1622       jnb BTN_SOAK_TEMP, Btn_Soak_Temp_Press
0D4B 308212    1623       jnb BTN_SOAK_TIME, Btn_Soak_Time_Press
0D4E 30841A    1624       jnb BTN_REFL_TEMP, Btn_Refl_Temp_Press
0D51 308622    1625       jnb BTN_REFL_TIME, Btn_Refl_Time_Press
0D54 22        1626       ret
0D55           1627   
0D55           1628   Btn_Soak_Temp_Press:
0D55 120FFF    1629       lcall Wait_25ms_BLOCKING
0D58 756901    1630       mov Current_State, #1
0D5B 757200    1631       mov Cursor_Idx, #0
0D5E 8021      1632       sjmp Redraw_Screen
0D60           1633   
0D60           1634   Btn_Soak_Time_Press:
0D60 120FFF    1635       lcall Wait_25ms_BLOCKING
0D63 756902    1636       mov Current_State, #2
0D66 757200    1637       mov Cursor_Idx, #0
0D69 8016      1638       sjmp Redraw_Screen
0D6B           1639   
0D6B           1640   Btn_Refl_Temp_Press:
0D6B 120FFF    1641       lcall Wait_25ms_BLOCKING
0D6E 756903    1642       mov Current_State, #3
0D71 757200    1643       mov Cursor_Idx, #0
0D74 800B      1644       sjmp Redraw_Screen
0D76           1645   
0D76           1646   Btn_Refl_Time_Press:
0D76 120FFF    1647       lcall Wait_25ms_BLOCKING 
0D79 756904    1648       mov Current_State, #4
0D7C 757200    1649       mov Cursor_Idx, #0
0D7F 8000      1650       sjmp Redraw_Screen
0D81           1651   
0D81           1652   Redraw_Screen:
0D81           1653       ; Wait for button release
0D81 3080FD    1654       jnb BTN_SOAK_TEMP, $
0D84 3082FD    1655       jnb BTN_SOAK_TIME, $
0D87 3084FD    1656       jnb BTN_REFL_TEMP, $
0D8A 3086FD    1657       jnb BTN_REFL_TIME, $
0D8D           1658   
0D8D 120F0D    1659       lcall Update_Screen_Full
0D90 22        1660       ret
0D91           1661   
0D91           1662   ; ----------------------------------------------------------------
0D91           1663   ; MODULE: KEYPAD HANDLER (Input Logic)
0D91           1664   ; ----------------------------------------------------------------
0D91           1665   Check_Keypad:
0D91           1666       ; If State is 0 (Home), ignore keypad
0D91 E569      1667       mov A, Current_State
0D93 6050      1668       jz Keypad_Exit
0D95           1669       
0D95 120DE6    1670       lcall Keypad_Scan
0D98 504B      1671       jnc Keypad_Exit         ; Carry = 0 means no key pressed
0D9A           1672   
0D9A           1673       ; --- Check Special Keys ---
0D9A EF        1674       mov A, R7
0D9B B40E0A    1675       cjne A, #14, Check_Hash ; 14 is Star (*)
0D9E           1676       
0D9E           1677       ; Star Key Pressed: Reset Buffer
0D9E 120EEA    1678       lcall Reset_Current_Buffer
0DA1 120F0D    1679       lcall Update_Screen_Full
0DA4 757200    1680       mov Cursor_Idx, #0
0DA7 22        1681       ret
0DA8           1682   
0DA8           1683   Check_Hash:
0DA8 EF        1684       mov A, R7
0DA9 B40C01    1685       cjne A, #12, Check_Numeric ; 12 is Hash (#)
0DAC 22        1686       ret                     ; Ignore Hash key
0DAD           1687   
0DAD           1688   Check_Numeric:
0DAD           1689       ; Ensure key is 0-9
0DAD EF        1690       mov A, R7
0DAE C3        1691       clr C
0DAF 940A      1692       subb A, #10
0DB1 5031      1693       jnc Symbol_Key_Ignored
0DB3           1694       
0DB3           1695       ; Convert to ASCII
0DB3 EF        1696       mov A, R7
0DB4 2430      1697       add A, #0x30
0DB6 FD        1698       mov R5, A
0DB7           1699   
0DB7           1700       ; Save to Buffer
0DB7 121018    1701       lcall Get_Current_Buffer_Addr
0DBA E572      1702       mov A, Cursor_Idx
0DBC 28        1703       add A, R0
0DBD F8        1704       mov R0, A
0DBE ED        1705       mov A, R5
0DBF F6        1706       mov @R0, A
0DC0 0572      1707       inc Cursor_Idx
0DC2           1708   
0DC2           1709       ; --- Check Cursor Limits ---
0DC2 E569      1710       mov A, Current_State
0DC4 B40102    1711       cjne A, #1, Check_Limit_Time_1
0DC7 8005      1712       sjmp Limit_Temp_3
0DC9           1713   
0DC9           1714   Check_Limit_Time_1:
0DC9 B4030B    1715       cjne A, #3, Limit_Time_4
0DCC 8000      1716       sjmp Limit_Temp_3
0DCE           1717   
0DCE           1718   Limit_Temp_3:
0DCE E572      1719       mov A, Cursor_Idx
0DD0 B4030D    1720       cjne A, #3, Do_Refresh
0DD3 1572      1721       dec Cursor_Idx          ; Stay at last digit
0DD5 8009      1722       sjmp Do_Refresh
0DD7           1723   
0DD7           1724   Limit_Time_4:
0DD7 E572      1725       mov A, Cursor_Idx
0DD9 B40404    1726       cjne A, #4, Do_Refresh
0DDC 1572      1727       dec Cursor_Idx          ; Stay at last digit
0DDE 8000      1728       sjmp Do_Refresh
0DE0           1729   
0DE0           1730   Do_Refresh:
0DE0 120F0D    1731       lcall Update_Screen_Full
0DE3 22        1732       ret
0DE4           1733   
0DE4           1734   Symbol_Key_Ignored:
0DE4 22        1735       ret
0DE5           1736   Keypad_Exit:
0DE5 22        1737       ret
0DE6           1738   
0DE6           1739   ; ----------------------------------------------------------------
0DE6           1740   ; MODULE: HARDWARE SCANNER (Matrix Logic)
0DE6           1741   ; ----------------------------------------------------------------
0DE6           1742   Keypad_Scan:
0DE6           1743       ; Step 1: Check if ANY key is pressed (All Rows Low)
0DE6 C292      1744       clr ROW1
0DE8 C294      1745       clr ROW2
0DEA C296      1746       clr ROW3
0DEC C2A0      1747       clr ROW4
0DEE A2A2      1748       mov C, COL1
0DF0 82A4      1749       anl C, COL2
0DF2 82A6      1750       anl C, COL3
0DF4 82B0      1751       anl C, COL4
0DF6 5002      1752       jnc Keypad_Debounce
0DF8 C3        1753       clr C
0DF9 22        1754       ret
0DFA           1755   
0DFA           1756   Keypad_Debounce:
0DFA 120FFF    1757       lcall Wait_25ms_BLOCKING
0DFD A2A2      1758       mov C, COL1
0DFF 82A4      1759       anl C, COL2
0E01 82A6      1760       anl C, COL3
0E03 82B0      1761       anl C, COL4
0E05 5002      1762       jnc Keypad_Find_Row
0E07 C3        1763       clr C
0E08 22        1764       ret
0E09           1765   
0E09           1766   Keypad_Find_Row:
0E09 D292      1767       setb ROW1
0E0B D294      1768       setb ROW2
0E0D D296      1769       setb ROW3
0E0F D2A0      1770       setb ROW4
0E11           1771   
0E11           1772       ; Row 1
0E11 C292      1773       clr ROW1
0E13 30A23D    1774       jnb COL1, Keypad_Key_1
0E16 30A43E    1775       jnb COL2, Keypad_Key_2
0E19 30A63F    1776       jnb COL3, Keypad_Key_3
0E1C 30B040    1777       jnb COL4, Keypad_Key_A
0E1F D292      1778       setb ROW1
0E21           1779   
0E21           1780       ; Row 2
0E21 C294      1781       clr ROW2
0E23 30A23D    1782       jnb COL1, Keypad_Key_4
0E26 30A43E    1783       jnb COL2, Keypad_Key_5
0E29 30A63F    1784       jnb COL3, Keypad_Key_6
0E2C 30B040    1785       jnb COL4, Keypad_Key_B
0E2F D294      1786       setb ROW2
0E31           1787   
0E31           1788       ; Row 3
0E31 C296      1789       clr ROW3
0E33 30A23D    1790       jnb COL1, Keypad_Key_7
0E36 30A43E    1791       jnb COL2, Keypad_Key_8
0E39 30A63F    1792       jnb COL3, Keypad_Key_9
0E3C 30B040    1793       jnb COL4, Keypad_Key_C
0E3F D296      1794       setb ROW3
0E41           1795   
0E41           1796       ; Row 4
0E41 C2A0      1797       clr ROW4
0E43 30A23D    1798       jnb COL1, Keypad_Key_Star
0E46 30A43E    1799       jnb COL2, Keypad_Key_0
0E49 30A63F    1800       jnb COL3, Keypad_Key_Hash
0E4C 30B040    1801       jnb COL4, Keypad_Key_D
0E4F D2A0      1802       setb ROW4
0E51 C3        1803       clr C
0E52 22        1804       ret
0E53           1805   
0E53           1806   ; Key Mapping (Renamed to avoid conflicts)
0E53 7F01      1807   Keypad_Key_1: mov R7, #1
0E55 803C      1808          sjmp Wait_Release
0E57 7F02      1809   Keypad_Key_2: mov R7, #2
0E59 8038      1810          sjmp Wait_Release
0E5B 7F03      1811   Keypad_Key_3: mov R7, #3
0E5D 8034      1812          sjmp Wait_Release
0E5F 7F0A      1813   Keypad_Key_A: mov R7, #10
0E61 8030      1814          sjmp Wait_Release
0E63 7F04      1815   Keypad_Key_4: mov R7, #4
0E65 802C      1816          sjmp Wait_Release
0E67 7F05      1817   Keypad_Key_5: mov R7, #5
0E69 8028      1818          sjmp Wait_Release
0E6B 7F06      1819   Keypad_Key_6: mov R7, #6
0E6D 8024      1820          sjmp Wait_Release
0E6F 7F0B      1821   Keypad_Key_B: mov R7, #11
0E71 8020      1822          sjmp Wait_Release
0E73 7F07      1823   Keypad_Key_7: mov R7, #7
0E75 801C      1824          sjmp Wait_Release
0E77 7F08      1825   Keypad_Key_8: mov R7, #8
0E79 8018      1826          sjmp Wait_Release
0E7B 7F09      1827   Keypad_Key_9: mov R7, #9
0E7D 8014      1828          sjmp Wait_Release
0E7F 7F0D      1829   Keypad_Key_C: mov R7, #13
0E81 8010      1830          sjmp Wait_Release
0E83 7F0E      1831   Keypad_Key_Star: mov R7, #14
0E85 800C      1832          sjmp Wait_Release
0E87 7F00      1833   Keypad_Key_0: mov R7, #0
0E89 8008      1834          sjmp Wait_Release
0E8B 7F0C      1835   Keypad_Key_Hash: mov R7, #12
0E8D 8004      1836          sjmp Wait_Release
0E8F 7F0F      1837   Keypad_Key_D: mov R7, #15
0E91 8000      1838          sjmp Wait_Release
0E93           1839   
0E93           1840   Wait_Release:
0E93 A2A2      1841       mov C, COL1
0E95 82A4      1842       anl C, COL2
0E97 82A6      1843       anl C, COL3
0E99 82B0      1844       anl C, COL4
0E9B 50F6      1845       jnc Wait_Release
0E9D D3        1846       setb C
0E9E D292      1847       setb ROW1
0EA0 D294      1848       setb ROW2
0EA2 D296      1849       setb ROW3
0EA4 D2A0      1850       setb ROW4
0EA6 22        1851       ret
0EA7           1852   
0EA7           1853   Wait_25ms:
0EA7           1854       ; 1. Check if we are already waiting
0EA7 20140E    1855       jb wait25_active, Check_Timer_Status
0EAA           1856       
0EAA           1857       ; 2. Check if we just finished
0EAA 301504    1858       jnb wait25_done, Start_New_Timer
0EAD           1859       
0EAD           1860       ; 3. Timer is DONE! Reset flags and return True
0EAD C215      1861       clr wait25_done
0EAF D3        1862       setb C          ; Carry = 1 means "Done"
0EB0 22        1863       ret
0EB1           1864   
0EB1           1865   Start_New_Timer:
0EB1           1866       ; 4. Start a new 25ms wait
0EB1 754F00    1867       mov wait25_count, #0
0EB4 D214      1868       setb wait25_active
0EB6 C3        1869       clr C           ; Carry = 0 means "Not Done Yet"
0EB7 22        1870       ret
0EB8           1871   
0EB8           1872   Check_Timer_Status:
0EB8           1873       ; 5. Still waiting... return False immediately
0EB8 C3        1874       clr C           ; Carry = 0 means "Not Done Yet"
0EB9 22        1875       ret
0EBA           1876   
0EBA           1877   ; ----------------------------------------------------------------
0EBA           1878   ; MODULE: BUFFER INIT (Reset Logic)
0EBA           1879   ; ----------------------------------------------------------------
0EBA           1880   Init_All_Buffers:
0EBA 7880      1881       mov R0, #Buf_Soak_Temp
0EBC 120ECF    1882       lcall Init_Temp_Template
0EBF 7889      1883       mov R0, #Buf_Refl_Temp
0EC1 120ECF    1884       lcall Init_Temp_Template
0EC4 7884      1885       mov R0, #Buf_Soak_Time
0EC6 120EDB    1886       lcall Init_Time_Template
0EC9 788D      1887       mov R0, #Buf_Refl_Time
0ECB 120EDB    1888       lcall Init_Time_Template
0ECE 22        1889       ret
0ECF           1890   
0ECF           1891   Init_Temp_Template:
0ECF 7630      1892       mov @R0, #'0'
0ED1 08        1893       inc R0
0ED2 7630      1894       mov @R0, #'0'
0ED4 08        1895       inc R0
0ED5 7630      1896       mov @R0, #'0'
0ED7 08        1897       inc R0
0ED8 7600      1898       mov @R0, #0
0EDA 22        1899       ret
0EDB           1900   
0EDB           1901   Init_Time_Template:
0EDB 7630      1902       mov @R0, #'0'
0EDD 08        1903       inc R0
0EDE 7630      1904       mov @R0, #'0'
0EE0 08        1905       inc R0
0EE1 7630      1906       mov @R0, #'0'
0EE3 08        1907       inc R0
0EE4 7630      1908       mov @R0, #'0'
0EE6 08        1909       inc R0
0EE7 7600      1910       mov @R0, #0
0EE9 22        1911       ret
0EEA           1912   
0EEA           1913   Reset_Current_Buffer:
0EEA E569      1914       mov A, Current_State
0EEC B40106    1915       cjne A, #1, Reset_Chk_2
0EEF 7880      1916       mov R0, #Buf_Soak_Temp
0EF1 120ECF    1917       lcall Init_Temp_Template
0EF4 22        1918       ret
0EF5           1919   Reset_Chk_2:
0EF5 B40206    1920       cjne A, #2, Reset_Chk_3
0EF8 7884      1921       mov R0, #Buf_Soak_Time
0EFA 120EDB    1922       lcall Init_Time_Template
0EFD 22        1923       ret
0EFE           1924   Reset_Chk_3:
0EFE B40306    1925       cjne A, #3, Reset_Chk_4
0F01 7889      1926       mov R0, #Buf_Refl_Temp
0F03 120ECF    1927       lcall Init_Temp_Template
0F06 22        1928       ret
0F07           1929   Reset_Chk_4:
0F07 788D      1930       mov R0, #Buf_Refl_Time
0F09 120EDB    1931       lcall Init_Time_Template
0F0C 22        1932       ret
0F0D           1933   
0F0D           1934   ; ----------------------------------------------------------------
0F0D           1935   ; MODULE: SCREEN UPDATE (Visual Logic)
0F0D           1936   ; ----------------------------------------------------------------
0F0D           1937   Update_Screen_Full:
0F0D 121005    1938       lcall Clear_Screen_Func
0F10 C0E0      1939            push acc
0F12 7401      1939            mov a, #1
0F14 14        1939            dec a
0F15 12062B    1939            lcall ?Set_Cursor_1 ; Select column and row
0F18 D0E0      1939            pop acc
0F1A           1940   
0F1A           1941       ; --- Draw Line 1 (Titles) ---
0F1A E569      1942       mov A, Current_State
0F1C B40013    1943       cjne A, #0, Update_State_1
0F1F C083      1944            push dph
0F21 C082      1944            push dpl
0F23 C0E0      1944            push acc
0F25 900350    1944            mov dptr, #Txt_Home
0F28 12061E    1944            lcall ?Send_Constant_String
0F2B D0E0      1944            pop acc
0F2D D082      1944            pop dpl
0F2F D083      1944            pop dph
0F31 22        1945       ret 
0F32           1946   Update_State_1:
0F32 B40114    1947       cjne A, #1, Update_State_2
0F35 C083      1948            push dph
0F37 C082      1948            push dpl
0F39 C0E0      1948            push acc
0F3B 900361    1948            mov dptr, #Txt_SoakT
0F3E 12061E    1948            lcall ?Send_Constant_String
0F41 D0E0      1948            pop acc
0F43 D082      1948            pop dpl
0F45 D083      1948            pop dph
0F47 8042      1949       sjmp Draw_Temp_Format
0F49           1950   Update_State_2:
0F49 B40214    1951       cjne A, #2, Update_State_3
0F4C C083      1952            push dph
0F4E C082      1952            push dpl
0F50 C0E0      1952            push acc
0F52 900372    1952            mov dptr, #Txt_SoakTime
0F55 12061E    1952            lcall ?Send_Constant_String
0F58 D0E0      1952            pop acc
0F5A D082      1952            pop dpl
0F5C D083      1952            pop dph
0F5E 8042      1953       sjmp Draw_Time_Format
0F60           1954   Update_State_3:
0F60 B40314    1955       cjne A, #3, Update_State_4
0F63 C083      1956            push dph
0F65 C082      1956            push dpl
0F67 C0E0      1956            push acc
0F69 900383    1956            mov dptr, #Txt_ReflT
0F6C 12061E    1956            lcall ?Send_Constant_String
0F6F D0E0      1956            pop acc
0F71 D082      1956            pop dpl
0F73 D083      1956            pop dph
0F75 8014      1957       sjmp Draw_Temp_Format
0F77           1958   Update_State_4:
0F77 C083      1959            push dph
0F79 C082      1959            push dpl
0F7B C0E0      1959            push acc
0F7D 900394    1959            mov dptr, #Txt_ReflTime
0F80 12061E    1959            lcall ?Send_Constant_String
0F83 D0E0      1959            pop acc
0F85 D082      1959            pop dpl
0F87 D083      1959            pop dph
0F89 8017      1960       sjmp Draw_Time_Format
0F8B           1961   
0F8B           1962   ; --- Draw Line 2 (Values) ---
0F8B           1963   Draw_Temp_Format:
0F8B C0E0      1964            push acc
0F8D 7401      1964            mov a, #1
0F8F 14        1964            dec a
0F90 120629    1964            lcall ?Set_Cursor_2 ; Select column and row
0F93 D0E0      1964            pop acc
0F95 121018    1965       lcall Get_Current_Buffer_Addr
0F98 120FF5    1966       lcall Print_String_RAM
0F9B 7443      1967       mov A, #'C'
0F9D 1205E1    1968       lcall ?WriteData
0FA0 8027      1969       sjmp Restore_Cursor
0FA2           1970   
0FA2           1971   Draw_Time_Format:
0FA2 C0E0      1972            push acc
0FA4 7401      1972            mov a, #1
0FA6 14        1972            dec a
0FA7 120629    1972            lcall ?Set_Cursor_2 ; Select column and row
0FAA D0E0      1972            pop acc
0FAC 121018    1973       lcall Get_Current_Buffer_Addr
0FAF           1974       ; MM
0FAF E6        1975       mov A, @R0
0FB0 1205E1    1976       lcall ?WriteData
0FB3 08        1977       inc R0
0FB4 E6        1978       mov A, @R0
0FB5 1205E1    1979       lcall ?WriteData
0FB8 08        1980       inc R0
0FB9           1981       ; Colon
0FB9 743A      1982       mov A, #':'
0FBB 1205E1    1983       lcall ?WriteData
0FBE           1984       ; SS
0FBE E6        1985       mov A, @R0
0FBF 1205E1    1986       lcall ?WriteData
0FC2 08        1987       inc R0
0FC3 E6        1988       mov A, @R0
0FC4 1205E1    1989       lcall ?WriteData
0FC7           1990       ; Unit
0FC7           1991       ;got rid of the "s"
0FC7           1992       ;mov A, #'s'
0FC7           1993       ;lcall ?WriteData
0FC7 8000      1994       sjmp Restore_Cursor
0FC9           1995   
0FC9           1996   ; --- Restore Cursor Position ---
0FC9           1997   Restore_Cursor:
0FC9 E569      1998       mov A, Current_State
0FCB B40202    1999       cjne A, #2, RC_Check_State_4  
0FCE 800D      2000       sjmp Adjust_Cursor_Time
0FD0           2001   RC_Check_State_4:             
0FD0 B40402    2002       cjne A, #4, Normal_Cursor
0FD3 8008      2003       sjmp Adjust_Cursor_Time
0FD5           2004   
0FD5           2005   Normal_Cursor:
0FD5 E572      2006       mov A, Cursor_Idx
0FD7 24C0      2007       add A, #0xC0
0FD9 1205E6    2008       lcall ?WriteCommand
0FDC 22        2009       ret
0FDD           2010   
0FDD           2011   Adjust_Cursor_Time:
0FDD           2012       ; Skip the colon index (2)
0FDD E572      2013       mov A, Cursor_Idx
0FDF B40201    2014       cjne A, #2, No_Skip
0FE2 04        2015       inc A 
0FE3           2016   No_Skip:
0FE3           2017       ; Add 1 if past the colon
0FE3 C3        2018       clr C
0FE4 9402      2019       subb A, #2
0FE6 4005      2020       jc No_Add
0FE8 E572      2021       mov A, Cursor_Idx
0FEA 04        2022       inc A
0FEB 8002      2023       sjmp Final_Cursor_Set
0FED           2024   No_Add:
0FED E572      2025       mov A, Cursor_Idx
0FEF           2026   Final_Cursor_Set:
0FEF 24C0      2027       add A, #0xC0
0FF1 1205E6    2028       lcall ?WriteCommand
0FF4 22        2029       ret
0FF5           2030   
0FF5           2031   Print_String_RAM:
0FF5 E6        2032       mov A, @R0
0FF6 6006      2033       jz Print_String_Done
0FF8 1205E1    2034       lcall ?WriteData
0FFB 08        2035       inc R0
0FFC 80F7      2036       sjmp Print_String_RAM
0FFE           2037   Print_String_Done:
0FFE 22        2038       ret
0FFF           2039   
0FFF           2040   ; Blocking wrapper for LCD clear (keeps old behavior just for this)
0FFF           2041   Wait_25ms_BLOCKING:
0FFF 120EA7    2042       lcall Wait_25ms
1002 50FB      2043       jnc Wait_25ms_BLOCKING ; Keep jumping back until Done (C=1)
1004 22        2044       ret
1005           2045   
1005           2046   Clear_Screen_Func:
1005 7401      2047       mov A, #0x01
1007 1205E6    2048       lcall ?WriteCommand
100A           2049       
100A           2050       ; --- FIX: HARDWARE DELAY LOOP (MAX STRENGTH) ---
100A           2051       ; The LCD needs ~2ms to clear. 
100A           2052       ; We use R0=255 to guarantee ~5ms+ delay.
100A           2053       ; This ensures the LCD is 100% ready before we send "Ramp to Soak".
100A 78FF      2054       mov R0, #255
100C           2055   Clear_Delay_Loop_Outer:
100C 79FF      2056       mov R1, #255
100E           2057   Clear_Delay_Loop_Inner:
100E D9FE      2058       djnz R1, Clear_Delay_Loop_Inner
1010 D8FA      2059       djnz R0, Clear_Delay_Loop_Outer
1012           2060       ; -----------------------------------------------
1012           2061   
1012 740C      2062       mov A, #0x0C  ; Display ON, Cursor OFF
1014 1205E6    2063       lcall ?WriteCommand
1017 22        2064       ret
1018           2065   
1018           2066   Get_Current_Buffer_Addr:
1018 E569      2067       mov A, Current_State
101A B40103    2068       cjne A, #1, Get_Buf_2
101D 7880      2069       mov R0, #Buf_Soak_Temp
101F 22        2070       ret
1020           2071   Get_Buf_2:
1020 B40203    2072       cjne A, #2, Get_Buf_3
1023 7884      2073       mov R0, #Buf_Soak_Time
1025 22        2074       ret
1026           2075   Get_Buf_3:
1026 B40303    2076       cjne A, #3, Get_Buf_4
1029 7889      2077       mov R0, #Buf_Refl_Temp
102B 22        2078       ret
102C           2079   Get_Buf_4:
102C 788D      2080       mov R0, #Buf_Refl_Time
102E 22        2081       ret
102F           2082       
102F           2083   ; --- Helper to prevent "Machine Gun" button presses ---
102F           2084   Wait_For_P1_0_Release:
102F 3090FD    2085       jnb P1.0, $    ; Wait here while the button is still pressed (0)
1032 22        2086       ret
1033           2087   
1033           2088   ; --- Full reset helper for P3.7 (active-low) ---
1033           2089   Wait_For_P3_7_Release:
1033 30B7FD    2090       jnb P3_7, $    ; Wait here while the button is still pressed (0)
1036 22        2091       ret
1037           2092   
1037           2093   Full_Reset:
1037 121033    2094       lcall Wait_For_P3_7_Release
103A 020BC6    2095       ljmp main
103D           2096   
103D           2097   ; ================================================================
103D           2098   ; MODULE: THERMOCOUPLE ADC DRIVER (WITH NOISE SUPPRESSION & JUMP FIX)
103D           2099   ; ================================================================
103D           2100   Read_Thermocouple:
103D           2101       ; 1. Check Non-Blocking Timer
103D 120EA7    2102       lcall Wait_25ms
1040           2103       
1040           2104       ; [FIX] TRAMPOLINE JUMP
1040           2105       ; "jnc" cannot jump to the end because the code is too long.
1040           2106       ; We invert logic: If Carry=1 (Time is up), Jump NEARBY.
1040 4001      2107       jc Proceed_Reading
1042 22        2108       ret  ; If Carry=0, Return immediately.
1043           2109   
1043           2110   Proceed_Reading:
1043           2111       ; --- 25ms Passed! Time to Read ---
1043           2112   
1043           2113       ; [FIX] SILENCE THE BUZZER (Noise Suppression)
1043           2114       ; Save buzzer state and force it OFF during the sensitive read
1043 E588      2115       mov A, TCON      
1045 5410      2116       anl A, #0x10     ; Isolate TR0 bit
1047 C0E0      2117       push acc         ; Save it
1049 C28C      2118       clr TR0          ; STOP NOISE
104B           2119   
104B           2120       ; 2. Initialize / Trigger ADC
104B 75A180    2121       mov ADC_C, #0x80    ; Reset
104E 00        2122       nop
104F 00        2123       nop
1050 75A101    2124       mov ADC_C, #0x01    ; Start Channel 0
1053           2125       
1053           2126       ; 3. Settle Delay
1053 7DFA      2127       mov R5, #250
1055           2128   ADC_Settle_Loop:
1055 00        2129       nop
1056 00        2130       nop
1057 DDFC      2131       djnz R5, ADC_Settle_Loop
1059           2132       
1059           2133       ; 4. Read Raw Data
1059 85A232    2134       mov x+0, ADC_L
105C 85A333    2135       mov x+1, ADC_H
105F 753400    2136       mov x+2, #0
1062 753500    2137       mov x+3, #0
1065           2138       
1065           2139       ; 5. Mask Data
1065 E533      2140       mov a, x+1
1067 540F      2141       anl a, #0x0F
1069 F533      2142       mov x+1, a
106B           2143       
106B           2144       ; [FIX] RESTORE THE BUZZER
106B D0E0      2145       pop acc          ; Get previous state
106D 6002      2146       jz Skip_Restore  ; If it was OFF, keep it OFF
106F D28C      2147       setb TR0         ; If it was ON, turn it back ON
1071           2148   Skip_Restore:
1071           2149   
1071           2150       ; 6. Math Conversions
1071 753616    2151            mov y+0, #low (4118 % 0x10000) 
1074 753710    2151            mov y+1, #high(4118 % 0x10000) 
1077 753800    2151            mov y+2, #low (4118 / 0x10000) 
107A 753900    2151            mov y+3, #high(4118 / 0x10000) 
107D 12018C    2152       lcall mul32       
1080           2153   
1080 75A104    2154       mov ADC_C, #0x04    ; Read LM4040
1083 85A236    2155       mov y+0, ADC_L      
1086 85A337    2156       mov y+1, ADC_H      
1089 753800    2157       mov y+2, #0
108C 753900    2158       mov y+3, #0
108F 75A100    2159       mov ADC_C, #0x00    ; Reset
1092           2160       
1092 120280    2161       lcall div32         
1095 753664    2162            mov y+0, #low (100 % 0x10000) 
1098 753700    2162            mov y+1, #high(100 % 0x10000) 
109B 753800    2162            mov y+2, #low (100 / 0x10000) 
109E 753900    2162            mov y+3, #high(100 / 0x10000) 
10A1 12018C    2163       lcall mul32
10A4 75362B    2164            mov y+0, #low (1323 % 0x10000) 
10A7 753705    2164            mov y+1, #high(1323 % 0x10000) 
10AA 753800    2164            mov y+2, #low (1323 / 0x10000) 
10AD 753900    2164            mov y+3, #high(1323 / 0x10000)         
10B0 120280    2165       lcall div32    
10B3 753614    2166            mov y+0, #low (COLD_JUNCTION_TEMP % 0x10000) 
10B6 753700    2166            mov y+1, #high(COLD_JUNCTION_TEMP % 0x10000) 
10B9 753800    2166            mov y+2, #low (COLD_JUNCTION_TEMP / 0x10000) 
10BC 753900    2166            mov y+3, #high(COLD_JUNCTION_TEMP / 0x10000) 
10BF 1200D3    2167       lcall add32     
10C2           2168       
10C2           2169       ; 8. Store Result
10C2 85323F    2170       mov current_temp+0, x+0
10C5 853340    2171       mov current_temp+1, x+1
10C8 853441    2172       mov current_temp+2, x+2
10CB 853542    2173       mov current_temp+3, x+3
10CE           2174   
10CE 22        2175       ret
10CF           2176       
10CF           2177   ; ================================================================
10CF           2178   ; MODULE: POWER CONTROLLER (The Brain)
10CF           2179   ; ================================================================
10CF           2180   Power_Control:
10CF           2181       ; Default: Turn Heat OFF (Safety)
10CF 755C00    2182       mov power_output+0, #0
10D2 755D00    2183       mov power_output+1, #0
10D5 755E00    2184       mov power_output+2, #0
10D8 755F00    2185       mov power_output+3, #0
10DB           2186   
10DB E568      2187       mov a, Control_FSM_state
10DD           2188   
10DD           2189       ; --- State 2: RAMP TO SOAK ---
10DD B40202    2190       cjne a, #2, PC_Check_Soak
10E0           2191       ; Mode: Full Speed Ahead
10E0 8016      2192       sjmp Set_Max_Power
10E2           2193   
10E2           2194   PC_Check_Soak:
10E2           2195       ; --- State 3: SOAK PHASE ---
10E2 B40305    2196       cjne a, #3, PC_Check_Ramp_Reflow
10E5           2197       ; Mode: Maintenance (Low Power)
10E5           2198       ; If Temp > Target, OFF. If Temp < Target, 20% Power.
10E5 20030F    2199       jb soak_temp_reached, PC_Done ; If hot enough, stay OFF
10E8 801B      2200       sjmp Set_20_Percent_Power     ; If cold, use 20%
10EA           2201   
10EA           2202   PC_Check_Ramp_Reflow:
10EA           2203       ; --- State 4: RAMP TO REFLOW ---
10EA B40402    2204       cjne a, #4, PC_Check_Reflow
10ED           2205       ; Mode: Full Speed Ahead
10ED 8009      2206       sjmp Set_Max_Power
10EF           2207   
10EF           2208   PC_Check_Reflow:
10EF           2209       ; --- State 5: REFLOW PHASE ---
10EF B40505    2210       cjne a, #5, PC_Done
10F2           2211       ; Mode: Maintenance (Low Power)
10F2 200402    2212       jb reflow_temp_reached, PC_Done
10F5 800E      2213       sjmp Set_20_Percent_Power
10F7           2214   
10F7           2215   PC_Done:
10F7 22        2216       ret
10F8           2217   
10F8           2218   ; --- Power Helpers ---
10F8           2219   
10F8           2220   Set_Max_Power:
10F8           2221       ; Load 1500 (0x05DC) = 100% Duty Cycle
10F8 755CDC    2222       mov power_output+0, #0xDC
10FB 755D05    2223       mov power_output+1, #0x05
10FE 755E00    2224       mov power_output+2, #0
1101 755F00    2225       mov power_output+3, #0
1104 22        2226       ret
1105           2227   
1105           2228   Set_20_Percent_Power:
1105           2229       ; Load 300 (0x012C) = 20% Duty Cycle
1105 755C2C    2230       mov power_output+0, #0x2C
1108 755D01    2231       mov power_output+1, #0x01
110B 755E00    2232       mov power_output+2, #0
110E 755F00    2233       mov power_output+3, #0
1111 22        2234       ret
1112           2235   
1112           2236   
1112           2237   ;--------------------------------------------------------------
1112           2238   ; set servo angle according to the state
1112           2239   ; call servo control function every 1ms
1112           2240   ;--------------------------------------------------------------
1112           2241   call_servo_control:
1112           2242            ; check current state and change servo angle
1112 E568      2243            mov a, Control_FSM_state
1114           2244            
1114           2245            ; handle state 0
1114 B40004    2246            cjne a, #0, servo_state1
1117 C21F      2247            clr servo_angle_zero ; close door at state 0
1119 802C      2248            sjmp check_servo_flag
111B           2249   
111B           2250            ; handle state 1
111B           2251            servo_state1:
111B B40104    2252            cjne a, #1, servo_state2
111E D21F      2253            setb servo_angle_zero ; open door at state 1
1120 8025      2254            sjmp check_servo_flag
1122           2255   
1122           2256            ; handle state 2
1122           2257            servo_state2:
1122 B40204    2258            cjne a, #2, servo_state3
1125 C21F      2259            clr servo_angle_zero ; close door at state 2
1127 801E      2260            sjmp check_servo_flag
1129           2261   
1129           2262            ; handle state 3
1129           2263            servo_state3:
1129 B40304    2264            cjne a, #3, servo_state4
112C C21F      2265            clr servo_angle_zero ; close door at state 3
112E 8017      2266            sjmp check_servo_flag
1130           2267   
1130           2268            ; handle state 4
1130           2269            servo_state4:
1130 B40404    2270            cjne a, #4, servo_state5
1133 C21F      2271            clr servo_angle_zero ; close door at state 4
1135 8010      2272            sjmp check_servo_flag
1137           2273   
1137           2274            ; handle state 5
1137           2275            servo_state5:
1137 B40504    2276            cjne a, #5, servo_state6
113A C21F      2277            clr servo_angle_zero ; close door at state 5
113C 8009      2278            sjmp check_servo_flag
113E           2279   
113E           2280            ; handle state 6
113E           2281            servo_state6:
113E B40604    2282            cjne a, #6, servo_state7
1141 C21F      2283            clr servo_angle_zero ; close door at state 6
1143 8002      2284            sjmp check_servo_flag
1145           2285   
1145           2286            ; handle state 7
1145           2287            servo_state7:
1145 D21F      2288            setb servo_angle_zero ; open door at state 7
1147           2289   
1147           2290   check_servo_flag:
1147           2291            ; check 1 ms flag
1147 101E01    2292            jbc one_millisecond_flag_servo, run_servo_control
114A 22        2293            ret
114B           2294   
114B           2295   run_servo_control:
114B 12114F    2296            lcall servo_control
114E 22        2297            ret
114F           2298   
114F           2299   
114F           2300   ;---------------------------------------------------------------
114F           2301   ; servo control
114F           2302   ; generate a 20 ms period pwm signal to control the servo motor
114F           2303   ; able to make the servo motor stay at 0 degree and 180 degree
114F           2304   ;---------------------------------------------------------------
114F           2305   servo_control:
114F D2ED      2306       setb LEDRA.5
1151 C0E0      2307            push acc
1153 C0D0      2308            push psw
1155 E577      2309            mov a, servo_pwm_counter ; move servo counter to accumulator
1157 04        2310            inc A ; a += 1
1158 B41402    2311            cjne a, #SERVO_PERIOD, servo_pwm_angle_compare ; jump if wrapup not needed
115B 7400      2312            mov a, #0
115D           2313   
115D           2314   servo_pwm_angle_compare: ; read target angle
115D F577      2315            mov servo_pwm_counter, A
115F 201F09    2316            jb servo_angle_zero, set_zero_degree ; set servo motor to 0 degree
1162           2317            ; set servo motor to 180 degrees
1162 E577      2318            mov a, servo_pwm_counter
1164 C3        2319            clr c
1165 9402      2320            subb a, #SERVO_180
1167 400B      2321            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 180 degrees duty cycle
1169 800D      2322            sjmp servo_pwm_set_low ; set low if greater
116B           2323   
116B           2324   set_zero_degree:
116B           2325            ; set servo motor to 0 degree
116B E577      2326            mov a, servo_pwm_counter
116D C3        2327            clr c
116E 9401      2328            subb a, #SERVO_0
1170 4002      2329            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 0 degrees duty cycle
1172 8004      2330            sjmp servo_pwm_set_low ; set low if greater
1174           2331   
1174           2332   servo_pwm_set_high:
1174           2333            ; set pwm pin high
1174 D2B6      2334            setb SERVO_OUT
1176 8002      2335            sjmp servo_control_done
1178           2336   
1178           2337   servo_pwm_set_low:
1178           2338            ; set pwm pin low
1178 C2B6      2339            clr SERVO_OUT
117A           2340   
117A           2341   servo_control_done:
117A D0D0      2342            pop psw
117C D0E0      2343            pop acc
117E 22        2344            ret
117F           2345   
117F           2346   ;-------------------------------------------------------------------------------
117F           2347   ; power_control
117F           2348   ;-------------------------------------------------------------------------------
117F           2349   ; Determine the power output based on current state and current temperature 
117F           2350   ; input parameter: Control_FSM_state
117F           2351   ;-------------------------------------------------------------------------------
117F           2352   
117F           2353   proportional_power_control:
117F E568      2354            mov a, Control_FSM_state
1181           2355   
1181           2356   state0_power_control:
1181           2357            ; idle
1181           2358            ; 0% power
1181 B4000F    2359            cjne a, #0, state1_power_control
1184 755C00    2360            mov power_output, #low(NO_POWER)
1187 755D00    2361            mov power_output+1, #low(NO_POWER)
118A 755E00    2362            mov power_output+2, #0
118D 755F00    2363            mov power_output+3, #0
1190 02132B    2364            ljmp power_control_done
1193           2365   
1193           2366   state1_power_control:
1193           2367            ; idle
1193           2368            ; 0% power
1193 B4010F    2369            cjne a, #1, state2_power_control
1196 755C00    2370            mov power_output, #low(NO_POWER)
1199 755D00    2371            mov power_output+1, #low(NO_POWER)
119C 755E00    2372            mov power_output+2, #0
119F 755F00    2373            mov power_output+3, #0
11A2 02132B    2374            ljmp power_control_done
11A5           2375            
11A5           2376   state2_power_control:
11A5           2377            ; ramp to soak, ramp to ~150C
11A5           2378            ; 100% power
11A5 B4020F    2379            cjne a, #2, state3_power_control
11A8 755CDC    2380            mov power_output, #low(MAX_POWER)
11AB 755D05    2381            mov power_output+1, #high(MAX_POWER)
11AE 755E00    2382            mov power_output+2, #0
11B1 755F00    2383            mov power_output+3, #0
11B4 02132B    2384            ljmp power_control_done
11B7           2385   
11B7           2386   state3_power_control:
11B7           2387            ; soak period, hold at 150C
11B7           2388            ; 20% base power + proportional calculated power
11B7 B40302    2389            cjne a, #3, jump_state4_power_control
11BA 8003      2390            sjmp state3_power_control_calculation
11BC           2391   
11BC           2392   jump_state4_power_control:
11BC 0212E9    2393            ljmp state4_power_control
11BF           2394   
11BF           2395   state3_power_control_calculation:
11BF           2396            ; move soak_temp to x
11BF 854332    2397            mov x, soak_temp
11C2 854433    2398            mov x+1, soak_temp+1
11C5 854534    2399            mov x+2, soak_temp+2
11C8 854635    2400            mov x+3, soak_temp+3
11CB           2401            ; move current_temp to y
11CB 853F36    2402            mov y, current_temp
11CE 854037    2403            mov y+1, current_temp+1
11D1 854138    2404            mov y+2, current_temp+2
11D4 854239    2405            mov y+3, current_temp+3
11D7           2406   
11D7           2407            ; compare between soak_temp and current_temp
11D7 C200      2408            clr mf
11D9 120178    2409            lcall x_gteq_y
11DC 10002B    2410            jbc mf, st_sub_ct
11DF           2411            ; current_temp - soak_temp if st < ct
11DF C220      2412            clr soak_temp_greater
11E1           2413            ; move current_temp to y
11E1 854336    2414            mov y, soak_temp
11E4 854437    2415            mov y+1, soak_temp+1
11E7 854538    2416            mov y+2, soak_temp+2
11EA 854639    2417            mov y+3, soak_temp+3
11ED           2418            ; move current_temp to x
11ED 853F32    2419            mov x, current_temp
11F0 854033    2420            mov x+1, current_temp+1
11F3 854134    2421            mov x+2, current_temp+2
11F6 854235    2422            mov x+3, current_temp+3
11F9 1200F6    2423            lcall sub32
11FC 85326A    2424            mov soak_temp_diff, x
11FF 85336B    2425            mov soak_temp_diff+1, x+1
1202 85346C    2426            mov soak_temp_diff+2, x+2
1205 85356D    2427            mov soak_temp_diff+3, x+3
1208 8011      2428            sjmp proportional_input_soak
120A           2429   
120A           2430   st_sub_ct:
120A           2431            ; soak_temp - current_temp
120A D220      2432            setb soak_temp_greater
120C 1200F6    2433            lcall sub32
120F 85326A    2434            mov soak_temp_diff, x
1212 85336B    2435            mov soak_temp_diff+1, x+1
1215 85346C    2436            mov soak_temp_diff+2, x+2
1218 85356D    2437            mov soak_temp_diff+3, x+3
121B           2438   
121B           2439   proportional_input_soak:
121B           2440            ; proportaional block calculation       
121B           2441            ; move soak_temp_diff to x
121B 856A32    2442            mov x, soak_temp_diff
121E 856B33    2443            mov x+1, soak_temp_diff+1
1221 856C34    2444            mov x+2, soak_temp_diff+2
1224 856D35    2445            mov x+3, soak_temp_diff+3
1227           2446            ; move proportional gain to y
1227 753605    2447            mov y+0, #low (KP % 0x10000) 
122A 753700    2447            mov y+1, #high(KP % 0x10000) 
122D 753800    2447            mov y+2, #low (KP / 0x10000) 
1230 753900    2447            mov y+3, #high(KP / 0x10000) 
1233 12018C    2448            lcall mul32 ; proportional_output = proportional_gain * difference
1236           2449            
1236 85326E    2450            mov proportional_gain_var, x
1239 85336F    2451            mov proportional_gain_var+1, x+1
123C 853470    2452            mov proportional_gain_var+2, x+2
123F 853571    2453            mov proportional_gain_var+3, x+3
1242           2454   
1242           2455            ; base_power + soak_power when soak_temp > current_temp
1242 302029    2456            jnb soak_temp_greater, sub_proportional_soak
1245 856E32    2457            mov x, proportional_gain_var
1248 856F33    2458            mov x+1, proportional_gain_var+1
124B 857034    2459            mov x+2, proportional_gain_var+2
124E 857135    2460            mov x+3, proportional_gain_var+3
1251 75362C    2461            mov y+0, #low (BASE_POWER % 0x10000) 
1254 753701    2461            mov y+1, #high(BASE_POWER % 0x10000) 
1257 753800    2461            mov y+2, #low (BASE_POWER / 0x10000) 
125A 753900    2461            mov y+3, #high(BASE_POWER / 0x10000) 
125D 1200D3    2462            lcall add32
1260           2463            ; x now holds the power output before the saturator
1260 85326E    2464            mov proportional_gain_var, x
1263 85336F    2465            mov proportional_gain_var+1, x+1
1266 853470    2466            mov proportional_gain_var+2, x+2
1269 853571    2467            mov proportional_gain_var+3, x+3
126C 803D      2468            sjmp saturator_soak
126E           2469   
126E           2470   sub_proportional_soak:
126E           2471            ; base_power - soak_power when soak_temp <= current_temp
126E 75322C    2472            mov x+0, #low (BASE_POWER % 0x10000) 
1271 753301    2472            mov x+1, #high(BASE_POWER % 0x10000) 
1274 753400    2472            mov x+2, #low (BASE_POWER / 0x10000) 
1277 753500    2472            mov x+3, #high(BASE_POWER / 0x10000) 
127A 856E36    2473            mov y, proportional_gain_var
127D 856F37    2474            mov y+1, proportional_gain_var+1
1280 857038    2475            mov y+2, proportional_gain_var+2
1283 857139    2476            mov y+3, proportional_gain_var+3
1286           2477   
1286           2478            ; compare whether base_power < proportional_gain_var
1286 C200      2479            clr mf
1288 12011A    2480            lcall x_lt_y ; set mf to 1 if base_power < proportional_gain_var, clamp output to 0
128B 30000E    2481            jnb mf, bp_gteq_pgv
128E 756E00    2482            mov proportional_gain_var, #low(NO_POWER)
1291 756F00    2483            mov proportional_gain_var+1, #high(NO_POWER)
1294 757000    2484            mov proportional_gain_var+2, #0
1297 757100    2485            mov proportional_gain_var+3, #0
129A 800F      2486            sjmp saturator_soak
129C           2487   
129C           2488   bp_gteq_pgv:
129C           2489            ; calculate subtracted gain
129C 1200F6    2490            lcall sub32
129F           2491            ; x now holds the power output before the saturator
129F 85326E    2492            mov proportional_gain_var, x
12A2 85336F    2493            mov proportional_gain_var+1, x+1
12A5 853470    2494            mov proportional_gain_var+2, x+2
12A8 853571    2495            mov proportional_gain_var+3, x+3
12AB           2496   
12AB           2497   saturator_soak:
12AB           2498            ; proportional_gain_var now holds the power output before the saturator
12AB           2499            ; saturate power output to max power
12AB 856E32    2500            mov x, proportional_gain_var
12AE 856F33    2501            mov x+1, proportional_gain_var+1
12B1 857034    2502            mov x+2, proportional_gain_var+2
12B4 857135    2503            mov x+3, proportional_gain_var+3
12B7           2504   
12B7 7536DC    2505            mov y+0, #low (MAX_POWER % 0x10000) 
12BA 753705    2505            mov y+1, #high(MAX_POWER % 0x10000) 
12BD 753800    2505            mov y+2, #low (MAX_POWER / 0x10000) 
12C0 753900    2505            mov y+3, #high(MAX_POWER / 0x10000) 
12C3           2506   
12C3 C200      2507            clr mf
12C5 120136    2508            lcall x_gt_y ; set mf to 1 if calculated power output greater than max power
12C8 20000F    2509            jb mf, saturated_soak
12CB           2510            ; set power_output to calculated power if not saturated
12CB 856E5C    2511            mov power_output, proportional_gain_var
12CE 856F5D    2512            mov power_output+1, proportional_gain_var+1
12D1 85705E    2513            mov power_output+2, proportional_gain_var+2
12D4 85715F    2514            mov power_output+3, proportional_gain_var+3
12D7 02132B    2515            ljmp power_control_done
12DA           2516   
12DA           2517   saturated_soak:
12DA 755CDC    2518            mov power_output, #low(MAX_POWER)
12DD 755D05    2519            mov power_output+1, #high(MAX_POWER)
12E0 755E00    2520            mov power_output+2, #0
12E3 755F00    2521            mov power_output+3, #0
12E6 02132B    2522            ljmp power_control_done
12E9           2523   
12E9           2524   
12E9           2525   state4_power_control:
12E9           2526            ; ramp to reflow, max power
12E9 B4040F    2527            cjne a, #4, state5_power_control
12EC 755CDC    2528            mov power_output, #low(MAX_POWER)
12EF 755D05    2529            mov power_output+1, #high(MAX_POWER)
12F2 755E00    2530            mov power_output+2, #0
12F5 755F00    2531            mov power_output+3, #0
12F8 02132B    2532            ljmp power_control_done
12FB           2533   
12FB           2534   state5_power_control:
12FB           2535            ; reflow 20% base power
12FB B4050F    2536            cjne a, #5, state6_power_control
12FE 755C2C    2537            mov power_output, #low(BASE_POWER)  
1301 755D01    2538            mov power_output+1, #high(BASE_POWER)
1304 755E00    2539            mov power_output+2, #0
1307 755F00    2540            mov power_output+3, #0
130A 02132B    2541            ljmp power_control_done
130D           2542   
130D           2543   state6_power_control:
130D           2544            ; cooling 0% power
130D B4060F    2545            cjne a, #6, state_7_power_control
1310 755C00    2546            mov power_output, #low(NO_POWER)
1313 755D00    2547            mov power_output+1, #high(NO_POWER)
1316 755E00    2548            mov power_output+2, #0
1319 755F00    2549            mov power_output+3, #0
131C 02132B    2550            ljmp power_control_done
131F           2551   
131F           2552   state_7_power_control:
131F           2553            ; idle 0% power
131F 755C00    2554            mov power_output, #low(NO_POWER)
1322 755D00    2555            mov power_output+1, #high(NO_POWER)
1325 755E00    2556            mov power_output+2, #0
1328 755F00    2557            mov power_output+3, #0
132B           2558   
132B           2559   power_control_done:
132B 22        2560            ret
132C           2561   
132C           2562   ; ================================================================
132C           2563   ; SERIAL COMMUNICATION BLOCK (Paste before END)
132C           2564   ; ================================================================
132C           2565   
132C           2566   ; ----------------------------------------------------------------
132C           2567   ; ----------------------------------------------------------------
132C           2568   ; ISR: Catch incoming characters from Python
132C           2569   ; ----------------------------------------------------------------
132C           2570   Serial_ISR:
132C C0E0      2571       push acc
132E C0D0      2572       push psw
1330 C000      2573       push AR0
1332           2574       
1332           2575       ; --- CRITICAL FIX: Check & Clear Transmit Flag ---
1332 309904    2576       jnb TI, Check_RI      ; If TI is 0, check RX
1335 C299      2577       clr TI                ; CLEAR TI! (Stops the infinite loop)
1337 8031      2578       sjmp Serial_Done_Safe ; Exit immediately (We don't need to read anything for TX)
1339           2579   
1339           2580   Check_RI:
1339 30982E    2581       jnb RI, Serial_Done_Safe ; If RX is also 0, just exit
133C C298      2582       clr RI                   ; Clear RX flag
133E           2583   
133E E599      2584       mov a, SBUF              ; Read character
1340           2585       
1340           2586       ; Check for Newline (End of Command)
1340 B40A02    2587       cjne a, #10, Check_CR   
1343 8017      2588       sjmp End_Of_Command
1345           2589   Check_CR:
1345 B40D02    2590       cjne a, #13, Store_Char 
1348 8012      2591       sjmp End_Of_Command
134A           2592   
134A           2593   Store_Char:
134A           2594       ; Safety limit 7 chars
134A E580      2595       mov a, rx_index
134C B40702    2596       cjne a, #7, Save_It
134F 8019      2597       sjmp Serial_Done_Safe
1351           2598   Save_It:
1351 7878      2599       mov R0, #rx_buffer
1353 28        2600       add a, R0
1354 F8        2601       mov R0, a
1355 E599      2602       mov a, SBUF
1357 F6        2603       mov @R0, a
1358 0580      2604       inc rx_index
135A 800E      2605       sjmp Serial_Done_Safe
135C           2606   
135C           2607   End_Of_Command:
135C           2608       ; Null-terminate string
135C E580      2609       mov a, rx_index
135E 7878      2610       mov R0, #rx_buffer
1360 28        2611       add a, R0
1361 F8        2612       mov R0, a
1362 7600      2613       mov @R0, #0
1364           2614       
1364 758000    2615       mov rx_index, #0        ; Reset
1367 758101    2616       mov cmd_received, #1    ; Flag Main Loop
136A           2617   
136A           2618   Serial_Done_Safe:           ; <--- Renamed label to avoid "Redefine Symbol" errors
136A D000      2619       pop AR0
136C D0D0      2620       pop psw
136E D0E0      2621       pop acc
1370 32        2622       reti
1371           2623   
1371           2624   ; ----------------------------------------------------------------
1371           2625   ; PROCESSOR: Apply the command to variables
1371           2626   ; ----------------------------------------------------------------
1371           2627   Process_Serial_Command:
1371           2628       ; --- CHECK FLAG (BYTE SAFE) ---
1371 E581      2629       mov a, cmd_received
1373 6063      2630       jz Serial_Ret         ; If 0, exit
1375           2631       ; ------------------------------
1375           2632   
1375 758100    2633       mov cmd_received, #0  ; Clear flag
1378           2634   
1378 7878      2635       mov R0, #rx_buffer
137A E6        2636       mov a, @R0            ; Load Command Letter
137B           2637       
137B           2638       ; S = Soak Temp
137B B4530C    2639       cjne a, #'S', Check_K
137E 08        2640       inc R0 ; Skip S
137F 08        2641       inc R0 ; Skip :
1380 1213D9    2642       lcall Parse_Serial_Num
1383 8F43      2643       mov soak_temp+0, R7
1385 754400    2644       mov soak_temp+1, #0
1388 804E      2645       sjmp Serial_Ret
138A           2646   
138A           2647   Check_K: ; K = Soak Time
138A B44B0C    2648       cjne a, #'K', Check_R
138D 08        2649       inc R0 ; Skip K
138E 08        2650       inc R0 ; Skip :
138F 1213D9    2651       lcall Parse_Serial_Num
1392 8F54      2652       mov soak_time+0, R7
1394 755500    2653       mov soak_time+1, #0
1397 803F      2654       sjmp Serial_Ret
1399           2655   
1399           2656   Check_R: ; R = Reflow Temp
1399 B4520C    2657       cjne a, #'R', Check_L
139C 08        2658       inc R0 ; Skip R
139D 08        2659       inc R0 ; Skip :
139E 1213D9    2660       lcall Parse_Serial_Num
13A1 8F47      2661       mov reflow_temp+0, R7
13A3 754800    2662       mov reflow_temp+1, #0
13A6 8030      2663       sjmp Serial_Ret
13A8           2664   
13A8           2665   Check_L: ; L = Reflow Time
13A8 B44C0C    2666       cjne a, #'L', Check_Run
13AB 08        2667       inc R0 ; Skip L
13AC 08        2668       inc R0 ; Skip :
13AD 1213D9    2669       lcall Parse_Serial_Num
13B0 8F58      2670       mov reflow_time+0, R7
13B2 755900    2671       mov reflow_time+1, #0
13B5 8021      2672       sjmp Serial_Ret
13B7           2673   
13B7           2674   Check_Run: ; RUN:1 or RUN:0
13B7           2675       ; We check the character at index 4 (R, U, N, :, [1])
13B7 7878      2676       mov R0, #rx_buffer
13B9 08        2677       inc R0 ; R
13BA 08        2678       inc R0 ; U
13BB 08        2679       inc R0 ; N
13BC 08        2680       inc R0 ; :
13BD E6        2681       mov a, @R0 ; '1' or '0'
13BE           2682       
13BE B4310F    2683       cjne a, #'1', Stop_Oven
13C1           2684       
13C1           2685       ; START
13C1 756802    2686       mov Control_FSM_state, #2
13C4 753000    2687       mov current_time_sec, #0
13C7 753100    2688       mov current_time_minute, #0
13CA D20F      2689       setb tc_startup_window
13CC C20E      2690       clr tc_missing_abort
13CE 8008      2691       sjmp Serial_Ret
13D0           2692   
13D0           2693   Stop_Oven:
13D0 756800    2694       mov Control_FSM_state, #0
13D3 756900    2695       mov Current_State, #0
13D6 D20C      2696       setb state_change_signal
13D8           2697   
13D8           2698   Serial_Ret:
13D8 22        2699       ret
13D9           2700   
13D9           2701   ; ----------------------------------------------------------------
13D9           2702   ; HELPER: ASCII to Integer
13D9           2703   ; ----------------------------------------------------------------
13D9           2704   Parse_Serial_Num:
13D9 7F00      2705       mov R7, #0
13DB           2706   Parse_Next:
13DB E6        2707       mov A, @R0
13DC 6018      2708       jz Parse_Done           ; Null terminator = done
13DE B40A02    2709       cjne A, #10, Chk_13
13E1 8013      2710       sjmp Parse_Done
13E3           2711   Chk_13:
13E3 B40D02    2712       cjne A, #13, Do_Conv
13E6 800E      2713       sjmp Parse_Done
13E8           2714   
13E8           2715   Do_Conv:
13E8 C3        2716       clr C
13E9 9430      2717       subb A, #0x30           ; ASCII to Int
13EB FD        2718       mov R5, A
13EC           2719       
13EC EF        2720       mov A, R7
13ED 75F00A    2721       mov B, #10
13F0 A4        2722       mul AB
13F1 2D        2723       add A, R5
13F2 FF        2724       mov R7, A
13F3           2725       
13F3 08        2726       inc R0
13F4 80E5      2727       sjmp Parse_Next
13F6           2728   Parse_Done:
13F6 22        2729       ret
13F7           2730   
13F7           2731   END
