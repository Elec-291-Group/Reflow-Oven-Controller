0000              1   ; Project 1
0000              2   ; CV-8052 microcontroller in DE10-Lite board
0000              3   ;-------------------------------------------------------------------------------
0000              4   ; Reset vector
0000              5   org 0x0000
0000 02136D       6       ljmp main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9       reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 02046E      12       ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15       reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18       reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 32          21       reti
0024             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
002B 02052E      24       ljmp Timer2_ISR
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 32   $LIST
0320             34   ; ----------------------------------------------------------------------------------------------;
0320             35   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             36   dseg at 0x30
0030             37   ; time buffer 
0030             38   current_time_sec:     ds 1
0031             39   current_time_minute:  ds 1
0032             40   soak_time_sec:        ds 1
0033             41   soak_time_minute:     ds 1
0034             42   reflow_time_sec:      ds 1
0035             43   reflow_time_minute:   ds 1
0036             44   soak_end_time_sec:      ds 1
0037             45   soak_end_time_minute:   ds 1
0038             46   reflow_end_time_sec:    ds 1
0039             47   reflow_end_time_minute: ds 1
003A             48   
003A             49   ; math32 buffer variables
003A             50   x:      ds  4
003E             51   y:      ds  4
0042             52   bcd:    ds  5
0047             53   
0047             54   current_temp: ds 4 ;
004B             55   soak_temp:    ds 4 ;
004F             56   reflow_temp:  ds 4 ;
0053             57   
0053             58   wait25_btn_cnt:    ds 1
0054             59   wait25_keypad_cnt: ds 1
0055             60   wait25_adc_cnt:    ds 1
0056             61   wait25_lcd_cnt:    ds 1
0057             62   wait25_count:      ds 1
0058             63   
0058             64   power_output:  ds 4 ;
005C             65   pwm_counter:   ds 4 ; counter for pwm (0-1500_timer: ds 1
0060             66   
0060             67   Control_FSM_state: ds 1 
0061             68   Current_State:     ds 1
0062             69   
0062             70   soak_temp_diff: ds 4 ; temperature difference between target soak temp and current oven temp 
0066             71   proportional_gain_var: ds 4 ; power gain calculated from the proportional block
006A             72   
006A             73   ;-- UI buffers I added (ayaan)
006A             74   Cursor_Idx: ds 1
006B             75   
006B             76   ; Buzzer module variables
006B             77   buzz_state:      ds 1   ; 0=IDLE, 1=ON, 2=OFF
006C             78   buzz_timer:      ds 1   ; counts ms within ON/OFF window
006D             79   buzz_beeps_left: ds 1   ; how many beeps remaining
006E             80   buzz_priority:   ds 1   ; 0 none, 1=state, 2=done, 3=error
006F             81   
006F             82   SEC_FSM_timer: ds 1
0070             83   SEC_FSM_state: ds 1
0071             84   ; Push buttons for globel interrupt 
0071             85   PB0_DEB_timer:  ds 1
0072             86   PB0_DEB_state:  ds 1
0073             87   PB2_DEB_timer:  ds 1
0074             88   PB2_DEB_state:  ds 1
0075             89   BTN_DEB_state:  ds 1   ;- state machine state (0-3)
0076             90   BTN_DEB_timer:  ds 1   ;- debounce timer (incremented by ISR every 1ms)
0077             91   BTN_DEB_id:     ds 1   ;- which button was pressed (1-4)
0078             92   
0078             93   ; Buzzer state
0078             94   beep_count:  ds 1      ; remaining beeps
0079             95   beep_state:  ds 1      ; 0=idle, 1=ON, 2=OFF
007A             96   beep_tmr:    ds 2      ; 16-bit ms timer (needs to reach 500)
007C             97   
007C             98   servo_pwm_counter: ds 1 ; counter for the servo pwm signal
007D             99   
0080            100   iseg at 0x80
0080            101   Buf_Soak_Temp: ds 4   
0084            102   Buf_Soak_Time: ds 5   
0089            103   Buf_Refl_Temp: ds 4   
008D            104   Buf_Refl_Time: ds 5
0092            105   ; 
0092            106   ;-------------------------------------------------------------------------------
0092            107   ; bit operation setb, clr, jb, and jnb
0000            108   bseg
0000            109   mf:     dbit 1 ; math32 sign
0001            110   one_second_flag: dbit 1
0002            111   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003            112   one_ms_buzz_flag: dbit 1 ; one_millisecond_flag for buzz
0004            113   one_second_lcd_flag: dbit 1
0005            114   
0005            115   soak_temp_reached: dbit 1
0006            116   reflow_temp_reached: dbit 1
0007            117   cooling_temp_reached: dbit 1
0008            118   
0008            119   soak_time_reached: dbit 1
0009            120   reflow_time_reached: dbit 1
000A            121   
000A            122   reset_signal: dbit 1
000B            123   stop_signal: dbit 1
000C            124   start_signal_count: dbit 1
000D            125   time_count_doing_signal: dbit 1
000E            126   config_finish_signal: dbit 1
000F            127   
000F            128   state_change_signal: dbit 1
0010            129   state_change_signal_TC: dbit 1
0011            130   state_change_signal_Count: dbit 1
0012            131   state_change_beep_signal: dbit 1
0013            132   
0013            133   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
0014            134   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0015            135   
0015            136   PB0_flag: dbit 1 ; start entire program
0016            137   PB1_flag: dbit 1 ; start soak
0017            138   PB2_flag: dbit 1 ; pause process
0018            139   
0018            140   ;buzzer beep
0018            141   one_ms_beep_flag: dbit 1
0019            142   beep_error_done: dbit 1
001A            143   
001A            144   ; BSEG (Bit Segment)
001A            145   wait25_active: dbit 1 ; 1 = We are currently waiting
001B            146   wait25_done:   dbit 1 ; 1 = The 25ms has finished
001C            147   wait25_btn_active:    dbit 1
001D            148   wait25_btn_done:      dbit 1
001E            149   wait25_keypad_active: dbit 1
001F            150   wait25_keypad_done:   dbit 1
0020            151   wait25_adc_active:    dbit 1
0021            152   wait25_adc_done:      dbit 1
0022            153   wait25_lcd_active:    dbit 1
0023            154   wait25_lcd_done:      dbit 1
0024            155   
0024            156   fullscreen_update_signal: dbit 1
0025            157   
0025            158   one_second_flag_test: dbit 1
0026            159   one_millisecond_flag_servo: dbit 1 ; set the one millsiecond flag for servo pwm signal generation
0027            160   
0027            161   servo_angle_zero: dbit 1 ; flag for indicating whether the servo angle should be at 0 or not: 1 -> 0; 0 -> 180
0028            162   soak_temp_greater: dbit 1 ; target soak_temp greater than current_temp
0029            163   ; 11 bits used
0029            164   
0029            165   ;-------------------------------------------------------------------------------
0320            166   cseg
0320            167   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            168   BAUD           EQU 57600
0320            169   
0320            170   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            171   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            172   ; is always 12 unlike the N76E003 where is selectable.
0320            173   
0320            174   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            175   
0320            176   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            177   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            178   
0320            179   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            180   
0320            181   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            182   BEEP_ON_MS          EQU 100  ; 100ms
0320            183   BEEP_OFF_MS    EQU 100  ; 100ms
0320            184   
0320            185   PWM_OUT        EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            186   
0320            187   ; These 'equ' must match the wiring between the DE10Lite board and the LCD!
0320            188   ; P0 is in connector JPIO.
0320            189   
0320            190   ;Added correct I/O definitions
0320            191   ;-- LCD Pins ---
0320            192   ELCD_RS equ P1.7
0320            193   ELCD_E  equ P1.1
0320            194   ELCD_D4 equ P0.7
0320            195   ELCD_D5 equ P0.5
0320            196   ELCD_D6 equ P0.3
0320            197   ELCD_D7 equ P0.1
0320            198   
0320            199   ; -- Buttons --
0320            200   BTN_SOAK_TEMP equ P0.0
0320            201   BTN_SOAK_TIME equ P0.2
0320            202   BTN_REFL_TEMP equ P0.4
0320            203   BTN_REFL_TIME equ P0.6
0320            204   PB0                equ P1.0
0320            205   PB2                equ P3.7
0320            206   
0320            207   ; --- PB0PAD ---
0320            208   ROW1 equ P1.2
0320            209   ROW2 equ P1.4
0320            210   ROW3 equ P1.6
0320            211   ROW4 equ P2.0
0320            212   COL1 equ P2.2
0320            213   COL2 equ P2.4
0320            214   COL3 equ P2.6
0320            215   COL4 equ P3.0
0320            216   
0320            217   SERVO_OUT      EQU p3.6 ; servo pin
0320            218   
0320            219   SERVO_PERIOD   EQU 20 ; pwm signal period for the servo motor (20 ms)
0320            220   SERVO_0        EQU 1 ; pwm high time for the servo motor to stay at 0 degree
0320            221   SERVO_180      EQU 2 ; pwm high time for the servo motor to stay at 180 degrees
0320            222   
0320            223   COLD_JUNCTION_TEMP equ 20
0320            224   MAX_POWER           EQU 1500 ; max oven power
0320            225   NO_POWER            EQU 0    ; no power
0320            226   BASE_POWER     EQU (MAX_POWER/5) ; 20% base power for state 2, 4
0320            227   KP                          EQU 5 ; proportional gain
0320            228   
0320            229   ;                     1234567890123456 <-- 16 characters per line LCD
0320 696E6974   230   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   231   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   232   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            233   
0350            234   ; --- UI STRINGS (REQUIRED FOR PB0PAD LOGIC), <- I can fix if duplicates
0350 53656C65   235   Txt_Home:     db 'Select Mode:    ', 0
     6374204D
     6F64653A
     20202020
     00
0361 53657420   236   Txt_SoakT:    db 'Set Soak Temp   ', 0
     536F616B
     2054656D
     70202020
     00
0372 53657420   237   Txt_SoakTime: db 'Set Soak Time   ', 0
     536F616B
     2054696D
     65202020
     00
0383 53657420   238   Txt_ReflT:    db 'Set Reflow Temp ', 0
     5265666C
     6F772054
     656D7020
     00
0394 53657420   239   Txt_ReflTime: db 'Set Reflow Time ', 0
     5265666C
     6F772054
     696D6520
     00
03A5            240   
03A5            241   ;                       1234567890123456
03A5 53657420   242   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
03B5 536F616B   243   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
03C0 5265666C   244   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
03CD 536F616B   245   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
03D8 5265666C   246   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03E5            247   
03E5 54656D70   248   String_temp_line:  db 'Temp: ', 0
     3A2000
03EC            249   
03EC            250   ;                     1234567890123456
03EC 52616D70   251   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03FC 536F616B   252   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
040C 52616D70   253   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
041C 5265666C   254   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
042C 436F6F6C   255   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
043C 50726F63   256   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
044C            257   
044C 20202020   258   String_Blank:    db '                ', 0
     20202020
     20202020
     20202020
     00
045D            259   
045D            260   ;-------------------------------------------------------------------------------
045D            261   ; Timers Setting:
045D            262   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
045D            263   ;   Timer 1: Serial port baud rate 57600 generator
045D            264   ;   Timer 2: 1ms interrupt for BCD counter increment/decrement
045D            265   ;-------------------------------------------------------------------------------
045D            266   ; Routine to initialize the ISR for Timer 0 ;
045D            267   Timer0_Init:
045D E589       268       mov a, TMOD
045F 54F0       269       anl a, #0xf0 ; Clear the bits for timer 0
0461 4401       270       orl a, #0x01 ; Configure timer 0 as 16-timer
0463 F589       271       mov TMOD, a
0465 758CFD     272       mov TH0, #high(TIMER0_RELOAD)
0468 758A5A     273       mov TL0, #low(TIMER0_RELOAD)
046B            274       ; Enable the timer and interrupts
046B D2A9       275       setb ET0  ; Enable timer 0 interrupt
046D            276       ; setb TR0  (no need to open at first)
046D 22         277       ret
046E            278   ; ISR for timer 0.  Set to execute every 1/4096Hz 
046E            279   ; to generate a 2048 Hz square wave at pin P1.5 
046E            280   Timer0_ISR:
046E            281       ;clr TF0  ; According to the data sheet this is done for us already.
046E 758CFD     282       mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
0471 758A5A     283       mov TL0, #low(TIMER0_RELOAD)
0474 B295       284       cpl SOUND_OUT ; Connect speaker to P1.5
0476 32         285       reti
0477            286   ; -----------------------------------------------------------------------------------------------;
0477            287   
0477            288   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
0477            289   Initialize_Serial_Port:
0477            290       ; Configure serial port and baud rate
0477 C28E       291       clr TR1 ; Disable timer 1
0479 53890F     292       anl TMOD, #0x0f ; Mask the bits for timer 1
047C 438920     293       orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
047F 438780     294       orl PCON, #80H ; Set SMOD to 1
0482 758DFD     295       mov TH1, #low(TIMER_1_RELOAD)
0485 758BFD     296       mov TL1, #low(TIMER_1_RELOAD) 
0488 D28E       297       setb TR1 ; Enable timer 1
048A 759852     298       mov SCON, #52H
048D 22         299       ret
048E            300   
048E            301   ; uart sending functions
048E            302   putchar:
048E 109902     303       jbc TI, putchar_L1
0491 80FB       304       sjmp putchar
0493            305   putchar_L1:
0493 F599       306       mov SBUF,a
0495 22         307       ret
0496            308   
0496            309   SendString:
0496 E4         310       clr a
0497 93         311       movc a, @a+dptr
0498 6006       312       jz SendString_L1
049A 12048E     313       lcall putchar
049D A3         314       inc dptr
049E 80F6       315       sjmp SendString  
04A0            316   SendString_L1:
04A0 22         317       ret
04A1            318   
04A1            319   ;-------------------------------------------------------------------------------
04A1            320   ; serial debugging
04A1            321   ; send a four byte number via serial to laptop
04A1            322   ; need to be used with python script
04A1            323   ; content needed to be sent should be stored in the varaible x
04A1            324   ;-------------------------------------------------------------------------------
04A1            325   Send32:
04A1            326       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
04A1 74AA       327       mov A, #0AAH
04A3 12048E     328       lcall putchar
04A6 7455       329       mov A, #055H
04A8 12048E     330       lcall putchar
04AB            331   
04AB E53D       332       mov A, x+3
04AD 12048E     333       lcall putchar
04B0 E53C       334       mov A, x+2
04B2 12048E     335       lcall putchar
04B5 E53B       336       mov A, x+1
04B7 12048E     337       lcall putchar
04BA E53A       338       mov A, x+0
04BC 12048E     339       lcall putchar
04BF            340   
04BF 740A       341       mov A, #0AH
04C1 12048E     342       lcall putchar
04C4 22         343       ret
04C5            344   ; -----------------------------------------------------------------------------------------------;
04C5            345   
04C5            346   ;-------------------------------------------------------------------------------
04C5            347   ; Serial temperature line for PuTTY/screen
04C5            348   ; Outputs: "Temp: XXXC\r\n"
04C5            349   ;-------------------------------------------------------------------------------
04C5            350   Serial_Send_Temp_Line:
04C5 9003E5     351       mov dptr, #String_temp_line
04C8 120496     352       lcall SendString
04CB            353   
04CB            354       ; Convert current_temp to BCD (same as LCD)
04CB 85473A     355       mov x, current_temp
04CE 85483B     356       mov x+1, current_temp+1
04D1 85493C     357       mov x+2, current_temp+2
04D4 854A3D     358       mov x+3, current_temp+3
04D7 12002E     359       lcall hex2bcd
04DA            360   
04DA 7F00       361       mov R7, #0          ; printed_flag = 0
04DC            362   
04DC            363       ; Print Hundreds (if non-zero)
04DC E543       364       mov a, bcd+1
04DE 540F       365       anl a, #0x0F
04E0 6007       366       jz Serial_Skip_Hundreds
04E2 2430       367       add a, #0x30
04E4 12048E     368       lcall putchar
04E7 7F01       369       mov R7, #1
04E9            370   Serial_Skip_Hundreds:
04E9            371   
04E9            372       ; Print Tens (if non-zero or if hundreds already printed)
04E9 E542       373       mov a, bcd+0
04EB C4         374       swap a
04EC 540F       375       anl a, #0x0F
04EE 7003       376       jnz Serial_Print_Tens
04F0 EF         377       mov a, R7
04F1 600C       378       jz Serial_Skip_Tens
04F3            379   Serial_Print_Tens:
04F3 E542       380       mov a, bcd+0
04F5 C4         381       swap a
04F6 540F       382       anl a, #0x0F
04F8 2430       383       add a, #0x30
04FA 12048E     384       lcall putchar
04FD 7F01       385       mov R7, #1
04FF            386   Serial_Skip_Tens:
04FF            387   
04FF            388       ; Print Ones (always)
04FF E542       389       mov a, bcd+0
0501 540F       390       anl a, #0x0F
0503 2430       391       add a, #0x30
0505 12048E     392       lcall putchar
0508            393   
0508            394       ; Print 'C' and newline
0508 7443       395       mov a, #'C'
050A 12048E     396       lcall putchar
050D 740D       397       mov a, #0DH     ; CR
050F 12048E     398       lcall putchar
0512 740A       399       mov a, #0AH     ; LF
0514 12048E     400       lcall putchar
0517 22         401       ret
0518            402   
0518            403   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
0518              1   ;-------------------------------------------------------------------------------
0518              2   ; Timer2_ISR.inc
0518              3   ; Contains Initialization and ISR for the 1ms System Timer
0518              4   ;-------------------------------------------------------------------------------
0518              5   
0518              6   ;-------------------------------------------------------------------------------
0518              7   ; Routine to initialize the ISR for timer 2
0518              8   ;-------------------------------------------------------------------------------
0518              9   Timer2_Init:
0518 75C800      10       mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
051B 75CDF5      11       mov TH2, #high(TIMER2_RELOAD)
051E 75CC27      12       mov TL2, #low(TIMER2_RELOAD)
0521             13       ; Set the reload value
0521 75CBF5      14       mov RCAP2H, #high(TIMER2_RELOAD)
0524 75CA27      15       mov RCAP2L, #low(TIMER2_RELOAD)
0527             16       
0527 C2CF        17       clr TF2       ; Clear flag just in case
0529             18       ; Enable the timer and interrupts
0529 D2AD        19       setb ET2      ; Enable timer 2 interrupt
052B D2CA        20       setb TR2      ; Enable timer 2
052D 22          21       ret
052E             22   
052E             23   ;-------------------------------------------------------------------------------
052E             24   ; ISR for timer 2.  Runs every 1 ms
052E             25   ;-------------------------------------------------------------------------------
052E             26   Timer2_ISR:
052E C0E0        27       push acc
0530 C0D0        28       push psw
0532             29       
0532 C2CF        30       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
0534             31   
0534             32       ; --- 1. Existing Non-Blocking Seconds Increment and Periphals Debounce Timers ---
0534 056F        33       inc SEC_FSM_timer
0536 D202        34       setb one_ms_pwm_flag 
0538 D203        35            setb one_ms_buzz_flag
053A D218        36       setb one_ms_beep_flag
053C             37   
053C 0571        38       inc PB0_DEB_timer
053E 0573        39       inc PB2_DEB_timer
0540 0576        40       inc BTN_DEB_timer
0542 D218        41       setb one_ms_beep_flag
0544 D226        42       setb one_millisecond_flag_servo
0546             43   
0546             44       ; --- 2. NEW: Non-Blocking Delay Counters ---
0546             45       ; A. BUTTON DELAY
0546 301C0B      46       jnb wait25_btn_active, T2_Check_Keypad
0549 0553        47       inc wait25_btn_cnt
054B E553        48       mov a, wait25_btn_cnt
054D B41904      49       cjne a, #25, T2_Check_Keypad
0550 D21D        50       setb wait25_btn_done
0552 C21C        51       clr wait25_btn_active
0554             52       
0554             53       ; B. KEYPAD DELAY
0554             54   T2_Check_Keypad:
0554 301E0B      55       jnb wait25_keypad_active, T2_Check_ADC
0557 0554        56       inc wait25_keypad_cnt
0559 E554        57       mov a, wait25_keypad_cnt
055B B41904      58       cjne a, #25, T2_Check_ADC
055E D21F        59       setb wait25_keypad_done
0560 C21E        60       clr wait25_keypad_active
0562             61   
0562             62       ; C. ADC DELAY (Thermocouple)
0562             63   T2_Check_ADC:
0562 30200B      64       jnb wait25_adc_active, T2_Check_LCD
0565 0555        65       inc wait25_adc_cnt
0567 E555        66       mov a, wait25_adc_cnt
0569 B41904      67       cjne a, #25, T2_Check_LCD
056C D221        68       setb wait25_adc_done
056E C220        69       clr wait25_adc_active
0570             70   
0570             71       ; D. LCD DELAY
0570             72   T2_Check_LCD:
0570 30220B      73       jnb wait25_lcd_active, T2_Check_Generic
0573 0556        74       inc wait25_lcd_cnt
0575 E556        75       mov a, wait25_lcd_cnt
0577 B41904      76       cjne a, #25, T2_Check_Generic
057A D223        77       setb wait25_lcd_done
057C C222        78       clr wait25_lcd_active
057E             79   
057E             80       ; E. GENERIC DELAY (Used by Wait_25ms in Main)
057E             81   T2_Check_Generic:
057E 301A0B      82       jnb wait25_active, Timer2_ISR_done
0581 0557        83       inc wait25_count
0583 E557        84       mov a, wait25_count
0585 B41904      85       cjne a, #25, Timer2_ISR_done
0588 D21B        86       setb wait25_done      ; Tells Wait_25ms that we are finished
058A C21A        87       clr wait25_active     ; Stop counting
058C             88   
058C             89   Timer2_ISR_done:
058C D0D0        90       pop psw
058E D0E0        91       pop acc
0590 32          92       reti
0591             93            
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
0591              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
0591              2   cseg
0591              3   
0591              4   ; When using a 33.333333MHz crystal clock
0591              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
0591              6   
0591              7   ;---------------------------------;
0591              8   ; Wait 40 microseconds            ;
0591              9   ;---------------------------------;
0591             10   Wait40uSec:
0591 C000        11            push AR0
0593 78BE        12            mov R0, #190
0595             13   L0: 
0595 00          14            nop
0596 00          15            nop
0597 00          16            nop
0598 00          17            nop
0599 D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
059B D000        19            pop AR0
059D 22          20       ret
059E             21   
059E             22   ;---------------------------------;
059E             23   ; Wait 'R2' milliseconds          ;
059E             24   ;---------------------------------;
                 25   Wait_Milli_Seconds mac
                 26   	push AR2
                 27   	mov R2, %0
                 28   	lcall ?Wait_Milli_Seconds
                 29   	pop AR2
                 30   endmac
059E             31   
059E             32   ?Wait_Milli_Seconds:
059E C000        33            push AR0
05A0 C001        34            push AR1
05A2 7932        35   L3: mov R1, #50
05A4 78DF        36   L2: mov R0, #223
05A6 D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
05A8 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
05AA DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
05AC D001        40       pop AR1
05AE D000        41       pop AR0
05B0 22          42       ret
05B1             43            
05B1             44   ;---------------------------------;
05B1             45   ; Toggles the 'E' pin in the LCD  ;
05B1             46   ;---------------------------------;
05B1             47   ELCD_pulse:
05B1 D291        48            setb ELCD_E
05B3 120591      49            lcall Wait40uSec
05B6 C291        50            clr ELCD_E
05B8 120591      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
05BB 22          52       ret
05BC             53   
05BC             54   ;---------------------------------;
05BC             55   ; Writes acc to LCD in 4-bit mode ;
05BC             56   ;---------------------------------;
05BC             57   ELCD_byte:
05BC             58            ; Write high 4 bits first
05BC A2E7        59            mov c, ACC.7
05BE 9281        60            mov ELCD_D7, c
05C0 A2E6        61            mov c, ACC.6
05C2 9283        62            mov ELCD_D6, c
05C4 A2E5        63            mov c, ACC.5
05C6 9285        64            mov ELCD_D5, c
05C8 A2E4        65            mov c, ACC.4
05CA 9287        66            mov ELCD_D4, c
05CC 1205B1      67       lcall ELCD_pulse
05CF             68            ; Write low 4 bits next
05CF A2E3        69            mov c, ACC.3
05D1 9281        70            mov ELCD_D7, c
05D3 A2E2        71            mov c, ACC.2
05D5 9283        72            mov ELCD_D6, c
05D7 A2E1        73            mov c, ACC.1
05D9 9285        74            mov ELCD_D5, c
05DB A2E0        75            mov c, ACC.0
05DD 9287        76            mov ELCD_D4, c
05DF 1205B1      77       lcall ELCD_pulse
05E2 22          78            ret
05E3             79   
05E3             80   ;---------------------------------;
05E3             81   ; Write data to LCD               ;
05E3             82   ;---------------------------------;
                 83   WriteData mac
                 84   	mov a, %0
                 85   	lcall ?WriteData
                 86   endmac
05E3             87            
05E3             88   ?WriteData:
05E3 D297        89            setb ELCD_RS
05E5 0205BC      90            ljmp ELCD_byte
05E8             91   
05E8             92   ;---------------------------------;
05E8             93   ; Write command to LCD            ;
05E8             94   ;---------------------------------;
                 95   WriteCommand mac
                 96   	mov a, %0
                 97   	lcall ?WriteCommand
                 98   endmac
05E8             99   
05E8            100   ?WriteCommand:
05E8 C297       101            clr ELCD_RS
05EA 0205BC     102            ljmp ELCD_byte
05ED            103   
05ED            104   ;---------------------------------;
05ED            105   ; Configure LCD in 4-bit mode     ;
05ED            106   ;---------------------------------;
05ED            107   ELCD_4BIT:
05ED C291       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
05EF            109            ;clr ELCD_RW  ; RW forced to zero
05EF            110            
05EF            111            ; After power on, let the LCD start up before initializing
05EF C002       112            push AR2
05F1 7A28       112            mov R2, #40
05F3 12059E     112            lcall ?Wait_Milli_Seconds
05F6 D002       112            pop AR2
05F8            113            
05F8            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
05F8 7433       115            mov a, #0x33
05FA 1205E8     115            lcall ?WriteCommand
05FD 7433       116            mov a, #0x33
05FF 1205E8     116            lcall ?WriteCommand
0602 7432       117            mov a, #0x32
0604 1205E8     117            lcall ?WriteCommand ; change to 4-bit mode
0607            118   
0607            119            ; Configure the LCD
0607 7428       120            mov a, #0x28
0609 1205E8     120            lcall ?WriteCommand
060C 740C       121            mov a, #0x0c
060E 1205E8     121            lcall ?WriteCommand
0611 7401       122            mov a, #0x01
0613 1205E8     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
0616            123   
0616            124       ;Wait for the clear screen command to finish.
0616 C002       125            push AR2
0618 7A02       125            mov R2, #2
061A 12059E     125            lcall ?Wait_Milli_Seconds
061D D002       125            pop AR2
061F 22         126       ret
0620            127   
0620            128   ;---------------------------------;
0620            129   ; Send a constant string to LCD   ;
0620            130   ;---------------------------------;
                131   Send_Constant_String mac
                132   	push dph
                133   	push dpl
                134   	push acc
                135   	mov dptr, %0
                136   	lcall ?Send_Constant_String
                137   	pop acc
                138   	pop dpl
                139   	pop dph
                140   endmac
0620            141   
0620            142   ?Send_Constant_String:
0620 E4         143       clr a
0621 93         144       movc a, @a+dptr
0622 6006       145       jz ?Send_Constant_String_Done
0624 1205E3     146       lcall ?WriteData
0627 A3         147       inc dptr
0628 80F6       148       sjmp ?Send_Constant_String
062A            149   ?Send_Constant_String_Done:
062A 22         150       ret  
062B            151   
062B            152   ;---------------------------------;
062B            153   ; Set LCD cursor at row, column   ;
062B            154   ;---------------------------------;
                155   Set_Cursor mac
                156   	push acc
                157   	mov a, #%1
                158   	dec a
                159   	lcall ?Set_Cursor_%0 ; Select column and row
                160   	pop acc
                161   endmac
062B            162   
062B            163   ?Set_Cursor_2:
062B 4440       164            orl a, #01000000B
062D            165   ?Set_Cursor_1:
062D 4480       166            orl a, #10000000B
062F 0205E8     167            ljmp ?WriteCommand ; Select column and row
0632            168   
0632            169   ;---------------------------------;
0632            170   ; Display a BCD number in the LCD ;
0632            171   ;---------------------------------;
                172   Display_BCD mac
                173   	push ar0
                174   	mov r0, %0
                175   	lcall ?Display_BCD
                176   	pop ar0
                177   endmac
0632            178   
0632            179   ?Display_BCD:
0632 C0E0       180            push acc
0634            181            ; Write most significant digit
0634 E8         182            mov a, r0
0635 C4         183            swap a
0636 540F       184            anl a, #0fh
0638 4430       185            orl a, #30h
063A 1205E3     186            lcall ?WriteData
063D            187            ; write least significant digit
063D E8         188            mov a, r0
063E 540F       189            anl a, #0fh
0640 4430       190            orl a, #30h
0642 1205E3     191            lcall ?WriteData
0645 D0E0       192            pop acc
0647 22         193            ret
0648            194   
0648            195   ;------------------------------------;
0648            196   ; Display a char in the LCD          ;
0648            197   ;------------------------------------;
                198   Display_char mac
                199   	push acc
                200   	mov a, %0
                201   	lcall ?WriteData
                202   	pop acc
                203   endmac
0648            204   
0648            406            ;-----------------------------------------------------------------------------------------------;
0648            407   
0648            408   ;-------------------------------------------------------------------------------
0648            409   ; Display Function for 7-segment displays       
0648            410   ;-------------------------------------------------------------------------------
0648            411   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
0648            412   T_7seg:
0648 C0F9A4B0   413       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
064D 9282F880   414       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
0652 8883C6A1   415       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
0658            416   
0658            417   ; Displays a BCD number pased in R0 in HEX5-HEX0
0658            418   Display_BCD_7_Seg_HEX10:
0658 900648     419       mov dptr, #T_7seg
065B E8         420       mov a, R0
065C C4         421       swap a
065D 540F       422       anl a, #0FH
065F 93         423       movc a, @a+dptr
0660 F592       424       mov HEX1, a
0662 E8         425       mov a, R0
0663 540F       426       anl a, #0FH
0665 93         427       movc a, @a+dptr
0666 F591       428       mov HEX0, a
0668 22         429       ret
0669            430   
0669            431   Display_BCD_7_Seg_HEX32:
0669 900648     432       mov dptr, #T_7seg
066C E8         433       mov a, R0
066D C4         434       swap a
066E 540F       435       anl a, #0FH
0670 93         436       movc a, @a+dptr
0671 F594       437       mov HEX3, a
0673 E8         438       mov a, R0
0674 540F       439       anl a, #0FH
0676 93         440       movc a, @a+dptr
0677 F593       441       mov HEX2, a
0679 22         442       ret
067A            443   
067A            444   Display_BCD_7_Seg_HEX54:
067A 900648     445       mov dptr, #T_7seg
067D E8         446       mov a, R0
067E C4         447       swap a
067F 540F       448       anl a, #0FH
0681 93         449       movc a, @a+dptr
0682 F58F       450       mov HEX5, a
0684 E8         451       mov a, R0
0685 540F       452       anl a, #0FH
0687 93         453       movc a, @a+dptr
0688 F58E       454       mov HEX4, a
068A 22         455       ret
068B            456   
068B            457   ; The 8-bit hex number passed in the accumulator is converted to
068B            458   ; BCD and stored in [R1, R0]
068B            459   Hex_to_bcd_8bit:
068B 75F064     460       mov b, #100
068E 84         461       div ab
068F F9         462       mov R1, a   ; After dividing, a has the 100s
0690 E5F0       463       mov a, b    ; Remainder is in register b
0692 75F00A     464       mov b, #10
0695 84         465       div ab ; The tens are stored in a, the units are stored in b 
0696 C4         466       swap a
0697 54F0       467       anl a, #0xf0
0699 45F0       468       orl a, b
069B F8         469       mov R0, a
069C 22         470       ret
069D            471   ;-------------------------------------------------------------------------------
069D            472   ; Display Function for LCD                      
069D            473   ;-------------------------------------------------------------------------------
069D            474   LCD_Print_2Digits:
069D 12068B     475       lcall Hex_to_bcd_8bit
06A0 E8         476       mov a, R0
06A1 C4         477       swap a
06A2 540F       478       anl a, #0x0F
06A4 2430       479       add a, #0x30
06A6 1205E3     480       lcall ?WriteData
06A9 E8         481       mov a, R0
06AA 540F       482       anl a, #0x0F
06AC 2430       483       add a, #0x30
06AE 1205E3     484       lcall ?WriteData
06B1 22         485       ret
06B2            486   
06B2            487   LCD_Display_Update_func:
06B2 C0E0       488       push acc
06B4            489       
06B4            490       ; ==========================================
06B4            491       ; PART 1: STATIC TEXT (Title)
06B4            492       ; Runs ONLY when the state changes
06B4            493       ; ==========================================
06B4            494       
06B4            495       ; [FIX] "Trampoline" logic for long distance jump
06B4            496       ; If signal is SET (1), we stay here and update.
06B4            497       ; If signal is CLEAR (0), we Long Jump to the Live Update section.
06B4 300F04     498       jnb state_change_signal, Do_Dynamic_Update
06B7 C20F       499            clr state_change_signal
06B9 8003       500            sjmp Do_Static_Update
06BB            501   Do_Dynamic_Update:
06BB 0207F2     502            ljmp Check_Live_Update
06BE            503   
06BE            504   Do_Static_Update:
06BE            505       ; State Changed: Clear Screen and Write Title
06BE 120985     506       lcall Clear_Screen_Func
06C1 E560       507       mov a, Control_FSM_state
06C3            508       
06C3            509       ; State 0: Welcome
06C3 B4003B     510       cjne a, #0, LCD_Check_1
06C6 C0E0       511            push acc
06C8 7401       511            mov a, #1
06CA 14         511            dec a
06CB 12062D     511            lcall ?Set_Cursor_1 ; Select column and row
06CE D0E0       511            pop acc
06D0 C083       512            push dph
06D2 C082       512            push dpl
06D4 C0E0       512            push acc
06D6 900330     512            mov dptr, #String_state0_1
06D9 120620     512            lcall ?Send_Constant_String
06DC D0E0       512            pop acc
06DE D082       512            pop dpl
06E0 D083       512            pop dph
06E2 C0E0       513            push acc
06E4 7401       513            mov a, #1
06E6 14         513            dec a
06E7 12062B     513            lcall ?Set_Cursor_2 ; Select column and row
06EA D0E0       513            pop acc
06EC C083       514            push dph
06EE C082       514            push dpl
06F0 C0E0       514            push acc
06F2 900340     514            mov dptr, #String_state0_2
06F5 120620     514            lcall ?Send_Constant_String
06F8 D0E0       514            pop acc
06FA D082       514            pop dpl
06FC D083       514            pop dph
06FE 0207EF     515       ljmp LCD_Done_Bridge ; Exit
0701            516   
0701            517   LCD_Check_1: ; Setup
0701 B4011F     518       cjne a, #1, LCD_Check_2
0704 C0E0       519            push acc
0706 7401       519            mov a, #1
0708 14         519            dec a
0709 12062D     519            lcall ?Set_Cursor_1 ; Select column and row
070C D0E0       519            pop acc
070E C083       520            push dph
0710 C082       520            push dpl
0712 C0E0       520            push acc
0714 9003A5     520            mov dptr, #String_state1
0717 120620     520            lcall ?Send_Constant_String
071A D0E0       520            pop acc
071C D082       520            pop dpl
071E D083       520            pop dph
0720 0207EF     521       ljmp LCD_Done_Bridge
0723            522   
0723            523   LCD_Check_2: ; Ramp to Soak
0723 B4021F     524       cjne a, #2, LCD_Check_3
0726 C0E0       525            push acc
0728 7401       525            mov a, #1
072A 14         525            dec a
072B 12062D     525            lcall ?Set_Cursor_1 ; Select column and row
072E D0E0       525            pop acc
0730 C083       526            push dph
0732 C082       526            push dpl
0734 C0E0       526            push acc
0736 9003EC     526            mov dptr, #String_state2
0739 120620     526            lcall ?Send_Constant_String
073C D0E0       526            pop acc
073E D082       526            pop dpl
0740 D083       526            pop dph
0742 020812     527       ljmp LCD_Update_Temp_Value ; Draw Temp immediately!
0745            528   
0745            529   LCD_Check_3: ; Soak
0745 B4031F     530       cjne a, #3, LCD_Check_4
0748 C0E0       531            push acc
074A 7401       531            mov a, #1
074C 14         531            dec a
074D 12062D     531            lcall ?Set_Cursor_1 ; Select column and row
0750 D0E0       531            pop acc
0752 C083       532            push dph
0754 C082       532            push dpl
0756 C0E0       532            push acc
0758 9003FC     532            mov dptr, #String_state3
075B 120620     532            lcall ?Send_Constant_String
075E D0E0       532            pop acc
0760 D082       532            pop dpl
0762 D083       532            pop dph
0764 020812     533       ljmp LCD_Update_Temp_Value
0767            534   
0767            535   LCD_Check_4: ; Ramp to Peak
0767 B4041F     536       cjne a, #4, LCD_Check_5
076A C0E0       537            push acc
076C 7401       537            mov a, #1
076E 14         537            dec a
076F 12062D     537            lcall ?Set_Cursor_1 ; Select column and row
0772 D0E0       537            pop acc
0774 C083       538            push dph
0776 C082       538            push dpl
0778 C0E0       538            push acc
077A 90040C     538            mov dptr, #String_state4
077D 120620     538            lcall ?Send_Constant_String
0780 D0E0       538            pop acc
0782 D082       538            pop dpl
0784 D083       538            pop dph
0786 020812     539       ljmp LCD_Update_Temp_Value
0789            540   
0789            541   LCD_Check_5: ; Reflow
0789 B4051F     542       cjne a, #5, LCD_Check_6
078C C0E0       543            push acc
078E 7401       543            mov a, #1
0790 14         543            dec a
0791 12062D     543            lcall ?Set_Cursor_1 ; Select column and row
0794 D0E0       543            pop acc
0796 C083       544            push dph
0798 C082       544            push dpl
079A C0E0       544            push acc
079C 90041C     544            mov dptr, #String_state5
079F 120620     544            lcall ?Send_Constant_String
07A2 D0E0       544            pop acc
07A4 D082       544            pop dpl
07A6 D083       544            pop dph
07A8 020812     545       ljmp LCD_Update_Temp_Value
07AB            546   
07AB            547   LCD_Check_6: ; Cooling
07AB B4061F     548       cjne a, #6, LCD_Check_7
07AE C0E0       549            push acc
07B0 7401       549            mov a, #1
07B2 14         549            dec a
07B3 12062D     549            lcall ?Set_Cursor_1 ; Select column and row
07B6 D0E0       549            pop acc
07B8 C083       550            push dph
07BA C082       550            push dpl
07BC C0E0       550            push acc
07BE 90042C     550            mov dptr, #String_state6
07C1 120620     550            lcall ?Send_Constant_String
07C4 D0E0       550            pop acc
07C6 D082       550            pop dpl
07C8 D083       550            pop dph
07CA 020812     551       ljmp LCD_Update_Temp_Value
07CD            552   
07CD            553   LCD_Check_7: ; Done
07CD            554       ; [FIX] Check distance safe logic for State 7
07CD B4071F     555       cjne a, #7, LCD_Done_Bridge ; If not 7, we are done
07D0 C0E0       556            push acc
07D2 7401       556            mov a, #1
07D4 14         556            dec a
07D5 12062D     556            lcall ?Set_Cursor_1 ; Select column and row
07D8 D0E0       556            pop acc
07DA C083       557            push dph
07DC C082       557            push dpl
07DE C0E0       557            push acc
07E0 90043C     557            mov dptr, #String_state7
07E3 120620     557            lcall ?Send_Constant_String
07E6 D0E0       557            pop acc
07E8 D082       557            pop dpl
07EA D083       557            pop dph
07EC 0207EF     558       ljmp LCD_Done_Bridge
07EF            559   
07EF            560   ; Local bridge to reach the far-away LCD_Done
07EF            561   LCD_Done_Bridge:
07EF 020873     562       ljmp LCD_Done
07F2            563   
07F2            564   ; ==========================================
07F2            565   ; PART 2: DYNAMIC VALUES (Temperature)
07F2            566   ; Runs every time 'one_second_flag' is set
07F2            567   ; ==========================================
07F2            568   Check_Live_Update:
07F2 3001FA     569       jnb one_second_flag, LCD_Done_Bridge
07F5 C201       570       clr one_second_flag
07F7            571       
07F7            572       ; Only update temp for States 2, 3, 4, 5, 6
07F7 E560       573       mov a, Control_FSM_state
07F9 B40202     574       cjne a, #2, Check_St3
07FC 8014       575       sjmp LCD_Update_Temp_Value
07FE            576   Check_St3:
07FE B40302     577       cjne a, #3, Check_St4
0801 800F       578       sjmp LCD_Update_Temp_Value
0803            579   Check_St4:
0803 B40402     580       cjne a, #4, Check_St5
0806 800A       581       sjmp LCD_Update_Temp_Value
0808            582   Check_St5:
0808 B40502     583       cjne a, #5, Check_St6
080B 8005       584       sjmp LCD_Update_Temp_Value
080D            585   Check_St6:
080D B40663     586       cjne a, #6, LCD_Done
0810 8000       587       sjmp LCD_Update_Temp_Value
0812            588   
0812            589   ; --- HELPER: Prints "XXX C" on Line 2 ---
0812            590   LCD_Update_Temp_Value:
0812 C0E0       591            push acc
0814 7401       591            mov a, #1
0816 14         591            dec a
0817 12062B     591            lcall ?Set_Cursor_2 ; Select column and row
081A D0E0       591            pop acc
081C            592       
081C            593       ; Convert current_temp to BCD
081C 85473A     594       mov x, current_temp
081F 85483B     595       mov x+1, current_temp+1
0822 85493C     596       mov x+2, current_temp+2
0825 854A3D     597       mov x+3, current_temp+3
0828 12002E     598       lcall hex2bcd
082B            599   
082B            600       ; Update HEX2-HEX0 with temperature
082B 1209B0     601       lcall Update_HEX_Temp
082E            602       
082E            603       ; Print Hundreds
082E E543       604       mov a, bcd+1
0830 540F       605       anl a, #0x0F
0832 2430       606       add a, #0x30
0834 1205E3     607       lcall ?WriteData
0837            608       
0837            609       ; Print Tens
0837 E542       610       mov a, bcd+0
0839 C4         611       swap a
083A 540F       612       anl a, #0x0F
083C 2430       613       add a, #0x30
083E 1205E3     614       lcall ?WriteData
0841            615       
0841            616       ; Print Ones
0841 E542       617       mov a, bcd+0
0843 540F       618       anl a, #0x0F
0845 2430       619       add a, #0x30
0847 1205E3     620       lcall ?WriteData
084A            621       
084A            622       ; Print 'C'
084A 7443       623       mov a, #'C'
084C 1205E3     624       lcall ?WriteData
084F            625       
084F            626       ; Clear remaining line space (prevents garbage)
084F 7420       627       mov a, #' '
0851 1205E3     628       lcall ?WriteData
0854 1205E3     629       lcall ?WriteData
0857            630   
0857            631       ; Print time MM:SS at bottom right
0857 C0E0       632            push acc
0859 740C       632            mov a, #12
085B 14         632            dec a
085C 12062B     632            lcall ?Set_Cursor_2 ; Select column and row
085F D0E0       632            pop acc
0861 E531       633       mov a, current_time_minute
0863 12069D     634       lcall LCD_Print_2Digits
0866 743A       635       mov a, #':'
0868 1205E3     636       lcall ?WriteData
086B E530       637       mov a, current_time_sec
086D 12069D     638       lcall LCD_Print_2Digits
0870            639   
0870            640       ; Mirror temp to serial (PuTTY/screen)
0870 1204C5     641       lcall Serial_Send_Temp_Line
0873            642   
0873            643   LCD_Done:
0873 D0E0       644       pop acc
0875 22         645       ret
0876            646   
0876            647   ; ----------------------------------------------------------------
0876            648   ; MODULE: SCREEN UPDATE (Visual Logic)
0876            649   ; ----------------------------------------------------------------
0876            650   Update_Screen_Full:
0876 E560       651            mov a, Control_FSM_state
0878 B40102     652            cjne a, #1, Update_Screen_Full_ret
087B 8001       653            sjmp Update_Screen_Full_do
087D            654   Update_Screen_Full_ret:
087D 22         655            ret
087E            656   Update_Screen_Full_do:
087E 3024FC     657       jnb fullscreen_update_signal, Update_Screen_Full_ret
0881 C224       658       clr fullscreen_update_signal
0883            659   
0883 120985     660       lcall Clear_Screen_Func
0886 C0E0       661            push acc
0888 7401       661            mov a, #1
088A 14         661            dec a
088B 12062D     661            lcall ?Set_Cursor_1 ; Select column and row
088E D0E0       661            pop acc
0890            662       ; --- Draw Line 1 (Titles) ---
0890 E561       663       mov A, Current_State
0892 B40013     664       cjne A, #0, Update_State_1
0895 C083       665            push dph
0897 C082       665            push dpl
0899 C0E0       665            push acc
089B 900350     665            mov dptr, #Txt_Home
089E 120620     665            lcall ?Send_Constant_String
08A1 D0E0       665            pop acc
08A3 D082       665            pop dpl
08A5 D083       665            pop dph
08A7 22         666       ret 
08A8            667   Update_State_1:
08A8 B40114     668       cjne A, #1, Update_State_2
08AB C083       669            push dph
08AD C082       669            push dpl
08AF C0E0       669            push acc
08B1 900361     669            mov dptr, #Txt_SoakT
08B4 120620     669            lcall ?Send_Constant_String
08B7 D0E0       669            pop acc
08B9 D082       669            pop dpl
08BB D083       669            pop dph
08BD 8042       670       sjmp Draw_Temp_Format
08BF            671   Update_State_2:
08BF B40214     672       cjne A, #2, Update_State_3
08C2 C083       673            push dph
08C4 C082       673            push dpl
08C6 C0E0       673            push acc
08C8 900372     673            mov dptr, #Txt_SoakTime
08CB 120620     673            lcall ?Send_Constant_String
08CE D0E0       673            pop acc
08D0 D082       673            pop dpl
08D2 D083       673            pop dph
08D4 8046       674       sjmp Draw_Time_Format
08D6            675   Update_State_3:
08D6 B40314     676       cjne A, #3, Update_State_4
08D9 C083       677            push dph
08DB C082       677            push dpl
08DD C0E0       677            push acc
08DF 900383     677            mov dptr, #Txt_ReflT
08E2 120620     677            lcall ?Send_Constant_String
08E5 D0E0       677            pop acc
08E7 D082       677            pop dpl
08E9 D083       677            pop dph
08EB 8014       678       sjmp Draw_Temp_Format
08ED            679   Update_State_4:
08ED C083       680            push dph
08EF C082       680            push dpl
08F1 C0E0       680            push acc
08F3 900394     680            mov dptr, #Txt_ReflTime
08F6 120620     680            lcall ?Send_Constant_String
08F9 D0E0       680            pop acc
08FB D082       680            pop dpl
08FD D083       680            pop dph
08FF 801B       681       sjmp Draw_Time_Format
0901            682   
0901            683   ; --- Draw Line 2 (Values) ---
0901            684   Draw_Temp_Format:
0901 C0E0       685            push acc
0903 7401       685            mov a, #1
0905 14         685            dec a
0906 12062B     685            lcall ?Set_Cursor_2 ; Select column and row
0909 D0E0       685            pop acc
090B 120999     686       lcall Get_Current_Buffer_Addr
090E 12097B     687       lcall Print_String_RAM
0911 C0E0       688            push acc
0913 7443       688            mov a, #'C'
0915 1205E3     688            lcall ?WriteData
0918 D0E0       688            pop acc
091A 8034       689       sjmp Restore_Cursor
091C            690   
091C            691   Draw_Time_Format:
091C C0E0       692            push acc
091E 7401       692            mov a, #1
0920 14         692            dec a
0921 12062B     692            lcall ?Set_Cursor_2 ; Select column and row
0924 D0E0       692            pop acc
0926 120999     693       lcall Get_Current_Buffer_Addr
0929            694       ; MM
0929 E6         695       mov A, @R0
092A 1205E3     696       lcall ?WriteData
092D 08         697       inc R0
092E E6         698       mov A, @R0
092F 1205E3     699       lcall ?WriteData
0932 08         700       inc R0
0933            701       ; Colon
0933 C0E0       702            push acc
0935 743A       702            mov a, #':'
0937 1205E3     702            lcall ?WriteData
093A D0E0       702            pop acc
093C            703       ; SS
093C E6         704       mov A, @R0
093D 1205E3     705       lcall ?WriteData
0940 08         706       inc R0
0941 E6         707       mov A, @R0
0942 1205E3     708       lcall ?WriteData
0945            709       ; Unit
0945 C0E0       710            push acc
0947 7473       710            mov a, #'s'
0949 1205E3     710            lcall ?WriteData
094C D0E0       710            pop acc
094E 8000       711       sjmp Restore_Cursor
0950            712   
0950            713   ; --- Restore Cursor Position ---
0950            714   Restore_Cursor:
0950 E561       715       mov A, Current_State
0952 B40202     716       cjne A, #2, RC_Check_State_4  
0955 800C       717       sjmp Adjust_Cursor_Time
0957            718   RC_Check_State_4:             
0957 B40402     719       cjne A, #4, Normal_Cursor
095A 8007       720       sjmp Adjust_Cursor_Time
095C            721   
095C            722   Normal_Cursor:
095C E56A       723       mov A, Cursor_Idx
095E 24C0       724       add A, #0xC0
0960 1205E8     725       lcall ?WriteCommand
0963            726   
0963            727   Adjust_Cursor_Time:
0963            728       ; Skip the colon index (2)
0963 E56A       729       mov A, Cursor_Idx
0965 B40201     730       cjne A, #2, No_Skip
0968 04         731       inc A 
0969            732   No_Skip:
0969            733       ; Add 1 if past the colon
0969 C3         734       clr C
096A 9402       735       subb A, #2
096C 4005       736       jc No_Add
096E E56A       737       mov A, Cursor_Idx
0970 04         738       inc A
0971 8002       739       sjmp Final_Cursor_Set
0973            740   No_Add:
0973 E56A       741       mov A, Cursor_Idx
0975            742   Final_Cursor_Set:
0975 24C0       743       add A, #0xC0
0977 1205E8     744       lcall ?WriteCommand
097A 22         745       ret
097B            746   
097B            747   Print_String_RAM:
097B E6         748       mov A, @R0
097C 6006       749       jz Print_String_Done
097E 1205E3     750       lcall ?WriteData
0981 08         751       inc R0
0982 80F7       752       sjmp Print_String_RAM
0984            753   Print_String_Done:
0984 22         754       ret
0985            755   
0985            756   ; --- Clear Screen with hardware delay ---
0985            757   Clear_Screen_Func:
0985 7401       758            mov a, #0x01
0987 1205E8     758            lcall ?WriteCommand        ; Clear display command
098A C002       759            push AR2
098C 7A02       759            mov R2, #2
098E 12059E     759            lcall ?Wait_Milli_Seconds
0991 D002       759            pop AR2     ; LCD needs ~2ms to clear
0993 740C       760            mov a, #0x0C
0995 1205E8     760            lcall ?WriteCommand        ; Display ON, Cursor OFF
0998 22         761       ret
0999            762   
0999            763   Get_Current_Buffer_Addr:
0999 E561       764       mov A, Current_State
099B B40103     765       cjne A, #1, Get_Buf_2
099E 7880       766       mov R0, #Buf_Soak_Temp
09A0 22         767       ret
09A1            768   Get_Buf_2:
09A1 B40203     769       cjne A, #2, Get_Buf_3
09A4 7884       770       mov R0, #Buf_Soak_Time
09A6 22         771       ret
09A7            772   Get_Buf_3:
09A7 B40303     773       cjne A, #3, Get_Buf_4
09AA 7889       774       mov R0, #Buf_Refl_Temp
09AC 22         775       ret
09AD            776   Get_Buf_4:
09AD 788D       777       mov R0, #Buf_Refl_Time
09AF 22         778       ret
09B0            779   
09B0            780   ;-------------------------------------------------------------------------------
09B0            781   ; Update HEX2-HEX0 with temperature (3 digits)
09B0            782   ;-------------------------------------------------------------------------------
09B0            783   Update_HEX_Temp:
09B0 900648     784       mov dptr, #T_7seg
09B3            785       ; Hundreds -> HEX2
09B3 E543       786       mov a, bcd+1
09B5 540F       787       anl a, #0x0F
09B7 93         788       movc a, @a+dptr
09B8 F593       789       mov HEX2, a
09BA            790       ; Tens -> HEX1
09BA E542       791       mov a, bcd+0
09BC C4         792       swap a
09BD 540F       793       anl a, #0x0F
09BF 93         794       movc a, @a+dptr
09C0 F592       795       mov HEX1, a
09C2            796       ; Ones -> HEX0
09C2 E542       797       mov a, bcd+0
09C4 540F       798       anl a, #0x0F
09C6 93         799       movc a, @a+dptr
09C7 F591       800       mov HEX0, a
09C9 22         801       ret
09CA            802       
09CA            803   ; ----------------------------------------------------------------
09CA            804   ; MODULE: BUTTON HANDLER 
09CA            805   ; ----------------------------------------------------------------
09CA            806   PB0_DEB:
09CA            807   ;non-blocking state machine for PB0 debounce
09CA E572       808       mov a, PB0_DEB_state
09CC            809   PB0_DEB_state0:
09CC B4000A     810       cjne a, #0, PB0_DEB_state1
09CF 20902F     811       jb PB0, PB0_DEB_done
09D2 757100     812       mov PB0_DEB_timer, #0
09D5 0572       813       inc PB0_DEB_state
09D7 8028       814       sjmp PB0_DEB_done
09D9            815   PB0_DEB_state1:
09D9 B40109     816       cjne a, #1, PB0_DEB_state2
09DC            817       ; this is the debounce state
09DC E571       818       mov a, PB0_DEB_timer
09DE B43220     819       cjne a, #50, PB0_DEB_done ; 50 ms passed?
09E1 0572       820       inc PB0_DEB_state
09E3 801C       821       sjmp PB0_DEB_done  
09E5            822   PB0_DEB_state2:
09E5 B4020C     823       cjne a, #2, PB0_DEB_state3
09E8 209004     824       jb PB0, PB0_DEB_state2b
09EB 0572       825       inc PB0_DEB_state
09ED 8012       826       sjmp PB0_DEB_done  
09EF            827   PB0_DEB_state2b:
09EF 757200     828       mov PB0_DEB_state, #0
09F2 800D       829       sjmp PB0_DEB_done
09F4            830   PB0_DEB_state3:
09F4 B4030A     831       cjne a, #3, PB0_DEB_done
09F7 309007     832       jnb PB0, PB0_DEB_done
09FA D215       833       setb PB0_flag ; Suscesfully detected a valid PB0 press/release
09FC B2ED       834            cpl LEDRA.5
09FE 757200     835       mov PB0_DEB_state, #0  
0A01            836   PB0_DEB_done:
0A01 22         837       ret
0A02            838   
0A02            839   PB2_DEB:
0A02            840   ;non-blocking state machine for PB2 debounce
0A02 E574       841       mov a, PB2_DEB_state
0A04            842   PB2_DEB_state0:
0A04 B4000A     843       cjne a, #0, PB2_DEB_state1
0A07 20B72D     844       jb PB2, PB2_DEB_done
0A0A 757300     845       mov PB2_DEB_timer, #0
0A0D 0574       846       inc PB2_DEB_state
0A0F 8026       847       sjmp PB2_DEB_done
0A11            848   PB2_DEB_state1:
0A11 B40109     849       cjne a, #1, PB2_DEB_state2
0A14            850       ; this is the debounce state
0A14 E573       851       mov a, PB2_DEB_timer
0A16 B4321E     852       cjne a, #50, PB2_DEB_done ; 50 ms passed?
0A19 0574       853       inc PB2_DEB_state
0A1B 801A       854       sjmp PB2_DEB_done  
0A1D            855   PB2_DEB_state2:
0A1D B4020C     856       cjne a, #2, PB2_DEB_state3
0A20 20B704     857       jb PB2, PB2_DEB_state2b
0A23 0574       858       inc PB2_DEB_state
0A25 8010       859       sjmp PB2_DEB_done  
0A27            860   PB2_DEB_state2b:
0A27 757400     861       mov PB2_DEB_state, #0
0A2A 800B       862       sjmp PB2_DEB_done
0A2C            863   PB2_DEB_state3:
0A2C B40308     864       cjne a, #3, PB2_DEB_done
0A2F 30B705     865       jnb PB2, PB2_DEB_done
0A32 D217       866       setb PB2_flag ; Suscesfully detected a valid PB2 press/release
0A34 757400     867       mov PB2_DEB_state, #0  
0A37            868   PB2_DEB_done:
0A37 22         869       ret
0A38            870   
0A38            871   Check_Buttons:
0A38 C0E0       872       push ACC
0A3A C0D0       873       push PSW
0A3C            874       
0A3C            875       ; Only process in Control_FSM_state 1
0A3C E560       876       mov a, Control_FSM_state
0A3E B40107     877       cjne a, #1, Check_Buttons_Done_bridge
0A41            878       
0A41            879       ; --- FORCE INPUT MODE ---
0A41 438055     880       orl P0, #055H   ; Sets P0.0, P0.2, P0.4, P0.6 to '1' (Input Mode)
0A44            881       
0A44 E575       882       mov a, BTN_DEB_state
0A46            883       
0A46 8003       884       sjmp BTN_DEB_state0
0A48            885   Check_Buttons_Done_bridge:
0A48 020AF2     886       ljmp Check_Buttons_Done
0A4B            887   
0A4B            888   ; ============================================================
0A4B            889   ; State 0: Wait for any button press
0A4B            890   ; ============================================================
0A4B            891   BTN_DEB_state0:
0A4B B4002A     892       cjne a, #0, BTN_DEB_state1
0A4E            893       
0A4E            894       ; Check each button, record which one was pressed
0A4E 30800C     895       jnb BTN_SOAK_TEMP, BTN_Detect_SoakTemp
0A51 30820E     896       jnb BTN_SOAK_TIME, BTN_Detect_SoakTime
0A54 308410     897       jnb BTN_REFL_TEMP, BTN_Detect_ReflTemp
0A57 308612     898       jnb BTN_REFL_TIME, BTN_Detect_ReflTime
0A5A 020AF2     899       ljmp Check_Buttons_Done     ; No button pressed
0A5D            900   
0A5D            901   BTN_Detect_SoakTemp:
0A5D 757701     902       mov BTN_DEB_id, #1
0A60 800F       903       sjmp BTN_Start_Debounce
0A62            904   BTN_Detect_SoakTime:
0A62 757702     905       mov BTN_DEB_id, #2
0A65 800A       906       sjmp BTN_Start_Debounce
0A67            907   BTN_Detect_ReflTemp:
0A67 757703     908       mov BTN_DEB_id, #3
0A6A 8005       909       sjmp BTN_Start_Debounce
0A6C            910   BTN_Detect_ReflTime:
0A6C 757704     911       mov BTN_DEB_id, #4
0A6F 8000       912       sjmp BTN_Start_Debounce
0A71            913   
0A71            914   BTN_Start_Debounce:
0A71 757600     915       mov BTN_DEB_timer, #0
0A74 0575       916       inc BTN_DEB_state
0A76 807A       917       sjmp Check_Buttons_Done
0A78            918   
0A78            919   ; ============================================================
0A78            920   ; State 1: Debounce delay (wait 50ms)
0A78            921   ; ============================================================
0A78            922   BTN_DEB_state1:
0A78 B40109     923       cjne a, #1, BTN_DEB_state2
0A7B E576       924       mov a, BTN_DEB_timer
0A7D B43272     925       cjne a, #50, Check_Buttons_Done   ; Wait 50ms
0A80 0575       926       inc BTN_DEB_state
0A82 806E       927       sjmp Check_Buttons_Done
0A84            928   
0A84            929   ; ============================================================
0A84            930   ; State 2: Verify button still pressed
0A84            931   ; ============================================================
0A84            932   BTN_DEB_state2:
0A84 B40226     933       cjne a, #2, BTN_DEB_state3
0A87            934       
0A87            935       ; Check if the same button is still pressed
0A87 E577       936       mov a, BTN_DEB_id
0A89 B40105     937       cjne a, #1, BTN_Verify_Check2
0A8C 30801A     938       jnb BTN_SOAK_TEMP, BTN_Verify_OK
0A8F 8013       939       sjmp BTN_Verify_Fail
0A91            940   BTN_Verify_Check2:
0A91 B40205     941       cjne a, #2, BTN_Verify_Check3
0A94 308212     942       jnb BTN_SOAK_TIME, BTN_Verify_OK
0A97 800B       943       sjmp BTN_Verify_Fail
0A99            944   BTN_Verify_Check3:
0A99 B40305     945       cjne a, #3, BTN_Verify_Check4
0A9C 30840A     946       jnb BTN_REFL_TEMP, BTN_Verify_OK
0A9F 8003       947       sjmp BTN_Verify_Fail
0AA1            948   BTN_Verify_Check4:
0AA1 308605     949       jnb BTN_REFL_TIME, BTN_Verify_OK
0AA4            950       ; Fall through to fail
0AA4            951   
0AA4            952   BTN_Verify_Fail:
0AA4 757500     953       mov BTN_DEB_state, #0           ; Was noise, reset
0AA7 8049       954       sjmp Check_Buttons_Done
0AA9            955   
0AA9            956   BTN_Verify_OK:
0AA9 0575       957       inc BTN_DEB_state               ; Confirmed, wait for release
0AAB 8045       958       sjmp Check_Buttons_Done
0AAD            959   
0AAD            960   ; ============================================================
0AAD            961   ; State 3: Wait for button release, then trigger action
0AAD            962   ; ============================================================
0AAD            963   BTN_DEB_state3:
0AAD B40342     964       cjne a, #3, Check_Buttons_Done
0AB0            965       
0AB0            966       ; Check if the button is released
0AB0 E577       967       mov a, BTN_DEB_id
0AB2 B40105     968       cjne a, #1, BTN_Release_Check2
0AB5 30803A     969       jnb BTN_SOAK_TEMP, Check_Buttons_Done   ; Still pressed, wait
0AB8 8013       970       sjmp BTN_Do_Action
0ABA            971   BTN_Release_Check2:
0ABA B40205     972       cjne a, #2, BTN_Release_Check3
0ABD 308232     973       jnb BTN_SOAK_TIME, Check_Buttons_Done
0AC0 800B       974       sjmp BTN_Do_Action
0AC2            975   BTN_Release_Check3:
0AC2 B40305     976       cjne a, #3, BTN_Release_Check4
0AC5 30842A     977       jnb BTN_REFL_TEMP, Check_Buttons_Done
0AC8 8003       978       sjmp BTN_Do_Action
0ACA            979   BTN_Release_Check4:
0ACA 308625     980       jnb BTN_REFL_TIME, Check_Buttons_Done
0ACD            981       ; Fall through to action
0ACD            982   
0ACD            983   ; ============================================================
0ACD            984   ; Button Released - Execute Action
0ACD            985   ; ============================================================
0ACD            986   BTN_Do_Action:
0ACD E577       987       mov a, BTN_DEB_id
0ACF            988       
0ACF B40105     989       cjne a, #1, BTN_Action_2
0AD2 756101     990       mov Current_State, #1           ; Soak Temp
0AD5 8013       991       sjmp BTN_Action_Complete
0AD7            992   BTN_Action_2:
0AD7 B40205     993       cjne a, #2, BTN_Action_3
0ADA 756102     994       mov Current_State, #2           ; Soak Time
0ADD 800B       995       sjmp BTN_Action_Complete
0ADF            996   BTN_Action_3:
0ADF B40305     997       cjne a, #3, BTN_Action_4
0AE2 756103     998       mov Current_State, #3           ; Refl Temp
0AE5 8003       999       sjmp BTN_Action_Complete
0AE7           1000   BTN_Action_4:
0AE7 756104    1001       mov Current_State, #4           ; Refl Time
0AEA           1002   
0AEA           1003   BTN_Action_Complete:
0AEA 756A00    1004       mov Cursor_Idx, #0
0AED D224      1005       setb fullscreen_update_signal   ; Trigger screen redraw
0AEF 757500    1006       mov BTN_DEB_state, #0           ; Reset state machine
0AF2           1007   
0AF2           1008   Check_Buttons_Done:
0AF2 D0D0      1009       pop PSW
0AF4 D0E0      1010       pop ACC
0AF6 22        1011       ret
0AF7           1012   
0AF7           1013   ; ------------------------------------------------------------------------------
0AF7           1014   ; Non-blocking FSM for the one second counter
0AF7           1015   ;-------------------------------------------------------------------------------
0AF7           1016   SEC_FSM:
0AF7 E570      1017       mov a, SEC_FSM_state
0AF9           1018   SEC_FSM_state0:
0AF9 B4000C    1019       cjne a, #0, SEC_FSM_state1
0AFC E56F      1020       mov a, SEC_FSM_timer
0AFE B4FA51    1021       cjne a, #250, SEC_FSM_done
0B01 756F00    1022       mov SEC_FSM_timer, #0
0B04 0570      1023       inc SEC_FSM_state
0B06 804A      1024       sjmp SEC_FSM_done
0B08           1025   SEC_FSM_state1:  
0B08 B4010E    1026       cjne a, #1, SEC_FSM_state2
0B0B D2E9      1027       setb LEDRA.1
0B0D E56F      1028       mov a, SEC_FSM_timer
0B0F B4FA40    1029       cjne a, #250, SEC_FSM_done
0B12 756F00    1030       mov SEC_FSM_timer, #0
0B15 0570      1031       inc SEC_FSM_state
0B17 8039      1032       sjmp SEC_FSM_done
0B19           1033   SEC_FSM_state2:  
0B19 B4020E    1034       cjne a, #2, SEC_FSM_state3
0B1C D2EA      1035       setb LEDRA.2
0B1E E56F      1036       mov a, SEC_FSM_timer
0B20 B4FA2F    1037       cjne a, #250, SEC_FSM_done
0B23 756F00    1038       mov SEC_FSM_timer, #0
0B26 0570      1039       inc SEC_FSM_state
0B28 8028      1040       sjmp SEC_FSM_done
0B2A           1041   SEC_FSM_state3:  
0B2A B40325    1042       cjne a, #3, SEC_FSM_done
0B2D D2EB      1043       setb LEDRA.3
0B2F E56F      1044       mov a, SEC_FSM_timer
0B31 B4FA1E    1045       cjne a, #250, SEC_FSM_done
0B34 756F00    1046       mov SEC_FSM_timer, #0
0B37 757000    1047       mov SEC_FSM_state, #0
0B3A           1048       
0B3A           1049       ; These flags are always set (global use)
0B3A D204      1050       setb one_second_lcd_flag
0B3C D201      1051       setb one_second_flag
0B3E           1052       
0B3E           1053       ; Heartbeat LED always toggles
0B3E B2E8      1054       cpl LEDRA.0
0B40           1055       
0B40           1056       ; Only update time if counting is enabled
0B40 300D0F    1057       jnb time_count_doing_signal, SEC_FSM_done
0B43           1058       
0B43           1059       ; Update current time (only when counting)
0B43 E530      1060       mov a, current_time_sec
0B45 04        1061       inc a
0B46 B43C07    1062       cjne a, #60, SEC_NoMinuteCarry
0B49 753000    1063       mov current_time_sec, #0
0B4C 0531      1064       inc current_time_minute
0B4E 8002      1065       sjmp SEC_FSM_done
0B50           1066   SEC_NoMinuteCarry:
0B50 F530      1067       mov current_time_sec, a
0B52           1068   SEC_FSM_done:
0B52 22        1069       ret
0B53           1070   
0B53           1071   ; ------------------------------------------------------------------------------
0B53           1072   ; Counting the processing time 
0B53           1073   ;-------------------------------------------------------------------------------
0B53           1074   Time_Counter:
0B53 C0E0      1075       push ACC
0B55 C0D0      1076       push psw
0B57 E560      1077       mov a, Control_FSM_state
0B59           1078       
0B59           1079       ; State 2: Start counting
0B59 B4020F    1080       cjne a, #2, Time_Counter_Nstate2
0B5C 101102    1081       jbc state_change_signal_Count, Time_Counter_Start
0B5F 800F      1082       sjmp Time_Counter_Done
0B61           1083   
0B61           1084   Time_Counter_Start:
0B61 753000    1085       mov current_time_sec, #0
0B64 753100    1086       mov current_time_minute, #0
0B67 D20D      1087       setb time_count_doing_signal
0B69 8005      1088       sjmp Time_Counter_Done
0B6B           1089   
0B6B           1090   Time_Counter_Nstate2:
0B6B           1091       ; State 6: Stop counting
0B6B B40602    1092       cjne a, #6, Time_Counter_Done
0B6E C20D      1093       clr time_count_doing_signal
0B70           1094   
0B70           1095   Time_Counter_Done:
0B70 D0D0      1096       pop psw
0B72 D0E0      1097       pop ACC
0B74 22        1098       ret
0B75           1099   
0B75           1100   
0B75           1101   ;-------------------------------------------------------------------------------
0B75           1102   ; Time_Compare_MMSS
0B75           1103   ;
0B75           1104   ; PURPOSE:
0B75           1105   ;   Compare elapsed time (current_time_minute:current_time_sec)
0B75           1106   ;   against soak and reflow setpoints (soak_time_*, reflow_time_*).
0B75           1107   ;
0B75           1108   ; BEHAVIOR:
0B75           1109   ;   - If current_time >= soak_time   if soak_time_reached    = 1
0B75           1110   ;   - If current_time >= reflow_time if reflow_time_reached = 1
0B75           1111   ;
0B75           1112   ; NOTES:
0B75           1113   ;   Compare minutes first, then seconds.
0B75           1114   ;-------------------------------------------------------------------------------
0B75           1115   Time_Compare_MMSS:
0B75 C0E0      1116       push acc
0B77 C0D0      1117       push psw
0B79           1118   
0B79 E560      1119            mov a, Control_FSM_state
0B7B B4032E    1120            cjne a, #3, TC_Not_Soak
0B7E           1121   ; soak state time comparison
0B7E 101002    1122            jbc state_change_signal_TC, TC_Soak_Start_Record
0B81 8015      1123            sjmp TC_Soak_Comparing
0B83           1124   
0B83           1125   TC_Soak_Start_Record:
0B83 E531      1126            mov a, current_time_minute
0B85 2533      1127            add a, soak_time_minute
0B87 F537      1128            mov soak_end_time_minute, a
0B89           1129   
0B89 E530      1130            mov a, current_time_sec
0B8B 2532      1131            add a, soak_time_sec
0B8D F536      1132            mov soak_end_time_sec, a
0B8F           1133   
0B8F C3        1134            clr c
0B90 943C      1135            subb a, #60
0B92 4004      1136            jc TC_Soak_Comparing
0B94           1137   
0B94 F536      1138            mov soak_end_time_sec, a
0B96 0537      1139            inc soak_end_time_minute
0B98           1140   
0B98           1141   TC_Soak_Comparing:
0B98 E531      1142       mov  a, current_time_minute
0B9A C3        1143       clr  c
0B9B 9537      1144       subb a, soak_end_time_minute
0B9D 403C      1145            jc   TC_Done                   ; current_min < end_min
0B9F 7007      1146       jnz  TC_Soak_Reached           ; current_min > end_min
0BA1           1147   
0BA1           1148       ; minutes equal -> compare seconds
0BA1 E530      1149       mov  a, current_time_sec
0BA3 C3        1150       clr  c
0BA4 9536      1151       subb a, soak_end_time_sec
0BA6 7033      1152       jnz   TC_Done
0BA8           1153   
0BA8           1154   TC_Soak_Reached:
0BA8 D208      1155       setb soak_time_reached
0BAA 802F      1156            sjmp TC_Done
0BAC           1157   
0BAC           1158   TC_Not_Soak:
0BAC E560      1159            mov a, Control_FSM_state
0BAE B4052A    1160            cjne a, #5, TC_Done
0BB1           1161   ; soak state time comparison
0BB1 101002    1162            jbc state_change_signal_TC, TC_Reflow_Start_Record
0BB4 8013      1163            sjmp TC_Reflow_Comparing
0BB6           1164   
0BB6           1165   TC_Reflow_Start_Record:
0BB6 E531      1166            mov a, current_time_minute
0BB8 2535      1167            add a, reflow_time_minute
0BBA F539      1168            mov reflow_end_time_minute, a
0BBC           1169   
0BBC E530      1170            mov a, current_time_sec
0BBE 2534      1171            add a, reflow_time_sec
0BC0 F538      1172            mov reflow_end_time_sec, a
0BC2 C3        1173            clr c
0BC3 943C      1174            subb a, #60
0BC5           1175   
0BC5 F538      1176            mov reflow_end_time_sec, a
0BC7 0539      1177            inc reflow_end_time_minute
0BC9           1178   
0BC9           1179   TC_Reflow_Comparing:
0BC9 E531      1180       mov  a, current_time_minute
0BCB C3        1181       clr  c
0BCC 9539      1182       subb a, reflow_end_time_minute
0BCE 400B      1183       jc   TC_Done
0BD0 7007      1184       jnz  TC_Reflow_Reached
0BD2           1185   
0BD2 E530      1186       mov  a, current_time_sec
0BD4 C3        1187       clr  c
0BD5 9538      1188       subb a, reflow_end_time_sec
0BD7 4002      1189            jc   TC_Done
0BD9           1190   
0BD9           1191   TC_Reflow_Reached:
0BD9 D209      1192       setb reflow_time_reached
0BDB           1193   
0BDB           1194   TC_Done:
0BDB D0D0      1195       pop  psw
0BDD D0E0      1196       pop  acc
0BDF 22        1197       ret
0BE0           1198   
0BE0           1199   ;-------------------------------------------------------------------------------;
0BE0           1200   ; Temp_Compare
0BE0           1201   ; Checks if we have reached the user's target temperatures.
0BE0           1202   ; Only compares relevant temperature based on current Control_FSM_state:
0BE0           1203   ;   State 2: Sets 'soak_temp_reached' if current_temp >= soak_temp
0BE0           1204   ;   State 4: Sets 'reflow_temp_reached' if current_temp >= reflow_temp
0BE0           1205   ;   State 6: Sets 'cooling_temp_reached' if current_temp < 100C
0BE0           1206   ;-------------------------------------------------------------------------------;
0BE0           1207   Temp_Compare:
0BE0 C0E0      1208       push acc
0BE2 C0D0      1209       push psw
0BE4 C000      1210       push AR0
0BE6 C001      1211       push AR1
0BE8 C002      1212       push AR2
0BEA           1213       
0BEA E560      1214       mov a, Control_FSM_state
0BEC           1215       
0BEC           1216       ; --- CHECK STATE 2: SOAK TEMP ---
0BEC B40202    1217       cjne a, #2, Temp_Compare_Check_State4
0BEF 800A      1218       sjmp Check_Soak_Threshold
0BF1           1219       
0BF1           1220   Temp_Compare_Check_State4:
0BF1           1221       ; --- CHECK STATE 4: REFLOW TEMP ---
0BF1 B40402    1222       cjne a, #4, Temp_Compare_Check_State6
0BF4 801D      1223       sjmp Check_Reflow_Threshold
0BF6           1224       
0BF6           1225   Temp_Compare_Check_State6:
0BF6           1226       ; --- CHECK STATE 6: COOLING TEMP ---
0BF6 B4064D    1227       cjne a, #6, Temp_Compare_Done
0BF9 8030      1228       sjmp Check_Cooling_Threshold
0BFB           1229   
0BFB           1230   Check_Soak_Threshold:
0BFB           1231       ; Copy current_temp to X
0BFB 7847      1232       mov R0, #current_temp
0BFD 793A      1233       mov R1, #x
0BFF 120C51    1234       lcall Copy4_Bytes_R0_to_R1
0C02           1235   
0C02           1236       ; Copy soak_temp to Y
0C02 784B      1237       mov R0, #soak_temp
0C04 793E      1238       mov R1, #y
0C06 120C51    1239       lcall Copy4_Bytes_R0_to_R1
0C09           1240   
0C09           1241       ; Compare: Is X (Current) < Y (Target)?
0C09 12011A    1242       lcall x_lt_y
0C0C 200037    1243       jb mf, Temp_Compare_Done          ; If Current < Target, not reached yet
0C0F           1244       
0C0F           1245       ; If Current >= Target
0C0F D205      1246       setb soak_temp_reached
0C11 8033      1247       sjmp Temp_Compare_Done
0C13           1248   
0C13           1249   Check_Reflow_Threshold:
0C13           1250       ; Copy current_temp to X
0C13 7847      1251       mov R0, #current_temp
0C15 793A      1252       mov R1, #x
0C17 120C51    1253       lcall Copy4_Bytes_R0_to_R1
0C1A           1254   
0C1A           1255       ; Copy reflow_temp to Y
0C1A 784F      1256       mov R0, #reflow_temp
0C1C 793E      1257       mov R1, #y
0C1E 120C51    1258       lcall Copy4_Bytes_R0_to_R1
0C21           1259   
0C21           1260       ; Compare
0C21 12011A    1261       lcall x_lt_y
0C24 20001F    1262       jb mf, Temp_Compare_Done          ; If Current < Target, not reached yet
0C27           1263       
0C27           1264       ; If Current >= Target
0C27 D206      1265       setb reflow_temp_reached
0C29 801B      1266       sjmp Temp_Compare_Done
0C2B           1267   
0C2B           1268   Check_Cooling_Threshold:
0C2B           1269       ; Copy current_temp to X
0C2B 7847      1270       mov R0, #current_temp
0C2D 793A      1271       mov R1, #x
0C2F 120C51    1272       lcall Copy4_Bytes_R0_to_R1
0C32           1273       
0C32 753E64    1274            mov y+0, #low (100 % 0x10000) 
0C35 753F00    1274            mov y+1, #high(100 % 0x10000) 
0C38 754000    1274            mov y+2, #low (100 / 0x10000) 
0C3B 754100    1274            mov y+3, #high(100 / 0x10000)                         ; Cooling target = 100C
0C3E 12011A    1275       lcall x_lt_y
0C41 300002    1276       jnb mf, Temp_Compare_Done         ; If temp >= 100, not cooled yet
0C44           1277       
0C44           1278       ; If Current < 100C
0C44 D207      1279       setb cooling_temp_reached
0C46           1280   
0C46           1281   ; ---------------------------------------------------------
0C46           1282   Temp_Compare_Done:
0C46 D002      1283       pop AR2
0C48 D001      1284       pop AR1
0C4A D000      1285       pop AR0
0C4C D0D0      1286       pop psw
0C4E D0E0      1287       pop acc
0C50 22        1288       ret
0C51           1289   
0C51           1290   ;-------------------------------------------------------------------------------;
0C51           1291   ; Copy4_Bytes_R0_to_R1
0C51           1292   ;
0C51           1293   ; PURPOSE:
0C51           1294   ;   Utility routine to copy a 32-bit value (4 bytes)
0C51           1295   ;   from one memory location to another.
0C51           1296   ;
0C51           1297   ; INPUTS:
0C51           1298   ;   R0 st source address
0C51           1299   ;   R1 at destination address
0C51           1300   ;
0C51           1301   ; USES:
0C51           1302   ;   R2 as loop counter
0C51           1303   ;
0C51           1304   ; EXAMPLE:
0C51           1305   ;   mov R0, #current_temp
0C51           1306   ;   mov R1, #x
0C51           1307   ;   lcall Copy4_Bytes_R0_to_R1
0C51           1308   ;-------------------------------------------------------------------------------;
0C51           1309   Copy4_Bytes_R0_to_R1:
0C51 7A04      1310       mov  R2, #4
0C53           1311   Copy4_Loop:
0C53 E6        1312       mov  a, @R0
0C54 F7        1313       mov  @R1, a
0C55 08        1314       inc  R0
0C56 09        1315       inc  R1
0C57 DAFA      1316       djnz R2, Copy4_Loop
0C59 22        1317       ret
0C5A           1318   
0C5A           1319   ;-------------------------------------------------------------------------------
0C5A           1320   ; PWM
0C5A           1321   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0C5A           1322   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0C5A           1323   ; ------------------------------------------------------------------------------
0C5A           1324   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0C5A 100202    1325       jbc one_ms_pwm_flag, pwm_wave_generator
0C5D 8071      1326       sjmp end_pwm_generator
0C5F           1327   
0C5F           1328   pwm_wave_generator:
0C5F C200      1329       clr mf
0C61           1330       ; move pwm counter value into x for comparison purpose
0C61 855C3A    1331       mov x, pwm_counter
0C64 855D3B    1332       mov x+1, pwm_counter+1
0C67 855E3C    1333       mov x+2, pwm_counter+2
0C6A 855F3D    1334       mov x+3, pwm_counter+3
0C6D           1335   
0C6D 753EDB    1336            mov y+0, #low (PWM_PERIOD % 0x10000) 
0C70 753F05    1336            mov y+1, #high(PWM_PERIOD % 0x10000) 
0C73 754000    1336            mov y+2, #low (PWM_PERIOD / 0x10000) 
0C76 754100    1336            mov y+3, #high(PWM_PERIOD / 0x10000) 
0C79           1337   
0C79           1338       ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
0C79           1339       ; increase x by 1
0C79 120152    1340       lcall x_eq_y 
0C7C 20001D    1341       jb mf, wrap_pwm_counter
0C7F           1342       ; x not equal 1499, increment by 1
0C7F 753E01    1343            mov y+0, #low (1 % 0x10000) 
0C82 753F00    1343            mov y+1, #high(1 % 0x10000) 
0C85 754000    1343            mov y+2, #low (1 / 0x10000) 
0C88 754100    1343            mov y+3, #high(1 / 0x10000) 
0C8B 1200D3    1344       lcall add32
0C8E           1345       ; update pwm_counter
0C8E 853A5C    1346       mov pwm_counter, x
0C91 853B5D    1347       mov pwm_counter+1, x+1
0C94 853C5E    1348       mov pwm_counter+2, x+2
0C97 853D5F    1349       mov pwm_counter+3, x+3
0C9A 8018      1350       sjmp set_pwm
0C9C           1351   
0C9C           1352   wrap_pwm_counter:
0C9C           1353       ; x equal 1499, wrap to 0
0C9C 753A00    1354            mov x+0, #low (0 % 0x10000) 
0C9F 753B00    1354            mov x+1, #high(0 % 0x10000) 
0CA2 753C00    1354            mov x+2, #low (0 / 0x10000) 
0CA5 753D00    1354            mov x+3, #high(0 / 0x10000) 
0CA8 853A5C    1355       mov pwm_counter, x
0CAB 853B5D    1356       mov pwm_counter+1, x+1
0CAE 853C5E    1357       mov pwm_counter+2, x+2
0CB1 853D5F    1358       mov pwm_counter+3, x+3
0CB4           1359   
0CB4           1360   set_pwm:
0CB4           1361       ; compare with power_output, if pwm counter smaller than power_output, 
0CB4           1362       ; set pwm pin high; else set pwm pin low load y with power output value
0CB4 85583E    1363       mov y, power_output
0CB7 85593F    1364       mov y+1, power_output+1
0CBA 855A40    1365       mov y+2, power_output+2
0CBD 855B41    1366       mov y+3, power_output+3
0CC0           1367   
0CC0           1368       ; compare x(pwm counter) with y(power output)
0CC0 12011A    1369       lcall x_lt_y
0CC3 200006    1370       jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
0CC6           1371       ;output set pwm pin low if pwm counter greater than power output
0CC6 C293      1372       clr PWM_OUT
0CC8 C2EC      1373       clr LEDRA.4
0CCA 8004      1374       sjmp end_pwm_generator
0CCC           1375   
0CCC           1376   set_pwm_high:
0CCC D293      1377       setb PWM_OUT
0CCE D2EC      1378       setb LEDRA.4
0CD0           1379   
0CD0           1380   end_pwm_generator:
0CD0 22        1381       ret
0CD1           1382   
0CD1           1383   ;-------------------------------------------------------------------------------
0CD1           1384   
0CD1           1385   ;-------------------------------------------------------------------------------;
0CD1           1386   ; Abort condition safety check Temperature time
0CD1           1387   ;
0CD1           1388   ; PURPOSE:
0CD1           1389   ;   Automatic cycle termination on error:
0CD1           1390   ;   Abort if oven fails to reach at least 50C in first 60s.
0CD1           1391   ;
0CD1           1392   ; TRIP CONDITION:
0CD1           1393   ;   if (current_time >= 60s) AND (current_temp < 50C)
0CD1           1394   ;       -> set tc_missing_abort
0CD1           1395   ;       -> set stop_signal
0CD1           1396   ;
0CD1           1397   ; ASSUMPTIONS:
0CD1           1398   ;   - current_time is in SECONDS (32-bit, little-endian)
0CD1           1399   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
0CD1           1400   ;
0CD1           1401   ;   the Load_Y constants accordingly.
0CD1           1402   ;-------------------------------------------------------------------------------;
0CD1           1403   ;-------------------------------------------------------------------------------;
0CD1           1404   ; Abort condition safety check Temperature time
0CD1           1405   ;
0CD1           1406   ; PURPOSE:
0CD1           1407   ;   Automatic cycle termination on error:
0CD1           1408   ;   Abort if oven fails to reach at least 50C in first 60s (1 minute).
0CD1           1409   ;
0CD1           1410   ; TRIP CONDITION:
0CD1           1411   ;   if (current_time_minute >= 1) AND (current_temp < 50C)
0CD1           1412   ;       -> set tc_missing_abort
0CD1           1413   ;       -> set stop_signal
0CD1           1414   ;
0CD1           1415   ; ASSUMPTIONS:
0CD1           1416   ;   - current_time_sec (byte): seconds 0-59
0CD1           1417   ;   - current_time_minute (byte): minutes counter
0CD1           1418   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
0CD1           1419   ;-------------------------------------------------------------------------------;
0CD1           1420   Safety_Check_TC:
0CD1 C0E0      1421       push acc
0CD3 C0D0      1422       push psw
0CD5 C000      1423       push AR0
0CD7 C001      1424       push AR1
0CD9           1425   
0CD9           1426       ; ---------------------------------------------------------
0CD9           1427       ; GATEKEEPER: IGNORE UNLESS IN STATE 2 (RAMP TO SOAK)
0CD9           1428       ; ---------------------------------------------------------
0CD9 E560      1429       mov a, Control_FSM_state
0CDB B40202    1430       cjne a, #2, Safety_TC_Exit_Bridge ; If State != 2, skip everything
0CDE 8003      1431       sjmp Safety_Logic_Proceed         ; If State == 2, do the check
0CE0           1432   
0CE0           1433   Safety_TC_Exit_Bridge:
0CE0 020D19    1434       ljmp Safety_TC_Done               ; Jump to the end
0CE3           1435   
0CE3           1436   Safety_Logic_Proceed:
0CE3           1437       ; If already aborted or startup window closed, do nothing
0CE3 201333    1438       jb   tc_missing_abort, Safety_TC_Done
0CE6 301430    1439       jnb  tc_startup_window, Safety_TC_Done
0CE9           1440   
0CE9           1441       ; Check: current_time_minute >= 1 ? (has 1 minute passed?)
0CE9 E531      1442       mov  a, current_time_minute
0CEB 602C      1443       jz   Safety_TC_Done               ; minute == 0, still waiting
0CED           1444   
0CED           1445       ; We reached 1 minute: close the startup window so it won't re-check later
0CED C214      1446       clr  tc_startup_window
0CEF           1447   
0CEF           1448       ; Now check: current_temp < 50 ?
0CEF 7847      1449       mov  R0, #current_temp
0CF1 793A      1450       mov  R1, #x
0CF3 120C51    1451       lcall Copy4_Bytes_R0_to_R1
0CF6           1452   
0CF6 753E32    1453            mov y+0, #low (50 % 0x10000) 
0CF9 753F00    1453            mov y+1, #high(50 % 0x10000) 
0CFC 754000    1453            mov y+2, #low (50 / 0x10000) 
0CFF 754100    1453            mov y+3, #high(50 / 0x10000) 
0D02 12011A    1454       lcall x_lt_y
0D05 300011    1455       jnb  mf, Safety_TC_Done           ; temp >= 50  pass
0D08           1456   
0D08           1457       ; FAIL: at 1 minute, still below 50C  abort
0D08 C293      1458       clr  PWM_OUT
0D0A D213      1459       setb tc_missing_abort
0D0C D20B      1460       setb stop_signal
0D0E 120D56    1461       lcall Beep_Ten
0D11           1462       
0D11           1463       ; Force FSM to State 0 (Welcome)
0D11 756000    1464       mov Control_FSM_state, #0
0D14           1465       
0D14           1466       ; Force UI to State 0 (Home Screen)
0D14 756100    1467       mov Current_State, #0
0D17           1468       
0D17           1469       ; Trigger Screen Refresh
0D17 D20F      1470       setb state_change_signal          ; Tell loop to redraw "Welcome"
0D19           1471   
0D19           1472   Safety_TC_Done:
0D19 D001      1473       pop  AR1
0D1B D000      1474       pop  AR0
0D1D D0D0      1475       pop  psw
0D1F D0E0      1476       pop  acc
0D21 22        1477       ret
0D22           1478   
0D22           1479   ; ============================================================
0D22           1480   ; BUZZER STARTUP FUNCTIONS
0D22           1481   ; ============================================================
0D22           1482   ;============================================================
0D22           1483   ; Beep_Judge
0D22           1484   ; Purpose: Trigger appropriate beep pattern based on events
0D22           1485   ;   - Beep once when state changes
0D22           1486   ;   - Beep five times when entering state 6 (cooling/finished)
0D22           1487   ;   - Beep ten times if tc_missing_abort = 1 (error)
0D22           1488   ;
0D22           1489   ; Call this in main loop after Control_FSM
0D22           1490   ;============================================================
0D22           1491   Beep_Judge:
0D22 C0E0      1492       push acc
0D24 C0D0      1493       push psw
0D26           1494   
0D26           1495       ; --- Priority 1: Error condition (highest priority) ---
0D26 30130A    1496       jnb tc_missing_abort, Beep_Judge_Check_State6
0D29           1497       ; Error detected - beep 10 times (only once per error)
0D29 20191B    1498       jb beep_error_done, Beep_Judge_Done   ; Already beeped for this error?
0D2C D219      1499       setb beep_error_done                   ; Mark as handled
0D2E 120D56    1500       lcall Beep_Ten
0D31 8014      1501       sjmp Beep_Judge_Done
0D33           1502   
0D33           1503   Beep_Judge_Check_State6:
0D33           1504       ; --- Priority 2: Entering State 6 (finished) ---
0D33 301211    1505       jnb state_change_beep_signal, Beep_Judge_Done  ; No state change? Exit
0D36           1506       
0D36 E560      1507       mov a, Control_FSM_state
0D38 B40607    1508       cjne a, #6, Beep_Judge_Normal_Change
0D3B           1509       ; Entering state 6 - beep 5 times
0D3B C212      1510       clr state_change_beep_signal               ; Consume the signal
0D3D 120D51    1511       lcall Beep_Five
0D40 8005      1512       sjmp Beep_Judge_Done
0D42           1513   
0D42           1514   Beep_Judge_Normal_Change:
0D42           1515       ; --- Priority 3: Normal state change - beep once ---
0D42 C212      1516       clr state_change_beep_signal               ; Consume the signal
0D44 120D4C    1517       lcall Beep_Once
0D47           1518   
0D47           1519   Beep_Judge_Done:
0D47 D0D0      1520       pop psw
0D49 D0E0      1521       pop acc
0D4B 22        1522       ret
0D4C           1523   
0D4C           1524   Beep_Once:
0D4C 757801    1525       mov beep_count, #1
0D4F 800A      1526       sjmp Beep_Start
0D51           1527   
0D51           1528   Beep_Five:
0D51 757805    1529       mov beep_count, #5
0D54 8005      1530       sjmp Beep_Start
0D56           1531   
0D56           1532   Beep_Ten:
0D56 75780A    1533       mov beep_count, #10
0D59 8000      1534       sjmp Beep_Start      ; [FIX] Added explicit jump for safety
0D5B           1535   
0D5B           1536   Beep_Start:
0D5B C28C      1537       clr TR0              ; [FIX] Stop timer briefly to reset cleanly
0D5D 757901    1538       mov beep_state, #1   ; Set State to ON
0D60 757A00    1539       mov beep_tmr, #0     ; Reset Timer High Byte
0D63 757B00    1540       mov beep_tmr+1, #0   ; Reset Timer Low Byte
0D66 D2A9      1541       setb ET0             ; [FIX] Ensure Interrupt is enabled
0D68 D28C      1542       setb TR0             ; START the 2kHz tone
0D6A 22        1543       ret
0D6B           1544   ;============================================================
0D6B           1545   
0D6B           1546   ;============================================================
0D6B           1547   ; Buzzer beep Task 
0D6B           1548   ; Purpose: beeps, holds, stop
0D6B           1549   ; Buzzer task:
0D6B           1550   ; Beep once when state changes
0D6B           1551   ; Beep five times if finished
0D6B           1552   ; Beep ten times if meets error
0D6B           1553   ;============================================================
0D6B           1554   Beep_Task:
0D6B 301835    1555       jnb one_ms_beep_flag, Beep_Done
0D6E C218      1556       clr one_ms_beep_flag
0D70           1557   
0D70 E579      1558       mov a, beep_state
0D72 602F      1559       jz Beep_Done
0D74           1560   
0D74           1561   ; ---- increment 16-bit timer ----
0D74 057A      1562       inc beep_tmr
0D76 E57A      1563       mov a, beep_tmr
0D78 7002      1564       jnz Beep_Check
0D7A 057B      1565       inc beep_tmr+1
0D7C           1566   
0D7C           1567   Beep_Check:
0D7C           1568       ; [FIX] FUZZY TIMER CHECK
0D7C           1569       ; Check if High Byte is non-zero (Time >= 256ms)
0D7C E57B      1570       mov a, beep_tmr+1
0D7E 6023      1571       jz Beep_Done        ; If 0, keep beeping
0D80           1572   
0D80           1573       ; --- Time Limit Reached ---
0D80 757A00    1574       mov beep_tmr, #0    ; Reset timer
0D83 757B00    1575       mov beep_tmr+1, #0
0D86           1576   
0D86 E579      1577       mov a, beep_state
0D88 B40106    1578       cjne a, #1, Beep_Off_State
0D8B           1579   
0D8B           1580       ; State was 1 (ON) -> Turn OFF
0D8B C28C      1581       clr TR0             ; Hardware Silence
0D8D 757902    1582       mov beep_state, #2  ; Set State to OFF (Pause)
0D90 22        1583       ret
0D91           1584   
0D91           1585   Beep_Off_State:
0D91           1586   ; ---- OFF finished -> decrement count / next ON ----
0D91 1578      1587       dec beep_count
0D93 E578      1588       mov a, beep_count
0D95 6006      1589       jz  Beep_Stop
0D97           1590   
0D97 757901    1591       mov beep_state, #1
0D9A D28C      1592       setb TR0
0D9C 22        1593       ret
0D9D           1594   
0D9D           1595   Beep_Stop:
0D9D C28C      1596       clr TR0
0D9F 757900    1597       mov beep_state, #0
0DA2 22        1598       ret
0DA3           1599   
0DA3           1600   Beep_Done:
0DA3 22        1601       ret
0DA4           1602   ;==================================================================
0DA4           1603   
0DA4           1604   ;-------------------------------------------------------------------------------;
0DA4           1605   ; Main Control FSM for the entire process
0DA4           1606   ;-------------------------------------------------------------------------------;
0DA4           1607   ;-------------------------------------------------------------------------------;
0DA4           1608   ; FSM LOGIC (Button Logic Fixed)
0DA4           1609   ;-------------------------------------------------------------------------------;
0DA4           1610   Control_FSM:
0DA4 E560      1611       mov a, Control_FSM_state
0DA6 8008      1612       sjmp Control_FSM_state0
0DA8           1613   
0DA8           1614   Control_FSM_state0_a:
0DA8 756000    1615            mov Control_FSM_state, #0
0DAB D20F      1616            setb state_change_signal
0DAD D210      1617            setb state_change_signal_TC
0DAF 22        1618            ret
0DB0           1619   Control_FSM_state0:
0DB0 B40017    1620       cjne a, #0, Control_FSM_state1
0DB3 C219      1621       clr beep_error_done
0DB5 301504    1622       jnb PB0_flag, Control_FSM_state0_ret  ; Check flag
0DB8 C215      1623       clr PB0_flag                 
0DBA 8001      1624       sjmp Control_FSM_state1_a
0DBC           1625   Control_FSM_state0_ret:
0DBC 22        1626       ret
0DBD           1627   
0DBD           1628   Control_FSM_state1_a:
0DBD 756001    1629       mov Control_FSM_state, #1
0DC0 756100    1630       mov Current_State, #0
0DC3 D20F      1631       setb state_change_signal
0DC5 D210      1632            setb state_change_signal_TC
0DC7 D212      1633       setb state_change_beep_signal
0DC9 22        1634            ret
0DCA           1635   Control_FSM_state1:
0DCA B40114    1636       cjne a, #1, Control_FSM_state2
0DCD 301504    1637       jnb PB0_flag, Control_FSM_state1_ret  ; Check flag
0DD0 C215      1638       clr PB0_flag                    
0DD2 8001      1639       sjmp Control_FSM_state2_a
0DD4           1640   Control_FSM_state1_ret:
0DD4 22        1641       ret
0DD5           1642   
0DD5           1643   ; --- STATE 2: RAMP TO SOAK ---
0DD5           1644   Control_FSM_state2_a:
0DD5 756002    1645            mov Control_FSM_state, #2
0DD8 D20F      1646            setb state_change_signal
0DDA D210      1647            setb state_change_signal_TC
0DDC D211      1648            setb state_change_signal_Count
0DDE D212      1649       setb state_change_beep_signal
0DE0 22        1650            ret
0DE1           1651   Control_FSM_state2:
0DE1 B4021C    1652       cjne a, #2, Control_FSM_state3
0DE4 301705    1653       jnb PB2_flag, State2_Check
0DE7 C217      1654       clr PB2_flag
0DE9 020E4E    1655       ljmp Control_FSM_state6_a ; Pause
0DEC           1656   
0DEC           1657   State2_Check:
0DEC 300506    1658       jnb soak_temp_reached, State2_Ret
0DEF           1659       
0DEF           1660       ; --- We reached Temp! Move to State 3 ---
0DEF C205      1661       clr soak_temp_reached
0DF1 C208      1662       clr soak_time_reached
0DF3 8001      1663            sjmp Control_FSM_state3_a
0DF5           1664   State2_Ret:
0DF5 22        1665       ret
0DF6           1666   
0DF6           1667   ; --- STATE 3: SOAK PHASE ---
0DF6           1668   Control_FSM_state3_a:
0DF6 756003    1669            mov Control_FSM_state, #3
0DF9 D20F      1670            setb state_change_signal
0DFB D210      1671            setb state_change_signal_TC
0DFD D212      1672       setb state_change_beep_signal
0DFF 22        1673            ret
0E00           1674   Control_FSM_state3:
0E00 B4031A    1675       cjne a, #3, Control_FSM_state4
0E03 301705    1676       jnb PB2_flag, State3_Check
0E06 C217      1677       clr PB2_flag
0E08 020E4E    1678       ljmp Control_FSM_state6_a
0E0B           1679   State3_Check:
0E0B 300804    1680       jnb soak_time_reached, State3_Ret
0E0E C208      1681       clr soak_time_reached
0E10 8001      1682       sjmp Control_FSM_state4_a
0E12           1683   State3_Ret:
0E12 22        1684       ret
0E13           1685   
0E13           1686   ; --- STATE 4: RAMP TO PEAK ---
0E13           1687   Control_FSM_state4_a:
0E13 756004    1688            mov Control_FSM_state, #4
0E16 D20F      1689            setb state_change_signal
0E18 D210      1690            setb state_change_signal_TC
0E1A D212      1691       setb state_change_beep_signal
0E1C 22        1692            ret
0E1D           1693   Control_FSM_state4:
0E1D B4041C    1694       cjne a, #4, Control_FSM_state5
0E20 301705    1695       jnb PB2_flag, State4_Check
0E23 C217      1696       clr PB2_flag
0E25 020E4E    1697       ljmp Control_FSM_state6_a
0E28           1698   State4_Check:
0E28 300606    1699       jnb reflow_temp_reached, State4_Ret
0E2B C206      1700       clr reflow_temp_reached
0E2D C209      1701       clr reflow_time_reached
0E2F 8001      1702            sjmp Control_FSM_state5_a
0E31           1703   State4_Ret:
0E31 22        1704       ret
0E32           1705   
0E32           1706   ; --- STATE 5: REFLOW PHASE ---
0E32           1707   Control_FSM_state5_a:
0E32 756005    1708            mov Control_FSM_state, #5
0E35 D20F      1709            setb state_change_signal
0E37 D210      1710            setb state_change_signal_TC
0E39 D212      1711       setb state_change_beep_signal
0E3B 22        1712            ret
0E3C           1713   Control_FSM_state5:
0E3C B4051B    1714       cjne a, #5, Control_FSM_state6
0E3F 301704    1715       jnb PB2_flag, State5_Check
0E42 C217      1716       clr PB2_flag
0E44 8008      1717       sjmp Control_FSM_state6_a
0E46           1718   State5_Check:
0E46 300904    1719       jnb reflow_time_reached, State5_Ret
0E49 C209      1720       clr reflow_time_reached
0E4B 8001      1721       sjmp Control_FSM_state6_a
0E4D           1722   State5_Ret:
0E4D 22        1723       ret
0E4E           1724   
0E4E           1725   ; --- STATE 6: COOLING ---
0E4E           1726   Control_FSM_state6_a:
0E4E 756006    1727            mov Control_FSM_state, #6
0E51 D20F      1728            setb state_change_signal
0E53 D210      1729            setb state_change_signal_TC
0E55 D211      1730            setb state_change_signal_Count
0E57 D212      1731       setb state_change_beep_signal
0E59 22        1732            ret
0E5A           1733   Control_FSM_state6:
0E5A B40612    1734       cjne a, #6, Control_FSM_state7
0E5D           1735       ; Wait for Cooling Temp Reached
0E5D 300704    1736       jnb cooling_temp_reached, State6_Ret
0E60 C207      1737       clr cooling_temp_reached
0E62 8001      1738       sjmp Control_FSM_state7_a
0E64           1739   State6_Ret:
0E64 22        1740       ret
0E65           1741   
0E65           1742   ; --- STATE 7: DONE ---
0E65           1743   Control_FSM_state7_a:
0E65 756007    1744            mov Control_FSM_state, #7
0E68 D20F      1745            setb state_change_signal
0E6A D210      1746            setb state_change_signal_TC
0E6C D212      1747       setb state_change_beep_signal
0E6E 22        1748            ret
0E6F           1749   Control_FSM_state7:
0E6F B40708    1750       cjne a, #7, Control_FSM_done
0E72           1751       ; Let's assume you meant the physical button P1.0 like State 0
0E72 101502    1752       jbc PB0_flag, Control_FSM_state7_pressed
0E75 8003      1753            sjmp Control_FSM_done
0E77           1754   Control_FSM_state7_pressed:
0E77 020DA8    1755       ljmp Control_FSM_state0_a
0E7A           1756   
0E7A           1757   Control_FSM_done:
0E7A 22        1758       ret
0E7B           1759   
0E7B           1760   ; ================================================================
0E7B           1761   ; UI & HELPER SUBROUTINES
0E7B           1762   ; ================================================================
0E7B           1763   
0E7B           1764   ; ----------------------------------------------------------------
0E7B           1765   ; MODULE: BRIDGE (Text to Integer Conversion)
0E7B           1766   ; ----------------------------------------------------------------
0E7B           1767   
0E7B           1768   ;--------------------------
0E7B           1769   ;keep updating varaibles
0E7B           1770   Update_FSM_Variables:
0E7B C0E0      1771            push ACC
0E7D C006      1772            push AR6
0E7F C007      1773            push AR7
0E81 E560      1774            mov a, Control_FSM_state
0E83 B40132    1775            cjne a, #1, Update_FSM_Variables_done
0E86           1776   
0E86           1777       ; --- 1. SOAK TEMP ---
0E86 7880      1778       mov R0, #Buf_Soak_Temp
0E88 120EBF    1779       lcall Parse_Temp_String
0E8B 8F4B      1780       mov soak_temp+0, R7
0E8D 754C00    1781       mov soak_temp+1, #0
0E90 754D00    1782       mov soak_temp+2, #0
0E93 754E00    1783       mov soak_temp+3, #0
0E96           1784   
0E96           1785       ; --- 2. REFLOW TEMP ---
0E96 7889      1786       mov R0, #Buf_Refl_Temp
0E98 120EBF    1787       lcall Parse_Temp_String
0E9B 8F4F      1788       mov reflow_temp+0, R7
0E9D 755000    1789       mov reflow_temp+1, #0
0EA0 755100    1790       mov reflow_temp+2, #0
0EA3 755200    1791       mov reflow_temp+3, #0
0EA6           1792   
0EA6           1793       ; --- 3. SOAK TIME ---
0EA6 7884      1794       mov R0, #Buf_Soak_Time
0EA8 120ED3    1795       lcall Parse_Time_String
0EAB 8F33      1796       mov soak_time_minute, R7
0EAD 8E32      1797       mov soak_time_sec, R6
0EAF           1798   
0EAF           1799       ; --- 4. REFLOW TIME ---
0EAF 788D      1800       mov R0, #Buf_Refl_Time
0EB1 120ED3    1801       lcall Parse_Time_String
0EB4 8F35      1802       mov reflow_time_minute, R7
0EB6 8E34      1803       mov reflow_time_sec, R6
0EB8           1804   
0EB8           1805   Update_FSM_Variables_done:
0EB8 D007      1806            pop AR7
0EBA D006      1807            pop AR6
0EBC D0E0      1808            pop ACC
0EBE 22        1809       ret
0EBF           1810   ;--------------------------
0EBF           1811   
0EBF           1812   ; --- Helper: Parse "123" to Integer ---
0EBF           1813   Parse_Temp_String:
0EBF 7F00      1814       mov R7, #0              ; Clear Result
0EC1           1815   Parse_Temp_Loop:
0EC1 E6        1816       mov A, @R0
0EC2 600E      1817       jz Parse_Temp_Done      ; If Null, we are done
0EC4           1818       
0EC4           1819       ; Convert ASCII to Digit
0EC4 C3        1820       clr C
0EC5 9430      1821       subb A, #0x30
0EC7 FD        1822       mov R5, A               ; R5 = New Digit
0EC8           1823       
0EC8           1824       ; Result = (Result * 10) + New Digit
0EC8 EF        1825       mov A, R7
0EC9 75F00A    1826       mov B, #10
0ECC A4        1827       mul AB
0ECD 2D        1828       add A, R5
0ECE FF        1829       mov R7, A
0ECF           1830       
0ECF 08        1831       inc R0
0ED0 80EF      1832       sjmp Parse_Temp_Loop
0ED2           1833   Parse_Temp_Done:
0ED2 22        1834       ret
0ED3           1835   
0ED3           1836   ; --- Helper: Parse "MMSS" to Seconds ---
0ED3           1837   Parse_Time_String:
0ED3           1838       ; Minutes tens
0ED3 E6        1839       mov A, @R0
0ED4 C3        1840       clr C
0ED5 9430      1841       subb A, #0x30
0ED7 75F00A    1842       mov B, #10
0EDA A4        1843       mul AB
0EDB FD        1844       mov R5, A
0EDC 08        1845       inc R0
0EDD           1846   
0EDD           1847       ; Minutes ones
0EDD E6        1848       mov A, @R0
0EDE C3        1849       clr C
0EDF 9430      1850       subb A, #0x30
0EE1 2D        1851       add A, R5
0EE2 FD        1852       mov R5, A
0EE3 08        1853       inc R0
0EE4           1854   
0EE4           1855       ; Seconds tens
0EE4 E6        1856       mov A, @R0
0EE5 C3        1857       clr C
0EE6 9430      1858       subb A, #0x30
0EE8 75F00A    1859       mov B, #10
0EEB A4        1860       mul AB
0EEC FC        1861       mov R4, A
0EED 08        1862       inc R0
0EEE           1863   
0EEE           1864       ; Seconds ones
0EEE E6        1865       mov A, @R0
0EEF C3        1866       clr C
0EF0 9430      1867       subb A, #0x30
0EF2 2C        1868       add A, R4
0EF3 FC        1869       mov R4, A
0EF4           1870   
0EF4           1871       ; Return minutes/seconds
0EF4 ED        1872            mov a, R5
0EF5 FF        1873       mov R7, a     ; minutes
0EF6 EC        1874            mov a, R4
0EF7 FE        1875       mov R6, a     ; seconds
0EF8 22        1876       ret
0EF9           1877   
0EF9           1878   ; ----------------------------------------------------------------
0EF9           1879   ; MODULE: BUTTON HANDLER (Mode Selection)
0EF9           1880   ; ----------------------------------------------------------------
0EF9           1881   ; Blocking wrapper for LCD clear (keeps old behavior just for this)
0EF9           1882   Wait_25ms_BLOCKING:
0EF9 121018    1883       lcall Wait_25ms
0EFC 50FB      1884       jnc Wait_25ms_BLOCKING ; Keep jumping back until Done (C=1)
0EFE 22        1885       ret
0EFF           1886   
0EFF           1887   ; ----------------------------------------------------------------
0EFF           1888   ; MODULE: KEYPAD HANDLER (Input Logic)
0EFF           1889   ; ----------------------------------------------------------------
0EFF           1890   Check_Keypad:
0EFF E560      1891       mov a, Control_FSM_state
0F01 B40152    1892       cjne a, #1, Keypad_Exit
0F04           1893   
0F04           1894       ; If State is 0 (Home), ignore keypad
0F04 E561      1895       mov A, Current_State
0F06 604E      1896       jz Keypad_Exit
0F08           1897       
0F08 120F57    1898       lcall Keypad_Scan
0F0B 5049      1899       jnc Keypad_Exit         ; Carry = 0 means no key pressed
0F0D           1900   
0F0D           1901       ; --- Check Special Keys ---
0F0D EF        1902       mov A, R7
0F0E B40E09    1903       cjne A, #14, Check_Hash ; 14 is Star (*)
0F11           1904       
0F11           1905       ; Star Key Pressed: Reset Buffer
0F11 12105B    1906       lcall Reset_Current_Buffer
0F14 D224      1907       setb fullscreen_update_signal
0F16 756A00    1908       mov Cursor_Idx, #0
0F19 22        1909       ret
0F1A           1910   
0F1A           1911   Check_Hash:
0F1A EF        1912       mov A, R7
0F1B B40C01    1913       cjne A, #12, Check_Numeric ; 12 is Hash (#)
0F1E 22        1914       ret                     ; Ignore Hash key
0F1F           1915   
0F1F           1916   Check_Numeric:
0F1F           1917       ; Ensure key is 0-9
0F1F EF        1918       mov A, R7
0F20 C3        1919       clr C
0F21 940A      1920       subb A, #10
0F23 5030      1921       jnc Symbol_Key_Ignored
0F25           1922       
0F25           1923       ; Convert to ASCII
0F25 EF        1924       mov A, R7
0F26 2430      1925       add A, #0x30
0F28 FD        1926       mov R5, A
0F29           1927   
0F29           1928       ; Save to Buffer
0F29 120999    1929       lcall Get_Current_Buffer_Addr
0F2C E56A      1930       mov A, Cursor_Idx
0F2E 28        1931       add A, R0
0F2F F8        1932       mov R0, A
0F30 ED        1933       mov A, R5
0F31 F6        1934       mov @R0, A
0F32 056A      1935       inc Cursor_Idx
0F34           1936   
0F34           1937       ; --- Check Cursor Limits ---
0F34 E561      1938       mov A, Current_State
0F36 B40102    1939       cjne A, #1, Check_Limit_Time_1
0F39 8005      1940       sjmp Limit_Temp_3
0F3B           1941   
0F3B           1942   Check_Limit_Time_1:
0F3B B4030B    1943       cjne A, #3, Limit_Time_4
0F3E 8000      1944       sjmp Limit_Temp_3
0F40           1945   
0F40           1946   Limit_Temp_3:
0F40 E56A      1947       mov A, Cursor_Idx
0F42 B4030D    1948       cjne A, #3, Do_Refresh
0F45 156A      1949       dec Cursor_Idx          ; Stay at last digit
0F47 8009      1950       sjmp Do_Refresh
0F49           1951   
0F49           1952   Limit_Time_4:
0F49 E56A      1953       mov A, Cursor_Idx
0F4B B40404    1954       cjne A, #4, Do_Refresh
0F4E 156A      1955       dec Cursor_Idx          ; Stay at last digit
0F50 8000      1956       sjmp Do_Refresh
0F52           1957   
0F52           1958   Do_Refresh:
0F52 D224      1959       setb fullscreen_update_signal
0F54 22        1960       ret
0F55           1961   
0F55           1962   Symbol_Key_Ignored:
0F55 22        1963       ret
0F56           1964   Keypad_Exit:
0F56 22        1965       ret
0F57           1966   
0F57           1967   ; ----------------------------------------------------------------
0F57           1968   ; MODULE: HARDWARE SCANNER (Matrix Logic)
0F57           1969   ; ----------------------------------------------------------------
0F57           1970   Keypad_Scan:
0F57           1971       ; Step 1: Check if ANY key is pressed (All Rows Low)
0F57 C292      1972       clr ROW1
0F59 C294      1973       clr ROW2
0F5B C296      1974       clr ROW3
0F5D C2A0      1975       clr ROW4
0F5F A2A2      1976       mov C, COL1
0F61 82A4      1977       anl C, COL2
0F63 82A6      1978       anl C, COL3
0F65 82B0      1979       anl C, COL4
0F67 5002      1980       jnc Keypad_Debounce
0F69 C3        1981       clr C
0F6A 22        1982       ret
0F6B           1983   
0F6B           1984   Keypad_Debounce:
0F6B 120EF9    1985       lcall Wait_25ms_BLOCKING
0F6E A2A2      1986       mov C, COL1
0F70 82A4      1987       anl C, COL2
0F72 82A6      1988       anl C, COL3
0F74 82B0      1989       anl C, COL4
0F76 5002      1990       jnc Keypad_Find_Row
0F78 C3        1991       clr C
0F79 22        1992       ret
0F7A           1993   
0F7A           1994   Keypad_Find_Row:
0F7A D292      1995       setb ROW1
0F7C D294      1996       setb ROW2
0F7E D296      1997       setb ROW3
0F80 D2A0      1998       setb ROW4
0F82           1999   
0F82           2000       ; Row 1
0F82 C292      2001       clr ROW1
0F84 30A23D    2002       jnb COL1, Keypad_Key_1
0F87 30A43E    2003       jnb COL2, Keypad_Key_2
0F8A 30A63F    2004       jnb COL3, Keypad_Key_3
0F8D 30B040    2005       jnb COL4, Keypad_Key_A
0F90 D292      2006       setb ROW1
0F92           2007   
0F92           2008       ; Row 2
0F92 C294      2009       clr ROW2
0F94 30A23D    2010       jnb COL1, Keypad_Key_4
0F97 30A43E    2011       jnb COL2, Keypad_Key_5
0F9A 30A63F    2012       jnb COL3, Keypad_Key_6
0F9D 30B040    2013       jnb COL4, Keypad_Key_B
0FA0 D294      2014       setb ROW2
0FA2           2015   
0FA2           2016       ; Row 3
0FA2 C296      2017       clr ROW3
0FA4 30A23D    2018       jnb COL1, Keypad_Key_7
0FA7 30A43E    2019       jnb COL2, Keypad_Key_8
0FAA 30A63F    2020       jnb COL3, Keypad_Key_9
0FAD 30B040    2021       jnb COL4, Keypad_Key_C
0FB0 D296      2022       setb ROW3
0FB2           2023   
0FB2           2024       ; Row 4
0FB2 C2A0      2025       clr ROW4
0FB4 30A23D    2026       jnb COL1, Keypad_Key_Star
0FB7 30A43E    2027       jnb COL2, Keypad_Key_0
0FBA 30A63F    2028       jnb COL3, Keypad_Key_Hash
0FBD 30B040    2029       jnb COL4, Keypad_Key_D
0FC0 D2A0      2030       setb ROW4
0FC2 C3        2031       clr C
0FC3 22        2032       ret
0FC4           2033   
0FC4           2034   ; Key Mapping (Renamed to avoid conflicts)
0FC4 7F01      2035   Keypad_Key_1: mov R7, #1
0FC6 803C      2036          sjmp Wait_Release
0FC8 7F02      2037   Keypad_Key_2: mov R7, #2
0FCA 8038      2038          sjmp Wait_Release
0FCC 7F03      2039   Keypad_Key_3: mov R7, #3
0FCE 8034      2040          sjmp Wait_Release
0FD0 7F0A      2041   Keypad_Key_A: mov R7, #10
0FD2 8030      2042          sjmp Wait_Release
0FD4 7F04      2043   Keypad_Key_4: mov R7, #4
0FD6 802C      2044          sjmp Wait_Release
0FD8 7F05      2045   Keypad_Key_5: mov R7, #5
0FDA 8028      2046          sjmp Wait_Release
0FDC 7F06      2047   Keypad_Key_6: mov R7, #6
0FDE 8024      2048          sjmp Wait_Release
0FE0 7F0B      2049   Keypad_Key_B: mov R7, #11
0FE2 8020      2050          sjmp Wait_Release
0FE4 7F07      2051   Keypad_Key_7: mov R7, #7
0FE6 801C      2052          sjmp Wait_Release
0FE8 7F08      2053   Keypad_Key_8: mov R7, #8
0FEA 8018      2054          sjmp Wait_Release
0FEC 7F09      2055   Keypad_Key_9: mov R7, #9
0FEE 8014      2056          sjmp Wait_Release
0FF0 7F0D      2057   Keypad_Key_C: mov R7, #13
0FF2 8010      2058          sjmp Wait_Release
0FF4 7F0E      2059   Keypad_Key_Star: mov R7, #14
0FF6 800C      2060          sjmp Wait_Release
0FF8 7F00      2061   Keypad_Key_0: mov R7, #0
0FFA 8008      2062          sjmp Wait_Release
0FFC 7F0C      2063   Keypad_Key_Hash: mov R7, #12
0FFE 8004      2064          sjmp Wait_Release
1000 7F0F      2065   Keypad_Key_D: mov R7, #15
1002 8000      2066          sjmp Wait_Release
1004           2067   
1004           2068   Wait_Release:
1004 A2A2      2069       mov C, COL1
1006 82A4      2070       anl C, COL2
1008 82A6      2071       anl C, COL3
100A 82B0      2072       anl C, COL4
100C 50F6      2073       jnc Wait_Release
100E D3        2074       setb C
100F D292      2075       setb ROW1
1011 D294      2076       setb ROW2
1013 D296      2077       setb ROW3
1015 D2A0      2078       setb ROW4
1017 22        2079       ret
1018           2080   
1018           2081   Wait_25ms:
1018           2082       ; 1. Check if we are already waiting
1018 201A0E    2083       jb wait25_active, Check_Timer_Status
101B           2084       
101B           2085       ; 2. Check if we just finished
101B 301B04    2086       jnb wait25_done, Start_New_Timer
101E           2087       
101E           2088       ; 3. Timer is DONE! Reset flags and return True
101E C21B      2089       clr wait25_done
1020 D3        2090       setb C          ; Carry = 1 means "Done"
1021 22        2091       ret
1022           2092   
1022           2093   Start_New_Timer:
1022           2094       ; 4. Start a new 25ms wait
1022 755700    2095       mov wait25_count, #0
1025 D21A      2096       setb wait25_active
1027 C3        2097       clr C           ; Carry = 0 means "Not Done Yet"
1028 22        2098       ret
1029           2099   
1029           2100   Check_Timer_Status:
1029           2101       ; 5. Still waiting... return False immediately
1029 C3        2102       clr C           ; Carry = 0 means "Not Done Yet"
102A 22        2103       ret
102B           2104   
102B           2105   ; ----------------------------------------------------------------
102B           2106   ; MODULE: BUFFER INIT (Reset Logic)
102B           2107   ; ----------------------------------------------------------------
102B           2108   Init_All_Buffers:
102B 7880      2109       mov R0, #Buf_Soak_Temp
102D 121040    2110       lcall Init_Temp_Template
1030 7889      2111       mov R0, #Buf_Refl_Temp
1032 121040    2112       lcall Init_Temp_Template
1035 7884      2113       mov R0, #Buf_Soak_Time
1037 12104C    2114       lcall Init_Time_Template
103A 788D      2115       mov R0, #Buf_Refl_Time
103C 12104C    2116       lcall Init_Time_Template
103F 22        2117       ret
1040           2118   
1040           2119   Init_Temp_Template:
1040 7630      2120       mov @R0, #'0'
1042 08        2121       inc R0
1043 7630      2122       mov @R0, #'0'
1045 08        2123       inc R0
1046 7630      2124       mov @R0, #'0'
1048 08        2125       inc R0
1049 7600      2126       mov @R0, #0
104B 22        2127       ret
104C           2128   
104C           2129   Init_Time_Template:
104C 7630      2130       mov @R0, #'0'
104E 08        2131       inc R0
104F 7630      2132       mov @R0, #'0'
1051 08        2133       inc R0
1052 7630      2134       mov @R0, #'0'
1054 08        2135       inc R0
1055 7630      2136       mov @R0, #'0'
1057 08        2137       inc R0
1058 7600      2138       mov @R0, #0
105A 22        2139       ret
105B           2140   
105B           2141   Reset_Current_Buffer:
105B E561      2142       mov A, Current_State
105D B40106    2143       cjne A, #1, Reset_Chk_2
1060 7880      2144       mov R0, #Buf_Soak_Temp
1062 121040    2145       lcall Init_Temp_Template
1065 22        2146       ret
1066           2147   Reset_Chk_2:
1066 B40206    2148       cjne A, #2, Reset_Chk_3
1069 7884      2149       mov R0, #Buf_Soak_Time
106B 12104C    2150       lcall Init_Time_Template
106E 22        2151       ret
106F           2152   Reset_Chk_3:
106F B40306    2153       cjne A, #3, Reset_Chk_4
1072 7889      2154       mov R0, #Buf_Refl_Temp
1074 121040    2155       lcall Init_Temp_Template
1077 22        2156       ret
1078           2157   Reset_Chk_4:
1078 788D      2158       mov R0, #Buf_Refl_Time
107A 12104C    2159       lcall Init_Time_Template
107D 22        2160       ret 
107E           2161       
107E           2162   ; ================================================================
107E           2163   ; MODULE: THERMOCOUPLE ADC DRIVER (WITH NOISE SUPPRESSION & JUMP FIX)
107E           2164   ; ================================================================
107E           2165   Read_Thermocouple:
107E           2166       ; 1. Check Non-Blocking Timer
107E 121018    2167       lcall Wait_25ms
1081           2168       
1081           2169       ; [FIX] TRAMPOLINE JUMP
1081           2170       ; "jnc" cannot jump to the end because the code is too long.
1081           2171       ; We invert logic: If Carry=1 (Time is up), Jump NEARBY.
1081 4001      2172       jc Proceed_Reading
1083 22        2173       ret  ; If Carry=0, Return immediately.
1084           2174   
1084           2175   Proceed_Reading:
1084           2176       ; --- 25ms Passed! Time to Read ---
1084           2177   
1084           2178       ; [FIX] SILENCE THE BUZZER (Noise Suppression)
1084           2179       ; Save buzzer state and force it OFF during the sensitive read
1084 E588      2180       mov A, TCON      
1086 5410      2181       anl A, #0x10     ; Isolate TR0 bit
1088 C0E0      2182       push acc         ; Save it
108A C28C      2183       clr TR0          ; STOP NOISE
108C           2184   
108C           2185       ; 2. Initialize / Trigger ADC
108C 75A180    2186       mov ADC_C, #0x80    ; Reset
108F 00        2187       nop
1090 00        2188       nop
1091 75A101    2189       mov ADC_C, #0x01    ; Start Channel 0
1094           2190       
1094           2191       ; 3. Settle Delay
1094 7DFA      2192       mov R5, #250
1096           2193   ADC_Settle_Loop:
1096 00        2194       nop
1097 00        2195       nop
1098 DDFC      2196       djnz R5, ADC_Settle_Loop
109A           2197       
109A           2198       ; 4. Read Raw Data
109A 85A23A    2199       mov x+0, ADC_L
109D 85A33B    2200       mov x+1, ADC_H
10A0 753C00    2201       mov x+2, #0
10A3 753D00    2202       mov x+3, #0
10A6           2203       
10A6           2204       ; 5. Mask Data
10A6 E53B      2205       mov a, x+1
10A8 540F      2206       anl a, #0x0F
10AA F53B      2207       mov x+1, a
10AC           2208       
10AC           2209       ; [FIX] RESTORE THE BUZZER
10AC D0E0      2210       pop acc          ; Get previous state
10AE 6002      2211       jz Skip_Restore  ; If it was OFF, keep it OFF
10B0 D28C      2212       setb TR0         ; If it was ON, turn it back ON
10B2           2213   Skip_Restore:
10B2           2214   
10B2           2215       ; 6. Math Conversions
10B2 753E16    2216            mov y+0, #low (4118 % 0x10000) 
10B5 753F10    2216            mov y+1, #high(4118 % 0x10000) 
10B8 754000    2216            mov y+2, #low (4118 / 0x10000) 
10BB 754100    2216            mov y+3, #high(4118 / 0x10000) 
10BE 12018C    2217       lcall mul32       
10C1           2218   
10C1 75A104    2219       mov ADC_C, #0x04    ; Read LM4040
10C4 85A23E    2220       mov y+0, ADC_L      
10C7 85A33F    2221       mov y+1, ADC_H      
10CA 754000    2222       mov y+2, #0
10CD 754100    2223       mov y+3, #0
10D0 75A100    2224       mov ADC_C, #0x00    ; Reset
10D3           2225       
10D3 120280    2226       lcall div32         
10D6 753E64    2227            mov y+0, #low (100 % 0x10000) 
10D9 753F00    2227            mov y+1, #high(100 % 0x10000) 
10DC 754000    2227            mov y+2, #low (100 / 0x10000) 
10DF 754100    2227            mov y+3, #high(100 / 0x10000) 
10E2 12018C    2228       lcall mul32
10E5 753E2B    2229            mov y+0, #low (1323 % 0x10000) 
10E8 753F05    2229            mov y+1, #high(1323 % 0x10000) 
10EB 754000    2229            mov y+2, #low (1323 / 0x10000) 
10EE 754100    2229            mov y+3, #high(1323 / 0x10000)         
10F1 120280    2230       lcall div32    
10F4 753E14    2231            mov y+0, #low (COLD_JUNCTION_TEMP % 0x10000) 
10F7 753F00    2231            mov y+1, #high(COLD_JUNCTION_TEMP % 0x10000) 
10FA 754000    2231            mov y+2, #low (COLD_JUNCTION_TEMP / 0x10000) 
10FD 754100    2231            mov y+3, #high(COLD_JUNCTION_TEMP / 0x10000) 
1100 1200D3    2232       lcall add32     
1103           2233       
1103           2234       ; 8. Store Result
1103 853A47    2235       mov current_temp+0, x+0
1106 853B48    2236       mov current_temp+1, x+1
1109 853C49    2237       mov current_temp+2, x+2
110C 853D4A    2238       mov current_temp+3, x+3
110F           2239   
110F 22        2240       ret
1110           2241       
1110           2242   ; ================================================================
1110           2243   ; MODULE: POWER CONTROLLER (The Brain)
1110           2244   ; ================================================================
1110           2245   Power_Control:
1110           2246       ; Default: Turn Heat OFF (Safety)
1110 755800    2247       mov power_output+0, #0
1113 755900    2248       mov power_output+1, #0
1116 755A00    2249       mov power_output+2, #0
1119 755B00    2250       mov power_output+3, #0
111C           2251   
111C E560      2252       mov a, Control_FSM_state
111E           2253   
111E           2254       ; --- State 2: RAMP TO SOAK ---
111E B40202    2255       cjne a, #2, PC_Check_Soak
1121           2256       ; Mode: Full Speed Ahead
1121 8016      2257       sjmp Set_Max_Power
1123           2258   
1123           2259   PC_Check_Soak:
1123           2260       ; --- State 3: SOAK PHASE ---
1123 B40305    2261       cjne a, #3, PC_Check_Ramp_Reflow
1126           2262       ; Mode: Maintenance (Low Power)
1126           2263       ; If Temp > Target, OFF. If Temp < Target, 20% Power.
1126 20050F    2264       jb soak_temp_reached, PC_Done ; If hot enough, stay OFF
1129 801B      2265       sjmp Set_20_Percent_Power     ; If cold, use 20%
112B           2266   
112B           2267   PC_Check_Ramp_Reflow:
112B           2268       ; --- State 4: RAMP TO REFLOW ---
112B B40402    2269       cjne a, #4, PC_Check_Reflow
112E           2270       ; Mode: Full Speed Ahead
112E 8009      2271       sjmp Set_Max_Power
1130           2272   
1130           2273   PC_Check_Reflow:
1130           2274       ; --- State 5: REFLOW PHASE ---
1130 B40505    2275       cjne a, #5, PC_Done
1133           2276       ; Mode: Maintenance (Low Power)
1133 200602    2277       jb reflow_temp_reached, PC_Done
1136 800E      2278       sjmp Set_20_Percent_Power
1138           2279   
1138           2280   PC_Done:
1138 22        2281       ret
1139           2282   
1139           2283   ; --- Power Helpers ---
1139           2284   
1139           2285   Set_Max_Power:
1139           2286       ; Load 1500 (0x05DC) = 100% Duty Cycle
1139 7558DC    2287       mov power_output+0, #0xDC
113C 755905    2288       mov power_output+1, #0x05
113F 755A00    2289       mov power_output+2, #0
1142 755B00    2290       mov power_output+3, #0
1145 22        2291       ret
1146           2292   
1146           2293   Set_20_Percent_Power:
1146           2294       ; Load 300 (0x012C) = 20% Duty Cycle
1146 75582C    2295       mov power_output+0, #0x2C
1149 755901    2296       mov power_output+1, #0x01
114C 755A00    2297       mov power_output+2, #0
114F 755B00    2298       mov power_output+3, #0
1152 22        2299       ret
1153           2300   
1153           2301   ;--------------------------------------------------------------
1153           2302   ; set servo angle according to the state
1153           2303   ; call servo control function every 1ms
1153           2304   ;--------------------------------------------------------------
1153           2305   call_servo_control:
1153           2306            ; check current state and change servo angle
1153 E560      2307            mov a, Control_FSM_state
1155           2308            
1155           2309            ; handle state 0
1155 B40004    2310            cjne a, #0, servo_state1
1158 C227      2311            clr servo_angle_zero ; close door at state 0
115A 802C      2312            sjmp check_servo_flag
115C           2313   
115C           2314            ; handle state 1
115C           2315            servo_state1:
115C B40104    2316            cjne a, #1, servo_state2
115F D227      2317            setb servo_angle_zero ; open door at state 1
1161 8025      2318            sjmp check_servo_flag
1163           2319   
1163           2320            ; handle state 2
1163           2321            servo_state2:
1163 B40204    2322            cjne a, #2, servo_state3
1166 C227      2323            clr servo_angle_zero ; close door at state 2
1168 801E      2324            sjmp check_servo_flag
116A           2325   
116A           2326            ; handle state 3
116A           2327            servo_state3:
116A B40304    2328            cjne a, #3, servo_state4
116D C227      2329            clr servo_angle_zero ; close door at state 3
116F 8017      2330            sjmp check_servo_flag
1171           2331   
1171           2332            ; handle state 4
1171           2333            servo_state4:
1171 B40404    2334            cjne a, #4, servo_state5
1174 C227      2335            clr servo_angle_zero ; close door at state 4
1176 8010      2336            sjmp check_servo_flag
1178           2337   
1178           2338            ; handle state 5
1178           2339            servo_state5:
1178 B40504    2340            cjne a, #5, servo_state6
117B C227      2341            clr servo_angle_zero ; close door at state 5
117D 8009      2342            sjmp check_servo_flag
117F           2343   
117F           2344            ; handle state 6
117F           2345            servo_state6:
117F B40604    2346            cjne a, #6, servo_state7
1182 C227      2347            clr servo_angle_zero ; close door at state 6
1184 8002      2348            sjmp check_servo_flag
1186           2349   
1186           2350            ; handle state 7
1186           2351            servo_state7:
1186 D227      2352            setb servo_angle_zero ; open door at state 7
1188           2353   
1188           2354   check_servo_flag:
1188           2355            ; check 1 ms flag
1188 102601    2356            jbc one_millisecond_flag_servo, run_servo_control
118B 22        2357            ret
118C           2358   
118C           2359   run_servo_control:
118C 121190    2360            lcall servo_control
118F 22        2361            ret
1190           2362   
1190           2363   
1190           2364   ;---------------------------------------------------------------
1190           2365   ; servo control
1190           2366   ; generate a 20 ms period pwm signal to control the servo motor
1190           2367   ; able to make the servo motor stay at 0 degree and 180 degree
1190           2368   ;---------------------------------------------------------------
1190           2369   servo_control:
1190 D2ED      2370       setb LEDRA.5
1192 C0E0      2371            push acc
1194 C0D0      2372            push psw
1196 E57C      2373            mov a, servo_pwm_counter ; move servo counter to accumulator
1198 04        2374            inc A ; a += 1
1199 B41402    2375            cjne a, #SERVO_PERIOD, servo_pwm_angle_compare ; jump if wrapup not needed
119C 7400      2376            mov a, #0
119E           2377   
119E           2378   servo_pwm_angle_compare: ; read target angle
119E F57C      2379            mov servo_pwm_counter, A
11A0 202709    2380            jb servo_angle_zero, set_zero_degree ; set servo motor to 0 degree
11A3           2381            ; set servo motor to 180 degrees
11A3 E57C      2382            mov a, servo_pwm_counter
11A5 C3        2383            clr c
11A6 9402      2384            subb a, #SERVO_180
11A8 400B      2385            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 180 degrees duty cycle
11AA 800D      2386            sjmp servo_pwm_set_low ; set low if greater
11AC           2387   
11AC           2388   set_zero_degree:
11AC           2389            ; set servo motor to 0 degree
11AC E57C      2390            mov a, servo_pwm_counter
11AE C3        2391            clr c
11AF 9401      2392            subb a, #SERVO_0
11B1 4002      2393            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 0 degrees duty cycle
11B3 8004      2394            sjmp servo_pwm_set_low ; set low if greater
11B5           2395   
11B5           2396   servo_pwm_set_high:
11B5           2397            ; set pwm pin high
11B5 D2B6      2398            setb SERVO_OUT
11B7 8002      2399            sjmp servo_control_done
11B9           2400   
11B9           2401   servo_pwm_set_low:
11B9           2402            ; set pwm pin low
11B9 C2B6      2403            clr SERVO_OUT
11BB           2404   
11BB           2405   servo_control_done:
11BB D0D0      2406            pop psw
11BD D0E0      2407            pop acc
11BF 22        2408            ret
11C0           2409   
11C0           2410   ;-------------------------------------------------------------------------------
11C0           2411   ; power_control
11C0           2412   ;-------------------------------------------------------------------------------
11C0           2413   ; Determine the power output based on current state and current temperature 
11C0           2414   ; input parameter: Control_FSM_state
11C0           2415   ;-------------------------------------------------------------------------------
11C0           2416   
11C0           2417   proportional_power_control:
11C0 E560      2418            mov a, Control_FSM_state
11C2           2419   
11C2           2420   state0_power_control:
11C2           2421            ; idle
11C2           2422            ; 0% power
11C2 B4000F    2423            cjne a, #0, state1_power_control
11C5 755800    2424            mov power_output, #low(NO_POWER)
11C8 755900    2425            mov power_output+1, #low(NO_POWER)
11CB 755A00    2426            mov power_output+2, #0
11CE 755B00    2427            mov power_output+3, #0
11D1 02136C    2428            ljmp power_control_done
11D4           2429   
11D4           2430   state1_power_control:
11D4           2431            ; idle
11D4           2432            ; 0% power
11D4 B4010F    2433            cjne a, #1, state2_power_control
11D7 755800    2434            mov power_output, #low(NO_POWER)
11DA 755900    2435            mov power_output+1, #low(NO_POWER)
11DD 755A00    2436            mov power_output+2, #0
11E0 755B00    2437            mov power_output+3, #0
11E3 02136C    2438            ljmp power_control_done
11E6           2439            
11E6           2440   state2_power_control:
11E6           2441            ; ramp to soak, ramp to ~150C
11E6           2442            ; 100% power
11E6 B4020F    2443            cjne a, #2, state3_power_control
11E9 7558DC    2444            mov power_output, #low(MAX_POWER)
11EC 755905    2445            mov power_output+1, #high(MAX_POWER)
11EF 755A00    2446            mov power_output+2, #0
11F2 755B00    2447            mov power_output+3, #0
11F5 02136C    2448            ljmp power_control_done
11F8           2449   
11F8           2450   state3_power_control:
11F8           2451            ; soak period, hold at 150C
11F8           2452            ; 20% base power + proportional calculated power
11F8 B40302    2453            cjne a, #3, jump_state4_power_control
11FB 8003      2454            sjmp state3_power_control_calculation
11FD           2455   
11FD           2456   jump_state4_power_control:
11FD 02132A    2457            ljmp state4_power_control
1200           2458   
1200           2459   state3_power_control_calculation:
1200           2460            ; move soak_temp to x
1200 854B3A    2461            mov x, soak_temp
1203 854C3B    2462            mov x+1, soak_temp+1
1206 854D3C    2463            mov x+2, soak_temp+2
1209 854E3D    2464            mov x+3, soak_temp+3
120C           2465            ; move current_temp to y
120C 85473E    2466            mov y, current_temp
120F 85483F    2467            mov y+1, current_temp+1
1212 854940    2468            mov y+2, current_temp+2
1215 854A41    2469            mov y+3, current_temp+3
1218           2470   
1218           2471            ; compare between soak_temp and current_temp
1218 C200      2472            clr mf
121A 120178    2473            lcall x_gteq_y
121D 10002B    2474            jbc mf, st_sub_ct
1220           2475            ; current_temp - soak_temp if st < ct
1220 C228      2476            clr soak_temp_greater
1222           2477            ; move current_temp to y
1222 854B3E    2478            mov y, soak_temp
1225 854C3F    2479            mov y+1, soak_temp+1
1228 854D40    2480            mov y+2, soak_temp+2
122B 854E41    2481            mov y+3, soak_temp+3
122E           2482            ; move current_temp to x
122E 85473A    2483            mov x, current_temp
1231 85483B    2484            mov x+1, current_temp+1
1234 85493C    2485            mov x+2, current_temp+2
1237 854A3D    2486            mov x+3, current_temp+3
123A 1200F6    2487            lcall sub32
123D 853A62    2488            mov soak_temp_diff, x
1240 853B63    2489            mov soak_temp_diff+1, x+1
1243 853C64    2490            mov soak_temp_diff+2, x+2
1246 853D65    2491            mov soak_temp_diff+3, x+3
1249 8011      2492            sjmp proportional_input_soak
124B           2493   
124B           2494   st_sub_ct:
124B           2495            ; soak_temp - current_temp
124B D228      2496            setb soak_temp_greater
124D 1200F6    2497            lcall sub32
1250 853A62    2498            mov soak_temp_diff, x
1253 853B63    2499            mov soak_temp_diff+1, x+1
1256 853C64    2500            mov soak_temp_diff+2, x+2
1259 853D65    2501            mov soak_temp_diff+3, x+3
125C           2502   
125C           2503   proportional_input_soak:
125C           2504            ; proportaional block calculation       
125C           2505            ; move soak_temp_diff to x
125C 85623A    2506            mov x, soak_temp_diff
125F 85633B    2507            mov x+1, soak_temp_diff+1
1262 85643C    2508            mov x+2, soak_temp_diff+2
1265 85653D    2509            mov x+3, soak_temp_diff+3
1268           2510            ; move proportional gain to y
1268 753E05    2511            mov y+0, #low (KP % 0x10000) 
126B 753F00    2511            mov y+1, #high(KP % 0x10000) 
126E 754000    2511            mov y+2, #low (KP / 0x10000) 
1271 754100    2511            mov y+3, #high(KP / 0x10000) 
1274 12018C    2512            lcall mul32 ; proportional_output = proportional_gain * difference
1277           2513            
1277 853A66    2514            mov proportional_gain_var, x
127A 853B67    2515            mov proportional_gain_var+1, x+1
127D 853C68    2516            mov proportional_gain_var+2, x+2
1280 853D69    2517            mov proportional_gain_var+3, x+3
1283           2518   
1283           2519            ; base_power + soak_power when soak_temp > current_temp
1283 302829    2520            jnb soak_temp_greater, sub_proportional_soak
1286 85663A    2521            mov x, proportional_gain_var
1289 85673B    2522            mov x+1, proportional_gain_var+1
128C 85683C    2523            mov x+2, proportional_gain_var+2
128F 85693D    2524            mov x+3, proportional_gain_var+3
1292 753E2C    2525            mov y+0, #low (BASE_POWER % 0x10000) 
1295 753F01    2525            mov y+1, #high(BASE_POWER % 0x10000) 
1298 754000    2525            mov y+2, #low (BASE_POWER / 0x10000) 
129B 754100    2525            mov y+3, #high(BASE_POWER / 0x10000) 
129E 1200D3    2526            lcall add32
12A1           2527            ; x now holds the power output before the saturator
12A1 853A66    2528            mov proportional_gain_var, x
12A4 853B67    2529            mov proportional_gain_var+1, x+1
12A7 853C68    2530            mov proportional_gain_var+2, x+2
12AA 853D69    2531            mov proportional_gain_var+3, x+3
12AD 803D      2532            sjmp saturator_soak
12AF           2533   
12AF           2534   sub_proportional_soak:
12AF           2535            ; base_power - soak_power when soak_temp <= current_temp
12AF 753A2C    2536            mov x+0, #low (BASE_POWER % 0x10000) 
12B2 753B01    2536            mov x+1, #high(BASE_POWER % 0x10000) 
12B5 753C00    2536            mov x+2, #low (BASE_POWER / 0x10000) 
12B8 753D00    2536            mov x+3, #high(BASE_POWER / 0x10000) 
12BB 85663E    2537            mov y, proportional_gain_var
12BE 85673F    2538            mov y+1, proportional_gain_var+1
12C1 856840    2539            mov y+2, proportional_gain_var+2
12C4 856941    2540            mov y+3, proportional_gain_var+3
12C7           2541   
12C7           2542            ; compare whether base_power < proportional_gain_var
12C7 C200      2543            clr mf
12C9 12011A    2544            lcall x_lt_y ; set mf to 1 if base_power < proportional_gain_var, clamp output to 0
12CC 30000E    2545            jnb mf, bp_gteq_pgv
12CF 756600    2546            mov proportional_gain_var, #low(NO_POWER)
12D2 756700    2547            mov proportional_gain_var+1, #high(NO_POWER)
12D5 756800    2548            mov proportional_gain_var+2, #0
12D8 756900    2549            mov proportional_gain_var+3, #0
12DB 800F      2550            sjmp saturator_soak
12DD           2551   
12DD           2552   bp_gteq_pgv:
12DD           2553            ; calculate subtracted gain
12DD 1200F6    2554            lcall sub32
12E0           2555            ; x now holds the power output before the saturator
12E0 853A66    2556            mov proportional_gain_var, x
12E3 853B67    2557            mov proportional_gain_var+1, x+1
12E6 853C68    2558            mov proportional_gain_var+2, x+2
12E9 853D69    2559            mov proportional_gain_var+3, x+3
12EC           2560   
12EC           2561   saturator_soak:
12EC           2562            ; proportional_gain_var now holds the power output before the saturator
12EC           2563            ; saturate power output to max power
12EC 85663A    2564            mov x, proportional_gain_var
12EF 85673B    2565            mov x+1, proportional_gain_var+1
12F2 85683C    2566            mov x+2, proportional_gain_var+2
12F5 85693D    2567            mov x+3, proportional_gain_var+3
12F8           2568   
12F8 753EDC    2569            mov y+0, #low (MAX_POWER % 0x10000) 
12FB 753F05    2569            mov y+1, #high(MAX_POWER % 0x10000) 
12FE 754000    2569            mov y+2, #low (MAX_POWER / 0x10000) 
1301 754100    2569            mov y+3, #high(MAX_POWER / 0x10000) 
1304           2570   
1304 C200      2571            clr mf
1306 120136    2572            lcall x_gt_y ; set mf to 1 if calculated power output greater than max power
1309 20000F    2573            jb mf, saturated_soak
130C           2574            ; set power_output to calculated power if not saturated
130C 856658    2575            mov power_output, proportional_gain_var
130F 856759    2576            mov power_output+1, proportional_gain_var+1
1312 85685A    2577            mov power_output+2, proportional_gain_var+2
1315 85695B    2578            mov power_output+3, proportional_gain_var+3
1318 02136C    2579            ljmp power_control_done
131B           2580   
131B           2581   saturated_soak:
131B 7558DC    2582            mov power_output, #low(MAX_POWER)
131E 755905    2583            mov power_output+1, #high(MAX_POWER)
1321 755A00    2584            mov power_output+2, #0
1324 755B00    2585            mov power_output+3, #0
1327 02136C    2586            ljmp power_control_done
132A           2587   
132A           2588   
132A           2589   state4_power_control:
132A           2590            ; ramp to reflow, max power
132A B4040F    2591            cjne a, #4, state5_power_control
132D 7558DC    2592            mov power_output, #low(MAX_POWER)
1330 755905    2593            mov power_output+1, #high(MAX_POWER)
1333 755A00    2594            mov power_output+2, #0
1336 755B00    2595            mov power_output+3, #0
1339 02136C    2596            ljmp power_control_done
133C           2597   
133C           2598   state5_power_control:
133C           2599            ; reflow 20% base power
133C B4050F    2600            cjne a, #5, state6_power_control
133F 75582C    2601            mov power_output, #low(BASE_POWER)  
1342 755901    2602            mov power_output+1, #high(BASE_POWER)
1345 755A00    2603            mov power_output+2, #0
1348 755B00    2604            mov power_output+3, #0
134B 02136C    2605            ljmp power_control_done
134E           2606   
134E           2607   state6_power_control:
134E           2608            ; cooling 0% power
134E B4060F    2609            cjne a, #6, state_7_power_control
1351 755800    2610            mov power_output, #low(NO_POWER)
1354 755900    2611            mov power_output+1, #high(NO_POWER)
1357 755A00    2612            mov power_output+2, #0
135A 755B00    2613            mov power_output+3, #0
135D 02136C    2614            ljmp power_control_done
1360           2615   
1360           2616   state_7_power_control:
1360           2617            ; idle 0% power
1360 755800    2618            mov power_output, #low(NO_POWER)
1363 755900    2619            mov power_output+1, #high(NO_POWER)
1366 755A00    2620            mov power_output+2, #0
1369 755B00    2621            mov power_output+3, #0
136C           2622   
136C           2623   power_control_done:
136C 22        2624            ret
136D           2625   
136D           2626   ;-------------------------------------------------------------------------------;
136D           2627   ;         Main program.          
136D           2628   ;-------------------------------------------------------------------------------;
136D           2629   main:
136D           2630   
136D           2631       ; --------------------------------------------------------
136D           2632       ; 1. SAFETY SHUTDOWN
136D           2633       ; --------------------------------------------------------
136D C2AF      2634       clr EA              ; FORCE Interrupts OFF immediately
136F 7581C0    2635       mov SP, #0xC0       ; Reset Stack Pointer to safe location
1372           2636       
1372           2637       ; --------------------------------------------------------
1372           2638       ; THE "DIRTY DELAY" (Fixes Reset Garbage)
1372           2639       ; We burn ~100ms here using a raw loop. 
1372           2640       ; We cannot use timers yet because they aren't initialized.
1372           2641       ; --------------------------------------------------------
1372 78FA      2642       mov R0, #250
1374           2643   Reset_Delay_Outer:
1374 79FF      2644       mov R1, #255
1376           2645   Reset_Delay_Inner:
1376 D9FE      2646       djnz R1, Reset_Delay_Inner
1378 D8FA      2647       djnz R0, Reset_Delay_Outer
137A           2648       
137A           2649       ; --- PORT CONFIGURATION ---
137A 759AAA    2650       mov P0MOD, #0xAA
137D           2651       ; P1: Mixed usage 
137D           2652       ; P1.7(LCD_RS), P1.6(Row3), P1.5(Sound), P1.4(Row2)
137D           2653       ; P1.3(PWM), P1.2(Row1), P1.1(LCD_E) -> All Outputs
137D           2654       ; P1.0 (Unused/RX) -> Input
137D           2655       ; Binary: 11111110 -> Hex: 0xFE
137D 759BFE    2656       mov P1MOD, #0xFE
1380           2657   
1380           2658       ; P2: Row4(Out), Cols(In)
1380           2659       ; P2.0 (Row4) is Out (1). P2.2, P2.4, P2.6 (Cols) are In (0).
1380           2660       ; Binary: 00000001 -> Hex: 0x01
1380 759C01    2661       mov P2MOD, #0x01
1383           2662   
1383           2663       ; P3: Col4(In)
1383           2664       ; P3.0 (Col4) is In (0).
1383 759D00    2665       mov P3MOD, #0x00
1386           2666       ; Turn off all the LEDs
1386 75E800    2667       mov LEDRA, #0 ; LEDRA is bit addressable
1389 759500    2668       mov LEDRB, #0 ; LEDRB is NOT bit addresable
138C           2669   
138C           2670       ; Enable Global interrupts
138C D2AF      2671       setb EA  
138E           2672   
138E           2673            ; FSM initial states
138E 757000    2674            mov SEC_FSM_state, #0
1391 756000    2675            mov Control_FSM_state, #0
1394 756100    2676            mov Current_State, #0
1397           2677            ; FSM timers initialization
1397 756F00    2678            mov SEC_FSM_timer, #0
139A           2679            ; time counters initialization
139A 753000    2680            mov current_time_sec, #0
139D 753100    2681            mov current_time_minute, #0
13A0 753200    2682            mov soak_time_sec, #0
13A3 753300    2683            mov soak_time_minute, #0
13A6 753400    2684            mov reflow_time_sec, #0
13A9 753500    2685            mov reflow_time_minute, #0
13AC 753600    2686            mov soak_end_time_sec, #0
13AF 753700    2687            mov soak_end_time_minute, #0
13B2 753800    2688            mov reflow_end_time_sec, #0
13B5 753900    2689            mov reflow_end_time_minute, #0
13B8           2690       ; Initialize counter to zero
13B8 755C00    2691       mov pwm_counter, #0
13BB 755D00    2692       mov pwm_counter+1, #0
13BE 755E00    2693       mov pwm_counter+2, #0
13C1 755F00    2694       mov pwm_counter+3, #0
13C4           2695       ; Initialize power output
13C4 755B00    2696       mov power_output+3, #0
13C7 755A00    2697       mov power_output+2, #0
13CA 755902    2698       mov power_output+1, #02H
13CD 7558EE    2699       mov power_output, #0EEH ; (initilize to 750 for testing)
13D0           2700            ; FSM Buttons push button init
13D0 757200    2701            mov     PB0_DEB_state, #0
13D3 757400    2702            mov     PB2_DEB_state, #0
13D6 757100    2703            mov     PB0_DEB_timer, #0
13D9 757300    2704            mov     PB2_DEB_timer, #0
13DC 757500    2705       mov BTN_DEB_state, #0
13DF 757600    2706       mov BTN_DEB_timer, #0
13E2           2707       ; [FIX] ADD THIS BLOCK TO STOP STARTUP BEEP
13E2 757900    2708       mov beep_state, #0
13E5 757800    2709       mov beep_count, #0
13E8 757A00    2710       mov beep_tmr, #0
13EB 757B00    2711       mov beep_tmr+1, #0
13EE C218      2712       clr one_ms_beep_flag
13F0 C28C      2713       clr TR0 ; Force buzzer hardware OFF
13F2           2714   
13F2           2715   
13F2           2716            ; Clear all the flags
13F2 C295      2717            clr SOUND_OUT
13F4 C219      2718       clr beep_error_done
13F6 C213      2719            clr tc_missing_abort
13F8 C20B      2720            clr stop_signal
13FA C215      2721            clr PB0_flag
13FC C216      2722            clr PB1_flag
13FE C217      2723            clr PB2_flag
1400 C201      2724            clr one_second_flag
1402 C204      2725            clr one_second_lcd_flag
1404 C20E      2726            clr config_finish_signal
1406 C20D      2727       clr time_count_doing_signal
1408 C224      2728       clr fullscreen_update_signal
140A C205      2729            clr soak_temp_reached
140C C208      2730            clr soak_time_reached
140E C206      2731            clr reflow_temp_reached
1410 C209      2732            clr reflow_time_reached
1412 C207      2733            clr cooling_temp_reached
1414 C210      2734       clr state_change_signal_TC
1416 C211      2735            clr state_change_signal_Count
1418 C212      2736       clr state_change_beep_signal
141A           2737       ; Set bit
141A D20F      2738            setb state_change_signal
141C D214      2739       setb tc_startup_window
141E           2740   
141E 12045D    2741       lcall Timer0_Init
1421 120518    2742       lcall Timer2_Init
1424 1205ED    2743       lcall ELCD_4BIT
1427           2744       ;----- Two new lines I added to initialize the UI
1427 12102B    2745       lcall Init_All_Buffers
142A 120477    2746       lcall Initialize_Serial_Port
142D           2747   ;-------------------------------------------------------------------------------;
142D           2748   ; while(1) loop
142D           2749   ;-------------------------------------------------------------------------------;
142D           2750   loop:
142D           2751   
142D 120AF7    2752            lcall SEC_FSM
1430           2753   
1430           2754            ; Check the FSM for the overall control flow of the reflow process
1430 120DA4    2755       lcall Control_FSM
1433           2756   
1433           2757       ; Check the FSM for PB01 debounce
1433 1209CA    2758       lcall PB0_DEB
1436 120A02    2759            lcall PB2_DEB
1439           2760       
1439           2761       ; Added to take temp readings
1439 12107E    2762       lcall Read_Thermocouple
143C           2763       
143C           2764       ; 1. Check if we reached temp (Observer)
143C 120BE0    2765       lcall Temp_Compare
143F           2766       
143F           2767       ; 2. Decide heater power based on flags (Driver)
143F           2768       ;lcall Power_Control
143F 1211C0    2769       lcall proportional_power_control
1442           2770       
1442 120CD1    2771       lcall Safety_Check_TC
1445           2772   
1445 120B53    2773            lcall Time_Counter
1448           2774   
1448           2775            ; Update Variables (times and temp)
1448 120E7B    2776            lcall Update_FSM_Variables
144B           2777   
144B           2778            ; Update while at state 1
144B           2779            ; LCD
144B 120876    2780            lcall Update_Screen_Full 
144E           2781            ; Buttons
144E 120A38    2782            lcall Check_Buttons 
1451           2783            ; PB0pad
1451 120EFF    2784       lcall Check_Keypad
1454           2785   
1454           2786       ; Update the LCD display based on the current state
1454 1206B2    2787       lcall LCD_Display_Update_func
1457           2788   
1457 120B75    2789            lcall Time_Compare_MMSS
145A           2790   
145A           2791       ; Update the pwm output for the ssr
145A 120C5A    2792       lcall PWM_Wave 
145D           2793            ; Update the Buzzer 
145D 120D6B    2794            lcall Beep_Task
1460           2795       ; Update the pwm output for the servo
1460 121153    2796       lcall call_servo_control
1463           2797   
1463 120D22    2798       lcall Beep_Judge
1466           2799   
1466           2800       ; After initialization the program stays in this 'forever' loop
1466 02142D    2801       ljmp loop
1469           2802   ;-------------------------------------------------------------------------------;
1469           2803   EN
