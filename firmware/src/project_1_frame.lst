0000              1   ; Project 1
0000              2   ; CV-8052 microcontroller in DE10-Lite board
0000              3   ;-------------------------------------------------------------------------------
0000              4   ; Reset vector
0000              5   org 0x0000
<<<<<<< HEAD
0000 020A43       6       ljmp main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9            reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 020414      12            ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15            reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18            reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 32          21            reti
0024             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
002B 02047F      24            ljmp Timer2_ISR
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 29   $LIST
0320             31   ; ----------------------------------------------------------------------------------------------;
0320             32   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             33   dseg at 0x30
0030             34   ; time buffer 
0030             35   current_time_sec:     ds 1
0031             36   current_time_minute:  ds 1
0032             37   soak_time_sec:        ds 1
0033             38   soak_time_minute:     ds 1
0034             39   reflow_time_sec:      ds 1
0035             40   reflow_time_minute:   ds 1
0036             41   soak_end_time_sec:      ds 1
0037             42   soak_end_time_minute:   ds 1
0038             43   reflow_end_time_sec:    ds 1
0039             44   reflow_end_time_minute: ds 1
003A             45   
003A             46   ; math32 buffer variables
003A             47   x:               ds      4
003E             48   y:               ds      4
0042             49   bcd:     ds      5
0047             50   
0047             51   current_temp: ds 4 ;
004B             52   soak_temp:    ds 4 ;
004F             53   reflow_temp:  ds 4 ;
0053             54   
0053             55   power_output:  ds 4 ;
0057             56   pwm_counter: ds 4 ; counter for pwm (0-1500)
005B             57   
005B             58   KEY1_DEB_timer: ds 1
005C             59   SEC_FSM_timer:  ds 1
005D             60   KEY1_DEB_state:    ds 1
005E             61   SEC_FSM_state:      ds 1
005F             62   Control_FSM_state: ds 1 
0060             63   
0060             64   ; Buzzer module variables
0060             65   buzz_state:      ds 1   ; 0=IDLE, 1=ON, 2=OFF
0061             66   buzz_timer:      ds 1   ; counts ms within ON/OFF window
0062             67   buzz_beeps_left: ds 1   ; how many beeps remaining
0063             68   buzz_priority:   ds 1   ; 0 none, 1=state, 2=done, 3=error
0064             69   ; 46d bytes used
0064             70   ;-------------------------------------------------------------------------------
0064             71   ; bit operation setb, clr, jb, and jnb
0000             72   bseg
0000             73   mf:              dbit 1 ; math32 sign
0001             74   one_second_lcd_flag: dbit 1
0002             75   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003             76   one_ms_buzz_flag: dbit 1 ; one_millisecond_flag for buzz
0004             77   
0004             78   soak_temp_reached: dbit 1
0005             79   reflow_temp_reached: dbit 1
0006             80   cooling_temp_reached: dbit 1
0007             81   
0007             82   soak_time_reached: dbit 1
0008             83   reflow_time_reached: dbit 1
0009             84   
0009             85   reset_signal: dbit 1
000A             86   stop_signal: dbit 1
000B             87   start_signal_count: dbit 1
000C             88   time_count_doing_signal: dbit 1
000D             89   config_finish_signal: dbit 1
000E             90   
000E             91   state_change_signal: dbit 1
000F             92   state_change_signal_TC: dbit 1
0010             93   state_change_signal_Count: dbit 1
0011             94   
0011             95   Key1_flag: dbit 1
0012             96   
0012             97   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
0013             98   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0014             99   
0014            100   PB0_flag: dbit 1 ; start entire program
0015            101   PB1_flag: dbit 1 ; start soak
0016            102   PB2_flag: dbit 1 ; pause process
0017            103   ; 11 bits used
0017            104   
0017            105   ;-------------------------------------------------------------------------------
0320            106   cseg
0320            107   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            108   BAUD                EQU 57600
0320            109   
0320            110   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            111   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            112   ; is always 12 unlike the N76E003 where is selectable.
0320            113   
0320            114   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            115   
0320            116   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            117   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            118   
0320            119   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            120   
0320            121   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            122   BEEP_ON_MS          EQU 100  ; 100ms
0320            123   BEEP_OFF_MS    EQU 100  ; 100ms
0320            124   
0320            125   PWM_OUT             EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            126   
0320            127   ; These 'equ' must match the wiring between the DE10Lite board and the LCD!
0320            128   ; P0 is in connector JPIO.
0320            129   ELCD_RS equ P3.7
0320            130   ELCD_RW equ P3.5
0320            131   ELCD_E  equ P3.3
0320            132   ELCD_D4 equ P3.1
0320            133   ELCD_D5 equ P2.7
0320            134   ELCD_D6 equ P2.5
0320            135   ELCD_D7 equ P2.3
0320            136   
0320            137   ;                     1234567890123456 <-- 16 characters per line LCD
0320 696E6974   138   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   139   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   140   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            141   
0350            142   ;                       1234567890123456
0350 53657420   143   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
0360 536F616B   144   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
036B 5265666C   145   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
0378 536F616B   146   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
0383 5265666C   147   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
0390            148   
0390            149   ;                     1234567890123456
0390 52616D70   150   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03A0 536F616B   151   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
03B0 52616D70   152   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
03C0 5265666C   153   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
03D0 436F6F6C   154   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
03E0 50726F63   155   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
03F0            156   
03F0 20202020   157   String_Blank:    db '                ', 0
=======
0000 020A8B       6       ljmp main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9       reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 020469      12       ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15       reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18       reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 32          21       reti
0024             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
002B 0204D6      24       ljmp Timer2_ISR
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 32   $LIST
0320             34   ; ----------------------------------------------------------------------------------------------;
0320             35   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             36   dseg at 0x30
0030             37   current_time_sec:     ds 1
0031             38   current_time_minute:  ds 1
0032             39   ; math32 buffer variables
0032             40   x:      ds  4
0036             41   y:      ds  4
003A             42   bcd:    ds  5
003F             43   
003F             44   current_temp: ds 4 ;
0043             45   soak_temp:    ds 4 ;
0047             46   reflow_temp:  ds 4 ;
004B             47   
004B             48   wait25_btn_cnt:    ds 1
004C             49   wait25_keypad_cnt: ds 1
004D             50   wait25_adc_cnt:    ds 1
004E             51   wait25_lcd_cnt:    ds 1
004F             52   wait25_count: ds 1  
0050             53   
0050             54   current_time: ds 4 ;
0054             55   soak_time:    ds 4 ;
0058             56   reflow_time:  ds 4 ;
005C             57   
005C             58   power_output:  ds 4 ;
0060             59   pwm_counter: ds 4 ; counter for pwm (0-1500)
0064             60   
0064             61   KEY1_DEB_timer: ds 1
0065             62   SEC_FSM_timer:  ds 1
0066             63   KEY1_DEB_state:    ds 1
0067             64   SEC_FSM_state:     ds 1
0068             65   Control_FSM_state: ds 1 
0069             66   
0069             67   Current_State:     ds 1
006A             68   
006A             69   
006A             70   ;-- UI buffers I added (ayaan)
006A             71   Cursor_Idx: ds 1
006B             72   
006B             73   ; These hold the TEXT (ASCII) safely
006B             74   ; Digits Only + Null Terminator, got rid of C,:, and s 
006B             75   Buf_Soak_Temp: ds 4   
006F             76   Buf_Soak_Time: ds 5   
0074             77   Buf_Refl_Temp: ds 4   
0078             78   Buf_Refl_Time: ds 5
007D             79   
007D             80   ; 46d bytes used
007D             81   
007D             82   ;-------------------------------------------------------------------------------
007D             83   ; bit operation setb, clr, jb, and jnb
0000             84   bseg
0000             85   mf:     dbit 1 ; math32 sign
0001             86   one_second_flag: dbit 1
0002             87   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003             88   
0003             89   soak_temp_reached: dbit 1
0004             90   reflow_temp_reached: dbit 1
0005             91   cooling_temp_reached: dbit 1
0006             92   
0006             93   soak_time_reached: dbit 1
0007             94   reflow_time_reached: dbit 1
0008             95   
0008             96   reset_signal: dbit 1
0009             97   stop_signal: dbit 1
000A             98   start_signal: dbit 1
000B             99   config_finish_signal: dbit 1
000C            100   
000C            101   state_change_signal: dbit 1
000D            102   
000D            103   Key1_flag: dbit 1
000E            104   
000E            105   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
000F            106   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0010            107   PB0_flag: dbit 1 ; start entire program
0011            108   PB1_flag: dbit 1 ; start soak
0012            109   PB2_flag: dbit 1 ; pause process
0013            110   
0013            111   ; BSEG (Bit Segment)
0013            112   wait25_active: dbit 1 ; 1 = We are currently waiting
0014            113   wait25_done:   dbit 1 ; 1 = The 25ms has finished
0015            114   wait25_btn_active:    dbit 1
0016            115   wait25_btn_done:      dbit 1
0017            116   wait25_keypad_active: dbit 1
0018            117   wait25_keypad_done:   dbit 1
0019            118   wait25_adc_active:    dbit 1
001A            119   wait25_adc_done:      dbit 1
001B            120   wait25_lcd_active:    dbit 1
001C            121   wait25_lcd_done:      dbit 1
001D            122   ; 11 bits used
001D            123   
001D            124   ;-------------------------------------------------------------------------------
0320            125   cseg
0320            126   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            127   BAUD           EQU 57600
0320            128   
0320            129   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            130   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            131   ; is always 12 unlike the N76E003 where is selectable.
0320            132   
0320            133   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            134   
0320            135   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            136   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            137   
0320            138   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            139   
0320            140   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            141   
0320            142   PWM_OUT        EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            143   
0320            144   ; These 'equ' must match the wiring between the DE10Lite board and the LCD!
0320            145   ; P0 is in connector JPIO.
0320            146   
0320            147   ;Added correct I/O definitions
0320            148   ;-- LCD Pins ---
0320            149   ELCD_RS equ P1.7
0320            150   ELCD_E  equ P1.1
0320            151   ELCD_D4 equ P0.7
0320            152   ELCD_D5 equ P0.5
0320            153   ELCD_D6 equ P0.3
0320            154   ELCD_D7 equ P0.1
0320            155   
0320            156   ; -- Buttons --
0320            157   BTN_SOAK_TEMP equ P0.0
0320            158   BTN_SOAK_TIME equ P0.2
0320            159   BTN_REFL_TEMP equ P0.4
0320            160   BTN_REFL_TIME equ P0.6
0320            161   
0320            162   ; --- KEYPAD ---
0320            163   ROW1 equ P1.2
0320            164   ROW2 equ P1.4
0320            165   ROW3 equ P1.6
0320            166   ROW4 equ P2.0
0320            167   COL1 equ P2.2
0320            168   COL2 equ P2.4
0320            169   COL3 equ P2.6
0320            170   COL4 equ P3.0
0320            171   
0320            172   ;                     1234567890123456 <-- 16 characters per line LCD
0320 696E6974   173   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   174   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   175   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            176   
0350            177   ; --- UI STRINGS (REQUIRED FOR KEYPAD LOGIC), <- I can fix if duplicates
0350 53656C65   178   Txt_Home:     db 'Select Mode:    ', 0
     6374204D
     6F64653A
     20202020
     00
0361 53657420   179   Txt_SoakT:    db 'Set Soak Temp   ', 0
     536F616B
     2054656D
     70202020
     00
0372 53657420   180   Txt_SoakTime: db 'Set Soak Time   ', 0
     536F616B
     2054696D
     65202020
     00
0383 53657420   181   Txt_ReflT:    db 'Set Reflow Temp ', 0
     5265666C
     6F772054
     656D7020
     00
0394 53657420   182   Txt_ReflTime: db 'Set Reflow Time ', 0
     5265666C
     6F772054
     696D6520
     00
03A5            183   
03A5            184   ;                       1234567890123456
03A5 53657420   185   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
03B5 536F616B   186   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
03C0 5265666C   187   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
03CD 536F616B   188   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
03D8 5265666C   189   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03E5            190   
03E5            191   ;                     1234567890123456
03E5 52616D70   192   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03F5 536F616B   193   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
0405 52616D70   194   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
0415 5265666C   195   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
0425 436F6F6C   196   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
0435 50726F63   197   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
0445            198   
0445 20202020   199   String_Blank:    db '                ', 0
>>>>>>> main
     20202020
     20202020
     20202020
     00
<<<<<<< HEAD
0401            158   
0401            159   ;-------------------------------------------------------------------------------
0401            160   ; Timers Setting:
0401            161   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
0401            162   ;        Timer 1: Serial port baud rate 57600 generator
0401            163   ;        Timer 2: 1ms interrupt for BCD counter increment/decrement
0401            164   ;-------------------------------------------------------------------------------
0401            165   ; Routine to initialize the ISR for Timer 0 ;
0401            166   Timer0_Init:
0401 E589       167            mov a, TMOD
0403 54F0       168            anl a, #0xf0 ; Clear the bits for timer 0
0405 4401       169            orl a, #0x01 ; Configure timer 0 as 16-timer
0407 F589       170            mov TMOD, a
0409 758CFD     171            mov TH0, #high(TIMER0_RELOAD)
040C 758A5A     172            mov TL0, #low(TIMER0_RELOAD)
040F            173            ; Enable the timer and interrupts
040F D2A9       174       setb ET0  ; Enable timer 0 interrupt
0411 D28C       175       setb TR0  ; Start timer 0
0413 22         176            ret
0414            177   ; ISR for timer 0.  Set to execute every 1/4096Hz 
0414            178   ; to generate a 2048 Hz square wave at pin P1.5 
0414            179   Timer0_ISR:
0414            180            ;clr TF0  ; According to the data sheet this is done for us already.
0414 758CFD     181            mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
0417 758A5A     182            mov TL0, #low(TIMER0_RELOAD)
041A B295       183            cpl SOUND_OUT ; Connect speaker to P1.5
041C 32         184            reti
041D            185   ; -----------------------------------------------------------------------------------------------;
041D            186   
041D            187   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
041D            188   Initialize_Serial_Port:
041D            189            ; Configure serial port and baud rate
041D C28E       190            clr TR1 ; Disable timer 1
041F 53890F     191            anl TMOD, #0x0f ; Mask the bits for timer 1
0422 438920     192            orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
0425 438780     193       orl PCON, #80H ; Set SMOD to 1
0428 758DFD     194            mov TH1, #low(TIMER_1_RELOAD)
042B 758BFD     195            mov TL1, #low(TIMER_1_RELOAD) 
042E D28E       196            setb TR1 ; Enable timer 1
0430 759852     197            mov SCON, #52H
0433 22         198            ret
0434            199   
0434            200   ; uart sending functions
0434            201   putchar:
0434 109902     202            jbc     TI, putchar_L1
0437 80FB       203            sjmp putchar
0439            204   putchar_L1:
0439 F599       205            mov     SBUF,a
043B 22         206            ret
043C            207   
043C            208   SendString:
043C E4         209       clr a
043D 93         210       movc a, @a+dptr
043E 6006       211       jz SendString_L1
0440 120434     212       lcall putchar
0443 A3         213       inc dptr
0444 80F6       214       sjmp SendString  
0446            215   SendString_L1:
0446 22         216            ret
0447            217   
0447            218   ;-------------------------------------------------------------------------------
0447            219   ; serial debugging
0447            220   ; send a four byte number via serial to laptop
0447            221   ; need to be used with python script
0447            222   ; content needed to be sent should be stored in the varaible x
0447            223   ;-------------------------------------------------------------------------------
0447            224   Send32:
0447            225       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
0447 74AA       226       mov A, #0AAH
0449 120434     227       lcall putchar
044C 7455       228       mov A, #055H
044E 120434     229       lcall putchar
0451            230   
0451 E53D       231       mov A, x+3
0453 120434     232       lcall putchar
0456 E53C       233       mov A, x+2
0458 120434     234       lcall putchar
045B E53B       235       mov A, x+1
045D 120434     236       lcall putchar
0460 E53A       237       mov A, x+0
0462 120434     238       lcall putchar
0465            239   
0465 740A       240       mov A, #0AH
0467 120434     241       lcall putchar
046A 22         242       ret
046B            243   ; -----------------------------------------------------------------------------------------------;
046B            244   
046B            245   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
046B              1   ;------------------------------------------------------------------------------------------------;
046B              2   ; Routine to initialize the ISR for timer 2 
046B              3   Timer2_Init:
046B 75C800       4            mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
046E 75CDF5       5            mov TH2, #high(TIMER2_RELOAD)
0471 75CC27       6            mov TL2, #low(TIMER2_RELOAD)
0474              7            ; Set the reload value
0474 75CBF5       8            mov RCAP2H, #high(TIMER2_RELOAD)
0477 75CA27       9            mov RCAP2L, #low(TIMER2_RELOAD)
047A             10            ; Enable the timer and interrupts
047A D2AD        11       setb ET2  ; Enable timer 2 interrupt
047C D2CA        12       setb TR2  ; Enable timer 2
047E 22          13            ret
047F             14   
047F             15   ; ISR for timer 2.  Runs every 1 ms ;
047F             16   Timer2_ISR:
047F C0E0        17            push acc
0481 C0D0        18            push psw
0483 C2CF        19            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
0485             20            ; cpl P1.1 ; Optional debug pin toggle for scope (ensure it's not used elsewhere)
0485             21   
0485             22   ; FSM states timers
0485 055B        23            inc KEY1_DEB_timer
0487 055C        24            inc SEC_FSM_timer
0489             25   
0489 D202        26            setb one_ms_pwm_flag ; set the one millisecond flag for pwm signal generation
048B D203        27            setb one_ms_buzz_flag
048D             28   
048D             29   Timer2_ISR_done:
048D D0D0        30            pop psw
048F D0E0        31            pop acc
0491 32          32            reti
0492             33   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
0492              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
0492              2   cseg
0492              3   
0492              4   ; When using a 33.333333MHz crystal clock
0492              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
0492              6   
0492              7   ;---------------------------------;
0492              8   ; Wait 40 microseconds            ;
0492              9   ;---------------------------------;
0492             10   Wait40uSec:
0492 C000        11            push AR0
0494 78BE        12            mov R0, #190
0496             13   L0: 
0496 00          14            nop
0497 00          15            nop
0498 00          16            nop
0499 00          17            nop
049A D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
049C D000        19            pop AR0
049E 22          20       ret
049F             21   
049F             22   ;---------------------------------;
049F             23   ; Wait 'R2' milliseconds          ;
049F             24   ;---------------------------------;
=======
0456            200   
0456            201   ;-------------------------------------------------------------------------------
0456            202   ; Timers Setting:
0456            203   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
0456            204   ;   Timer 1: Serial port baud rate 57600 generator
0456            205   ;   Timer 2: 1ms interrupt for BCD counter increment/decrement
0456            206   ;-------------------------------------------------------------------------------
0456            207   ; Routine to initialize the ISR for Timer 0 ;
0456            208   Timer0_Init:
0456 E589       209       mov a, TMOD
0458 54F0       210       anl a, #0xf0 ; Clear the bits for timer 0
045A 4401       211       orl a, #0x01 ; Configure timer 0 as 16-timer
045C F589       212       mov TMOD, a
045E 758CFD     213       mov TH0, #high(TIMER0_RELOAD)
0461 758A5A     214       mov TL0, #low(TIMER0_RELOAD)
0464            215       ; Enable the timer and interrupts
0464 D2A9       216       setb ET0  ; Enable timer 0 interrupt
0466 D28C       217       setb TR0  ; Start timer 0
0468 22         218       ret
0469            219   ; ISR for timer 0.  Set to execute every 1/4096Hz 
0469            220   ; to generate a 2048 Hz square wave at pin P1.5 
0469            221   Timer0_ISR:
0469            222       ;clr TF0  ; According to the data sheet this is done for us already.
0469 758CFD     223       mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
046C 758A5A     224       mov TL0, #low(TIMER0_RELOAD)
046F B295       225       cpl SOUND_OUT ; Connect speaker to P1.5
0471 32         226       reti
0472            227   ; -----------------------------------------------------------------------------------------------;
0472            228   
0472            229   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
0472            230   Initialize_Serial_Port:
0472            231       ; Configure serial port and baud rate
0472 C28E       232       clr TR1 ; Disable timer 1
0474 53890F     233       anl TMOD, #0x0f ; Mask the bits for timer 1
0477 438920     234       orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
047A 438780     235       orl PCON, #80H ; Set SMOD to 1
047D 758DFD     236       mov TH1, #low(TIMER_1_RELOAD)
0480 758BFD     237       mov TL1, #low(TIMER_1_RELOAD) 
0483 D28E       238       setb TR1 ; Enable timer 1
0485 759852     239       mov SCON, #52H
0488 22         240       ret
0489            241   
0489            242   ; uart sending functions
0489            243   putchar:
0489 109902     244       jbc TI, putchar_L1
048C 80FB       245       sjmp putchar
048E            246   putchar_L1:
048E F599       247       mov SBUF,a
0490 22         248       ret
0491            249   
0491            250   SendString:
0491 E4         251       clr a
0492 93         252       movc a, @a+dptr
0493 6006       253       jz SendString_L1
0495 120489     254       lcall putchar
0498 A3         255       inc dptr
0499 80F6       256       sjmp SendString  
049B            257   SendString_L1:
049B 22         258       ret
049C            259   
049C            260   ;-------------------------------------------------------------------------------
049C            261   ; serial debugging
049C            262   ; send a four byte number via serial to laptop
049C            263   ; need to be used with python script
049C            264   ; content needed to be sent should be stored in the varaible x
049C            265   ;-------------------------------------------------------------------------------
049C            266   Send32:
049C            267       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
049C 74AA       268       mov A, #0AAH
049E 120489     269       lcall putchar
04A1 7455       270       mov A, #055H
04A3 120489     271       lcall putchar
04A6            272   
04A6 E535       273       mov A, x+3
04A8 120489     274       lcall putchar
04AB E534       275       mov A, x+2
04AD 120489     276       lcall putchar
04B0 E533       277       mov A, x+1
04B2 120489     278       lcall putchar
04B5 E532       279       mov A, x+0
04B7 120489     280       lcall putchar
04BA            281   
04BA 740A       282       mov A, #0AH
04BC 120489     283       lcall putchar
04BF 22         284       ret
04C0            285   ; -----------------------------------------------------------------------------------------------;
04C0            286   
04C0            287   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
04C0              1   ;-------------------------------------------------------------------------------
04C0              2   ; Timer2_ISR.inc
04C0              3   ; Contains Initialization and ISR for the 1ms System Timer
04C0              4   ;-------------------------------------------------------------------------------
04C0              5   
04C0              6   ;-------------------------------------------------------------------------------
04C0              7   ; Routine to initialize the ISR for timer 2
04C0              8   ;-------------------------------------------------------------------------------
04C0              9   Timer2_Init:
04C0 75C800      10       mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
04C3 75CDF5      11       mov TH2, #high(TIMER2_RELOAD)
04C6 75CC27      12       mov TL2, #low(TIMER2_RELOAD)
04C9             13       ; Set the reload value
04C9 75CBF5      14       mov RCAP2H, #high(TIMER2_RELOAD)
04CC 75CA27      15       mov RCAP2L, #low(TIMER2_RELOAD)
04CF             16       
04CF C2CF        17       clr TF2       ; Clear flag just in case
04D1             18       ; Enable the timer and interrupts
04D1 D2AD        19       setb ET2      ; Enable timer 2 interrupt
04D3 D2CA        20       setb TR2      ; Enable timer 2
04D5 22          21       ret
04D6             22   
04D6             23   ;-------------------------------------------------------------------------------
04D6             24   ; ISR for timer 2.  Runs every 1 ms
04D6             25   ;-------------------------------------------------------------------------------
04D6             26   Timer2_ISR:
04D6 C0E0        27       push acc
04D8 C0D0        28       push psw
04DA             29       
04DA C2CF        30       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
04DC             31   
04DC             32       ; --- 1. Existing FSM Timers ---
04DC 0564        33       inc KEY1_DEB_timer
04DE 0565        34       inc SEC_FSM_timer
04E0 D202        35       setb one_ms_pwm_flag 
04E2             36   
04E2             37       ; --- 2. NEW: Non-Blocking Delay Counters ---
04E2             38       
04E2             39       ; A. BUTTON DELAY
04E2 30150B      40       jnb wait25_btn_active, T2_Check_Keypad
04E5 054B        41       inc wait25_btn_cnt
04E7 E54B        42       mov a, wait25_btn_cnt
04E9 B41904      43       cjne a, #25, T2_Check_Keypad
04EC D216        44       setb wait25_btn_done
04EE C215        45       clr wait25_btn_active
04F0             46       
04F0             47       ; B. KEYPAD DELAY
04F0             48   T2_Check_Keypad:
04F0 30170B      49       jnb wait25_keypad_active, T2_Check_ADC
04F3 054C        50       inc wait25_keypad_cnt
04F5 E54C        51       mov a, wait25_keypad_cnt
04F7 B41904      52       cjne a, #25, T2_Check_ADC
04FA D218        53       setb wait25_keypad_done
04FC C217        54       clr wait25_keypad_active
04FE             55   
04FE             56       ; C. ADC DELAY (Thermocouple)
04FE             57   T2_Check_ADC:
04FE 30190B      58       jnb wait25_adc_active, T2_Check_LCD
0501 054D        59       inc wait25_adc_cnt
0503 E54D        60       mov a, wait25_adc_cnt
0505 B41904      61       cjne a, #25, T2_Check_LCD
0508 D21A        62       setb wait25_adc_done
050A C219        63       clr wait25_adc_active
050C             64   
050C             65       ; D. LCD DELAY
050C             66   T2_Check_LCD:
050C 301B0B      67       jnb wait25_lcd_active, T2_Check_Generic
050F 054E        68       inc wait25_lcd_cnt
0511 E54E        69       mov a, wait25_lcd_cnt
0513 B41904      70       cjne a, #25, T2_Check_Generic
0516 D21C        71       setb wait25_lcd_done
0518 C21B        72       clr wait25_lcd_active
051A             73   
051A             74       ; E. GENERIC DELAY (Used by Wait_25ms in Main)
051A             75   T2_Check_Generic:
051A 30130B      76       jnb wait25_active, Timer2_ISR_done
051D 054F        77       inc wait25_count
051F E54F        78       mov a, wait25_count
0521 B41904      79       cjne a, #25, Timer2_ISR_done
0524 D214        80       setb wait25_done      ; Tells Wait_25ms that we are finished
0526 C213        81       clr wait25_active     ; Stop counting
0528             82   
0528             83   Timer2_ISR_done:
0528 D0D0        84       pop psw
052A D0E0        85       pop acc
052C 32          86       reti
052D             87            
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
052D              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
052D              2   cseg
052D              3   
052D              4   ; When using a 33.333333MHz crystal clock
052D              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
052D              6   
052D              7   ;---------------------------------;
052D              8   ; Wait 40 microseconds            ;
052D              9   ;---------------------------------;
052D             10   Wait40uSec:
052D C000        11            push AR0
052F 78BE        12            mov R0, #190
0531             13   L0: 
0531 00          14            nop
0532 00          15            nop
0533 00          16            nop
0534 00          17            nop
0535 D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
0537 D000        19            pop AR0
0539 22          20       ret
053A             21   
053A             22   ;---------------------------------;
053A             23   ; Wait 'R2' milliseconds          ;
053A             24   ;---------------------------------;
>>>>>>> main
                 25   Wait_Milli_Seconds mac
                 26   	push AR2
                 27   	mov R2, %0
                 28   	lcall ?Wait_Milli_Seconds
                 29   	pop AR2
                 30   endmac
<<<<<<< HEAD
049F             31   
049F             32   ?Wait_Milli_Seconds:
049F C000        33            push AR0
04A1 C001        34            push AR1
04A3 7932        35   L3: mov R1, #50
04A5 78DF        36   L2: mov R0, #223
04A7 D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
04A9 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
04AB DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
04AD D001        40       pop AR1
04AF D000        41       pop AR0
04B1 22          42       ret
04B2             43            
04B2             44   ;---------------------------------;
04B2             45   ; Toggles the 'E' pin in the LCD  ;
04B2             46   ;---------------------------------;
04B2             47   ELCD_pulse:
04B2 D2B3        48            setb ELCD_E
04B4 120492      49            lcall Wait40uSec
04B7 C2B3        50            clr ELCD_E
04B9 120492      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
04BC 22          52       ret
04BD             53   
04BD             54   ;---------------------------------;
04BD             55   ; Writes acc to LCD in 4-bit mode ;
04BD             56   ;---------------------------------;
04BD             57   ELCD_byte:
04BD             58            ; Write high 4 bits first
04BD A2E7        59            mov c, ACC.7
04BF 92A3        60            mov ELCD_D7, c
04C1 A2E6        61            mov c, ACC.6
04C3 92A5        62            mov ELCD_D6, c
04C5 A2E5        63            mov c, ACC.5
04C7 92A7        64            mov ELCD_D5, c
04C9 A2E4        65            mov c, ACC.4
04CB 92B1        66            mov ELCD_D4, c
04CD 1204B2      67       lcall ELCD_pulse
04D0             68            ; Write low 4 bits next
04D0 A2E3        69            mov c, ACC.3
04D2 92A3        70            mov ELCD_D7, c
04D4 A2E2        71            mov c, ACC.2
04D6 92A5        72            mov ELCD_D6, c
04D8 A2E1        73            mov c, ACC.1
04DA 92A7        74            mov ELCD_D5, c
04DC A2E0        75            mov c, ACC.0
04DE 92B1        76            mov ELCD_D4, c
04E0 1204B2      77       lcall ELCD_pulse
04E3 22          78            ret
04E4             79   
04E4             80   ;---------------------------------;
04E4             81   ; Write data to LCD               ;
04E4             82   ;---------------------------------;
=======
053A             31   
053A             32   ?Wait_Milli_Seconds:
053A C000        33            push AR0
053C C001        34            push AR1
053E 7932        35   L3: mov R1, #50
0540 78DF        36   L2: mov R0, #223
0542 D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
0544 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
0546 DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
0548 D001        40       pop AR1
054A D000        41       pop AR0
054C 22          42       ret
054D             43            
054D             44   ;---------------------------------;
054D             45   ; Toggles the 'E' pin in the LCD  ;
054D             46   ;---------------------------------;
054D             47   ELCD_pulse:
054D D291        48            setb ELCD_E
054F 12052D      49            lcall Wait40uSec
0552 C291        50            clr ELCD_E
0554 12052D      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
0557 22          52       ret
0558             53   
0558             54   ;---------------------------------;
0558             55   ; Writes acc to LCD in 4-bit mode ;
0558             56   ;---------------------------------;
0558             57   ELCD_byte:
0558             58            ; Write high 4 bits first
0558 A2E7        59            mov c, ACC.7
055A 9281        60            mov ELCD_D7, c
055C A2E6        61            mov c, ACC.6
055E 9283        62            mov ELCD_D6, c
0560 A2E5        63            mov c, ACC.5
0562 9285        64            mov ELCD_D5, c
0564 A2E4        65            mov c, ACC.4
0566 9287        66            mov ELCD_D4, c
0568 12054D      67       lcall ELCD_pulse
056B             68            ; Write low 4 bits next
056B A2E3        69            mov c, ACC.3
056D 9281        70            mov ELCD_D7, c
056F A2E2        71            mov c, ACC.2
0571 9283        72            mov ELCD_D6, c
0573 A2E1        73            mov c, ACC.1
0575 9285        74            mov ELCD_D5, c
0577 A2E0        75            mov c, ACC.0
0579 9287        76            mov ELCD_D4, c
057B 12054D      77       lcall ELCD_pulse
057E 22          78            ret
057F             79   
057F             80   ;---------------------------------;
057F             81   ; Write data to LCD               ;
057F             82   ;---------------------------------;
>>>>>>> main
                 83   WriteData mac
                 84   	mov a, %0
                 85   	lcall ?WriteData
                 86   endmac
<<<<<<< HEAD
04E4             87            
04E4             88   ?WriteData:
04E4 D2B7        89            setb ELCD_RS
04E6 0204BD      90            ljmp ELCD_byte
04E9             91   
04E9             92   ;---------------------------------;
04E9             93   ; Write command to LCD            ;
04E9             94   ;---------------------------------;
=======
057F             87            
057F             88   ?WriteData:
057F D297        89            setb ELCD_RS
0581 020558      90            ljmp ELCD_byte
0584             91   
0584             92   ;---------------------------------;
0584             93   ; Write command to LCD            ;
0584             94   ;---------------------------------;
>>>>>>> main
                 95   WriteCommand mac
                 96   	mov a, %0
                 97   	lcall ?WriteCommand
                 98   endmac
<<<<<<< HEAD
04E9             99   
04E9            100   ?WriteCommand:
04E9 C2B7       101            clr ELCD_RS
04EB 0204BD     102            ljmp ELCD_byte
04EE            103   
04EE            104   ;---------------------------------;
04EE            105   ; Configure LCD in 4-bit mode     ;
04EE            106   ;---------------------------------;
04EE            107   ELCD_4BIT:
04EE C2B3       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
04F0            109            ;clr ELCD_RW  ; RW forced to zero
04F0            110            
04F0            111            ; After power on, let the LCD start up before initializing
04F0 C002       112            push AR2
04F2 7A28       112            mov R2, #40
04F4 12049F     112            lcall ?Wait_Milli_Seconds
04F7 D002       112            pop AR2
04F9            112   
04F9            113            
04F9            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
04F9 7433       115            mov a, #0x33
04FB 1204E9     115            lcall ?WriteCommand
04FE 7433       116            mov a, #0x33
0500 1204E9     116            lcall ?WriteCommand
0503 7432       117            mov a, #0x32
0505 1204E9     117            lcall ?WriteCommand ; change to 4-bit mode
0508            118   
0508            119            ; Configure the LCD
0508 7428       120            mov a, #0x28
050A 1204E9     120            lcall ?WriteCommand
050D 740C       121            mov a, #0x0c
050F 1204E9     121            lcall ?WriteCommand
0512 7401       122            mov a, #0x01
0514 1204E9     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
0517            123   
0517            124       ;Wait for the clear screen command to finish.
0517 C002       125            push AR2
0519 7A02       125            mov R2, #2
051B 12049F     125            lcall ?Wait_Milli_Seconds
051E D002       125            pop AR2
0520            125   
0520 22         126       ret
0521            127   
0521            128   ;---------------------------------;
0521            129   ; Send a constant string to LCD   ;
0521            130   ;---------------------------------;
=======
0584             99   
0584            100   ?WriteCommand:
0584 C297       101            clr ELCD_RS
0586 020558     102            ljmp ELCD_byte
0589            103   
0589            104   ;---------------------------------;
0589            105   ; Configure LCD in 4-bit mode     ;
0589            106   ;---------------------------------;
0589            107   ELCD_4BIT:
0589 C291       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
058B            109            ;clr ELCD_RW  ; RW forced to zero
058B            110            
058B            111            ; After power on, let the LCD start up before initializing
058B C002       112            push AR2
058D 7A28       112            mov R2, #40
058F 12053A     112            lcall ?Wait_Milli_Seconds
0592 D002       112            pop AR2
0594            112   
0594            113            
0594            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
0594 7433       115            mov a, #0x33
0596 120584     115            lcall ?WriteCommand
0599 7433       116            mov a, #0x33
059B 120584     116            lcall ?WriteCommand
059E 7432       117            mov a, #0x32
05A0 120584     117            lcall ?WriteCommand ; change to 4-bit mode
05A3            118   
05A3            119            ; Configure the LCD
05A3 7428       120            mov a, #0x28
05A5 120584     120            lcall ?WriteCommand
05A8 740C       121            mov a, #0x0c
05AA 120584     121            lcall ?WriteCommand
05AD 7401       122            mov a, #0x01
05AF 120584     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
05B2            123   
05B2            124       ;Wait for the clear screen command to finish.
05B2 C002       125            push AR2
05B4 7A02       125            mov R2, #2
05B6 12053A     125            lcall ?Wait_Milli_Seconds
05B9 D002       125            pop AR2
05BB            125   
05BB 22         126       ret
05BC            127   
05BC            128   ;---------------------------------;
05BC            129   ; Send a constant string to LCD   ;
05BC            130   ;---------------------------------;
>>>>>>> main
                131   Send_Constant_String mac
                132   	push dph
                133   	push dpl
                134   	push acc
                135   	mov dptr, %0
                136   	lcall ?Send_Constant_String
                137   	pop acc
                138   	pop dpl
                139   	pop dph
                140   endmac
<<<<<<< HEAD
0521            141   
0521            142   ?Send_Constant_String:
0521 E4         143       clr a
0522 93         144       movc a, @a+dptr
0523 6006       145       jz ?Send_Constant_String_Done
0525 1204E4     146       lcall ?WriteData
0528 A3         147       inc dptr
0529 80F6       148       sjmp ?Send_Constant_String
052B            149   ?Send_Constant_String_Done:
052B 22         150       ret  
052C            151   
052C            152   ;---------------------------------;
052C            153   ; Set LCD cursor at row, column   ;
052C            154   ;---------------------------------;
=======
05BC            141   
05BC            142   ?Send_Constant_String:
05BC E4         143       clr a
05BD 93         144       movc a, @a+dptr
05BE 6006       145       jz ?Send_Constant_String_Done
05C0 12057F     146       lcall ?WriteData
05C3 A3         147       inc dptr
05C4 80F6       148       sjmp ?Send_Constant_String
05C6            149   ?Send_Constant_String_Done:
05C6 22         150       ret  
05C7            151   
05C7            152   ;---------------------------------;
05C7            153   ; Set LCD cursor at row, column   ;
05C7            154   ;---------------------------------;
>>>>>>> main
                155   Set_Cursor mac
                156   	push acc
                157   	mov a, #%1
                158   	dec a
                159   	lcall ?Set_Cursor_%0 ; Select column and row
                160   	pop acc
                161   endmac
<<<<<<< HEAD
052C            162   
052C            163   ?Set_Cursor_2:
052C 4440       164            orl a, #01000000B
052E            165   ?Set_Cursor_1:
052E 4480       166            orl a, #10000000B
0530 0204E9     167            ljmp ?WriteCommand ; Select column and row
0533            168   
0533            169   ;---------------------------------;
0533            170   ; Display a BCD number in the LCD ;
0533            171   ;---------------------------------;
=======
05C7            162   
05C7            163   ?Set_Cursor_2:
05C7 4440       164            orl a, #01000000B
05C9            165   ?Set_Cursor_1:
05C9 4480       166            orl a, #10000000B
05CB 020584     167            ljmp ?WriteCommand ; Select column and row
05CE            168   
05CE            169   ;---------------------------------;
05CE            170   ; Display a BCD number in the LCD ;
05CE            171   ;---------------------------------;
>>>>>>> main
                172   Display_BCD mac
                173   	push ar0
                174   	mov r0, %0
                175   	lcall ?Display_BCD
                176   	pop ar0
                177   endmac
<<<<<<< HEAD
0533            178   
0533            179   ?Display_BCD:
0533 C0E0       180            push acc
0535            181            ; Write most significant digit
0535 E8         182            mov a, r0
0536 C4         183            swap a
0537 540F       184            anl a, #0fh
0539 4430       185            orl a, #30h
053B 1204E4     186            lcall ?WriteData
053E            187            ; write least significant digit
053E E8         188            mov a, r0
053F 540F       189            anl a, #0fh
0541 4430       190            orl a, #30h
0543 1204E4     191            lcall ?WriteData
0546 D0E0       192            pop acc
0548 22         193            ret
0549            194   
0549            195   ;------------------------------------;
0549            196   ; Display a char in the LCD          ;
0549            197   ;------------------------------------;
=======
05CE            178   
05CE            179   ?Display_BCD:
05CE C0E0       180            push acc
05D0            181            ; Write most significant digit
05D0 E8         182            mov a, r0
05D1 C4         183            swap a
05D2 540F       184            anl a, #0fh
05D4 4430       185            orl a, #30h
05D6 12057F     186            lcall ?WriteData
05D9            187            ; write least significant digit
05D9 E8         188            mov a, r0
05DA 540F       189            anl a, #0fh
05DC 4430       190            orl a, #30h
05DE 12057F     191            lcall ?WriteData
05E1 D0E0       192            pop acc
05E3 22         193            ret
05E4            194   
05E4            195   ;------------------------------------;
05E4            196   ; Display a char in the LCD          ;
05E4            197   ;------------------------------------;
>>>>>>> main
                198   Display_char mac
                199   	push acc
                200   	mov a, %0
                201   	lcall ?WriteData
                202   	pop acc
                203   endmac
<<<<<<< HEAD
0549            204   
0549            248            ;-----------------------------------------------------------------------------------------------;
0549            249   
0549            250   ;-------------------------------------------------------------------------------
0549            251   ; Display Function for 7-segment displays                
0549            252   ;-------------------------------------------------------------------------------
0549            253   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
0549            254   T_7seg:
0549 C0F9A4B0   255       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
054E 9282F880   256       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
0553 8883C6A1   257       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
0559            258   
0559            259   ; Displays a BCD number pased in R0 in HEX5-HEX0
0559            260   Display_BCD_7_Seg_HEX10:
0559 900549     261            mov dptr, #T_7seg
055C E8         262            mov a, R0
055D C4         263            swap a
055E 540F       264            anl a, #0FH
0560 93         265            movc a, @a+dptr
0561 F592       266            mov HEX1, a
0563 E8         267            mov a, R0
0564 540F       268            anl a, #0FH
0566 93         269            movc a, @a+dptr
0567 F591       270            mov HEX0, a
0569 22         271            ret
056A            272   
056A            273   Display_BCD_7_Seg_HEX32:
056A 900549     274            mov dptr, #T_7seg
056D E8         275            mov a, R0
056E C4         276            swap a
056F 540F       277            anl a, #0FH
0571 93         278            movc a, @a+dptr
0572 F594       279            mov HEX3, a
0574 E8         280            mov a, R0
0575 540F       281            anl a, #0FH
0577 93         282            movc a, @a+dptr
0578 F593       283            mov HEX2, a
057A 22         284            ret
057B            285   
057B            286   Display_BCD_7_Seg_HEX54:
057B 900549     287            mov dptr, #T_7seg
057E E8         288            mov a, R0
057F C4         289            swap a
0580 540F       290            anl a, #0FH
0582 93         291            movc a, @a+dptr
0583 F58F       292            mov HEX5, a
0585 E8         293            mov a, R0
0586 540F       294            anl a, #0FH
0588 93         295            movc a, @a+dptr
0589 F58E       296            mov HEX4, a
058B 22         297            ret
058C            298   
058C            299   ; The 8-bit hex number passed in the accumulator is converted to
058C            300   ; BCD and stored in [R1, R0]
058C            301   Hex_to_bcd_8bit:
058C 75F064     302            mov b, #100
058F 84         303            div ab
0590 F9         304            mov R1, a   ; After dividing, a has the 100s
0591 E5F0       305            mov a, b    ; Remainder is in register b
0593 75F00A     306            mov b, #10
0596 84         307            div ab ; The tens are stored in a, the units are stored in b 
0597 C4         308            swap a
0598 54F0       309            anl a, #0xf0
059A 45F0       310            orl a, b
059C F8         311            mov R0, a
059D 22         312            ret
059E            313   
059E            314   ;-------------------------------------------------------------------------------
059E            315   ; Display Function for LCD                                               
059E            316   ;-------------------------------------------------------------------------------
059E            317   LCD_Display_Update_func:
059E C0E0       318            push acc
05A0 100E03     319            jbc state_change_signal, LCD_Display_Update_Do
05A3 0206D4     320            ljmp LCD_Display_Update_Done
05A6            321   
05A6            322   LCD_Display_Update_Do:
05A6 E55F       323            mov a, Control_FSM_state
05A8            324   
05A8            325   LCD_Display_Update_0:
05A8 B4003B     326            cjne a, #0, LCD_Display_Update_1
05AB C0E0       327            push acc
05AD 7401       327            mov a, #1
05AF 14         327            dec a
05B0 12052E     327            lcall ?Set_Cursor_1 ; Select column and row
05B3 D0E0       327            pop acc
05B5 C083       328            push dph
05B7 C082       328            push dpl
05B9 C0E0       328            push acc
05BB 900330     328            mov dptr, #String_state0_1
05BE 120521     328            lcall ?Send_Constant_String
05C1 D0E0       328            pop acc
05C3 D082       328            pop dpl
05C5 D083       328            pop dph
05C7 C0E0       329            push acc
05C9 7401       329            mov a, #1
05CB 14         329            dec a
05CC 12052C     329            lcall ?Set_Cursor_2 ; Select column and row
05CF D0E0       329            pop acc
05D1 C083       330            push dph
05D3 C082       330            push dpl
05D5 C0E0       330            push acc
05D7 900340     330            mov dptr, #String_state0_2
05DA 120521     330            lcall ?Send_Constant_String
05DD D0E0       330            pop acc
05DF D082       330            pop dpl
05E1 D083       330            pop dph
05E3 0206D4     331            ljmp LCD_Display_Update_done
05E6            332   
05E6            333   LCD_Display_Update_1:
05E6 B4011F     334            cjne a, #1, LCD_Display_Update_2
05E9 C0E0       335            push acc
05EB 7401       335            mov a, #1
05ED 14         335            dec a
05EE 12052E     335            lcall ?Set_Cursor_1 ; Select column and row
05F1 D0E0       335            pop acc
05F3 C083       336            push dph
05F5 C082       336            push dpl
05F7 C0E0       336            push acc
05F9 900350     336            mov dptr, #String_state1
05FC 120521     336            lcall ?Send_Constant_String
05FF D0E0       336            pop acc
0601 D082       336            pop dpl
0603 D083       336            pop dph
0605 0206D4     337            ljmp LCD_Display_Update_done
0608            338   
0608            339   LCD_Display_Update_2:
0608 B4021F     340            cjne a, #2, LCD_Display_Update_3
060B C0E0       341            push acc
060D 7401       341            mov a, #1
060F 14         341            dec a
0610 12052E     341            lcall ?Set_Cursor_1 ; Select column and row
0613 D0E0       341            pop acc
0615 C083       342            push dph
0617 C082       342            push dpl
0619 C0E0       342            push acc
061B 900390     342            mov dptr, #String_state2
061E 120521     342            lcall ?Send_Constant_String
0621 D0E0       342            pop acc
0623 D082       342            pop dpl
0625 D083       342            pop dph
0627 0206D4     343            ljmp LCD_Display_Update_done
062A            344   
062A            345   LCD_Display_Update_3:
062A B4031F     346            cjne a, #3, LCD_Display_Update_4
062D C0E0       347            push acc
062F 7401       347            mov a, #1
0631 14         347            dec a
0632 12052E     347            lcall ?Set_Cursor_1 ; Select column and row
0635 D0E0       347            pop acc
0637 C083       348            push dph
0639 C082       348            push dpl
063B C0E0       348            push acc
063D 9003A0     348            mov dptr, #String_state3
0640 120521     348            lcall ?Send_Constant_String
0643 D0E0       348            pop acc
0645 D082       348            pop dpl
0647 D083       348            pop dph
0649 0206D4     349            ljmp LCD_Display_Update_done
064C            350   
064C            351   LCD_Display_Update_4:
064C B4041F     352            cjne a, #4, LCD_Display_Update_5
064F C0E0       353            push acc
0651 7401       353            mov a, #1
0653 14         353            dec a
0654 12052E     353            lcall ?Set_Cursor_1 ; Select column and row
0657 D0E0       353            pop acc
0659 C083       354            push dph
065B C082       354            push dpl
065D C0E0       354            push acc
065F 9003B0     354            mov dptr, #String_state4
0662 120521     354            lcall ?Send_Constant_String
0665 D0E0       354            pop acc
0667 D082       354            pop dpl
0669 D083       354            pop dph
066B 0206D4     355            ljmp LCD_Display_Update_done
066E            356   
066E            357   LCD_Display_Update_5:
066E B4051F     358            cjne a, #5, LCD_Display_Update_6
0671 C0E0       359            push acc
0673 7401       359            mov a, #1
0675 14         359            dec a
0676 12052E     359            lcall ?Set_Cursor_1 ; Select column and row
0679 D0E0       359            pop acc
067B C083       360            push dph
067D C082       360            push dpl
067F C0E0       360            push acc
0681 9003C0     360            mov dptr, #String_state5
0684 120521     360            lcall ?Send_Constant_String
0687 D0E0       360            pop acc
0689 D082       360            pop dpl
068B D083       360            pop dph
068D 0206D4     361            ljmp LCD_Display_Update_done
0690            362   
0690            363   LCD_Display_Update_6:
0690 B4061F     364            cjne a, #6, LCD_Display_Update_7
0693 C0E0       365            push acc
0695 7401       365            mov a, #1
0697 14         365            dec a
0698 12052E     365            lcall ?Set_Cursor_1 ; Select column and row
069B D0E0       365            pop acc
069D C083       366            push dph
069F C082       366            push dpl
06A1 C0E0       366            push acc
06A3 9003D0     366            mov dptr, #String_state6
06A6 120521     366            lcall ?Send_Constant_String
06A9 D0E0       366            pop acc
06AB D082       366            pop dpl
06AD D083       366            pop dph
06AF 0206D4     367            ljmp LCD_Display_Update_done
06B2            368   
06B2            369   LCD_Display_Update_7:
06B2 B4071F     370            cjne a, #7, LCD_Display_Update_done
06B5 C0E0       371            push acc
06B7 7401       371            mov a, #1
06B9 14         371            dec a
06BA 12052E     371            lcall ?Set_Cursor_1 ; Select column and row
06BD D0E0       371            pop acc
06BF C083       372            push dph
06C1 C082       372            push dpl
06C3 C0E0       372            push acc
06C5 9003E0     372            mov dptr, #String_state7
06C8 120521     372            lcall ?Send_Constant_String
06CB D0E0       372            pop acc
06CD D082       372            pop dpl
06CF D083       372            pop dph
06D1 0206D4     373            ljmp LCD_Display_Update_done
06D4            374   
06D4            375   LCD_Display_Update_done:
06D4 D0E0       376            pop acc
06D6 22         377            ret
06D7            378   
06D7            379   LCD_Display_Update_Time:
06D7 300C2B     380            jnb time_count_doing_signal, LCD_Display_Update_Time_done
06DA 100102     381            jbc one_second_lcd_flag, LCD_Display_Update_Time_do
06DD 8026       382            sjmp LCD_Display_Update_Time_done
06DF            383   
06DF            384   LCD_Display_Update_Time_do:
06DF C0E0       385            push acc
06E1 740E       385            mov a, #14
06E3 14         385            dec a
06E4 12052C     385            lcall ?Set_Cursor_2 ; Select column and row
06E7 D0E0       385            pop acc
06E9 C000       386            push ar0
06EB A830       386            mov r0, current_time_sec
06ED 120533     386            lcall ?Display_BCD
06F0 D000       386            pop ar0
06F2 C0E0       387            push acc
06F4 740B       387            mov a, #11
06F6 14         387            dec a
06F7 12052C     387            lcall ?Set_Cursor_2 ; Select column and row
06FA D0E0       387            pop acc
06FC C000       388            push ar0
06FE A831       388            mov r0, current_time_minute
0700 120533     388            lcall ?Display_BCD
0703 D000       388            pop ar0
0705            389   
0705            390   LCD_Display_Update_Time_done:
0705 22         391            ret
0706            392   ;---------------------------------------------------------
0706            393   
0706            394   KEY1_DEB:
0706            395   ;non-blocking state machine for KEY1 debounce
0706 E55D       396            mov a, KEY1_DEB_state
0708            397   KEY1_DEB_state0:
0708 B4000A     398            cjne a, #0, KEY1_DEB_state1
070B 20F92D     399            jb KEY.1, KEY1_DEB_done
070E 755B00     400            mov KEY1_DEB_timer, #0
0711 055D       401            inc KEY1_DEB_state
0713 8026       402            sjmp KEY1_DEB_done
0715            403   KEY1_DEB_state1:
0715 B40109     404            cjne a, #1, KEY1_DEB_state2
0718            405            ; this is the debounce state
0718 E55B       406            mov a, KEY1_DEB_timer
071A B4321E     407            cjne a, #50, KEY1_DEB_done ; 50 ms passed?
071D 055D       408            inc KEY1_DEB_state
071F 801A       409            sjmp KEY1_DEB_done      
0721            410   KEY1_DEB_state2:
0721 B4020C     411            cjne a, #2, KEY1_DEB_state3
0724 20F904     412            jb KEY.1, KEY1_DEB_state2b
0727 055D       413            inc KEY1_DEB_state
0729 8010       414            sjmp KEY1_DEB_done      
072B            415   KEY1_DEB_state2b:
072B 755D00     416            mov KEY1_DEB_state, #0
072E 800B       417            sjmp KEY1_DEB_done
0730            418   KEY1_DEB_state3:
0730 B40308     419            cjne a, #3, KEY1_DEB_done
0733 30F905     420            jnb KEY.1, KEY1_DEB_done
0736 D211       421            setb Key1_flag ; Suscesfully detected a valid KEY1 press/release
0738 755D00     422            mov KEY1_DEB_state, #0  
073B            423   KEY1_DEB_done:
073B 22         424            ret
073C            425   
073C            426   ; ------------------------------------------------------------------------------
073C            427   ; Non-blocking FSM for the one second counter
073C            428   ;-------------------------------------------------------------------------------
073C            429   SEC_FSM:
073C E55E       430            mov a, SEC_FSM_state
073E            431   SEC_FSM_state0:
073E B4000C     432            cjne a, #0, SEC_FSM_state1
0741 E55C       433            mov a, SEC_FSM_timer
0743 B4FA4C     434            cjne a, #250, SEC_FSM_done ; 250 ms passed?
0746 755C00     435            mov SEC_FSM_timer, #0
0749 055E       436            inc SEC_FSM_state
074B 8045       437            sjmp SEC_FSM_done
074D            438   SEC_FSM_state1:  
074D B4010E     439            cjne a, #1, SEC_FSM_state2
0750 D2E9       440            setb LEDRA.1
0752 E55C       441            mov a, SEC_FSM_timer
0754 B4FA3B     442            cjne a, #250, SEC_FSM_done ; 250 ms passed?
0757 755C00     443            mov SEC_FSM_timer, #0
075A 055E       444            inc SEC_FSM_state
075C 8034       445            sjmp SEC_FSM_done
075E            446   SEC_FSM_state2:  
075E B4020E     447            cjne a, #2, SEC_FSM_state3
0761 D2EA       448            setb LEDRA.2
0763 E55C       449            mov a, SEC_FSM_timer
0765 B4FA2A     450            cjne a, #250, SEC_FSM_done ; 250 ms passed?
0768 755C00     451            mov SEC_FSM_timer, #0
076B 055E       452            inc SEC_FSM_state
076D 8023       453            sjmp SEC_FSM_done
076F            454   SEC_FSM_state3:  
076F B40320     455            cjne a, #3, SEC_FSM_done
0772 D2EB       456            setb LEDRA.3
0774 E55C       457            mov a, SEC_FSM_timer
0776 B4FA19     458            cjne a, #250, SEC_FSM_done ; 250 ms passed?
0779 755C00     459            mov SEC_FSM_timer, #0
077C 755E00     460            mov SEC_FSM_state, #0
077F            461            ; update current time
077F D201       462            setb one_second_lcd_flag
0781 E530       463       mov  a, current_time_sec
0783 04         464       inc  a
0784 B43C07     465       cjne a, #60, SEC_NoMinuteCarry
0787 753000     466       mov  current_time_sec, #0
078A 0531       467       inc  current_time_minute
078C 8002       468       sjmp SEC_TimeDone
078E            469   SEC_NoMinuteCarry:
078E F530       470       mov  current_time_sec, a
0790            471   SEC_TimeDone:
0790 B2E8       472       cpl  LEDRA.0              ; 1 Hz heartbeat LED
0792            473   SEC_FSM_done:
0792 22         474            ret
0793            475   
0793            476   ; ------------------------------------------------------------------------------
0793            477   ; Counting the processing time 
0793            478   ;-------------------------------------------------------------------------------
0793            479   Time_Counter:
0793 C0E0       480            push ACC
0795 C0D0       481            push psw
0797 E55F       482            mov a, Control_FSM_state
0799 B40211     483            cjne a, #2, Time_Counter_Nstate2
079C 101003     484            jbc state_change_signal_Count, Time_Counter_Start
079F 0207B8     485            ljmp Time_Counter_Done
07A2            486   
07A2            487   Time_Counter_Start:
07A2 753000     488            mov current_time_sec, #0
07A5 753100     489            mov current_time_minute, #0
07A8 D20C       490            setb time_count_doing_signal
07AA 0207B8     491            ljmp Time_Counter_Done
07AD            492   
07AD            493   Time_Counter_Nstate2:
07AD B40602     494            cjne a, #6, Time_Counter_Nstate6
07B0 C20C       495            clr time_count_doing_signal
07B2            496   
07B2            497   Time_Counter_Nstate6:
07B2 300C03     498            jnb time_count_doing_signal, Time_Counter_Done
07B5 12073C     499            lcall SEC_FSM
07B8            500   
07B8            501   Time_Counter_Done:
07B8 D0D0       502            pop psw
07BA D0E0       503            pop ACC
07BC 22         504            ret
07BD            505   
07BD            506   ;-------------------------------------------------------------------------------
07BD            507   ; PWM
07BD            508   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
07BD            509   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
07BD            510   ; ------------------------------------------------------------------------------
07BD            511   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
07BD 100202     512            jbc one_ms_pwm_flag, pwm_wave_generator
07C0 8071       513            sjmp end_pwm_generator
07C2            514   
07C2            515   pwm_wave_generator:
07C2 C200       516            clr mf
07C4            517            ; move pwm counter value into x for comparison purpose
07C4 85573A     518            mov x, pwm_counter
07C7 85583B     519            mov x+1, pwm_counter+1
07CA 85593C     520            mov x+2, pwm_counter+2
07CD 855A3D     521            mov x+3, pwm_counter+3
07D0            522   
07D0 753EDB     523            mov y+0, #low (PWM_PERIOD % 0x10000) 
07D3 753F05     523            mov y+1, #high(PWM_PERIOD % 0x10000) 
07D6 754000     523            mov y+2, #low (PWM_PERIOD / 0x10000) 
07D9 754100     523            mov y+3, #high(PWM_PERIOD / 0x10000) 
07DC            524   
07DC            525            ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
07DC            526            ; increase x by 1
07DC 120152     527            lcall x_eq_y 
07DF 20001D     528            jb mf, wrap_pwm_counter
07E2            529            ; x not equal 1499, increment by 1
07E2 753E01     530            mov y+0, #low (1 % 0x10000) 
07E5 753F00     530            mov y+1, #high(1 % 0x10000) 
07E8 754000     530            mov y+2, #low (1 / 0x10000) 
07EB 754100     530            mov y+3, #high(1 / 0x10000) 
07EE 1200D3     531            lcall add32
07F1            532            ; update pwm_counter
07F1 853A57     533            mov pwm_counter, x
07F4 853B58     534            mov pwm_counter+1, x+1
07F7 853C59     535            mov pwm_counter+2, x+2
07FA 853D5A     536            mov pwm_counter+3, x+3
07FD 8018       537            sjmp set_pwm
07FF            538   
07FF            539   wrap_pwm_counter:
07FF            540            ; x equal 1499, wrap to 0
07FF 753A00     541            mov x+0, #low (0 % 0x10000) 
0802 753B00     541            mov x+1, #high(0 % 0x10000) 
0805 753C00     541            mov x+2, #low (0 / 0x10000) 
0808 753D00     541            mov x+3, #high(0 / 0x10000) 
080B 853A57     542            mov pwm_counter, x
080E 853B58     543            mov pwm_counter+1, x+1
0811 853C59     544            mov pwm_counter+2, x+2
0814 853D5A     545            mov pwm_counter+3, x+3
0817            546   
0817            547   set_pwm:
0817            548            ; compare with power_output, if pwm counter smaller than power_output, 
0817            549            ; set pwm pin high; else set pwm pin low load y with power output value
0817 85533E     550            mov y, power_output
081A 85543F     551            mov y+1, power_output+1
081D 855540     552            mov y+2, power_output+2
0820 855641     553            mov y+3, power_output+3
0823            554   
0823            555            ; compare x(pwm counter) with y(power output)
0823 12011A     556            lcall x_lt_y
0826 200006     557            jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
0829            558            ;output set pwm pin low if pwm counter greater than power output
0829 C293       559            clr PWM_OUT
082B C2EC       560            clr LEDRA.4
082D 8004       561            sjmp end_pwm_generator
082F            562   
082F            563   set_pwm_high:
082F D293       564            setb PWM_OUT
0831 D2EC       565            setb LEDRA.4
0833            566   
0833            567   end_pwm_generator:
0833 22         568            ret
0834            569   
0834            570   ;-------------------------------------------------------------------------------
0834            571   
0834            572   ;-------------------------------------------------------------------------------
0834            573   ; BUZZER MODULE (non-blocking)
0834            574   ; Public API:
0834            575   ;   lcall Beep_StateChange   ; 1 beep  (priority 1)
0834            576   ;   lcall Beep_Done          ; 5 beeps (priority 2)
0834            577   ;   lcall Beep_Error         ; 10 beeps(priority 3)
0834            578   ; Background task:
0834            579   ;   lcall Buzzer_Task        ; call every loop
0834            580   ;-------------------------------------------------------------------------------
0834            581   Beep_StateChange:
0834 75F001     582       mov  B,  #1
0837 7F01       583       mov  R7, #1
0839 12084F     584       lcall Beep_Request
083C 22         585       ret
083D            586   
083D            587   Beep_Done:
083D 75F005     588       mov  B,  #5
0840 7F02       589       mov  R7, #2
0842 12084F     590       lcall Beep_Request
0845 22         591       ret
0846            592   
0846            593   Beep_Error:
0846 75F00A     594       mov  B,  #10
0849 7F03       595       mov  R7, #3
084B 12084F     596       lcall Beep_Request
084E 22         597       ret
084F            598   
084F            599   ;---------------------------------------------------------
084F            600   ; Beep_Request
084F            601   ; Inputs:
084F            602   ;   B  = number of beeps
084F            603   ;   R7 = priority (1/2/3)
084F            604   ; Behavior:
084F            605   ;   If new priority >= current, override current pattern.
084F            606   ;---------------------------------------------------------
084F            607   Beep_Request:
084F C0E0       608       push acc
0851 C0D0       609       push psw
0853            610   
0853 E563       611       mov  a, buzz_priority
0855 C3         612       clr  c
0856 9F         613       subb a, R7
0857 4004       614       jc   Beep_Accept
0859 6002       615       jz   Beep_Accept
085B 800D       616       sjmp Beep_Req_Done
085D            617   
085D            618   Beep_Accept:
085D 8F63       619       mov  buzz_priority, R7
085F 85F062     620       mov  buzz_beeps_left, B
0862 756100     621       mov  buzz_timer, #0
0865 756001     622       mov  buzz_state, #1      ; start ON now
0868 D28C       623       setb TR0                 ; tone ON
086A            624   
086A            625   Beep_Req_Done:
086A D0D0       626       pop  psw
086C D0E0       627       pop  acc
086E 22         628       ret
086F            629   
086F            630   ;---------------------------------------------------------
086F            631   ; Buzzer_Task
086F            632   ; - Call every loop
086F            633   ; - Advances only when one_millisecond_flag is set
086F            634   ;---------------------------------------------------------
086F            635   Buzzer_Task:
086F 100301     636       jbc  one_ms_buzz_flag, Buzzer_Step
0872 22         637       ret
0873            638   
0873            639   Buzzer_Step:
0873 E560       640       mov  a, buzz_state
0875            641   
0875            642   ; IDLE
0875            643   Buzzer_State0:
0875 B40008     644       cjne a, #0, Buzzer_State1
0878 C28C       645       clr  TR0
087A C295       646       clr  SOUND_OUT
087C 756300     647       mov  buzz_priority, #0
087F 22         648       ret
0880            649   
0880            650   ; ON phase
0880            651   Buzzer_State1:
0880 B40112     652       cjne a, #1, Buzzer_State2
0883 0561       653       inc  buzz_timer
0885 E561       654       mov  a, buzz_timer
0887 B46430     655       cjne a, #BEEP_ON_MS, Buzzer_Done
088A            656   
088A            657       ; ON time elapsed -> go OFF
088A 756100     658       mov  buzz_timer, #0
088D 756002     659       mov  buzz_state, #2
0890 C28C       660       clr  TR0
0892 C295       661       clr  SOUND_OUT
0894 22         662       ret
0895            663   
0895            664   ; OFF phase
0895            665   Buzzer_State2:
0895 0561       666       inc  buzz_timer
0897 E561       667       mov  a, buzz_timer
0899 B4641E     668       cjne a, #BEEP_OFF_MS, Buzzer_Done
089C            669   
089C            670       ; OFF time elapsed -> one beep finished
089C 756100     671       mov  buzz_timer, #0
089F            672   
089F E562       673       mov  a, buzz_beeps_left
08A1 600C       674       jz   Buzzer_GoIdle
08A3 1562       675       dec  buzz_beeps_left
08A5 E562       676       mov  a, buzz_beeps_left
08A7 6006       677       jz   Buzzer_GoIdle
08A9            678   
08A9            679       ; start next beep
08A9 756001     680       mov  buzz_state, #1
08AC D28C       681       setb TR0
08AE 22         682       ret
08AF            683   
08AF            684   Buzzer_GoIdle:
08AF 756000     685       mov  buzz_state, #0
08B2 C28C       686       clr  TR0
08B4 C295       687       clr  SOUND_OUT
08B6 756300     688       mov  buzz_priority, #0
08B9 22         689       ret
08BA            690   
08BA            691   Buzzer_Done:
08BA 22         692       ret
08BB            693   ;---------------------------------------------------------
08BB            694   
08BB            695   ;-------------------------------------------------------------------------------;
08BB            696   ; Temp_Compare
08BB            697   ;
08BB            698   ; PURPOSE:
08BB            699   ;   Compare the current measured temperature against
08BB            700   ;   the soak and reflow temperature setpoints.
08BB            701   ;
08BB            702   ; BEHAVIOR:
08BB            703   ;   - If current_temp >= soak_temp   if soak_temp_reached   = 1
08BB            704   ;   - If current_temp >= reflow_temp if reflow_temp_reached = 1
08BB            705   ;
08BB            706   ; NOTES:
08BB            707   ;   - Uses 32-bit UNSIGNED comparison from math32.asm
08BB            708   ;   - Comparison is done by:
08BB            709   ;       x < y ?   (mf = 1)  if NOT reached
08BB            710   ;       x >= y ?  (mf = 0)  if reached
08BB            711   ;   - This routine ONLY SETS flags.
08BB            712   ;     Clearing flags must be handled by the FSM.
08BB            713   ;
08BB            714   ; EXPECTED VARIABLES (DSEG / BSEG):
08BB            715   ;   current_temp[4], soak_temp[4], reflow_temp[4]
08BB            716   ;   x[4], y[4]
08BB            717   ;   mf (math32 compare flag)
08BB            718   ;   soak_temp_reached, reflow_temp_reached
08BB            719   ;-------------------------------------------------------------------------------;
08BB            720   Temp_Compare:
08BB C0E0       721       push acc
08BD C0D0       722       push psw
08BF C000       723       push AR0
08C1 C001       724       push AR1
08C3 C002       725       push AR2
08C5            726       
08C5            727   ; Check: current_temp >= soak_temp ?
08C5            728       ; Copy current_temp of x (math32 operand A)
08C5 7847       729       mov  R0, #current_temp
08C7 793A       730       mov  R1, #x
08C9 120965     731       lcall Copy4_Bytes_R0_to_R1
08CC            732   
08CC            733       ; Copy soak_temp of y (math32 operand B)
08CC 784B       734       mov  R0, #soak_temp
08CE 793E       735       mov  R1, #y
08D0 120965     736       lcall Copy4_Bytes_R0_to_R1
08D3            737   
08D3            738       ; Perform x < y comparison
08D3            739       ; mf = 1 if current_temp < soak_temp  (NOT reached)
08D3            740       ; mf = 0 if current_temp >= soak_temp (REACHED)
08D3 12011A     741       lcall x_lt_y
08D6 200002     742       jb   mf, Temp_Soak_NotReached
08D9 D204       743       setb soak_temp_reached
08DB            744   
08DB            745   ; Check: current_temp >= reflow_temp ?
08DB            746   Temp_Soak_NotReached:
08DB            747       ; Copy current_temp of x
08DB 7847       748       mov  R0, #current_temp
08DD 793A       749       mov  R1, #x
08DF 120965     750       lcall Copy4_Bytes_R0_to_R1
08E2            751   
08E2            752       ; Copy reflow_temp of y
08E2 784F       753       mov  R0, #reflow_temp
08E4 793E       754       mov  R1, #y
08E6 120965     755       lcall Copy4_Bytes_R0_to_R1
08E9            756   
08E9            757       ; Compare x < y again
08E9 12011A     758       lcall x_lt_y
08EC 200002     759       jb   mf, Temp_Reflow_NotReached
08EF D205       760       setb reflow_temp_reached
08F1            761   
08F1            762   Temp_Reflow_NotReached:
08F1 D002       763       pop  AR2
08F3 D001       764       pop  AR1
08F5 D000       765       pop  AR0
08F7 D0D0       766       pop  psw
08F9 D0E0       767       pop  acc
08FB 22         768       ret
08FC            769   
08FC            770   ;-------------------------------------------------------------------------------
08FC            771   ; Time_Compare_MMSS
08FC            772   ;
08FC            773   ; PURPOSE:
08FC            774   ;   Compare elapsed time (current_time_minute:current_time_sec)
08FC            775   ;   against soak and reflow setpoints (soak_time_*, reflow_time_*).
08FC            776   ;
08FC            777   ; BEHAVIOR:
08FC            778   ;   If current >= soak   -> set soak_time_reached
08FC            779   ;   If current >= reflow -> set reflow_time_reached
08FC            780   ;
08FC            781   ; NOTES:
08FC            782   ;   Compare minutes first, then seconds.
08FC            783   ;-------------------------------------------------------------------------------
08FC            784   Time_Compare_MMSS:
08FC C0E0       785       push acc
08FE C0D0       786       push psw
0900            787   
0900 E55F       788            mov a, Control_FSM_state
0902 B4032C     789            cjne a, #3, TC_Not_Soak
0905            790   ; soak state time comparison
0905 100F02     791            jbc state_change_signal_TC, TC_Soak_Start_Record
0908 8013       792            sjmp TC_Soak_Comparing
090A            793   
090A            794   TC_Soak_Start_Record:
090A E531       795            mov a, current_time_minute
090C 2533       796            add a, soak_time_minute
090E F537       797            mov soak_end_time_minute, a
0910            798   
0910 E530       799            mov a, current_time_sec
0912 2532       800            add a, soak_time_sec
0914 F536       801            mov soak_end_time_sec, a
0916 C3         802            clr c
0917 943C       803            subb a, #60
0919            804   
0919 F536       805            mov soak_end_time_sec, a
091B 0537       806            inc soak_end_time_minute
091D            807   
091D            808   TC_Soak_Comparing:
091D E537       809       mov  a, soak_end_time_minute
091F C3         810       clr  c
0920 9531       811       subb a, current_time_minute
0922 403C       812            jc   TC_Done                   ; current_min < end_min
0924 7007       813       jnz  TC_Soak_Reached           ; current_min > end_min
0926            814   
0926            815       ; minutes equal -> compare seconds
0926 E536       816       mov  a, soak_end_time_sec
0928 C3         817       clr  c
0929 9530       818       subb a, current_time_sec
092B 7033       819       jnz   TC_Done
092D            820   
092D            821   TC_Soak_Reached:
092D D207       822       setb soak_time_reached
092F 802F       823            sjmp TC_Done
0931            824   
0931            825   TC_Not_Soak:
0931 E55F       826            mov a, Control_FSM_state
0933 B4052A     827            cjne a, #5, TC_Done
0936            828   ; soak state time comparison
0936 100F02     829            jbc state_change_signal_TC, TC_Reflow_Start_Record
0939 8013       830            sjmp TC_Reflow_Comparing
093B            831   
093B            832   TC_Reflow_Start_Record:
093B E531       833            mov a, current_time_minute
093D 2535       834            add a, reflow_time_minute
093F F539       835            mov reflow_end_time_minute, a
0941            836   
0941 E530       837            mov a, current_time_sec
0943 2534       838            add a, reflow_time_sec
0945 F538       839            mov reflow_end_time_sec, a
0947 C3         840            clr c
0948 943C       841            subb a, #60
094A            842   
094A F538       843            mov reflow_end_time_sec, a
094C 0539       844            inc reflow_end_time_minute
094E            845   
094E            846   TC_Reflow_Comparing:
094E E539       847       mov  a, reflow_end_time_minute
0950 C3         848       clr  c
0951 9531       849       subb a, current_time_minute
0953 400B       850       jc   TC_Done
0955 7007       851       jnz  TC_Reflow_Reached
0957            852   
0957 E538       853       mov  a, reflow_end_time_sec
0959 C3         854       clr  c
095A 9530       855       subb a, current_time_sec
095C 4002       856            jc   TC_Done
095E            857   
095E            858   TC_Reflow_Reached:
095E D208       859       setb reflow_time_reached
0960            860   
0960            861   TC_Done:
0960 D0D0       862       pop  psw
0962 D0E0       863       pop  acc
0964 22         864       ret
0965            865   
0965            866   ;-------------------------------------------------------------------------------;
0965            867   ; Copy4_Bytes_R0_to_R1
0965            868   ;
0965            869   ; PURPOSE:
0965            870   ;   Utility routine to copy a 32-bit value (4 bytes)
0965            871   ;   from one memory location to another.
0965            872   ;
0965            873   ; INPUTS:
0965            874   ;   R0 st source address
0965            875   ;   R1 at destination address
0965            876   ;
0965            877   ; USES:
0965            878   ;   R2 as loop counter
0965            879   ;
0965            880   ; EXAMPLE:
0965            881   ;   mov R0, #current_temp
0965            882   ;   mov R1, #x
0965            883   ;   lcall Copy4_Bytes_R0_to_R1
0965            884   ;-------------------------------------------------------------------------------;
0965            885   Copy4_Bytes_R0_to_R1:
0965 7A04       886       mov  R2, #4
0967            887   Copy4_Loop:
0967 E6         888       mov  a, @R0
0968 F7         889       mov  @R1, a
0969 08         890       inc  R0
096A 09         891       inc  R1
096B DAFA       892       djnz R2, Copy4_Loop
096D 22         893       ret
096E            894   
096E            895   ;-------------------------------------------------------------------------------;
096E            896   ; Abort condition safety check Temperature time
096E            897   ;
096E            898   ; PURPOSE:
096E            899   ;   Automatic cycle termination on error:
096E            900   ;   Abort if oven fails to reach at least 50C in first 60s.
096E            901   ;
096E            902   ; TRIP CONDITION:
096E            903   ;   if (current_time >= 60s) AND (current_temp < 50C)
096E            904   ;       -> set tc_missing_abort
096E            905   ;       -> set stop_signal
096E            906   ;
096E            907   ; ASSUMPTIONS:
096E            908   ;   - current_time is in SECONDS (32-bit, little-endian)
096E            909   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
096E            910   ;
096E            911   ;   the Load_Y constants accordingly.
096E            912   ;-------------------------------------------------------------------------------;
096E            913   Safety_Check_TC:
096E C0E0       914       push acc
0970 C0D0       915       push psw
0972 C000       916       push AR0
0974 C001       917       push AR1
0976 C002       918       push AR2
0978            919   
0978            920       ; If already aborted or startup window closed, do nothing
0978 20122F     921       jb   tc_missing_abort, Safety_TC_Done
097B 30132C     922       jnb  tc_startup_window, Safety_TC_Done
097E            923   
097E            924       ; Check: elapsed >= 60 seconds ?
097E E531       925       mov  a, current_time_minute
0980 7007       926       jnz  Safety_TC_At60          ; if minute >= 1, definitely >=60s
0982            927   
0982 E530       928       mov  a, current_time_sec
0984 C3         929       clr  c
0985 943C       930       subb a, #60
0987 4021       931       jc   Safety_TC_Done          ; still < 60s
0989            932   
0989            933   Safety_TC_At60:
0989            934   
0989            935       ; We reached 60s: close the startup window so it won't re-check later
0989 C213       936       clr  tc_startup_window
098B            937   
098B            938       ; Now check: current_temp < 50 ?
098B 7847       939       mov  R0, #current_temp
098D 793A       940       mov  R1, #x
098F 120965     941       lcall Copy4_Bytes_R0_to_R1
0992            942   
0992 753E32     943            mov y+0, #low (50 % 0x10000) 
0995 753F00     943            mov y+1, #high(50 % 0x10000) 
0998 754000     943            mov y+2, #low (50 / 0x10000) 
099B 754100     943            mov y+3, #high(50 / 0x10000) 
099E 12011A     944       lcall x_lt_y
09A1 300006     945       jnb  mf, Safety_TC_Done        ; temp >= 50  pass
09A4            946   
09A4            947       ; FAIL: at 60s, still below 50C  abort
09A4 D212       948       setb tc_missing_abort
09A6 D20A       949       setb stop_signal
09A8 C293       950       clr  PWM_OUT
09AA            951   
09AA            952   Safety_TC_Done:
09AA D002       953       pop  AR2
09AC D001       954       pop  AR1
09AE D000       955       pop  AR0
09B0 D0D0       956       pop  psw
09B2 D0E0       957       pop  acc
09B4 22         958       ret
09B5            959   
09B5            960   ;-------------------------------------------------------------------------------;
09B5            961   ; Main Control FSM for the entire process
09B5            962   ;-------------------------------------------------------------------------------;
09B5            963   Control_FSM:
09B5 E55F       964            mov a, Control_FSM_state
09B7 8009       965            sjmp Control_FSM_state0
09B9            966   
09B9            967   Control_FSM_state0_a:
09B9 755F00     968            mov Control_FSM_state, #0
09BC C214       969            clr PB0_flag
09BE D20E       970            setb state_change_signal
09C0 D20F       971            setb state_change_signal_TC
09C2            972   Control_FSM_state0:
09C2 B4000B     973            cjne a, #0, Control_FSM_state1
09C5 101402     974            jbc PB0_flag, Control_FSM_state1_a
09C8 8078       975            sjmp Control_FSM_done
09CA            976   
09CA            977   Control_FSM_state1_a:
09CA 055F       978            inc Control_FSM_state
09CC D20E       979            setb state_change_signal
09CE D20F       980            setb state_change_signal_TC
09D0            981   Control_FSM_state1:
09D0 B40112     982            cjne a, #1, Control_FSM_state2
09D3 101502     983            jbc PB1_flag, Control_FSM_state1_b
09D6 806A       984            sjmp Control_FSM_done
09D8            985   Control_FSM_state1_b:
09D8 100D02     986            jbc config_finish_signal, Control_FSM_state2_a
09DB 8065       987            sjmp Control_FSM_done
09DD            988   
09DD            989   Control_FSM_state2_a:
09DD 055F       990            inc Control_FSM_state
09DF D20E       991            setb state_change_signal
09E1 D20F       992            setb state_change_signal_TC
09E3 D210       993            setb state_change_signal_Count
09E5            994   Control_FSM_state2:
09E5 B4020E     995            cjne a, #2, Control_FSM_state3
09E8 101638     996            jbc PB2_flag, Control_FSM_state6_a
09EB 100402     997            jbc soak_temp_reached, Control_FSM_state3_a
09EE 8052       998            sjmp Control_FSM_done
09F0            999   
09F0           1000   Control_FSM_state3_a:
09F0 055F      1001            inc Control_FSM_state
09F2 D20E      1002            setb state_change_signal
09F4 D20F      1003            setb state_change_signal_TC
09F6           1004   Control_FSM_state3:
09F6 B4030E    1005            cjne a, #3, Control_FSM_state4
09F9 101627    1006            jbc PB2_flag, Control_FSM_state6_a
09FC 100702    1007            jbc soak_time_reached, Control_FSM_state4_a
09FF 8041      1008            sjmp Control_FSM_done
0A01           1009   
0A01           1010   Control_FSM_state4_a:
0A01 055F      1011            inc Control_FSM_state   
0A03 D20E      1012            setb state_change_signal
0A05 D20F      1013            setb state_change_signal_TC
0A07           1014   Control_FSM_state4:
0A07 B4040E    1015            cjne a, #4, Control_FSM_state5
0A0A 101616    1016            jbc PB2_flag, Control_FSM_state6_a
0A0D 100502    1017            jbc reflow_temp_reached, Control_FSM_state5_a
0A10 8030      1018            sjmp Control_FSM_done
0A12           1019   
0A12           1020   Control_FSM_state5_a:
0A12 055F      1021            inc Control_FSM_state
0A14 D20E      1022            setb state_change_signal
0A16 D20F      1023            setb state_change_signal_TC
0A18           1024   Control_FSM_state5:
0A18 B40510    1025            cjne a, #5, Control_FSM_state6
0A1B 101605    1026            jbc PB2_flag, Control_FSM_state6_a
0A1E 100802    1027            jbc reflow_time_reached, Control_FSM_state6_a
0A21 801F      1028            sjmp Control_FSM_done
0A23           1029   
0A23           1030   Control_FSM_state6_a:
0A23 055F      1031            inc Control_FSM_state
0A25 D20E      1032            setb state_change_signal
0A27 D20F      1033            setb state_change_signal_TC
0A29 D210      1034            setb state_change_signal_Count
0A2B           1035   Control_FSM_state6:
0A2B B40614    1036            cjne a, #6, Control_FSM_done
0A2E 100602    1037            jbc cooling_temp_reached, Control_FSM_state7_a
0A31 800F      1038            sjmp Control_FSM_done
0A33           1039   
0A33           1040   Control_FSM_state7_a:
0A33 055F      1041            inc Control_FSM_state
0A35 D20E      1042            setb state_change_signal
0A37 D20F      1043            setb state_change_signal_TC
0A39           1044   Control_FSM_state7:
0A39 B40706    1045            cjne a, #7, Control_FSM_done
0A3C 301403    1046            jnb PB0_flag, Control_FSM_done
0A3F 0209B9    1047            ljmp Control_FSM_state0_a
0A42           1048   
0A42           1049   Control_FSM_done:
0A42 22        1050            ret
0A43           1051   ;-------------------------------------------------------------------------------;
0A43           1052   ;         Main program.          
0A43           1053   ;-------------------------------------------------------------------------------;
0A43           1054   main:
0A43           1055            ; Initialization
0A43 75817F    1056       mov SP, #0x7F
0A46           1057   
0A46           1058            ; We use the pins of P0 to control the LCD.  Configure as outputs.
0A46 759A7F    1059       mov P0MOD, #01111111b ; P0.0 to P0.6 are outputs.  ('1' makes the pin output)
0A49           1060       ; We use pins P1.5 and P1.1 as outputs also.  Configure accordingly.
0A49 759B22    1061       mov P1MOD, #00100010b ; P1.5 and P1.1 are outputs
0A4C 759CFF    1062       mov P2MOD, #0xff
0A4F 759DFF    1063       mov P3MOD, #0xff
0A52           1064       ; Turn off all the LEDs
0A52 75E800    1065       mov LEDRA, #0 ; LEDRA is bit addressable
0A55 759500    1066       mov LEDRB, #0 ; LEDRB is NOT bit addresable
0A58           1067   
0A58           1068            ; Enable Global interrupts
0A58 D2AF      1069       setb EA  
0A5A           1070   
0A5A           1071            ; FSM initial states
0A5A 755D00    1072            mov KEY1_DEB_state, #0
0A5D 755E00    1073            mov SEC_FSM_state, #0
0A60 755F00    1074            mov Control_FSM_state, #0
0A63           1075            ; FSM timers initialization
0A63 755B00    1076            mov KEY1_DEB_timer, #0
0A66 755C00    1077            mov SEC_FSM_timer, #0
0A69           1078            ; time counters initialization
0A69 753000    1079            mov current_time_sec, #0
0A6C 753100    1080            mov current_time_minute, #0
0A6F 753200    1081            mov soak_time_sec, #0
0A72 753300    1082            mov soak_time_minute, #0
0A75 753400    1083            mov reflow_time_sec, #0
0A78 753500    1084            mov reflow_time_minute, #0
0A7B 753600    1085            mov soak_end_time_sec, #0
0A7E 753700    1086            mov soak_end_time_minute, #0
0A81 753800    1087            mov reflow_end_time_sec, #0
0A84 753900    1088            mov reflow_end_time_minute, #0
0A87           1089   
0A87           1090            ; Initialize counter to zero
0A87 755700    1091       mov pwm_counter, #0
0A8A 755800    1092            mov pwm_counter+1, #0
0A8D 755900    1093            mov pwm_counter+2, #0
0A90 755A00    1094            mov pwm_counter+3, #0
0A93           1095            ; Initialize power output
0A93 755600    1096            mov power_output+3, #0
0A96 755500    1097            mov power_output+2, #0
0A99 755402    1098            mov power_output+1, #02H
0A9C 7553EE    1099            mov power_output, #0EEH ; (initilize to 750 for testing)
0A9F           1100   
0A9F           1101            ; Clear all the flags
0A9F C295      1102            clr SOUND_OUT
0AA1 C212      1103            clr tc_missing_abort
0AA3 C20A      1104            clr stop_signal
0AA5 C214      1105            clr PB0_flag
0AA7 C215      1106            clr PB1_flag
0AA9 C216      1107            clr PB2_flag
0AAB C201      1108            clr one_second_lcd_flag
0AAD C20D      1109            clr config_finish_signal
0AAF C204      1110            clr soak_temp_reached
0AB1 C207      1111            clr soak_time_reached
0AB3 C205      1112            clr reflow_temp_reached
0AB5 C208      1113            clr reflow_time_reached
0AB7 C206      1114            clr cooling_temp_reached
0AB9 C20E      1115            clr state_change_signal
0ABB C20F      1116            clr state_change_signal_TC
0ABD C210      1117            clr state_change_signal_Count
0ABF C20C      1118            clr time_count_doing_signal
0AC1           1119   
0AC1           1120            ; Set bit
0AC1 D213      1121            setb tc_startup_window
0AC3           1122   
0AC3 120401    1123            lcall Timer0_Init
0AC6 12046B    1124       lcall Timer2_Init
0AC9 1204EE    1125            lcall ELCD_4BIT
0ACC 12041D    1126            lcall Initialize_Serial_Port
0ACF           1127   ;-------------------------------------------------------------------------------;
0ACF           1128   ; while(1) loop
0ACF           1129   ;-------------------------------------------------------------------------------;
0ACF           1130   loop:
0ACF           1131            ; Check the FSM for KEY1 debounce
0ACF 120706    1132            lcall KEY1_DEB
0AD2           1133   
0AD2           1134            ; Check the FSM for the overall control flow of the reflow process
0AD2 1209B5    1135            lcall Control_FSM
0AD5           1136   
0AD5           1137            ; Update the LCD display based on the current state
0AD5 12059E    1138            lcall LCD_Display_Update_func
0AD8           1139   
0AD8           1140            ; Update the pwm output for the ssr
0AD8 1207BD    1141            lcall PWM_Wave 
0ADB           1142   
0ADB 120793    1143            lcall Time_Counter
0ADE           1144   
0ADE 1206D7    1145            lcall LCD_Display_Update_Time
0AE1           1146   
0AE1 1208FC    1147            lcall Time_Compare_MMSS
0AE4           1148   
0AE4           1149            ; After initialization the program stays in this 'forever' loop
0AE4 020ACF    1150            ljmp loop
0AE7           1151   ;-------------------------------------------------------------------------------;
0AE7           1152   
0AE7           1153   END
=======
05E4            204   
05E4            290            ;-----------------------------------------------------------------------------------------------;
05E4            291   
05E4            292   ;-------------------------------------------------------------------------------
05E4            293   ; Display Function for 7-segment displays       
05E4            294   ;-------------------------------------------------------------------------------
05E4            295   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
05E4            296   T_7seg:
05E4 C0F9A4B0   297       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
05E9 9282F880   298       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
05EE 8883C6A1   299       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
05F4            300   
05F4            301   ; Displays a BCD number pased in R0 in HEX5-HEX0
05F4            302   Display_BCD_7_Seg_HEX10:
05F4 9005E4     303       mov dptr, #T_7seg
05F7 E8         304       mov a, R0
05F8 C4         305       swap a
05F9 540F       306       anl a, #0FH
05FB 93         307       movc a, @a+dptr
05FC F592       308       mov HEX1, a
05FE E8         309       mov a, R0
05FF 540F       310       anl a, #0FH
0601 93         311       movc a, @a+dptr
0602 F591       312       mov HEX0, a
0604 22         313       ret
0605            314   
0605            315   Display_BCD_7_Seg_HEX32:
0605 9005E4     316       mov dptr, #T_7seg
0608 E8         317       mov a, R0
0609 C4         318       swap a
060A 540F       319       anl a, #0FH
060C 93         320       movc a, @a+dptr
060D F594       321       mov HEX3, a
060F E8         322       mov a, R0
0610 540F       323       anl a, #0FH
0612 93         324       movc a, @a+dptr
0613 F593       325       mov HEX2, a
0615 22         326       ret
0616            327   
0616            328   Display_BCD_7_Seg_HEX54:
0616 9005E4     329       mov dptr, #T_7seg
0619 E8         330       mov a, R0
061A C4         331       swap a
061B 540F       332       anl a, #0FH
061D 93         333       movc a, @a+dptr
061E F58F       334       mov HEX5, a
0620 E8         335       mov a, R0
0621 540F       336       anl a, #0FH
0623 93         337       movc a, @a+dptr
0624 F58E       338       mov HEX4, a
0626 22         339       ret
0627            340   
0627            341   ; The 8-bit hex number passed in the accumulator is converted to
0627            342   ; BCD and stored in [R1, R0]
0627            343   Hex_to_bcd_8bit:
0627 75F064     344       mov b, #100
062A 84         345       div ab
062B F9         346       mov R1, a   ; After dividing, a has the 100s
062C E5F0       347       mov a, b    ; Remainder is in register b
062E 75F00A     348       mov b, #10
0631 84         349       div ab ; The tens are stored in a, the units are stored in b 
0632 C4         350       swap a
0633 54F0       351       anl a, #0xf0
0635 45F0       352       orl a, b
0637 F8         353       mov R0, a
0638 22         354       ret
0639            355   ;-------------------------------------------------------------------------------
0639            356   ; Display Function for LCD                      
0639            357   ;-------------------------------------------------------------------------------
0639            358   LCD_Display_Update_func:
0639 C0E0       359       push acc
063B            360       
063B            361       ; ==========================================
063B            362       ; PART 1: STATIC TEXT (Title)
063B            363       ; Runs ONLY when the state changes
063B            364       ; ==========================================
063B            365       
063B            366       ; [FIX] "Trampoline" logic for long distance jump
063B            367       ; If signal is SET (1), we stay here and update.
063B            368       ; If signal is CLEAR (0), we Long Jump to the Live Update section.
063B 200C03     369       jb state_change_signal, Do_Static_Update
063E 020777     370       ljmp Check_Live_Update
0641            371   
0641            372   Do_Static_Update:
0641 C20C       373       clr state_change_signal
0643            374       
0643            375       ; State Changed: Clear Screen and Write Title
0643 120EA4     376       lcall Clear_Screen_Func
0646 E568       377       mov a, Control_FSM_state
0648            378       
0648            379       ; State 0: Welcome
0648 B4003B     380       cjne a, #0, LCD_Check_1
064B C0E0       381            push acc
064D 7401       381            mov a, #1
064F 14         381            dec a
0650 1205C9     381            lcall ?Set_Cursor_1 ; Select column and row
0653 D0E0       381            pop acc
0655 C083       382            push dph
0657 C082       382            push dpl
0659 C0E0       382            push acc
065B 900330     382            mov dptr, #String_state0_1
065E 1205BC     382            lcall ?Send_Constant_String
0661 D0E0       382            pop acc
0663 D082       382            pop dpl
0665 D083       382            pop dph
0667 C0E0       383            push acc
0669 7401       383            mov a, #1
066B 14         383            dec a
066C 1205C7     383            lcall ?Set_Cursor_2 ; Select column and row
066F D0E0       383            pop acc
0671 C083       384            push dph
0673 C082       384            push dpl
0675 C0E0       384            push acc
0677 900340     384            mov dptr, #String_state0_2
067A 1205BC     384            lcall ?Send_Constant_String
067D D0E0       384            pop acc
067F D082       384            pop dpl
0681 D083       384            pop dph
0683 020774     385       ljmp LCD_Done_Bridge ; Exit
0686            386   
0686            387   LCD_Check_1: ; Setup
0686 B4011F     388       cjne a, #1, LCD_Check_2
0689 C0E0       389            push acc
068B 7401       389            mov a, #1
068D 14         389            dec a
068E 1205C9     389            lcall ?Set_Cursor_1 ; Select column and row
0691 D0E0       389            pop acc
0693 C083       390            push dph
0695 C082       390            push dpl
0697 C0E0       390            push acc
0699 9003A5     390            mov dptr, #String_state1
069C 1205BC     390            lcall ?Send_Constant_String
069F D0E0       390            pop acc
06A1 D082       390            pop dpl
06A3 D083       390            pop dph
06A5 020774     391       ljmp LCD_Done_Bridge
06A8            392   
06A8            393   LCD_Check_2: ; Ramp to Soak
06A8 B4021F     394       cjne a, #2, LCD_Check_3
06AB C0E0       395            push acc
06AD 7401       395            mov a, #1
06AF 14         395            dec a
06B0 1205C9     395            lcall ?Set_Cursor_1 ; Select column and row
06B3 D0E0       395            pop acc
06B5 C083       396            push dph
06B7 C082       396            push dpl
06B9 C0E0       396            push acc
06BB 9003E5     396            mov dptr, #String_state2
06BE 1205BC     396            lcall ?Send_Constant_String
06C1 D0E0       396            pop acc
06C3 D082       396            pop dpl
06C5 D083       396            pop dph
06C7 020797     397       ljmp LCD_Update_Temp_Value ; Draw Temp immediately!
06CA            398   
06CA            399   LCD_Check_3: ; Soak
06CA B4031F     400       cjne a, #3, LCD_Check_4
06CD C0E0       401            push acc
06CF 7401       401            mov a, #1
06D1 14         401            dec a
06D2 1205C9     401            lcall ?Set_Cursor_1 ; Select column and row
06D5 D0E0       401            pop acc
06D7 C083       402            push dph
06D9 C082       402            push dpl
06DB C0E0       402            push acc
06DD 9003F5     402            mov dptr, #String_state3
06E0 1205BC     402            lcall ?Send_Constant_String
06E3 D0E0       402            pop acc
06E5 D082       402            pop dpl
06E7 D083       402            pop dph
06E9 020797     403       ljmp LCD_Update_Temp_Value
06EC            404   
06EC            405   LCD_Check_4: ; Ramp to Peak
06EC B4041F     406       cjne a, #4, LCD_Check_5
06EF C0E0       407            push acc
06F1 7401       407            mov a, #1
06F3 14         407            dec a
06F4 1205C9     407            lcall ?Set_Cursor_1 ; Select column and row
06F7 D0E0       407            pop acc
06F9 C083       408            push dph
06FB C082       408            push dpl
06FD C0E0       408            push acc
06FF 900405     408            mov dptr, #String_state4
0702 1205BC     408            lcall ?Send_Constant_String
0705 D0E0       408            pop acc
0707 D082       408            pop dpl
0709 D083       408            pop dph
070B 020797     409       ljmp LCD_Update_Temp_Value
070E            410   
070E            411   LCD_Check_5: ; Reflow
070E B4051F     412       cjne a, #5, LCD_Check_6
0711 C0E0       413            push acc
0713 7401       413            mov a, #1
0715 14         413            dec a
0716 1205C9     413            lcall ?Set_Cursor_1 ; Select column and row
0719 D0E0       413            pop acc
071B C083       414            push dph
071D C082       414            push dpl
071F C0E0       414            push acc
0721 900415     414            mov dptr, #String_state5
0724 1205BC     414            lcall ?Send_Constant_String
0727 D0E0       414            pop acc
0729 D082       414            pop dpl
072B D083       414            pop dph
072D 020797     415       ljmp LCD_Update_Temp_Value
0730            416   
0730            417   LCD_Check_6: ; Cooling
0730 B4061F     418       cjne a, #6, LCD_Check_7
0733 C0E0       419            push acc
0735 7401       419            mov a, #1
0737 14         419            dec a
0738 1205C9     419            lcall ?Set_Cursor_1 ; Select column and row
073B D0E0       419            pop acc
073D C083       420            push dph
073F C082       420            push dpl
0741 C0E0       420            push acc
0743 900425     420            mov dptr, #String_state6
0746 1205BC     420            lcall ?Send_Constant_String
0749 D0E0       420            pop acc
074B D082       420            pop dpl
074D D083       420            pop dph
074F 020797     421       ljmp LCD_Update_Temp_Value
0752            422   
0752            423   LCD_Check_7: ; Done
0752            424       ; [FIX] Check distance safe logic for State 7
0752 B4071F     425       cjne a, #7, LCD_Done_Bridge ; If not 7, we are done
0755 C0E0       426            push acc
0757 7401       426            mov a, #1
0759 14         426            dec a
075A 1205C9     426            lcall ?Set_Cursor_1 ; Select column and row
075D D0E0       426            pop acc
075F C083       427            push dph
0761 C082       427            push dpl
0763 C0E0       427            push acc
0765 900435     427            mov dptr, #String_state7
0768 1205BC     427            lcall ?Send_Constant_String
076B D0E0       427            pop acc
076D D082       427            pop dpl
076F D083       427            pop dph
0771 020774     428       ljmp LCD_Done_Bridge
0774            429   
0774            430   ; Local bridge to reach the far-away LCD_Done
0774            431   LCD_Done_Bridge:
0774 0207D9     432       ljmp LCD_Done
0777            433   
0777            434   ; ==========================================
0777            435   ; PART 2: DYNAMIC VALUES (Temperature)
0777            436   ; Runs every time 'one_second_flag' is set
0777            437   ; ==========================================
0777            438   Check_Live_Update:
0777 3001FA     439       jnb one_second_flag, LCD_Done_Bridge
077A C201       440       clr one_second_flag
077C            441       
077C            442       ; Only update temp for States 2, 3, 4, 5, 6
077C E568       443       mov a, Control_FSM_state
077E B40202     444       cjne a, #2, Check_St3
0781 8014       445       sjmp LCD_Update_Temp_Value
0783            446   Check_St3:
0783 B40302     447       cjne a, #3, Check_St4
0786 800F       448       sjmp LCD_Update_Temp_Value
0788            449   Check_St4:
0788 B40402     450       cjne a, #4, Check_St5
078B 800A       451       sjmp LCD_Update_Temp_Value
078D            452   Check_St5:
078D B40502     453       cjne a, #5, Check_St6
0790 8005       454       sjmp LCD_Update_Temp_Value
0792            455   Check_St6:
0792 B40644     456       cjne a, #6, LCD_Done
0795 8000       457       sjmp LCD_Update_Temp_Value
0797            458   
0797            459   ; --- HELPER: Prints "XXX C" on Line 2 ---
0797            460   LCD_Update_Temp_Value:
0797 C0E0       461            push acc
0799 7401       461            mov a, #1
079B 14         461            dec a
079C 1205C7     461            lcall ?Set_Cursor_2 ; Select column and row
079F D0E0       461            pop acc
07A1            462       
07A1            463       ; Convert current_temp to BCD
07A1 853F32     464       mov x, current_temp
07A4 854033     465       mov x+1, current_temp+1
07A7 854134     466       mov x+2, current_temp+2
07AA 854235     467       mov x+3, current_temp+3
07AD 12002E     468       lcall hex2bcd
07B0            469       
07B0            470       ; Print Hundreds
07B0 E53B       471       mov a, bcd+1
07B2 540F       472       anl a, #0x0F
07B4 2430       473       add a, #0x30
07B6 12057F     474       lcall ?WriteData
07B9            475       
07B9            476       ; Print Tens
07B9 E53A       477       mov a, bcd+0
07BB C4         478       swap a
07BC 540F       479       anl a, #0x0F
07BE 2430       480       add a, #0x30
07C0 12057F     481       lcall ?WriteData
07C3            482       
07C3            483       ; Print Ones
07C3 E53A       484       mov a, bcd+0
07C5 540F       485       anl a, #0x0F
07C7 2430       486       add a, #0x30
07C9 12057F     487       lcall ?WriteData
07CC            488       
07CC            489       ; Print 'C'
07CC 7443       490       mov a, #'C'
07CE 12057F     491       lcall ?WriteData
07D1            492       
07D1            493       ; Clear remaining line space (prevents garbage)
07D1 7420       494       mov a, #' '
07D3 12057F     495       lcall ?WriteData
07D6 12057F     496       lcall ?WriteData
07D9            497   
07D9            498   LCD_Done:
07D9 D0E0       499       pop acc
07DB 22         500       ret
07DC            501   ;---------------------------------------------------------
07DC            502   
07DC            503   KEY1_DEB:
07DC            504   ;non-blocking state machine for KEY1 debounce
07DC E566       505       mov a, KEY1_DEB_state
07DE            506   KEY1_DEB_state0:
07DE B4000A     507       cjne a, #0, KEY1_DEB_state1
07E1 20F92D     508       jb KEY.1, KEY1_DEB_done
07E4 756400     509       mov KEY1_DEB_timer, #0
07E7 0566       510       inc KEY1_DEB_state
07E9 8026       511       sjmp KEY1_DEB_done
07EB            512   KEY1_DEB_state1:
07EB B40109     513       cjne a, #1, KEY1_DEB_state2
07EE            514       ; this is the debounce state
07EE E564       515       mov a, KEY1_DEB_timer
07F0 B4321E     516       cjne a, #50, KEY1_DEB_done ; 50 ms passed?
07F3 0566       517       inc KEY1_DEB_state
07F5 801A       518       sjmp KEY1_DEB_done  
07F7            519   KEY1_DEB_state2:
07F7 B4020C     520       cjne a, #2, KEY1_DEB_state3
07FA 20F904     521       jb KEY.1, KEY1_DEB_state2b
07FD 0566       522       inc KEY1_DEB_state
07FF 8010       523       sjmp KEY1_DEB_done  
0801            524   KEY1_DEB_state2b:
0801 756600     525       mov KEY1_DEB_state, #0
0804 800B       526       sjmp KEY1_DEB_done
0806            527   KEY1_DEB_state3:
0806 B40308     528       cjne a, #3, KEY1_DEB_done
0809 30F905     529       jnb KEY.1, KEY1_DEB_done
080C D20D       530       setb Key1_flag ; Suscesfully detected a valid KEY1 press/release
080E 756600     531       mov KEY1_DEB_state, #0  
0811            532   KEY1_DEB_done:
0811 22         533       ret
0812            534   ; ------------------------------------------------------------------------------
0812            535   ; Non-blocking FSM for the one second counter
0812            536   ;-------------------------------------------------------------------------------
0812            537   SEC_FSM:
0812 E567       538       mov a, SEC_FSM_state
0814            539   SEC_FSM_state0:
0814 B4000C     540       cjne a, #0, SEC_FSM_state1
0817 E565       541       mov a, SEC_FSM_timer
0819 B4FA4B     542       cjne a, #250, SEC_FSM_done ; 250 ms passed?
081C 756500     543       mov SEC_FSM_timer, #0
081F 0567       544       inc SEC_FSM_state
0821 8044       545       sjmp SEC_FSM_done
0823            546   SEC_FSM_state1: 
0823 B4010E     547       cjne a, #1, SEC_FSM_state2
0826 D2E9       548       setb LEDRA.1
0828 E565       549       mov a, SEC_FSM_timer
082A B4FA3A     550       cjne a, #250, SEC_FSM_done ; 250 ms passed?
082D 756500     551       mov SEC_FSM_timer, #0
0830 0567       552       inc SEC_FSM_state
0832 8033       553       sjmp SEC_FSM_done
0834            554   SEC_FSM_state2: 
0834 B4020E     555       cjne a, #2, SEC_FSM_state3
0837 D2EA       556       setb LEDRA.2
0839 E565       557       mov a, SEC_FSM_timer
083B B4FA29     558       cjne a, #250, SEC_FSM_done ; 250 ms passed?
083E 756500     559       mov SEC_FSM_timer, #0
0841 0567       560       inc SEC_FSM_state
0843 8022       561       sjmp SEC_FSM_done
0845            562   SEC_FSM_state3: 
0845 B4031F     563       cjne a, #3, SEC_FSM_done
0848 D2EB       564       setb LEDRA.3
084A E565       565       mov a, SEC_FSM_timer
084C B4FA18     566       cjne a, #250, SEC_FSM_done ; 250 ms passed?
084F 756500     567       mov SEC_FSM_timer, #0
0852 756700     568       mov SEC_FSM_state, #0
0855            569       
0855            570       ; --- 1 Second has passed! ---
0855 D201       571       setb one_second_flag
0857            572       
0857 E530       573       mov a, current_time_sec
0859 B43B07     574       cjne a, #59, IncCurrentTimeSec 
085C            575       
085C            576       ; --- FIX: 59s -> 0s AND Increment Minute ---
085C 753000     577       mov current_time_sec, #0
085F 0531       578       inc current_time_minute    ; <--- YOU WERE MISSING THIS!
0861            579       ; -------------------------------------------
0861            580       
0861 8004       581       sjmp SEC_FSM_done
0863            582   
0863            583   IncCurrentTimeSec:
0863 0530       584       inc current_time_sec
0865 B2E8       585       cpl LEDRA.0 
0867            586   SEC_FSM_done:
0867 22         587       ret
0868            588   ;-------------------------------------------------------------------------------
0868            589   ; PWM
0868            590   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0868            591   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0868            592   ; ------------------------------------------------------------------------------
0868            593   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0868 100202     594       jbc one_ms_pwm_flag, pwm_wave_generator
086B 8071       595       sjmp end_pwm_generator
086D            596   
086D            597   pwm_wave_generator:
086D C200       598       clr mf
086F            599       ; move pwm counter value into x for comparison purpose
086F 856032     600       mov x, pwm_counter
0872 856133     601       mov x+1, pwm_counter+1
0875 856234     602       mov x+2, pwm_counter+2
0878 856335     603       mov x+3, pwm_counter+3
087B            604   
087B 7536DB     605            mov y+0, #low (PWM_PERIOD % 0x10000) 
087E 753705     605            mov y+1, #high(PWM_PERIOD % 0x10000) 
0881 753800     605            mov y+2, #low (PWM_PERIOD / 0x10000) 
0884 753900     605            mov y+3, #high(PWM_PERIOD / 0x10000) 
0887            606   
0887            607       ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
0887            608       ; increase x by 1
0887 120152     609       lcall x_eq_y 
088A 20001D     610       jb mf, wrap_pwm_counter
088D            611       ; x not equal 1499, increment by 1
088D 753601     612            mov y+0, #low (1 % 0x10000) 
0890 753700     612            mov y+1, #high(1 % 0x10000) 
0893 753800     612            mov y+2, #low (1 / 0x10000) 
0896 753900     612            mov y+3, #high(1 / 0x10000) 
0899 1200D3     613       lcall add32
089C            614       ; update pwm_counter
089C 853260     615       mov pwm_counter, x
089F 853361     616       mov pwm_counter+1, x+1
08A2 853462     617       mov pwm_counter+2, x+2
08A5 853563     618       mov pwm_counter+3, x+3
08A8 8018       619       sjmp set_pwm
08AA            620   
08AA            621   wrap_pwm_counter:
08AA            622       ; x equal 1499, wrap to 0
08AA 753200     623            mov x+0, #low (0 % 0x10000) 
08AD 753300     623            mov x+1, #high(0 % 0x10000) 
08B0 753400     623            mov x+2, #low (0 / 0x10000) 
08B3 753500     623            mov x+3, #high(0 / 0x10000) 
08B6 853260     624       mov pwm_counter, x
08B9 853361     625       mov pwm_counter+1, x+1
08BC 853462     626       mov pwm_counter+2, x+2
08BF 853563     627       mov pwm_counter+3, x+3
08C2            628   
08C2            629   set_pwm:
08C2            630       ; compare with power_output, if pwm counter smaller than power_output, 
08C2            631       ; set pwm pin high; else set pwm pin low load y with power output value
08C2 855C36     632       mov y, power_output
08C5 855D37     633       mov y+1, power_output+1
08C8 855E38     634       mov y+2, power_output+2
08CB 855F39     635       mov y+3, power_output+3
08CE            636   
08CE            637       ; compare x(pwm counter) with y(power output)
08CE 12011A     638       lcall x_lt_y
08D1 200006     639       jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
08D4            640       ;output set pwm pin low if pwm counter greater than power output
08D4 C293       641       clr PWM_OUT
08D6 C2EC       642       clr LEDRA.4
08D8 8004       643       sjmp end_pwm_generator
08DA            644   
08DA            645   set_pwm_high:
08DA D293       646       setb PWM_OUT
08DC D2EC       647       setb LEDRA.4
08DE            648   
08DE            649   end_pwm_generator:
08DE 22         650       ret
08DF            651   
08DF            652   ;-------------------------------------------------------------------------------;
08DF            653   ; Temp_Compare
08DF            654   ; Checks if we have reached the user's target temperatures.
08DF            655   ; Sets 'soak_temp_reached' if current_temp >= soak_temp
08DF            656   ; Sets 'reflow_temp_reached' if current_temp >= reflow_temp
08DF            657   ;-------------------------------------------------------------------------------;
08DF            658   Temp_Compare:
08DF            659       ; Reset flags initially
08DF C203       660       clr soak_temp_reached
08E1 C204       661       clr reflow_temp_reached
08E3            662   
08E3 C0E0       663       push acc
08E5 C0D0       664       push psw
08E7 C000       665       push AR0
08E9 C001       666       push AR1
08EB C002       667       push AR2
08ED            668       
08ED            669       ; --- 1. CHECK SOAK TEMP ---
08ED            670       ; Copy current_temp to X
08ED 783F       671       mov R0, #current_temp
08EF 7932       672       mov R1, #x
08F1 120965     673       lcall Copy4_Bytes_R0_to_R1
08F4            674   
08F4            675       ; Copy soak_temp to Y
08F4 7843       676       mov R0, #soak_temp
08F6 7936       677       mov R1, #y
08F8 120965     678       lcall Copy4_Bytes_R0_to_R1
08FB            679   
08FB            680       ; Compare: Is X (Current) < Y (Target)?
08FB 12011A     681       lcall x_lt_y
08FE 200002     682       jb mf, Check_Reflow_Threshold ; If Current < Target, jump (Flag stays 0)
0901            683       
0901            684       ; If we are here, Current >= Target
0901 D203       685       setb soak_temp_reached
0903            686   
0903            687   Check_Reflow_Threshold:
0903            688       ; --- 2. CHECK REFLOW TEMP ---
0903            689       ; Copy current_temp to X (Need to reload X because math32 destroys it)
0903 783F       690       mov R0, #current_temp
0905 7932       691       mov R1, #x
0907 120965     692       lcall Copy4_Bytes_R0_to_R1
090A            693   
090A            694       ; Copy reflow_temp to Y
090A 7847       695       mov R0, #reflow_temp
090C 7936       696       mov R1, #y
090E 120965     697       lcall Copy4_Bytes_R0_to_R1
0911            698   
0911            699       ; Compare
0911 12011A     700       lcall x_lt_y
0914 200002     701       jb mf, Temp_Compare_Done
0917            702       
0917            703       ; If Current >= Target
0917 D204       704       setb reflow_temp_reached
0919            705   
0919            706   Temp_Compare_Done:
0919 D002       707       pop AR2
091B D001       708       pop AR1
091D D000       709       pop AR0
091F D0D0       710       pop psw
0921 D0E0       711       pop acc
0923 22         712       ret
0924            713   ;-------------------------------------------------------------------------------;
0924            714   ; Time_Compare
0924            715   ;
0924            716   ; PURPOSE:
0924            717   ;   Compare the elapsed time against soak and reflow
0924            718   ;   time limits.
0924            719   ;
0924            720   ; BEHAVIOR:
0924            721   ;   - If current_time >= soak_time   if soak_time_reached    = 1
0924            722   ;   - If current_time >= reflow_time if reflow_time_reached = 1
0924            723   ;
0924            724   ; NOTES:
0924            725   ;   - Time values are treated as 32-bit UNSIGNED numbers
0924            726   ;     (e.g., milliseconds or seconds).
0924            727   ;   - Uses the SAME compare logic as Temp_Compare.
0924            728   ;   - This routine ONLY SETS flags.
0924            729   ;
0924            730   ; EXPECTED VARIABLES:
0924            731   ;   current_time[4], soak_time[4], reflow_time[4]
0924            732   ;   x[4], y[4]
0924            733   ;   mf, soak_time_reached, reflow_time_reached
0924            734   ;-------------------------------------------------------------------------------;
0924            735   Time_Compare:
0924 C0E0       736       push acc
0926 C0D0       737       push psw
0928 C000       738       push AR0
092A C001       739       push AR1
092C C002       740       push AR2
092E            741   
092E            742   ; Check: current_time >= soak_time ?
092E            743       ; Copy current_time of x
092E 7850       744       mov  R0, #current_time
0930 7932       745       mov  R1, #x
0932 120965     746       lcall Copy4_Bytes_R0_to_R1
0935            747   
0935            748       ; Copy soak_time of y
0935 7854       749       mov  R0, #soak_time
0937 7936       750       mov  R1, #y
0939 120965     751       lcall Copy4_Bytes_R0_to_R1
093C            752   
093C            753       ; Compare elapsed time vs soak time
093C 12011A     754       lcall x_lt_y
093F 200002     755       jb   mf, Time_Soak_NotReached
0942 D206       756       setb soak_time_reached
0944            757   
0944            758   ; Check: current_time >= reflow_time ?
0944            759   Time_Soak_NotReached:
0944            760       ; Copy current_time of x
0944 7850       761       mov  R0, #current_time
0946 7932       762       mov  R1, #x
0948 120965     763       lcall Copy4_Bytes_R0_to_R1
094B            764   
094B            765       ; Copy reflow_time of y
094B 7858       766       mov  R0, #reflow_time
094D 7936       767       mov  R1, #y
094F 120965     768       lcall Copy4_Bytes_R0_to_R1
0952            769   
0952            770       ; Compare elapsed time vs reflow time
0952 12011A     771       lcall x_lt_y
0955 200002     772       jb   mf, Time_Reflow_NotReached
0958 D207       773       setb reflow_time_reached
095A            774   
095A            775   Time_Reflow_NotReached:
095A D002       776       pop  AR2
095C D001       777       pop  AR1
095E D000       778       pop  AR0
0960 D0D0       779       pop  psw
0962 D0E0       780       pop  acc
0964 22         781       ret
0965            782   
0965            783   ;-------------------------------------------------------------------------------;
0965            784   ; Copy4_Bytes_R0_to_R1
0965            785   ;
0965            786   ; PURPOSE:
0965            787   ;   Utility routine to copy a 32-bit value (4 bytes)
0965            788   ;   from one memory location to another.
0965            789   ;
0965            790   ; INPUTS:
0965            791   ;   R0 st source address
0965            792   ;   R1 at destination address
0965            793   ;
0965            794   ; USES:
0965            795   ;   R2 as loop counter
0965            796   ;
0965            797   ; EXAMPLE:
0965            798   ;   mov R0, #current_temp
0965            799   ;   mov R1, #x
0965            800   ;   lcall Copy4_Bytes_R0_to_R1
0965            801   ;-------------------------------------------------------------------------------;
0965            802   Copy4_Bytes_R0_to_R1:
0965 7A04       803       mov  R2, #4
0967            804   Copy4_Loop:
0967 E6         805       mov  a, @R0
0968 F7         806       mov  @R1, a
0969 08         807       inc  R0
096A 09         808       inc  R1
096B DAFA       809       djnz R2, Copy4_Loop
096D 22         810       ret
096E            811   
096E            812   ;-------------------------------------------------------------------------------;
096E            813   ; Abort condition safety check Temperature time
096E            814   ;
096E            815   ; PURPOSE:
096E            816   ;   Automatic cycle termination on error:
096E            817   ;   Abort if oven fails to reach at least 50C in first 60s.
096E            818   ;
096E            819   ; TRIP CONDITION:
096E            820   ;   if (current_time >= 60s) AND (current_temp < 50C)
096E            821   ;       -> set tc_missing_abort
096E            822   ;       -> set stop_signal
096E            823   ;
096E            824   ; ASSUMPTIONS:
096E            825   ;   - current_time is in SECONDS (32-bit, little-endian)
096E            826   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
096E            827   ;
096E            828   ;   the Load_Y constants accordingly.
096E            829   ;-------------------------------------------------------------------------------;
096E            830   Safety_Check_TC:
096E C0E0       831       push acc
0970 C0D0       832       push psw
0972 C000       833       push AR0
0974 C001       834       push AR1
0976 C002       835       push AR2
0978            836   
0978            837       ; If already aborted or startup window closed, do nothing
0978 200E3D     838       jb   tc_missing_abort, Safety_TC_Done
097B 300F3A     839       jnb  tc_startup_window, Safety_TC_Done
097E            840   
097E            841       ; Check: current_time >= 60 ?
097E 7850       842       mov  R0, #current_time
0980 7932       843       mov  R1, #x
0982 120965     844       lcall Copy4_Bytes_R0_to_R1
0985            845   
0985 75363C     846            mov y+0, #low (60 % 0x10000) 
0988 753700     846            mov y+1, #high(60 % 0x10000) 
098B 753800     846            mov y+2, #low (60 / 0x10000) 
098E 753900     846            mov y+3, #high(60 / 0x10000) 
0991 12011A     847       lcall x_lt_y
0994 200021     848       jb   mf, Safety_TC_Done        ; still < 60s  keep waiting
0997            849   
0997            850       ; We reached 60s: close the startup window so it won't re-check later
0997 C20F       851       clr  tc_startup_window
0999            852   
0999            853       ; Now check: current_temp < 50 ?
0999 783F       854       mov  R0, #current_temp
099B 7932       855       mov  R1, #x
099D 120965     856       lcall Copy4_Bytes_R0_to_R1
09A0            857   
09A0 753632     858            mov y+0, #low (50 % 0x10000) 
09A3 753700     858            mov y+1, #high(50 % 0x10000) 
09A6 753800     858            mov y+2, #low (50 / 0x10000) 
09A9 753900     858            mov y+3, #high(50 / 0x10000) 
09AC 12011A     859       lcall x_lt_y
09AF 300006     860       jnb  mf, Safety_TC_Done        ; temp >= 50  pass
09B2            861   
09B2            862       ; FAIL: at 60s, still below 50C  abort
09B2 D20E       863       setb tc_missing_abort
09B4 D209       864       setb stop_signal
09B6 C293       865       clr  PWM_OUT
09B8            866   
09B8            867   Safety_TC_Done:
09B8 D002       868       pop  AR2
09BA D001       869       pop  AR1
09BC D000       870       pop  AR0
09BE D0D0       871       pop  psw
09C0 D0E0       872       pop  acc
09C2 22         873       ret
09C3            874   
09C3            875   ;-------------------------------------------------------------------------------;
09C3            876   ; Main Control FSM for the entire process
09C3            877   ;-------------------------------------------------------------------------------;
09C3            878   ;-------------------------------------------------------------------------------;
09C3            879   ; FSM LOGIC (Button Logic Fixed)
09C3            880   ;-------------------------------------------------------------------------------;
09C3            881   Control_FSM:
09C3 E568       882       mov a, Control_FSM_state
09C5 8005       883       sjmp Control_FSM_state0
09C7            884   
09C7            885   Control_FSM_state0_a:
09C7 756800     886       mov Control_FSM_state, #0
09CA D20C       887       setb state_change_signal
09CC            888       
09CC            889   Control_FSM_state0:
09CC B40015     890       cjne a, #0, Control_FSM_state1
09CF 209005     891       jb P1.0, Control_FSM_done_bridge ; If Button High (Not Pressed), Exit
09D2 120ECE     892       lcall Wait_For_P1_0_Release      ; If Low (Pressed), Wait & Proceed
09D5 8001       893       sjmp Control_FSM_state1_a  
09D7            894       
09D7            895   Control_FSM_done_bridge:
09D7 22         896       ret
09D8            897   
09D8            898   Control_FSM_state1_a:
09D8 0568       899       inc Control_FSM_state
09DA 756900     900       mov Current_State, #0
09DD 120DA7     901       lcall Update_Screen_Full 
09E0 D20C       902       setb state_change_signal
09E2 E568       903       mov a, Control_FSM_state
09E4            904       
09E4            905   Control_FSM_state1:
09E4 B40116     906       cjne a, #1, Control_FSM_state2
09E7 120BDF     907       lcall Check_Buttons 
09EA 120C2B     908       lcall Check_Keypad
09ED            909       
09ED            910       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
09ED 209008     911       jb P1.0, Control_FSM_state1_ret
09F0            912       
09F0            913       ; If we get here, Button is LOW (Pressed)
09F0 120ECE     914       lcall Wait_For_P1_0_Release
09F3 120B63     915       lcall Update_FSM_Variables
09F6 8001       916       sjmp Control_FSM_state2_a
09F8            917   Control_FSM_state1_ret:
09F8 22         918       ret
09F9            919   
09F9            920   ; --- STATE 2: RAMP TO SOAK ---
09F9            921   Control_FSM_state2_a:
09F9 0568       922       inc Control_FSM_state
09FB D20C       923       setb state_change_signal
09FD            924   Control_FSM_state2:
09FD B4021A     925       cjne a, #2, Control_FSM_state3
0A00 301205     926       jnb PB2_flag, State2_Check
0A03 C212       927       clr PB2_flag
0A05 020A65     928       ljmp Control_FSM_state6_a ; Pause
0A08            929   State2_Check:
0A08 30030E     930       jnb soak_temp_reached, State2_Ret
0A0B C203       931       clr soak_temp_reached
0A0D 0568       932       inc Control_FSM_state
0A0F D20C       933       setb state_change_signal
0A11 753000     934       mov current_time_sec, #0
0A14 753100     935       mov current_time_minute, #0
0A17            936       
0A17            937       ; --- ADD THIS LINE ---
0A17 C206       938       clr soak_time_reached  ; Ensure we start fresh!
0A19            939       ; ---------------------
0A19            940   
0A19            941   State2_Ret:
0A19 22         942       ret
0A1A            943   
0A1A            944   ; --- STATE 3: SOAK PHASE ---
0A1A            945   Control_FSM_state3:
0A1A B40312     946       cjne a, #3, Control_FSM_state4
0A1D 301205     947       jnb PB2_flag, State3_Check
0A20 C212       948       clr PB2_flag
0A22 020A65     949       ljmp Control_FSM_state6_a
0A25            950   State3_Check:
0A25 300606     951       jnb soak_time_reached, State3_Ret
0A28 C206       952       clr soak_time_reached
0A2A 0568       953       inc Control_FSM_state      
0A2C D20C       954       setb state_change_signal 
0A2E            955   State3_Ret:
0A2E 22         956       ret
0A2F            957   
0A2F            958   ; --- STATE 4: RAMP TO PEAK ---
0A2F            959   Control_FSM_state4:
0A2F B4041A     960       cjne a, #4, Control_FSM_state5
0A32 301205     961       jnb PB2_flag, State4_Check
0A35 C212       962       clr PB2_flag
0A37 020A65     963       ljmp Control_FSM_state6_a
0A3A            964   State4_Check:
0A3A 30040E     965       jnb reflow_temp_reached, State4_Ret
0A3D C204       966       clr reflow_temp_reached
0A3F 0568       967       inc Control_FSM_state
0A41 D20C       968       setb state_change_signal
0A43 753000     969       mov current_time_sec, #0
0A46 753100     970       mov current_time_minute, #0
0A49            971       ; --- ADD THIS LINE ---
0A49 C207       972       clr reflow_time_reached ; Kill the ghost flag
0A4B            973       ; ---------------------
0A4B            974   State4_Ret:
0A4B 22         975       ret
0A4C            976   
0A4C            977   ; --- STATE 5: REFLOW PHASE ---
0A4C            978   Control_FSM_state5:
0A4C B40502     979       cjne a, #5, Control_FSM_state6_trampoline
0A4F 8003       980       sjmp State5_Logic
0A51            981   Control_FSM_state6_trampoline:
0A51 020A69     982       ljmp Control_FSM_state6
0A54            983   
0A54            984   State5_Logic:
0A54 301205     985       jnb PB2_flag, State5_Check
0A57 C212       986       clr PB2_flag
0A59 020A65     987       ljmp Control_FSM_state6_a
0A5C            988   State5_Check:
0A5C 300705     989       jnb reflow_time_reached, State5_Ret
0A5F C207       990       clr reflow_time_reached
0A61 020A65     991       ljmp Control_FSM_state6_a
0A64            992   State5_Ret:
0A64 22         993       ret
0A65            994   
0A65            995   ; --- STATE 6: COOLING ---
0A65            996   Control_FSM_state6_a:
0A65 0568       997       inc Control_FSM_state
0A67 D20C       998       setb state_change_signal
0A69            999   Control_FSM_state6:
0A69 B4060A    1000       cjne a, #6, Control_FSM_state7
0A6C           1001       ; Wait for Cooling Temp Reached
0A6C 300506    1002       jnb cooling_temp_reached, State6_Ret
0A6F C205      1003       clr cooling_temp_reached
0A71 0568      1004       inc Control_FSM_state
0A73 D20C      1005       setb state_change_signal
0A75           1006   State6_Ret:
0A75 22        1007       ret
0A76           1008   
0A76           1009   ; --- STATE 7: DONE ---
0A76           1010   Control_FSM_state7:
0A76 B40711    1011       cjne a, #7, Control_FSM_done
0A79           1012       
0A79           1013       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
0A79 201009    1014       jb PB0_flag, Control_FSM_Reset_Logic ; Wait, PB0_flag is software flag?
0A7C           1015       
0A7C           1016       ; Let's assume you meant the physical button P1.0 like State 0
0A7C 20900B    1017       jb P1.0, Control_FSM_done
0A7F           1018       
0A7F 120ECE    1019       lcall Wait_For_P1_0_Release
0A82 0209C7    1020       ljmp Control_FSM_state0_a
0A85           1021   
0A85           1022   Control_FSM_Reset_Logic:
0A85           1023       ; If using PB0_flag from ISR, handle here
0A85 C210      1024       clr PB0_flag
0A87 0209C7    1025       ljmp Control_FSM_state0_a
0A8A           1026   
0A8A           1027   Control_FSM_done:
0A8A 22        1028       ret
0A8B           1029   ;-------------------------------------------------------------------------------;
0A8B           1030   ;         Main program.          
0A8B           1031   ;-------------------------------------------------------------------------------;
0A8B           1032   main:
0A8B           1033   
0A8B           1034       ; --------------------------------------------------------
0A8B           1035       ; 1. SAFETY SHUTDOWN
0A8B           1036       ; --------------------------------------------------------
0A8B C2AF      1037       clr EA              ; FORCE Interrupts OFF immediately
0A8D 7581C0    1038       mov SP, #0xC0       ; Reset Stack Pointer to safe location
0A90           1039       
0A90           1040       ; --------------------------------------------------------
0A90           1041       ; 2. THE "DIRTY DELAY" (Fixes Reset Garbage)
0A90           1042       ; We burn ~100ms here using a raw loop. 
0A90           1043       ; We cannot use timers yet because they aren't initialized.
0A90           1044       ; --------------------------------------------------------
0A90 78FA      1045       mov R0, #250
0A92           1046   Reset_Delay_Outer:
0A92 79FF      1047       mov R1, #255
0A94           1048   Reset_Delay_Inner:
0A94 D9FE      1049       djnz R1, Reset_Delay_Inner
0A96 D8FA      1050       djnz R0, Reset_Delay_Outer
0A98           1051       ; --------------------------------------------------------
0A98           1052   
0A98           1053       ; ... NOW continue with your normal Port Configuration ...
0A98           1054       
0A98           1055       ; --- PORT CONFIGURATION ---
0A98 759AAA    1056       mov P0MOD, #0xAA
0A9B           1057   
0A9B           1058       ; P1: Mixed usage 
0A9B           1059       ; P1.7(LCD_RS), P1.6(Row3), P1.5(Sound), P1.4(Row2)
0A9B           1060       ; P1.3(PWM), P1.2(Row1), P1.1(LCD_E) -> All Outputs
0A9B           1061       ; P1.0 (Unused/RX) -> Input
0A9B           1062       ; Binary: 11111110 -> Hex: 0xFE
0A9B 759BFE    1063       mov P1MOD, #0xFE
0A9E           1064   
0A9E           1065       ; P2: Row4(Out), Cols(In)
0A9E           1066       ; P2.0 (Row4) is Out (1). P2.2, P2.4, P2.6 (Cols) are In (0).
0A9E           1067       ; Binary: 00000001 -> Hex: 0x01
0A9E 759C01    1068       mov P2MOD, #0x01
0AA1           1069   
0AA1           1070       ; P3: Col4(In)
0AA1           1071       ; P3.0 (Col4) is In (0).
0AA1 759D00    1072       mov P3MOD, #0x00
0AA4           1073       ; Turn off all the LEDs
0AA4 75E800    1074       mov LEDRA, #0 ; LEDRA is bit addressable
0AA7 759500    1075       mov LEDRB, #0 ; LEDRB is NOT bit addresable
0AAA           1076   
0AAA           1077       ; Enable Global interrupts
0AAA D2AF      1078       setb EA  
0AAC           1079   
0AAC           1080       ; FSM initial states
0AAC 756600    1081       mov KEY1_DEB_state, #0
0AAF 756700    1082       mov SEC_FSM_state, #0
0AB2 756800    1083       mov Control_FSM_state, #0
0AB5 756900    1084       mov Current_State, #0
0AB8           1085       
0AB8           1086       ; FSM timers initialization
0AB8 756400    1087       mov KEY1_DEB_timer, #0
0ABB 756500    1088       mov SEC_FSM_timer, #0
0ABE           1089       ; time counters initialization
0ABE 753000    1090       mov current_time_sec, #0
0AC1 753100    1091       mov current_time_minute, #0
0AC4           1092       ; Initialize counter to zero
0AC4 756000    1093       mov pwm_counter, #0
0AC7 756100    1094       mov pwm_counter+1, #0
0ACA 756200    1095       mov pwm_counter+2, #0
0ACD 756300    1096       mov pwm_counter+3, #0
0AD0           1097       ; Initialize power output
0AD0 755F00    1098       mov power_output+3, #0
0AD3 755E00    1099       mov power_output+2, #0
0AD6 755D02    1100       mov power_output+1, #02H
0AD9 755CEE    1101       mov power_output, #0EEH ; (initilize to 750 for testing)
0ADC           1102   
0ADC           1103       ; Clear all the flags
0ADC C20E      1104       clr  tc_missing_abort
0ADE C209      1105       clr  stop_signal
0AE0 C210      1106       clr PB0_flag
0AE2 C211      1107       clr PB1_flag
0AE4 C212      1108       clr PB2_flag
0AE6 C201      1109       clr one_second_flag
0AE8 C20B      1110       clr config_finish_signal
0AEA C203      1111       clr soak_temp_reached
0AEC C206      1112       clr soak_time_reached
0AEE C204      1113       clr reflow_temp_reached
0AF0 C207      1114       clr reflow_time_reached
0AF2 C205      1115       clr cooling_temp_reached
0AF4 C20C      1116       clr state_change_signal
0AF6           1117       
0AF6 D20C      1118       setb state_change_signal
0AF8           1119   
0AF8           1120       ; Set bit
0AF8 D20F      1121       setb tc_startup_window
0AFA           1122   
0AFA 120456    1123       lcall Timer0_Init
0AFD 1204C0    1124       lcall Timer2_Init
0B00 120589    1125       lcall ELCD_4BIT
0B03           1126       ;----- Two new lines I added to initialize the UI
0B03 120D54    1127       lcall Init_All_Buffers
0B06 120DA7    1128       lcall Update_Screen_Full
0B09           1129       ;-----
0B09 120472    1130       lcall Initialize_Serial_Port
0B0C           1131   ;-------------------------------------------------------------------------------;
0B0C           1132   ; while(1) loop
0B0C           1133   ;-------------------------------------------------------------------------------;
0B0C           1134   loop:
0B0C           1135       ; Check the FSM for KEY1 debounce
0B0C 1207DC    1136       lcall KEY1_DEB
0B0F           1137       
0B0F           1138       ; Added to take temp readings
0B0F 120ED2    1139       lcall Read_Thermocouple
0B12           1140       
0B12           1141       ; 1. Check if we reached temp (Observer)
0B12 1208DF    1142       lcall Temp_Compare
0B15           1143       
0B15           1144       ; 2. Decide heater power based on flags (Driver)
0B15 120F31    1145       lcall Power_Control
0B18           1146       
0B18           1147       ; 3. [FIX] Calculate Total Seconds (Minutes * 60 + Seconds)
0B18           1148       ; ---------------------------------------------------------
0B18           1149       ; Load Minutes into X
0B18 853132    1150       mov x+0, current_time_minute
0B1B 753300    1151       mov x+1, #0
0B1E 753400    1152       mov x+2, #0
0B21 753500    1153       mov x+3, #0
0B24           1154       
0B24           1155       ; Multiply by 60 (Minutes -> Seconds)
0B24 75363C    1156            mov y+0, #low (60 % 0x10000) 
0B27 753700    1156            mov y+1, #high(60 % 0x10000) 
0B2A 753800    1156            mov y+2, #low (60 / 0x10000) 
0B2D 753900    1156            mov y+3, #high(60 / 0x10000) 
0B30 12018C    1157       lcall mul32
0B33           1158       
0B33           1159       ; Load Seconds into Y
0B33 853036    1160       mov y+0, current_time_sec
0B36 753700    1161       mov y+1, #0
0B39 753800    1162       mov y+2, #0
0B3C 753900    1163       mov y+3, #0
0B3F           1164       
0B3F           1165       ; Add them together (Total Seconds = X + Y)
0B3F 1200D3    1166       lcall add32
0B42           1167       
0B42           1168       ; Store Final Result into 'current_time'
0B42 853250    1169       mov current_time+0, x+0
0B45 853351    1170       mov current_time+1, x+1
0B48 853452    1171       mov current_time+2, x+2
0B4B 853553    1172       mov current_time+3, x+3
0B4E           1173       
0B4E 120924    1174       lcall Time_Compare
0B51           1175       
0B51 12096E    1176       lcall Safety_Check_TC
0B54           1177   
0B54           1178   
0B54           1179       ; Check the FSM for one second counter
0B54 120812    1180       lcall SEC_FSM
0B57           1181   
0B57           1182       ; Check the FSM for the overall control flow of the reflow process
0B57 1209C3    1183       lcall Control_FSM
0B5A           1184   
0B5A           1185       ; Update the LCD display based on the current state
0B5A 120639    1186       lcall LCD_Display_Update_func
0B5D           1187   
0B5D           1188       ; Update the pwm output for the ssr
0B5D 120868    1189       lcall PWM_Wave 
0B60           1190   
0B60           1191       ; After initialization the program stays in this 'forever' loop
0B60 020B0C    1192       ljmp loop
0B63           1193   ;-------------------------------------------------------------------------------;
0B63           1194   
0B63           1195   ; ================================================================
0B63           1196   ; UI & HELPER SUBROUTINES
0B63           1197   ; ================================================================
0B63           1198   
0B63           1199   ; ----------------------------------------------------------------
0B63           1200   ; MODULE: BRIDGE (Text to Integer Conversion)
0B63           1201   ; ----------------------------------------------------------------
0B63           1202   Update_FSM_Variables:
0B63           1203       ; --- 1. SOAK TEMP ---
0B63 786B      1204       mov R0, #Buf_Soak_Temp
0B65 120BA2    1205       lcall Parse_Temp_String
0B68 8F43      1206       mov soak_temp+0, R7
0B6A 754400    1207       mov soak_temp+1, #0
0B6D 754500    1208       mov soak_temp+2, #0
0B70 754600    1209       mov soak_temp+3, #0
0B73           1210   
0B73           1211       ; --- 2. REFLOW TEMP ---
0B73 7874      1212       mov R0, #Buf_Refl_Temp
0B75 120BA2    1213       lcall Parse_Temp_String
0B78 8F47      1214       mov reflow_temp+0, R7
0B7A 754800    1215       mov reflow_temp+1, #0
0B7D 754900    1216       mov reflow_temp+2, #0
0B80 754A00    1217       mov reflow_temp+3, #0
0B83           1218   
0B83           1219       ; --- 3. SOAK TIME ---
0B83 786F      1220       mov R0, #Buf_Soak_Time
0B85 120BB6    1221       lcall Parse_Time_String
0B88 8F54      1222       mov soak_time+0, R7
0B8A 8E55      1223       mov soak_time+1, R6
0B8C 755600    1224       mov soak_time+2, #0
0B8F 755700    1225       mov soak_time+3, #0
0B92           1226   
0B92           1227       ; --- 4. REFLOW TIME ---
0B92 7878      1228       mov R0, #Buf_Refl_Time
0B94 120BB6    1229       lcall Parse_Time_String
0B97 8F58      1230       mov reflow_time+0, R7
0B99 8E59      1231       mov reflow_time+1, R6
0B9B 755A00    1232       mov reflow_time+2, #0
0B9E 755B00    1233       mov reflow_time+3, #0
0BA1 22        1234       ret
0BA2           1235   
0BA2           1236   ; --- Helper: Parse "123" to Integer ---
0BA2           1237   Parse_Temp_String:
0BA2 7F00      1238       mov R7, #0              ; Clear Result
0BA4           1239   Parse_Temp_Loop:
0BA4 E6        1240       mov A, @R0
0BA5 600E      1241       jz Parse_Temp_Done      ; If Null, we are done
0BA7           1242       
0BA7           1243       ; Convert ASCII to Digit
0BA7 C3        1244       clr C
0BA8 9430      1245       subb A, #0x30
0BAA FD        1246       mov R5, A               ; R5 = New Digit
0BAB           1247       
0BAB           1248       ; Result = (Result * 10) + New Digit
0BAB EF        1249       mov A, R7
0BAC 75F00A    1250       mov B, #10
0BAF A4        1251       mul AB
0BB0 2D        1252       add A, R5
0BB1 FF        1253       mov R7, A
0BB2           1254       
0BB2 08        1255       inc R0
0BB3 80EF      1256       sjmp Parse_Temp_Loop
0BB5           1257   Parse_Temp_Done:
0BB5 22        1258       ret
0BB6           1259   
0BB6           1260   ; --- Helper: Parse "MMSS" to Seconds ---
0BB6           1261   Parse_Time_String:
0BB6           1262       ; 1. Minutes Tens
0BB6 E6        1263       mov A, @R0
0BB7 9430      1264       subb A, #0x30
0BB9 75F00A    1265       mov B, #10
0BBC A4        1266       mul AB
0BBD FD        1267       mov R5, A
0BBE 08        1268       inc R0
0BBF           1269       
0BBF           1270       ; 2. Minutes Ones
0BBF E6        1271       mov A, @R0
0BC0 9430      1272       subb A, #0x30
0BC2 2D        1273       add A, R5
0BC3 FD        1274       mov R5, A               ; R5 = Total Minutes
0BC4 08        1275       inc R0
0BC5           1276       
0BC5           1277       ; 3. Seconds Tens
0BC5 E6        1278       mov A, @R0
0BC6 9430      1279       subb A, #0x30
0BC8 75F00A    1280       mov B, #10
0BCB A4        1281       mul AB
0BCC FC        1282       mov R4, A
0BCD 08        1283       inc R0
0BCE           1284       
0BCE           1285       ; 4. Seconds Ones
0BCE E6        1286       mov A, @R0
0BCF 9430      1287       subb A, #0x30
0BD1 2C        1288       add A, R4               ; R4 = Total Seconds
0BD2           1289       
0BD2           1290       ; 5. Calculate Total Seconds = (Mins * 60) + Secs
0BD2 ED        1291       mov A, R5
0BD3 75F03C    1292       mov B, #60
0BD6 A4        1293       mul AB
0BD7 2C        1294       add A, R4
0BD8 FF        1295       mov R7, A               ; Low Byte
0BD9 E5F0      1296       mov A, B
0BDB 3400      1297       addc A, #0
0BDD FE        1298       mov R6, A               ; High Byte
0BDE 22        1299       ret
0BDF           1300   
0BDF           1301   ; ----------------------------------------------------------------
0BDF           1302   ; MODULE: BUTTON HANDLER (Mode Selection)
0BDF           1303   ; ----------------------------------------------------------------
0BDF           1304   Check_Buttons:
0BDF           1305       ; --- FORCE INPUT MODE ---
0BDF           1306       ; This clears any '0' the LCD library might have written to our buttons
0BDF 438055    1307       orl P0, #055H   ; Sets P0.0, P0.2, P0.4, and P0.6 to '1' (Input Mode)
0BE2           1308       ; ------------------------
0BE2           1309   
0BE2 30800A    1310       jnb BTN_SOAK_TEMP, Btn_Soak_Temp_Press
0BE5 308212    1311       jnb BTN_SOAK_TIME, Btn_Soak_Time_Press
0BE8 30841A    1312       jnb BTN_REFL_TEMP, Btn_Refl_Temp_Press
0BEB 308622    1313       jnb BTN_REFL_TIME, Btn_Refl_Time_Press
0BEE 22        1314       ret
0BEF           1315   
0BEF           1316   Btn_Soak_Temp_Press:
0BEF 120E9E    1317       lcall Wait_25ms_BLOCKING
0BF2 756901    1318       mov Current_State, #1
0BF5 756A00    1319       mov Cursor_Idx, #0
0BF8 8021      1320       sjmp Redraw_Screen
0BFA           1321   
0BFA           1322   Btn_Soak_Time_Press:
0BFA 120E9E    1323       lcall Wait_25ms_BLOCKING
0BFD 756902    1324       mov Current_State, #2
0C00 756A00    1325       mov Cursor_Idx, #0
0C03 8016      1326       sjmp Redraw_Screen
0C05           1327   
0C05           1328   Btn_Refl_Temp_Press:
0C05 120E9E    1329       lcall Wait_25ms_BLOCKING
0C08 756903    1330       mov Current_State, #3
0C0B 756A00    1331       mov Cursor_Idx, #0
0C0E 800B      1332       sjmp Redraw_Screen
0C10           1333   
0C10           1334   Btn_Refl_Time_Press:
0C10 120E9E    1335       lcall Wait_25ms_BLOCKING 
0C13 756904    1336       mov Current_State, #4
0C16 756A00    1337       mov Cursor_Idx, #0
0C19 8000      1338       sjmp Redraw_Screen
0C1B           1339   
0C1B           1340   Redraw_Screen:
0C1B           1341       ; Wait for button release
0C1B 3080FD    1342       jnb BTN_SOAK_TEMP, $
0C1E 3082FD    1343       jnb BTN_SOAK_TIME, $
0C21 3084FD    1344       jnb BTN_REFL_TEMP, $
0C24 3086FD    1345       jnb BTN_REFL_TIME, $
0C27           1346   
0C27 120DA7    1347       lcall Update_Screen_Full
0C2A 22        1348       ret
0C2B           1349   
0C2B           1350   ; ----------------------------------------------------------------
0C2B           1351   ; MODULE: KEYPAD HANDLER (Input Logic)
0C2B           1352   ; ----------------------------------------------------------------
0C2B           1353   Check_Keypad:
0C2B           1354       ; If State is 0 (Home), ignore keypad
0C2B E569      1355       mov A, Current_State
0C2D 6050      1356       jz Keypad_Exit
0C2F           1357       
0C2F 120C80    1358       lcall Keypad_Scan
0C32 504B      1359       jnc Keypad_Exit         ; Carry = 0 means no key pressed
0C34           1360   
0C34           1361       ; --- Check Special Keys ---
0C34 EF        1362       mov A, R7
0C35 B40E0A    1363       cjne A, #14, Check_Hash ; 14 is Star (*)
0C38           1364       
0C38           1365       ; Star Key Pressed: Reset Buffer
0C38 120D84    1366       lcall Reset_Current_Buffer
0C3B 120DA7    1367       lcall Update_Screen_Full
0C3E 756A00    1368       mov Cursor_Idx, #0
0C41 22        1369       ret
0C42           1370   
0C42           1371   Check_Hash:
0C42 EF        1372       mov A, R7
0C43 B40C01    1373       cjne A, #12, Check_Numeric ; 12 is Hash (#)
0C46 22        1374       ret                     ; Ignore Hash key
0C47           1375   
0C47           1376   Check_Numeric:
0C47           1377       ; Ensure key is 0-9
0C47 EF        1378       mov A, R7
0C48 C3        1379       clr C
0C49 940A      1380       subb A, #10
0C4B 5031      1381       jnc Symbol_Key_Ignored
0C4D           1382       
0C4D           1383       ; Convert to ASCII
0C4D EF        1384       mov A, R7
0C4E 2430      1385       add A, #0x30
0C50 FD        1386       mov R5, A
0C51           1387   
0C51           1388       ; Save to Buffer
0C51 120EB7    1389       lcall Get_Current_Buffer_Addr
0C54 E56A      1390       mov A, Cursor_Idx
0C56 28        1391       add A, R0
0C57 F8        1392       mov R0, A
0C58 ED        1393       mov A, R5
0C59 F6        1394       mov @R0, A
0C5A 056A      1395       inc Cursor_Idx
0C5C           1396   
0C5C           1397       ; --- Check Cursor Limits ---
0C5C E569      1398       mov A, Current_State
0C5E B40102    1399       cjne A, #1, Check_Limit_Time_1
0C61 8005      1400       sjmp Limit_Temp_3
0C63           1401   
0C63           1402   Check_Limit_Time_1:
0C63 B4030B    1403       cjne A, #3, Limit_Time_4
0C66 8000      1404       sjmp Limit_Temp_3
0C68           1405   
0C68           1406   Limit_Temp_3:
0C68 E56A      1407       mov A, Cursor_Idx
0C6A B4030D    1408       cjne A, #3, Do_Refresh
0C6D 156A      1409       dec Cursor_Idx          ; Stay at last digit
0C6F 8009      1410       sjmp Do_Refresh
0C71           1411   
0C71           1412   Limit_Time_4:
0C71 E56A      1413       mov A, Cursor_Idx
0C73 B40404    1414       cjne A, #4, Do_Refresh
0C76 156A      1415       dec Cursor_Idx          ; Stay at last digit
0C78 8000      1416       sjmp Do_Refresh
0C7A           1417   
0C7A           1418   Do_Refresh:
0C7A 120DA7    1419       lcall Update_Screen_Full
0C7D 22        1420       ret
0C7E           1421   
0C7E           1422   Symbol_Key_Ignored:
0C7E 22        1423       ret
0C7F           1424   Keypad_Exit:
0C7F 22        1425       ret
0C80           1426   
0C80           1427   ; ----------------------------------------------------------------
0C80           1428   ; MODULE: HARDWARE SCANNER (Matrix Logic)
0C80           1429   ; ----------------------------------------------------------------
0C80           1430   Keypad_Scan:
0C80           1431       ; Step 1: Check if ANY key is pressed (All Rows Low)
0C80 C292      1432       clr ROW1
0C82 C294      1433       clr ROW2
0C84 C296      1434       clr ROW3
0C86 C2A0      1435       clr ROW4
0C88 A2A2      1436       mov C, COL1
0C8A 82A4      1437       anl C, COL2
0C8C 82A6      1438       anl C, COL3
0C8E 82B0      1439       anl C, COL4
0C90 5002      1440       jnc Keypad_Debounce
0C92 C3        1441       clr C
0C93 22        1442       ret
0C94           1443   
0C94           1444   Keypad_Debounce:
0C94 120E9E    1445       lcall Wait_25ms_BLOCKING
0C97 A2A2      1446       mov C, COL1
0C99 82A4      1447       anl C, COL2
0C9B 82A6      1448       anl C, COL3
0C9D 82B0      1449       anl C, COL4
0C9F 5002      1450       jnc Keypad_Find_Row
0CA1 C3        1451       clr C
0CA2 22        1452       ret
0CA3           1453   
0CA3           1454   Keypad_Find_Row:
0CA3 D292      1455       setb ROW1
0CA5 D294      1456       setb ROW2
0CA7 D296      1457       setb ROW3
0CA9 D2A0      1458       setb ROW4
0CAB           1459   
0CAB           1460       ; Row 1
0CAB C292      1461       clr ROW1
0CAD 30A23D    1462       jnb COL1, Keypad_Key_1
0CB0 30A43E    1463       jnb COL2, Keypad_Key_2
0CB3 30A63F    1464       jnb COL3, Keypad_Key_3
0CB6 30B040    1465       jnb COL4, Keypad_Key_A
0CB9 D292      1466       setb ROW1
0CBB           1467   
0CBB           1468       ; Row 2
0CBB C294      1469       clr ROW2
0CBD 30A23D    1470       jnb COL1, Keypad_Key_4
0CC0 30A43E    1471       jnb COL2, Keypad_Key_5
0CC3 30A63F    1472       jnb COL3, Keypad_Key_6
0CC6 30B040    1473       jnb COL4, Keypad_Key_B
0CC9 D294      1474       setb ROW2
0CCB           1475   
0CCB           1476       ; Row 3
0CCB C296      1477       clr ROW3
0CCD 30A23D    1478       jnb COL1, Keypad_Key_7
0CD0 30A43E    1479       jnb COL2, Keypad_Key_8
0CD3 30A63F    1480       jnb COL3, Keypad_Key_9
0CD6 30B040    1481       jnb COL4, Keypad_Key_C
0CD9 D296      1482       setb ROW3
0CDB           1483   
0CDB           1484       ; Row 4
0CDB C2A0      1485       clr ROW4
0CDD 30A23D    1486       jnb COL1, Keypad_Key_Star
0CE0 30A43E    1487       jnb COL2, Keypad_Key_0
0CE3 30A63F    1488       jnb COL3, Keypad_Key_Hash
0CE6 30B040    1489       jnb COL4, Keypad_Key_D
0CE9 D2A0      1490       setb ROW4
0CEB C3        1491       clr C
0CEC 22        1492       ret
0CED           1493   
0CED           1494   ; Key Mapping (Renamed to avoid conflicts)
0CED 7F01      1495   Keypad_Key_1: mov R7, #1
0CEF 803C      1496          sjmp Wait_Release
0CF1 7F02      1497   Keypad_Key_2: mov R7, #2
0CF3 8038      1498          sjmp Wait_Release
0CF5 7F03      1499   Keypad_Key_3: mov R7, #3
0CF7 8034      1500          sjmp Wait_Release
0CF9 7F0A      1501   Keypad_Key_A: mov R7, #10
0CFB 8030      1502          sjmp Wait_Release
0CFD 7F04      1503   Keypad_Key_4: mov R7, #4
0CFF 802C      1504          sjmp Wait_Release
0D01 7F05      1505   Keypad_Key_5: mov R7, #5
0D03 8028      1506          sjmp Wait_Release
0D05 7F06      1507   Keypad_Key_6: mov R7, #6
0D07 8024      1508          sjmp Wait_Release
0D09 7F0B      1509   Keypad_Key_B: mov R7, #11
0D0B 8020      1510          sjmp Wait_Release
0D0D 7F07      1511   Keypad_Key_7: mov R7, #7
0D0F 801C      1512          sjmp Wait_Release
0D11 7F08      1513   Keypad_Key_8: mov R7, #8
0D13 8018      1514          sjmp Wait_Release
0D15 7F09      1515   Keypad_Key_9: mov R7, #9
0D17 8014      1516          sjmp Wait_Release
0D19 7F0D      1517   Keypad_Key_C: mov R7, #13
0D1B 8010      1518          sjmp Wait_Release
0D1D 7F0E      1519   Keypad_Key_Star: mov R7, #14
0D1F 800C      1520          sjmp Wait_Release
0D21 7F00      1521   Keypad_Key_0: mov R7, #0
0D23 8008      1522          sjmp Wait_Release
0D25 7F0C      1523   Keypad_Key_Hash: mov R7, #12
0D27 8004      1524          sjmp Wait_Release
0D29 7F0F      1525   Keypad_Key_D: mov R7, #15
0D2B 8000      1526          sjmp Wait_Release
0D2D           1527   
0D2D           1528   Wait_Release:
0D2D A2A2      1529       mov C, COL1
0D2F 82A4      1530       anl C, COL2
0D31 82A6      1531       anl C, COL3
0D33 82B0      1532       anl C, COL4
0D35 50F6      1533       jnc Wait_Release
0D37 D3        1534       setb C
0D38 D292      1535       setb ROW1
0D3A D294      1536       setb ROW2
0D3C D296      1537       setb ROW3
0D3E D2A0      1538       setb ROW4
0D40 22        1539       ret
0D41           1540   
0D41           1541   Wait_25ms:
0D41           1542       ; 1. Check if we are already waiting
0D41 20130E    1543       jb wait25_active, Check_Timer_Status
0D44           1544       
0D44           1545       ; 2. Check if we just finished
0D44 301404    1546       jnb wait25_done, Start_New_Timer
0D47           1547       
0D47           1548       ; 3. Timer is DONE! Reset flags and return True
0D47 C214      1549       clr wait25_done
0D49 D3        1550       setb C          ; Carry = 1 means "Done"
0D4A 22        1551       ret
0D4B           1552   
0D4B           1553   Start_New_Timer:
0D4B           1554       ; 4. Start a new 25ms wait
0D4B 754F00    1555       mov wait25_count, #0
0D4E D213      1556       setb wait25_active
0D50 C3        1557       clr C           ; Carry = 0 means "Not Done Yet"
0D51 22        1558       ret
0D52           1559   
0D52           1560   Check_Timer_Status:
0D52           1561       ; 5. Still waiting... return False immediately
0D52 C3        1562       clr C           ; Carry = 0 means "Not Done Yet"
0D53 22        1563       ret
0D54           1564   
0D54           1565   ; ----------------------------------------------------------------
0D54           1566   ; MODULE: BUFFER INIT (Reset Logic)
0D54           1567   ; ----------------------------------------------------------------
0D54           1568   Init_All_Buffers:
0D54 786B      1569       mov R0, #Buf_Soak_Temp
0D56 120D69    1570       lcall Init_Temp_Template
0D59 7874      1571       mov R0, #Buf_Refl_Temp
0D5B 120D69    1572       lcall Init_Temp_Template
0D5E 786F      1573       mov R0, #Buf_Soak_Time
0D60 120D75    1574       lcall Init_Time_Template
0D63 7878      1575       mov R0, #Buf_Refl_Time
0D65 120D75    1576       lcall Init_Time_Template
0D68 22        1577       ret
0D69           1578   
0D69           1579   Init_Temp_Template:
0D69 7630      1580       mov @R0, #'0'
0D6B 08        1581       inc R0
0D6C 7630      1582       mov @R0, #'0'
0D6E 08        1583       inc R0
0D6F 7630      1584       mov @R0, #'0'
0D71 08        1585       inc R0
0D72 7600      1586       mov @R0, #0
0D74 22        1587       ret
0D75           1588   
0D75           1589   Init_Time_Template:
0D75 7630      1590       mov @R0, #'0'
0D77 08        1591       inc R0
0D78 7630      1592       mov @R0, #'0'
0D7A 08        1593       inc R0
0D7B 7630      1594       mov @R0, #'0'
0D7D 08        1595       inc R0
0D7E 7630      1596       mov @R0, #'0'
0D80 08        1597       inc R0
0D81 7600      1598       mov @R0, #0
0D83 22        1599       ret
0D84           1600   
0D84           1601   Reset_Current_Buffer:
0D84 E569      1602       mov A, Current_State
0D86 B40106    1603       cjne A, #1, Reset_Chk_2
0D89 786B      1604       mov R0, #Buf_Soak_Temp
0D8B 120D69    1605       lcall Init_Temp_Template
0D8E 22        1606       ret
0D8F           1607   Reset_Chk_2:
0D8F B40206    1608       cjne A, #2, Reset_Chk_3
0D92 786F      1609       mov R0, #Buf_Soak_Time
0D94 120D75    1610       lcall Init_Time_Template
0D97 22        1611       ret
0D98           1612   Reset_Chk_3:
0D98 B40306    1613       cjne A, #3, Reset_Chk_4
0D9B 7874      1614       mov R0, #Buf_Refl_Temp
0D9D 120D69    1615       lcall Init_Temp_Template
0DA0 22        1616       ret
0DA1           1617   Reset_Chk_4:
0DA1 7878      1618       mov R0, #Buf_Refl_Time
0DA3 120D75    1619       lcall Init_Time_Template
0DA6 22        1620       ret
0DA7           1621   
0DA7           1622   ; ----------------------------------------------------------------
0DA7           1623   ; MODULE: SCREEN UPDATE (Visual Logic)
0DA7           1624   ; ----------------------------------------------------------------
0DA7           1625   Update_Screen_Full:
0DA7 120EA4    1626       lcall Clear_Screen_Func
0DAA C0E0      1627            push acc
0DAC 7401      1627            mov a, #1
0DAE 14        1627            dec a
0DAF 1205C9    1627            lcall ?Set_Cursor_1 ; Select column and row
0DB2 D0E0      1627            pop acc
0DB4           1628   
0DB4           1629       ; --- Draw Line 1 (Titles) ---
0DB4 E569      1630       mov A, Current_State
0DB6 B40013    1631       cjne A, #0, Update_State_1
0DB9 C083      1632            push dph
0DBB C082      1632            push dpl
0DBD C0E0      1632            push acc
0DBF 900350    1632            mov dptr, #Txt_Home
0DC2 1205BC    1632            lcall ?Send_Constant_String
0DC5 D0E0      1632            pop acc
0DC7 D082      1632            pop dpl
0DC9 D083      1632            pop dph
0DCB 22        1633       ret 
0DCC           1634   Update_State_1:
0DCC B40114    1635       cjne A, #1, Update_State_2
0DCF C083      1636            push dph
0DD1 C082      1636            push dpl
0DD3 C0E0      1636            push acc
0DD5 900361    1636            mov dptr, #Txt_SoakT
0DD8 1205BC    1636            lcall ?Send_Constant_String
0DDB D0E0      1636            pop acc
0DDD D082      1636            pop dpl
0DDF D083      1636            pop dph
0DE1 8042      1637       sjmp Draw_Temp_Format
0DE3           1638   Update_State_2:
0DE3 B40214    1639       cjne A, #2, Update_State_3
0DE6 C083      1640            push dph
0DE8 C082      1640            push dpl
0DEA C0E0      1640            push acc
0DEC 900372    1640            mov dptr, #Txt_SoakTime
0DEF 1205BC    1640            lcall ?Send_Constant_String
0DF2 D0E0      1640            pop acc
0DF4 D082      1640            pop dpl
0DF6 D083      1640            pop dph
0DF8 8042      1641       sjmp Draw_Time_Format
0DFA           1642   Update_State_3:
0DFA B40314    1643       cjne A, #3, Update_State_4
0DFD C083      1644            push dph
0DFF C082      1644            push dpl
0E01 C0E0      1644            push acc
0E03 900383    1644            mov dptr, #Txt_ReflT
0E06 1205BC    1644            lcall ?Send_Constant_String
0E09 D0E0      1644            pop acc
0E0B D082      1644            pop dpl
0E0D D083      1644            pop dph
0E0F 8014      1645       sjmp Draw_Temp_Format
0E11           1646   Update_State_4:
0E11 C083      1647            push dph
0E13 C082      1647            push dpl
0E15 C0E0      1647            push acc
0E17 900394    1647            mov dptr, #Txt_ReflTime
0E1A 1205BC    1647            lcall ?Send_Constant_String
0E1D D0E0      1647            pop acc
0E1F D082      1647            pop dpl
0E21 D083      1647            pop dph
0E23 8017      1648       sjmp Draw_Time_Format
0E25           1649   
0E25           1650   ; --- Draw Line 2 (Values) ---
0E25           1651   Draw_Temp_Format:
0E25 C0E0      1652            push acc
0E27 7401      1652            mov a, #1
0E29 14        1652            dec a
0E2A 1205C7    1652            lcall ?Set_Cursor_2 ; Select column and row
0E2D D0E0      1652            pop acc
0E2F 120EB7    1653       lcall Get_Current_Buffer_Addr
0E32 120E94    1654       lcall Print_String_RAM
0E35 7443      1655       mov A, #'C'
0E37 12057F    1656       lcall ?WriteData
0E3A 802C      1657       sjmp Restore_Cursor
0E3C           1658   
0E3C           1659   Draw_Time_Format:
0E3C C0E0      1660            push acc
0E3E 7401      1660            mov a, #1
0E40 14        1660            dec a
0E41 1205C7    1660            lcall ?Set_Cursor_2 ; Select column and row
0E44 D0E0      1660            pop acc
0E46 120EB7    1661       lcall Get_Current_Buffer_Addr
0E49           1662       ; MM
0E49 E6        1663       mov A, @R0
0E4A 12057F    1664       lcall ?WriteData
0E4D 08        1665       inc R0
0E4E E6        1666       mov A, @R0
0E4F 12057F    1667       lcall ?WriteData
0E52 08        1668       inc R0
0E53           1669       ; Colon
0E53 743A      1670       mov A, #':'
0E55 12057F    1671       lcall ?WriteData
0E58           1672       ; SS
0E58 E6        1673       mov A, @R0
0E59 12057F    1674       lcall ?WriteData
0E5C 08        1675       inc R0
0E5D E6        1676       mov A, @R0
0E5E 12057F    1677       lcall ?WriteData
0E61           1678       ; Unit
0E61 7473      1679       mov A, #'s'
0E63 12057F    1680       lcall ?WriteData
0E66 8000      1681       sjmp Restore_Cursor
0E68           1682   
0E68           1683   ; --- Restore Cursor Position ---
0E68           1684   Restore_Cursor:
0E68 E569      1685       mov A, Current_State
0E6A B40202    1686       cjne A, #2, RC_Check_State_4  
0E6D 800D      1687       sjmp Adjust_Cursor_Time
0E6F           1688   RC_Check_State_4:             
0E6F B40402    1689       cjne A, #4, Normal_Cursor
0E72 8008      1690       sjmp Adjust_Cursor_Time
0E74           1691   
0E74           1692   Normal_Cursor:
0E74 E56A      1693       mov A, Cursor_Idx
0E76 24C0      1694       add A, #0xC0
0E78 120584    1695       lcall ?WriteCommand
0E7B 22        1696       ret
0E7C           1697   
0E7C           1698   Adjust_Cursor_Time:
0E7C           1699       ; Skip the colon index (2)
0E7C E56A      1700       mov A, Cursor_Idx
0E7E B40201    1701       cjne A, #2, No_Skip
0E81 04        1702       inc A 
0E82           1703   No_Skip:
0E82           1704       ; Add 1 if past the colon
0E82 C3        1705       clr C
0E83 9402      1706       subb A, #2
0E85 4005      1707       jc No_Add
0E87 E56A      1708       mov A, Cursor_Idx
0E89 04        1709       inc A
0E8A 8002      1710       sjmp Final_Cursor_Set
0E8C           1711   No_Add:
0E8C E56A      1712       mov A, Cursor_Idx
0E8E           1713   Final_Cursor_Set:
0E8E 24C0      1714       add A, #0xC0
0E90 120584    1715       lcall ?WriteCommand
0E93 22        1716       ret
0E94           1717   
0E94           1718   Print_String_RAM:
0E94 E6        1719       mov A, @R0
0E95 6006      1720       jz Print_String_Done
0E97 12057F    1721       lcall ?WriteData
0E9A 08        1722       inc R0
0E9B 80F7      1723       sjmp Print_String_RAM
0E9D           1724   Print_String_Done:
0E9D 22        1725       ret
0E9E           1726   
0E9E           1727   ; Blocking wrapper for LCD clear (keeps old behavior just for this)
0E9E           1728   Wait_25ms_BLOCKING:
0E9E 120D41    1729       lcall Wait_25ms
0EA1 50FB      1730       jnc Wait_25ms_BLOCKING ; Keep jumping back until Done (C=1)
0EA3 22        1731       ret
0EA4           1732   
0EA4           1733   Clear_Screen_Func:
0EA4 7401      1734       mov A, #0x01
0EA6 120584    1735       lcall ?WriteCommand
0EA9           1736       
0EA9           1737       ; --- FIX: HARDWARE DELAY LOOP (MAX STRENGTH) ---
0EA9           1738       ; The LCD needs ~2ms to clear. 
0EA9           1739       ; We use R0=255 to guarantee ~5ms+ delay.
0EA9           1740       ; This ensures the LCD is 100% ready before we send "Ramp to Soak".
0EA9 78FF      1741       mov R0, #255
0EAB           1742   Clear_Delay_Loop_Outer:
0EAB 79FF      1743       mov R1, #255
0EAD           1744   Clear_Delay_Loop_Inner:
0EAD D9FE      1745       djnz R1, Clear_Delay_Loop_Inner
0EAF D8FA      1746       djnz R0, Clear_Delay_Loop_Outer
0EB1           1747       ; -----------------------------------------------
0EB1           1748   
0EB1 740C      1749       mov A, #0x0C  ; Display ON, Cursor OFF
0EB3 120584    1750       lcall ?WriteCommand
0EB6 22        1751       ret
0EB7           1752   
0EB7           1753   Get_Current_Buffer_Addr:
0EB7 E569      1754       mov A, Current_State
0EB9 B40103    1755       cjne A, #1, Get_Buf_2
0EBC 786B      1756       mov R0, #Buf_Soak_Temp
0EBE 22        1757       ret
0EBF           1758   Get_Buf_2:
0EBF B40203    1759       cjne A, #2, Get_Buf_3
0EC2 786F      1760       mov R0, #Buf_Soak_Time
0EC4 22        1761       ret
0EC5           1762   Get_Buf_3:
0EC5 B40303    1763       cjne A, #3, Get_Buf_4
0EC8 7874      1764       mov R0, #Buf_Refl_Temp
0ECA 22        1765       ret
0ECB           1766   Get_Buf_4:
0ECB 7878      1767       mov R0, #Buf_Refl_Time
0ECD 22        1768       ret
0ECE           1769       
0ECE           1770   ; --- Helper to prevent "Machine Gun" button presses ---
0ECE           1771   Wait_For_P1_0_Release:
0ECE 3090FD    1772       jnb P1.0, $    ; Wait here while the button is still pressed (0)
0ED1 22        1773       ret
0ED2           1774       
0ED2           1775       
0ED2           1776   ; ================================================================
0ED2           1777   ; MODULE: THERMOCOUPLE ADC DRIVER
0ED2           1778   ; ================================================================
0ED2           1779   Read_Thermocouple:
0ED2           1780       ; 1. Check Non-Blocking Timer (Run once every 25ms)
0ED2 120D41    1781       lcall Wait_25ms
0ED5 5059      1782       jnc Read_TC_Exit ; If 25ms hasn't passed, exit immediately
0ED7           1783       
0ED7           1784       ; --- 25ms Passed! Time to Read ---
0ED7           1785       
0ED7           1786       ; 2. Initialize / Trigger ADC
0ED7           1787       ; Writing to ADC_C (0xA1) triggers the conversion
0ED7 75A180    1788       mov ADC_C, #0x80    ; Reset / Strobe
0EDA 00        1789       nop
0EDB 00        1790       nop
0EDC 75A100    1791       mov ADC_C, #0x00    ; Select Channel 0 (ADCINPUT 0) and Start
0EDF           1792       
0EDF           1793       ; 3. [FIX] Settle Delay
0EDF           1794       ; The DE10-Lite ADC bridge needs time to fetch data from the MAX10 chip.
0EDF           1795       ; We burn ~500 cycles to be absolutely safe.
0EDF 7DFA      1796       mov R5, #250
0EE1           1797   ADC_Settle_Loop:
0EE1 00        1798       nop
0EE2 00        1799       nop
0EE3 DDFC      1800       djnz R5, ADC_Settle_Loop
0EE5           1801       
0EE5           1802       ; 4. Read Raw Data
0EE5 85A232    1803       mov x+0, ADC_L      ; Read Low Byte (0xA2)
0EE8 85A333    1804       mov x+1, ADC_H      ; Read High Byte (0xA3)
0EEB 753400    1805       mov x+2, #0
0EEE 753500    1806       mov x+3, #0
0EF1           1807       
0EF1           1808       ; 5. [FIX] Mask the 12-bit Data
0EF1           1809       ; The ADC is 12-bit. We MUST zero out the upper 4 bits of the High Byte
0EF1           1810       ; or the math below will overflow and return 0.
0EF1 E533      1811       mov a, x+1
0EF3 540F      1812       anl a, #0x0F
0EF5 F533      1813       mov x+1, a
0EF7           1814       
0EF7           1815       ; 6. Convert to Voltage (Count * 5000 / 4095)
0EF7 753688    1816            mov y+0, #low (5000 % 0x10000) 
0EFA 753713    1816            mov y+1, #high(5000 % 0x10000) 
0EFD 753800    1816            mov y+2, #low (5000 / 0x10000) 
0F00 753900    1816            mov y+3, #high(5000 / 0x10000)         ; Vref = 5000mV
0F03 12018C    1817       lcall mul32         
0F06           1818       
0F06 7536FF    1819            mov y+0, #low (4095 % 0x10000) 
0F09 75370F    1819            mov y+1, #high(4095 % 0x10000) 
0F0C 753800    1819            mov y+2, #low (4095 / 0x10000) 
0F0F 753900    1819            mov y+3, #high(4095 / 0x10000)         ; 12-bit resolution
0F12 120280    1820       lcall div32         
0F15           1821       
0F15           1822       ; 7. Convert to Temp (Voltage / 10mV) -> e.g. 250mV / 10 = 25C
0F15           1823       ; Change this Load_y value if your amp gain is different!
0F15 75360A    1824            mov y+0, #low (10 % 0x10000) 
0F18 753700    1824            mov y+1, #high(10 % 0x10000) 
0F1B 753800    1824            mov y+2, #low (10 / 0x10000) 
0F1E 753900    1824            mov y+3, #high(10 / 0x10000)           
0F21 120280    1825       lcall div32         
0F24           1826       
0F24           1827       ; 8. Store Final Result
0F24 85323F    1828       mov current_temp+0, x+0
0F27 853340    1829       mov current_temp+1, x+1
0F2A 853441    1830       mov current_temp+2, x+2
0F2D 853542    1831       mov current_temp+3, x+3
0F30           1832   
0F30           1833   Read_TC_Exit:
0F30 22        1834       ret
0F31           1835       
0F31           1836   ; ================================================================
0F31           1837   ; MODULE: POWER CONTROLLER (The Brain)
0F31           1838   ; ================================================================
0F31           1839   Power_Control:
0F31           1840       ; Default: Turn Heat OFF (Safety)
0F31 755C00    1841       mov power_output+0, #0
0F34 755D00    1842       mov power_output+1, #0
0F37 755E00    1843       mov power_output+2, #0
0F3A 755F00    1844       mov power_output+3, #0
0F3D           1845   
0F3D E568      1846       mov a, Control_FSM_state
0F3F           1847   
0F3F           1848       ; --- State 2: RAMP TO SOAK ---
0F3F B40202    1849       cjne a, #2, PC_Check_Soak
0F42           1850       ; Mode: Full Speed Ahead
0F42 8016      1851       sjmp Set_Max_Power
0F44           1852   
0F44           1853   PC_Check_Soak:
0F44           1854       ; --- State 3: SOAK PHASE ---
0F44 B40305    1855       cjne a, #3, PC_Check_Ramp_Reflow
0F47           1856       ; Mode: Maintenance (Low Power)
0F47           1857       ; If Temp > Target, OFF. If Temp < Target, 20% Power.
0F47 20030F    1858       jb soak_temp_reached, PC_Done ; If hot enough, stay OFF
0F4A 801B      1859       sjmp Set_20_Percent_Power     ; If cold, use 20%
0F4C           1860   
0F4C           1861   PC_Check_Ramp_Reflow:
0F4C           1862       ; --- State 4: RAMP TO REFLOW ---
0F4C B40402    1863       cjne a, #4, PC_Check_Reflow
0F4F           1864       ; Mode: Full Speed Ahead
0F4F 8009      1865       sjmp Set_Max_Power
0F51           1866   
0F51           1867   PC_Check_Reflow:
0F51           1868       ; --- State 5: REFLOW PHASE ---
0F51 B40505    1869       cjne a, #5, PC_Done
0F54           1870       ; Mode: Maintenance (Low Power)
0F54 200402    1871       jb reflow_temp_reached, PC_Done
0F57 800E      1872       sjmp Set_20_Percent_Power
0F59           1873   
0F59           1874   PC_Done:
0F59 22        1875       ret
0F5A           1876   
0F5A           1877   ; --- Power Helpers ---
0F5A           1878   
0F5A           1879   Set_Max_Power:
0F5A           1880       ; Load 1500 (0x05DC) = 100% Duty Cycle
0F5A 755CDC    1881       mov power_output+0, #0xDC
0F5D 755D05    1882       mov power_output+1, #0x05
0F60 755E00    1883       mov power_output+2, #0
0F63 755F00    1884       mov power_output+3, #0
0F66 22        1885       ret
0F67           1886   
0F67           1887   Set_20_Percent_Power:
0F67           1888       ; Load 300 (0x012C) = 20% Duty Cycle
0F67 755C2C    1889       mov power_output+0, #0x2C
0F6A 755D01    1890       mov power_output+1, #0x01
0F6D 755E00    1891       mov power_output+2, #0
0F70 755F00    1892       mov power_output+3, #0
0F73 22        1893       ret
0F74           1894   
0F74           1895   EN
>>>>>>> main
