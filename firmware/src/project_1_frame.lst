0000              1   ; Project 1
0000              2   ; CV-8052 microcontroller in DE10-Lite board
0000              3   ;-------------------------------------------------------------------------------
0000              4   ; Reset vector
0000              5   org 0x0000
0000 020B17       6       ljmp main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9       reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 020467      12       ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15       reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18       reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 32          21       reti
0024             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
002B 0204D4      24       ljmp Timer2_ISR
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 32   $LIST
0320             34   ; ----------------------------------------------------------------------------------------------;
0320             35   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             36   dseg at 0x30
0030             37   current_time_sec:     ds 1
0031             38   current_time_minute:  ds 1
0032             39   ; math32 buffer variables
0032             40   x:      ds  4
0036             41   y:      ds  4
003A             42   bcd:    ds  5
003F             43   
003F             44   current_temp: ds 4 ;
0043             45   soak_temp:    ds 4 ;
0047             46   reflow_temp:  ds 4 ;
004B             47   
004B             48   wait25_btn_cnt:    ds 1
004C             49   wait25_keypad_cnt: ds 1
004D             50   wait25_adc_cnt:    ds 1
004E             51   wait25_lcd_cnt:    ds 1
004F             52   wait25_count: ds 1  
0050             53   
0050             54   current_time: ds 4 ;
0054             55   soak_time:    ds 4 ;
0058             56   reflow_time:  ds 4 ;
005C             57   
005C             58   power_output:  ds 4 ;
0060             59   pwm_counter: ds 4 ; counter for pwm (0-1500)
0064             60   
0064             61   KEY1_DEB_timer: ds 1
0065             62   SEC_FSM_timer:  ds 1
0066             63   KEY1_DEB_state:    ds 1
0067             64   SEC_FSM_state:     ds 1
0068             65   Control_FSM_state: ds 1 
0069             66   
0069             67   Current_State:     ds 1
006A             68   
006A             69   
006A             70   ;-- UI buffers I added (ayaan)
006A             71   Cursor_Idx: ds 1
006B             72   
006B             73   ; These hold the TEXT (ASCII) safely
006B             74   ; Digits Only + Null Terminator, got rid of C,:, and s 
006B             75   
006B             76   ; Buzzer state
006B             77   beep_count:  ds 1      ; remaining beeps
006C             78   beep_state:  ds 1      ; 0=idle, 1=ON, 2=OFF
006D             79   beep_tmr:    ds 2      ; 16-bit ms timer (needs to reach 500)
006F             80   
0080             81   iseg at 0x80
0080             82   Buf_Soak_Temp: ds 4   
0084             83   Buf_Soak_Time: ds 5   
0089             84   Buf_Refl_Temp: ds 4   
008D             85   Buf_Refl_Time: ds 5
0092             86   
0092             87   
0092             88   
0092             89   ; 46d bytes used
0092             90   
0092             91   ;-------------------------------------------------------------------------------
0092             92   ; bit operation setb, clr, jb, and jnb
0000             93   bseg
0000             94   mf:     dbit 1 ; math32 sign
0001             95   one_second_flag: dbit 1
0002             96   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003             97   
0003             98   soak_temp_reached: dbit 1
0004             99   reflow_temp_reached: dbit 1
0005            100   cooling_temp_reached: dbit 1
0006            101   
0006            102   soak_time_reached: dbit 1
0007            103   reflow_time_reached: dbit 1
0008            104   
0008            105   reset_signal: dbit 1
0009            106   stop_signal: dbit 1
000A            107   start_signal: dbit 1
000B            108   config_finish_signal: dbit 1
000C            109   
000C            110   state_change_signal: dbit 1
000D            111   
000D            112   Key1_flag: dbit 1
000E            113   
000E            114   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
000F            115   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0010            116   PB0_flag: dbit 1 ; start entire program
0011            117   PB1_flag: dbit 1 ; start soak
0012            118   PB2_flag: dbit 1 ; pause process
0013            119   
0013            120   ;buzzer beep
0013            121   one_ms_beep_flag: dbit 1
0014            122   
0014            123   ; BSEG (Bit Segment)
0014            124   wait25_active: dbit 1 ; 1 = We are currently waiting
0015            125   wait25_done:   dbit 1 ; 1 = The 25ms has finished
0016            126   wait25_btn_active:    dbit 1
0017            127   wait25_btn_done:      dbit 1
0018            128   wait25_keypad_active: dbit 1
0019            129   wait25_keypad_done:   dbit 1
001A            130   wait25_adc_active:    dbit 1
001B            131   wait25_adc_done:      dbit 1
001C            132   wait25_lcd_active:    dbit 1
001D            133   wait25_lcd_done:      dbit 1
001E            134   ; 11 bits used
001E            135   
001E            136   ;-------------------------------------------------------------------------------
0320            137   cseg
0320            138   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            139   BAUD           EQU 57600
0320            140   
0320            141   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            142   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            143   ; is always 12 unlike the N76E003 where is selectable.
0320            144   
0320            145   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            146   
0320            147   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            148   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            149   
0320            150   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            151   
0320            152   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            153   
0320            154   PWM_OUT        EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            155   
0320            156   ; These 'equ' must match the wiring between the DE10Lite board and the LCD!
0320            157   ; P0 is in connector JPIO.
0320            158   
0320            159   ;Added correct I/O definitions
0320            160   ;-- LCD Pins ---
0320            161   ELCD_RS equ P1.7
0320            162   ELCD_E  equ P1.1
0320            163   ELCD_D4 equ P0.7
0320            164   ELCD_D5 equ P0.5
0320            165   ELCD_D6 equ P0.3
0320            166   ELCD_D7 equ P0.1
0320            167   
0320            168   ; -- Buttons --
0320            169   BTN_SOAK_TEMP equ P0.0
0320            170   BTN_SOAK_TIME equ P0.2
0320            171   BTN_REFL_TEMP equ P0.4
0320            172   BTN_REFL_TIME equ P0.6
0320            173   
0320            174   ; --- KEYPAD ---
0320            175   ROW1 equ P1.2
0320            176   ROW2 equ P1.4
0320            177   ROW3 equ P1.6
0320            178   ROW4 equ P2.0
0320            179   COL1 equ P2.2
0320            180   COL2 equ P2.4
0320            181   COL3 equ P2.6
0320            182   COL4 equ P3.0
0320            183   
0320            184   COLD_JUNCTION_TEMP equ 20
0320            185   
0320            186   ;                     1234567890123456 <-- 16 characters per line LCD
0320 696E6974   187   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   188   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   189   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            190   
0350            191   ; --- UI STRINGS (REQUIRED FOR KEYPAD LOGIC), <- I can fix if duplicates
0350 53656C65   192   Txt_Home:     db 'Select Mode:    ', 0
     6374204D
     6F64653A
     20202020
     00
0361 53657420   193   Txt_SoakT:    db 'Set Soak Temp   ', 0
     536F616B
     2054656D
     70202020
     00
0372 53657420   194   Txt_SoakTime: db 'Set Soak Time   ', 0
     536F616B
     2054696D
     65202020
     00
0383 53657420   195   Txt_ReflT:    db 'Set Reflow Temp ', 0
     5265666C
     6F772054
     656D7020
     00
0394 53657420   196   Txt_ReflTime: db 'Set Reflow Time ', 0
     5265666C
     6F772054
     696D6520
     00
03A5            197   
03A5            198   ;                       1234567890123456
03A5 53657420   199   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
03B5 536F616B   200   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
03C0 5265666C   201   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
03CD 536F616B   202   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
03D8 5265666C   203   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03E5            204   
03E5            205   ;                     1234567890123456
03E5 52616D70   206   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03F5 536F616B   207   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
0405 52616D70   208   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
0415 5265666C   209   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
0425 436F6F6C   210   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
0435 50726F63   211   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
0445            212   
0445 20202020   213   String_Blank:    db '                ', 0
     20202020
     20202020
     20202020
     00
0456            214   
0456            215   ;-------------------------------------------------------------------------------
0456            216   ; Timers Setting:
0456            217   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
0456            218   ;   Timer 1: Serial port baud rate 57600 generator
0456            219   ;   Timer 2: 1ms interrupt for BCD counter increment/decrement
0456            220   ;-------------------------------------------------------------------------------
0456            221   ; Routine to initialize the ISR for Timer 0 ;
0456            222   Timer0_Init:
0456 E589       223       mov a, TMOD
0458 54F0       224       anl a, #0xf0 ; Clear the bits for timer 0
045A 4401       225       orl a, #0x01 ; Configure timer 0 as 16-timer
045C F589       226       mov TMOD, a
045E 758CFD     227       mov TH0, #high(TIMER0_RELOAD)
0461 758A5A     228       mov TL0, #low(TIMER0_RELOAD)
0464            229       ; Enable the timer and interrupts
0464 D2A9       230       setb ET0  ; Enable timer 0 interrupt
0466            231       ; setb TR0  (no need to open at first)
0466 22         232       ret
0467            233   ; ISR for timer 0.  Set to execute every 1/4096Hz 
0467            234   ; to generate a 2048 Hz square wave at pin P1.5 
0467            235   Timer0_ISR:
0467            236       ;clr TF0  ; According to the data sheet this is done for us already.
0467 758CFD     237       mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
046A 758A5A     238       mov TL0, #low(TIMER0_RELOAD)
046D B295       239       cpl SOUND_OUT ; Connect speaker to P1.5
046F 32         240       reti
0470            241   ; -----------------------------------------------------------------------------------------------;
0470            242   
0470            243   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
0470            244   Initialize_Serial_Port:
0470            245       ; Configure serial port and baud rate
0470 C28E       246       clr TR1 ; Disable timer 1
0472 53890F     247       anl TMOD, #0x0f ; Mask the bits for timer 1
0475 438920     248       orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
0478 438780     249       orl PCON, #80H ; Set SMOD to 1
047B 758DFD     250       mov TH1, #low(TIMER_1_RELOAD)
047E 758BFD     251       mov TL1, #low(TIMER_1_RELOAD) 
0481 D28E       252       setb TR1 ; Enable timer 1
0483 759852     253       mov SCON, #52H
0486 22         254       ret
0487            255   
0487            256   ; uart sending functions
0487            257   putchar:
0487 109902     258       jbc TI, putchar_L1
048A 80FB       259       sjmp putchar
048C            260   putchar_L1:
048C F599       261       mov SBUF,a
048E 22         262       ret
048F            263   
048F            264   SendString:
048F E4         265       clr a
0490 93         266       movc a, @a+dptr
0491 6006       267       jz SendString_L1
0493 120487     268       lcall putchar
0496 A3         269       inc dptr
0497 80F6       270       sjmp SendString  
0499            271   SendString_L1:
0499 22         272       ret
049A            273   
049A            274   ;-------------------------------------------------------------------------------
049A            275   ; serial debugging
049A            276   ; send a four byte number via serial to laptop
049A            277   ; need to be used with python script
049A            278   ; content needed to be sent should be stored in the varaible x
049A            279   ;-------------------------------------------------------------------------------
049A            280   Send32:
049A            281       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
049A 74AA       282       mov A, #0AAH
049C 120487     283       lcall putchar
049F 7455       284       mov A, #055H
04A1 120487     285       lcall putchar
04A4            286   
04A4 E535       287       mov A, x+3
04A6 120487     288       lcall putchar
04A9 E534       289       mov A, x+2
04AB 120487     290       lcall putchar
04AE E533       291       mov A, x+1
04B0 120487     292       lcall putchar
04B3 E532       293       mov A, x+0
04B5 120487     294       lcall putchar
04B8            295   
04B8 740A       296       mov A, #0AH
04BA 120487     297       lcall putchar
04BD 22         298       ret
04BE            299   ; -----------------------------------------------------------------------------------------------;
04BE            300   
04BE            301   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
04BE              1   ;-------------------------------------------------------------------------------
04BE              2   ; Timer2_ISR.inc
04BE              3   ; Contains Initialization and ISR for the 1ms System Timer
04BE              4   ;-------------------------------------------------------------------------------
04BE              5   
04BE              6   ;-------------------------------------------------------------------------------
04BE              7   ; Routine to initialize the ISR for timer 2
04BE              8   ;-------------------------------------------------------------------------------
04BE              9   Timer2_Init:
04BE 75C800      10       mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
04C1 75CDF5      11       mov TH2, #high(TIMER2_RELOAD)
04C4 75CC27      12       mov TL2, #low(TIMER2_RELOAD)
04C7             13       ; Set the reload value
04C7 75CBF5      14       mov RCAP2H, #high(TIMER2_RELOAD)
04CA 75CA27      15       mov RCAP2L, #low(TIMER2_RELOAD)
04CD             16       
04CD C2CF        17       clr TF2       ; Clear flag just in case
04CF             18       ; Enable the timer and interrupts
04CF D2AD        19       setb ET2      ; Enable timer 2 interrupt
04D1 D2CA        20       setb TR2      ; Enable timer 2
04D3 22          21       ret
04D4             22   
04D4             23   ;-------------------------------------------------------------------------------
04D4             24   ; ISR for timer 2.  Runs every 1 ms
04D4             25   ;-------------------------------------------------------------------------------
04D4             26   Timer2_ISR:
04D4 C0E0        27       push acc
04D6 C0D0        28       push psw
04D8             29       
04D8 C2CF        30       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
04DA             31   
04DA             32       ; --- 1. Existing FSM Timers ---
04DA 0564        33       inc KEY1_DEB_timer
04DC 0565        34       inc SEC_FSM_timer
04DE D202        35       setb one_ms_pwm_flag 
04E0 D213        36       setb one_ms_beep_flag
04E2             37   
04E2             38       ; --- 2. NEW: Non-Blocking Delay Counters ---
04E2             39       
04E2             40       ; A. BUTTON DELAY
04E2 30160B      41       jnb wait25_btn_active, T2_Check_Keypad
04E5 054B        42       inc wait25_btn_cnt
04E7 E54B        43       mov a, wait25_btn_cnt
04E9 B41904      44       cjne a, #25, T2_Check_Keypad
04EC D217        45       setb wait25_btn_done
04EE C216        46       clr wait25_btn_active
04F0             47       
04F0             48       ; B. KEYPAD DELAY
04F0             49   T2_Check_Keypad:
04F0 30180B      50       jnb wait25_keypad_active, T2_Check_ADC
04F3 054C        51       inc wait25_keypad_cnt
04F5 E54C        52       mov a, wait25_keypad_cnt
04F7 B41904      53       cjne a, #25, T2_Check_ADC
04FA D219        54       setb wait25_keypad_done
04FC C218        55       clr wait25_keypad_active
04FE             56   
04FE             57       ; C. ADC DELAY (Thermocouple)
04FE             58   T2_Check_ADC:
04FE 301A0B      59       jnb wait25_adc_active, T2_Check_LCD
0501 054D        60       inc wait25_adc_cnt
0503 E54D        61       mov a, wait25_adc_cnt
0505 B41904      62       cjne a, #25, T2_Check_LCD
0508 D21B        63       setb wait25_adc_done
050A C21A        64       clr wait25_adc_active
050C             65   
050C             66       ; D. LCD DELAY
050C             67   T2_Check_LCD:
050C 301C0B      68       jnb wait25_lcd_active, T2_Check_Generic
050F 054E        69       inc wait25_lcd_cnt
0511 E54E        70       mov a, wait25_lcd_cnt
0513 B41904      71       cjne a, #25, T2_Check_Generic
0516 D21D        72       setb wait25_lcd_done
0518 C21C        73       clr wait25_lcd_active
051A             74   
051A             75       ; E. GENERIC DELAY (Used by Wait_25ms in Main)
051A             76   T2_Check_Generic:
051A 30140B      77       jnb wait25_active, Timer2_ISR_done
051D 054F        78       inc wait25_count
051F E54F        79       mov a, wait25_count
0521 B41904      80       cjne a, #25, Timer2_ISR_done
0524 D215        81       setb wait25_done      ; Tells Wait_25ms that we are finished
0526 C214        82       clr wait25_active     ; Stop counting
0528             83   
0528             84   Timer2_ISR_done:
0528 D0D0        85       pop psw
052A D0E0        86       pop acc
052C 32          87       reti
052D             88            
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
052D              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
052D              2   cseg
052D              3   
052D              4   ; When using a 33.333333MHz crystal clock
052D              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
052D              6   
052D              7   ;---------------------------------;
052D              8   ; Wait 40 microseconds            ;
052D              9   ;---------------------------------;
052D             10   Wait40uSec:
052D C000        11            push AR0
052F 78BE        12            mov R0, #190
0531             13   L0: 
0531 00          14            nop
0532 00          15            nop
0533 00          16            nop
0534 00          17            nop
0535 D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
0537 D000        19            pop AR0
0539 22          20       ret
053A             21   
053A             22   ;---------------------------------;
053A             23   ; Wait 'R2' milliseconds          ;
053A             24   ;---------------------------------;
                 25   Wait_Milli_Seconds mac
                 26   	push AR2
                 27   	mov R2, %0
                 28   	lcall ?Wait_Milli_Seconds
                 29   	pop AR2
                 30   endmac
053A             31   
053A             32   ?Wait_Milli_Seconds:
053A C000        33            push AR0
053C C001        34            push AR1
053E 7932        35   L3: mov R1, #50
0540 78DF        36   L2: mov R0, #223
0542 D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
0544 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
0546 DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
0548 D001        40       pop AR1
054A D000        41       pop AR0
054C 22          42       ret
054D             43            
054D             44   ;---------------------------------;
054D             45   ; Toggles the 'E' pin in the LCD  ;
054D             46   ;---------------------------------;
054D             47   ELCD_pulse:
054D D291        48            setb ELCD_E
054F 12052D      49            lcall Wait40uSec
0552 C291        50            clr ELCD_E
0554 12052D      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
0557 22          52       ret
0558             53   
0558             54   ;---------------------------------;
0558             55   ; Writes acc to LCD in 4-bit mode ;
0558             56   ;---------------------------------;
0558             57   ELCD_byte:
0558             58            ; Write high 4 bits first
0558 A2E7        59            mov c, ACC.7
055A 9281        60            mov ELCD_D7, c
055C A2E6        61            mov c, ACC.6
055E 9283        62            mov ELCD_D6, c
0560 A2E5        63            mov c, ACC.5
0562 9285        64            mov ELCD_D5, c
0564 A2E4        65            mov c, ACC.4
0566 9287        66            mov ELCD_D4, c
0568 12054D      67       lcall ELCD_pulse
056B             68            ; Write low 4 bits next
056B A2E3        69            mov c, ACC.3
056D 9281        70            mov ELCD_D7, c
056F A2E2        71            mov c, ACC.2
0571 9283        72            mov ELCD_D6, c
0573 A2E1        73            mov c, ACC.1
0575 9285        74            mov ELCD_D5, c
0577 A2E0        75            mov c, ACC.0
0579 9287        76            mov ELCD_D4, c
057B 12054D      77       lcall ELCD_pulse
057E 22          78            ret
057F             79   
057F             80   ;---------------------------------;
057F             81   ; Write data to LCD               ;
057F             82   ;---------------------------------;
                 83   WriteData mac
                 84   	mov a, %0
                 85   	lcall ?WriteData
                 86   endmac
057F             87            
057F             88   ?WriteData:
057F D297        89            setb ELCD_RS
0581 020558      90            ljmp ELCD_byte
0584             91   
0584             92   ;---------------------------------;
0584             93   ; Write command to LCD            ;
0584             94   ;---------------------------------;
                 95   WriteCommand mac
                 96   	mov a, %0
                 97   	lcall ?WriteCommand
                 98   endmac
0584             99   
0584            100   ?WriteCommand:
0584 C297       101            clr ELCD_RS
0586 020558     102            ljmp ELCD_byte
0589            103   
0589            104   ;---------------------------------;
0589            105   ; Configure LCD in 4-bit mode     ;
0589            106   ;---------------------------------;
0589            107   ELCD_4BIT:
0589 C291       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
058B            109            ;clr ELCD_RW  ; RW forced to zero
058B            110            
058B            111            ; After power on, let the LCD start up before initializing
058B C002       112            push AR2
058D 7A28       112            mov R2, #40
058F 12053A     112            lcall ?Wait_Milli_Seconds
0592 D002       112            pop AR2
0594            113            
0594            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
0594 7433       115            mov a, #0x33
0596 120584     115            lcall ?WriteCommand
0599 7433       116            mov a, #0x33
059B 120584     116            lcall ?WriteCommand
059E 7432       117            mov a, #0x32
05A0 120584     117            lcall ?WriteCommand ; change to 4-bit mode
05A3            118   
05A3            119            ; Configure the LCD
05A3 7428       120            mov a, #0x28
05A5 120584     120            lcall ?WriteCommand
05A8 740C       121            mov a, #0x0c
05AA 120584     121            lcall ?WriteCommand
05AD 7401       122            mov a, #0x01
05AF 120584     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
05B2            123   
05B2            124       ;Wait for the clear screen command to finish.
05B2 C002       125            push AR2
05B4 7A02       125            mov R2, #2
05B6 12053A     125            lcall ?Wait_Milli_Seconds
05B9 D002       125            pop AR2
05BB 22         126       ret
05BC            127   
05BC            128   ;---------------------------------;
05BC            129   ; Send a constant string to LCD   ;
05BC            130   ;---------------------------------;
                131   Send_Constant_String mac
                132   	push dph
                133   	push dpl
                134   	push acc
                135   	mov dptr, %0
                136   	lcall ?Send_Constant_String
                137   	pop acc
                138   	pop dpl
                139   	pop dph
                140   endmac
05BC            141   
05BC            142   ?Send_Constant_String:
05BC E4         143       clr a
05BD 93         144       movc a, @a+dptr
05BE 6006       145       jz ?Send_Constant_String_Done
05C0 12057F     146       lcall ?WriteData
05C3 A3         147       inc dptr
05C4 80F6       148       sjmp ?Send_Constant_String
05C6            149   ?Send_Constant_String_Done:
05C6 22         150       ret  
05C7            151   
05C7            152   ;---------------------------------;
05C7            153   ; Set LCD cursor at row, column   ;
05C7            154   ;---------------------------------;
                155   Set_Cursor mac
                156   	push acc
                157   	mov a, #%1
                158   	dec a
                159   	lcall ?Set_Cursor_%0 ; Select column and row
                160   	pop acc
                161   endmac
05C7            162   
05C7            163   ?Set_Cursor_2:
05C7 4440       164            orl a, #01000000B
05C9            165   ?Set_Cursor_1:
05C9 4480       166            orl a, #10000000B
05CB 020584     167            ljmp ?WriteCommand ; Select column and row
05CE            168   
05CE            169   ;---------------------------------;
05CE            170   ; Display a BCD number in the LCD ;
05CE            171   ;---------------------------------;
                172   Display_BCD mac
                173   	push ar0
                174   	mov r0, %0
                175   	lcall ?Display_BCD
                176   	pop ar0
                177   endmac
05CE            178   
05CE            179   ?Display_BCD:
05CE C0E0       180            push acc
05D0            181            ; Write most significant digit
05D0 E8         182            mov a, r0
05D1 C4         183            swap a
05D2 540F       184            anl a, #0fh
05D4 4430       185            orl a, #30h
05D6 12057F     186            lcall ?WriteData
05D9            187            ; write least significant digit
05D9 E8         188            mov a, r0
05DA 540F       189            anl a, #0fh
05DC 4430       190            orl a, #30h
05DE 12057F     191            lcall ?WriteData
05E1 D0E0       192            pop acc
05E3 22         193            ret
05E4            194   
05E4            195   ;------------------------------------;
05E4            196   ; Display a char in the LCD          ;
05E4            197   ;------------------------------------;
                198   Display_char mac
                199   	push acc
                200   	mov a, %0
                201   	lcall ?WriteData
                202   	pop acc
                203   endmac
05E4            204   
05E4            304            ;-----------------------------------------------------------------------------------------------;
05E4            305   
05E4            306   ;-------------------------------------------------------------------------------
05E4            307   ; Display Function for 7-segment displays       
05E4            308   ;-------------------------------------------------------------------------------
05E4            309   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
05E4            310   T_7seg:
05E4 C0F9A4B0   311       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
05E9 9282F880   312       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
05EE 8883C6A1   313       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
05F4            314   
05F4            315   ; Displays a BCD number pased in R0 in HEX5-HEX0
05F4            316   Display_BCD_7_Seg_HEX10:
05F4 9005E4     317       mov dptr, #T_7seg
05F7 E8         318       mov a, R0
05F8 C4         319       swap a
05F9 540F       320       anl a, #0FH
05FB 93         321       movc a, @a+dptr
05FC F592       322       mov HEX1, a
05FE E8         323       mov a, R0
05FF 540F       324       anl a, #0FH
0601 93         325       movc a, @a+dptr
0602 F591       326       mov HEX0, a
0604 22         327       ret
0605            328   
0605            329   Display_BCD_7_Seg_HEX32:
0605 9005E4     330       mov dptr, #T_7seg
0608 E8         331       mov a, R0
0609 C4         332       swap a
060A 540F       333       anl a, #0FH
060C 93         334       movc a, @a+dptr
060D F594       335       mov HEX3, a
060F E8         336       mov a, R0
0610 540F       337       anl a, #0FH
0612 93         338       movc a, @a+dptr
0613 F593       339       mov HEX2, a
0615 22         340       ret
0616            341   
0616            342   Display_BCD_7_Seg_HEX54:
0616 9005E4     343       mov dptr, #T_7seg
0619 E8         344       mov a, R0
061A C4         345       swap a
061B 540F       346       anl a, #0FH
061D 93         347       movc a, @a+dptr
061E F58F       348       mov HEX5, a
0620 E8         349       mov a, R0
0621 540F       350       anl a, #0FH
0623 93         351       movc a, @a+dptr
0624 F58E       352       mov HEX4, a
0626 22         353       ret
0627            354   
0627            355   ; The 8-bit hex number passed in the accumulator is converted to
0627            356   ; BCD and stored in [R1, R0]
0627            357   Hex_to_bcd_8bit:
0627 75F064     358       mov b, #100
062A 84         359       div ab
062B F9         360       mov R1, a   ; After dividing, a has the 100s
062C E5F0       361       mov a, b    ; Remainder is in register b
062E 75F00A     362       mov b, #10
0631 84         363       div ab ; The tens are stored in a, the units are stored in b 
0632 C4         364       swap a
0633 54F0       365       anl a, #0xf0
0635 45F0       366       orl a, b
0637 F8         367       mov R0, a
0638 22         368       ret
0639            369   ;-------------------------------------------------------------------------------
0639            370   ; Display Function for LCD                      
0639            371   ;-------------------------------------------------------------------------------
0639            372   LCD_Display_Update_func:
0639 C0E0       373       push acc
063B            374       
063B            375       ; ==========================================
063B            376       ; PART 1: STATIC TEXT (Title)
063B            377       ; Runs ONLY when the state changes
063B            378       ; ==========================================
063B            379       
063B            380       ; [FIX] "Trampoline" logic for long distance jump
063B            381       ; If signal is SET (1), we stay here and update.
063B            382       ; If signal is CLEAR (0), we Long Jump to the Live Update section.
063B 200C03     383       jb state_change_signal, Do_Static_Update
063E 020777     384       ljmp Check_Live_Update
0641            385   
0641            386   Do_Static_Update:
0641 C20C       387       clr state_change_signal
0643            388       
0643            389       ; State Changed: Clear Screen and Write Title
0643 120F43     390       lcall Clear_Screen_Func
0646 E568       391       mov a, Control_FSM_state
0648            392       
0648            393       ; State 0: Welcome
0648 B4003B     394       cjne a, #0, LCD_Check_1
064B C0E0       395            push acc
064D 7401       395            mov a, #1
064F 14         395            dec a
0650 1205C9     395            lcall ?Set_Cursor_1 ; Select column and row
0653 D0E0       395            pop acc
0655 C083       396            push dph
0657 C082       396            push dpl
0659 C0E0       396            push acc
065B 900330     396            mov dptr, #String_state0_1
065E 1205BC     396            lcall ?Send_Constant_String
0661 D0E0       396            pop acc
0663 D082       396            pop dpl
0665 D083       396            pop dph
0667 C0E0       397            push acc
0669 7401       397            mov a, #1
066B 14         397            dec a
066C 1205C7     397            lcall ?Set_Cursor_2 ; Select column and row
066F D0E0       397            pop acc
0671 C083       398            push dph
0673 C082       398            push dpl
0675 C0E0       398            push acc
0677 900340     398            mov dptr, #String_state0_2
067A 1205BC     398            lcall ?Send_Constant_String
067D D0E0       398            pop acc
067F D082       398            pop dpl
0681 D083       398            pop dph
0683 020774     399       ljmp LCD_Done_Bridge ; Exit
0686            400   
0686            401   LCD_Check_1: ; Setup
0686 B4011F     402       cjne a, #1, LCD_Check_2
0689 C0E0       403            push acc
068B 7401       403            mov a, #1
068D 14         403            dec a
068E 1205C9     403            lcall ?Set_Cursor_1 ; Select column and row
0691 D0E0       403            pop acc
0693 C083       404            push dph
0695 C082       404            push dpl
0697 C0E0       404            push acc
0699 9003A5     404            mov dptr, #String_state1
069C 1205BC     404            lcall ?Send_Constant_String
069F D0E0       404            pop acc
06A1 D082       404            pop dpl
06A3 D083       404            pop dph
06A5 020774     405       ljmp LCD_Done_Bridge
06A8            406   
06A8            407   LCD_Check_2: ; Ramp to Soak
06A8 B4021F     408       cjne a, #2, LCD_Check_3
06AB C0E0       409            push acc
06AD 7401       409            mov a, #1
06AF 14         409            dec a
06B0 1205C9     409            lcall ?Set_Cursor_1 ; Select column and row
06B3 D0E0       409            pop acc
06B5 C083       410            push dph
06B7 C082       410            push dpl
06B9 C0E0       410            push acc
06BB 9003E5     410            mov dptr, #String_state2
06BE 1205BC     410            lcall ?Send_Constant_String
06C1 D0E0       410            pop acc
06C3 D082       410            pop dpl
06C5 D083       410            pop dph
06C7 020797     411       ljmp LCD_Update_Temp_Value ; Draw Temp immediately!
06CA            412   
06CA            413   LCD_Check_3: ; Soak
06CA B4031F     414       cjne a, #3, LCD_Check_4
06CD C0E0       415            push acc
06CF 7401       415            mov a, #1
06D1 14         415            dec a
06D2 1205C9     415            lcall ?Set_Cursor_1 ; Select column and row
06D5 D0E0       415            pop acc
06D7 C083       416            push dph
06D9 C082       416            push dpl
06DB C0E0       416            push acc
06DD 9003F5     416            mov dptr, #String_state3
06E0 1205BC     416            lcall ?Send_Constant_String
06E3 D0E0       416            pop acc
06E5 D082       416            pop dpl
06E7 D083       416            pop dph
06E9 020797     417       ljmp LCD_Update_Temp_Value
06EC            418   
06EC            419   LCD_Check_4: ; Ramp to Peak
06EC B4041F     420       cjne a, #4, LCD_Check_5
06EF C0E0       421            push acc
06F1 7401       421            mov a, #1
06F3 14         421            dec a
06F4 1205C9     421            lcall ?Set_Cursor_1 ; Select column and row
06F7 D0E0       421            pop acc
06F9 C083       422            push dph
06FB C082       422            push dpl
06FD C0E0       422            push acc
06FF 900405     422            mov dptr, #String_state4
0702 1205BC     422            lcall ?Send_Constant_String
0705 D0E0       422            pop acc
0707 D082       422            pop dpl
0709 D083       422            pop dph
070B 020797     423       ljmp LCD_Update_Temp_Value
070E            424   
070E            425   LCD_Check_5: ; Reflow
070E B4051F     426       cjne a, #5, LCD_Check_6
0711 C0E0       427            push acc
0713 7401       427            mov a, #1
0715 14         427            dec a
0716 1205C9     427            lcall ?Set_Cursor_1 ; Select column and row
0719 D0E0       427            pop acc
071B C083       428            push dph
071D C082       428            push dpl
071F C0E0       428            push acc
0721 900415     428            mov dptr, #String_state5
0724 1205BC     428            lcall ?Send_Constant_String
0727 D0E0       428            pop acc
0729 D082       428            pop dpl
072B D083       428            pop dph
072D 020797     429       ljmp LCD_Update_Temp_Value
0730            430   
0730            431   LCD_Check_6: ; Cooling
0730 B4061F     432       cjne a, #6, LCD_Check_7
0733 C0E0       433            push acc
0735 7401       433            mov a, #1
0737 14         433            dec a
0738 1205C9     433            lcall ?Set_Cursor_1 ; Select column and row
073B D0E0       433            pop acc
073D C083       434            push dph
073F C082       434            push dpl
0741 C0E0       434            push acc
0743 900425     434            mov dptr, #String_state6
0746 1205BC     434            lcall ?Send_Constant_String
0749 D0E0       434            pop acc
074B D082       434            pop dpl
074D D083       434            pop dph
074F 020797     435       ljmp LCD_Update_Temp_Value
0752            436   
0752            437   LCD_Check_7: ; Done
0752            438       ; [FIX] Check distance safe logic for State 7
0752 B4071F     439       cjne a, #7, LCD_Done_Bridge ; If not 7, we are done
0755 C0E0       440            push acc
0757 7401       440            mov a, #1
0759 14         440            dec a
075A 1205C9     440            lcall ?Set_Cursor_1 ; Select column and row
075D D0E0       440            pop acc
075F C083       441            push dph
0761 C082       441            push dpl
0763 C0E0       441            push acc
0765 900435     441            mov dptr, #String_state7
0768 1205BC     441            lcall ?Send_Constant_String
076B D0E0       441            pop acc
076D D082       441            pop dpl
076F D083       441            pop dph
0771 020774     442       ljmp LCD_Done_Bridge
0774            443   
0774            444   ; Local bridge to reach the far-away LCD_Done
0774            445   LCD_Done_Bridge:
0774 0207D9     446       ljmp LCD_Done
0777            447   
0777            448   ; ==========================================
0777            449   ; PART 2: DYNAMIC VALUES (Temperature)
0777            450   ; Runs every time 'one_second_flag' is set
0777            451   ; ==========================================
0777            452   Check_Live_Update:
0777 3001FA     453       jnb one_second_flag, LCD_Done_Bridge
077A C201       454       clr one_second_flag
077C            455       
077C            456       ; Only update temp for States 2, 3, 4, 5, 6
077C E568       457       mov a, Control_FSM_state
077E B40202     458       cjne a, #2, Check_St3
0781 8014       459       sjmp LCD_Update_Temp_Value
0783            460   Check_St3:
0783 B40302     461       cjne a, #3, Check_St4
0786 800F       462       sjmp LCD_Update_Temp_Value
0788            463   Check_St4:
0788 B40402     464       cjne a, #4, Check_St5
078B 800A       465       sjmp LCD_Update_Temp_Value
078D            466   Check_St5:
078D B40502     467       cjne a, #5, Check_St6
0790 8005       468       sjmp LCD_Update_Temp_Value
0792            469   Check_St6:
0792 B40644     470       cjne a, #6, LCD_Done
0795 8000       471       sjmp LCD_Update_Temp_Value
0797            472   
0797            473   ; --- HELPER: Prints "XXX C" on Line 2 ---
0797            474   LCD_Update_Temp_Value:
0797 C0E0       475            push acc
0799 7401       475            mov a, #1
079B 14         475            dec a
079C 1205C7     475            lcall ?Set_Cursor_2 ; Select column and row
079F D0E0       475            pop acc
07A1            476       
07A1            477       ; Convert current_temp to BCD
07A1 853F32     478       mov x, current_temp
07A4 854033     479       mov x+1, current_temp+1
07A7 854134     480       mov x+2, current_temp+2
07AA 854235     481       mov x+3, current_temp+3
07AD 12002E     482       lcall hex2bcd
07B0            483       
07B0            484       ; Print Hundreds
07B0 E53B       485       mov a, bcd+1
07B2 540F       486       anl a, #0x0F
07B4 2430       487       add a, #0x30
07B6 12057F     488       lcall ?WriteData
07B9            489       
07B9            490       ; Print Tens
07B9 E53A       491       mov a, bcd+0
07BB C4         492       swap a
07BC 540F       493       anl a, #0x0F
07BE 2430       494       add a, #0x30
07C0 12057F     495       lcall ?WriteData
07C3            496       
07C3            497       ; Print Ones
07C3 E53A       498       mov a, bcd+0
07C5 540F       499       anl a, #0x0F
07C7 2430       500       add a, #0x30
07C9 12057F     501       lcall ?WriteData
07CC            502       
07CC            503       ; Print 'C'
07CC 7443       504       mov a, #'C'
07CE 12057F     505       lcall ?WriteData
07D1            506       
07D1            507       ; Clear remaining line space (prevents garbage)
07D1 7420       508       mov a, #' '
07D3 12057F     509       lcall ?WriteData
07D6 12057F     510       lcall ?WriteData
07D9            511   
07D9            512   LCD_Done:
07D9 D0E0       513       pop acc
07DB 22         514       ret
07DC            515   ;---------------------------------------------------------
07DC            516   
07DC            517   KEY1_DEB:
07DC            518   ;non-blocking state machine for KEY1 debounce
07DC E566       519       mov a, KEY1_DEB_state
07DE            520   KEY1_DEB_state0:
07DE B4000A     521       cjne a, #0, KEY1_DEB_state1
07E1 20F92D     522       jb KEY.1, KEY1_DEB_done
07E4 756400     523       mov KEY1_DEB_timer, #0
07E7 0566       524       inc KEY1_DEB_state
07E9 8026       525       sjmp KEY1_DEB_done
07EB            526   KEY1_DEB_state1:
07EB B40109     527       cjne a, #1, KEY1_DEB_state2
07EE            528       ; this is the debounce state
07EE E564       529       mov a, KEY1_DEB_timer
07F0 B4321E     530       cjne a, #50, KEY1_DEB_done ; 50 ms passed?
07F3 0566       531       inc KEY1_DEB_state
07F5 801A       532       sjmp KEY1_DEB_done  
07F7            533   KEY1_DEB_state2:
07F7 B4020C     534       cjne a, #2, KEY1_DEB_state3
07FA 20F904     535       jb KEY.1, KEY1_DEB_state2b
07FD 0566       536       inc KEY1_DEB_state
07FF 8010       537       sjmp KEY1_DEB_done  
0801            538   KEY1_DEB_state2b:
0801 756600     539       mov KEY1_DEB_state, #0
0804 800B       540       sjmp KEY1_DEB_done
0806            541   KEY1_DEB_state3:
0806 B40308     542       cjne a, #3, KEY1_DEB_done
0809 30F905     543       jnb KEY.1, KEY1_DEB_done
080C D20D       544       setb Key1_flag ; Suscesfully detected a valid KEY1 press/release
080E 756600     545       mov KEY1_DEB_state, #0  
0811            546   KEY1_DEB_done:
0811 22         547       ret
0812            548   ; ------------------------------------------------------------------------------
0812            549   ; Non-blocking FSM for the one second counter
0812            550   ;-------------------------------------------------------------------------------
0812            551   SEC_FSM:
0812 E567       552       mov a, SEC_FSM_state
0814            553   SEC_FSM_state0:
0814 B4000C     554       cjne a, #0, SEC_FSM_state1
0817 E565       555       mov a, SEC_FSM_timer
0819 B4FA4B     556       cjne a, #250, SEC_FSM_done ; 250 ms passed?
081C 756500     557       mov SEC_FSM_timer, #0
081F 0567       558       inc SEC_FSM_state
0821 8044       559       sjmp SEC_FSM_done
0823            560   SEC_FSM_state1: 
0823 B4010E     561       cjne a, #1, SEC_FSM_state2
0826 D2E9       562       setb LEDRA.1
0828 E565       563       mov a, SEC_FSM_timer
082A B4FA3A     564       cjne a, #250, SEC_FSM_done ; 250 ms passed?
082D 756500     565       mov SEC_FSM_timer, #0
0830 0567       566       inc SEC_FSM_state
0832 8033       567       sjmp SEC_FSM_done
0834            568   SEC_FSM_state2: 
0834 B4020E     569       cjne a, #2, SEC_FSM_state3
0837 D2EA       570       setb LEDRA.2
0839 E565       571       mov a, SEC_FSM_timer
083B B4FA29     572       cjne a, #250, SEC_FSM_done ; 250 ms passed?
083E 756500     573       mov SEC_FSM_timer, #0
0841 0567       574       inc SEC_FSM_state
0843 8022       575       sjmp SEC_FSM_done
0845            576   SEC_FSM_state3: 
0845 B4031F     577       cjne a, #3, SEC_FSM_done
0848 D2EB       578       setb LEDRA.3
084A E565       579       mov a, SEC_FSM_timer
084C B4FA18     580       cjne a, #250, SEC_FSM_done ; 250 ms passed?
084F 756500     581       mov SEC_FSM_timer, #0
0852 756700     582       mov SEC_FSM_state, #0
0855            583       
0855            584       ; --- 1 Second has passed! ---
0855 D201       585       setb one_second_flag
0857            586       
0857 E530       587       mov a, current_time_sec
0859 B43B07     588       cjne a, #59, IncCurrentTimeSec 
085C            589       
085C            590       ; --- FIX: 59s -> 0s AND Increment Minute ---
085C 753000     591       mov current_time_sec, #0
085F 0531       592       inc current_time_minute    ; <--- YOU WERE MISSING THIS!
0861            593       ; -------------------------------------------
0861            594       
0861 8004       595       sjmp SEC_FSM_done
0863            596   
0863            597   IncCurrentTimeSec:
0863 0530       598       inc current_time_sec
0865 B2E8       599       cpl LEDRA.0 
0867            600   SEC_FSM_done:
0867 22         601       ret
0868            602   ;-------------------------------------------------------------------------------
0868            603   ; PWM
0868            604   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0868            605   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0868            606   ; ------------------------------------------------------------------------------
0868            607   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0868 100202     608       jbc one_ms_pwm_flag, pwm_wave_generator
086B 8071       609       sjmp end_pwm_generator
086D            610   
086D            611   pwm_wave_generator:
086D C200       612       clr mf
086F            613       ; move pwm counter value into x for comparison purpose
086F 856032     614       mov x, pwm_counter
0872 856133     615       mov x+1, pwm_counter+1
0875 856234     616       mov x+2, pwm_counter+2
0878 856335     617       mov x+3, pwm_counter+3
087B            618   
087B 7536DB     619            mov y+0, #low (PWM_PERIOD % 0x10000) 
087E 753705     619            mov y+1, #high(PWM_PERIOD % 0x10000) 
0881 753800     619            mov y+2, #low (PWM_PERIOD / 0x10000) 
0884 753900     619            mov y+3, #high(PWM_PERIOD / 0x10000) 
0887            620   
0887            621       ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
0887            622       ; increase x by 1
0887 120152     623       lcall x_eq_y 
088A 20001D     624       jb mf, wrap_pwm_counter
088D            625       ; x not equal 1499, increment by 1
088D 753601     626            mov y+0, #low (1 % 0x10000) 
0890 753700     626            mov y+1, #high(1 % 0x10000) 
0893 753800     626            mov y+2, #low (1 / 0x10000) 
0896 753900     626            mov y+3, #high(1 / 0x10000) 
0899 1200D3     627       lcall add32
089C            628       ; update pwm_counter
089C 853260     629       mov pwm_counter, x
089F 853361     630       mov pwm_counter+1, x+1
08A2 853462     631       mov pwm_counter+2, x+2
08A5 853563     632       mov pwm_counter+3, x+3
08A8 8018       633       sjmp set_pwm
08AA            634   
08AA            635   wrap_pwm_counter:
08AA            636       ; x equal 1499, wrap to 0
08AA 753200     637            mov x+0, #low (0 % 0x10000) 
08AD 753300     637            mov x+1, #high(0 % 0x10000) 
08B0 753400     637            mov x+2, #low (0 / 0x10000) 
08B3 753500     637            mov x+3, #high(0 / 0x10000) 
08B6 853260     638       mov pwm_counter, x
08B9 853361     639       mov pwm_counter+1, x+1
08BC 853462     640       mov pwm_counter+2, x+2
08BF 853563     641       mov pwm_counter+3, x+3
08C2            642   
08C2            643   set_pwm:
08C2            644       ; compare with power_output, if pwm counter smaller than power_output, 
08C2            645       ; set pwm pin high; else set pwm pin low load y with power output value
08C2 855C36     646       mov y, power_output
08C5 855D37     647       mov y+1, power_output+1
08C8 855E38     648       mov y+2, power_output+2
08CB 855F39     649       mov y+3, power_output+3
08CE            650   
08CE            651       ; compare x(pwm counter) with y(power output)
08CE 12011A     652       lcall x_lt_y
08D1 200006     653       jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
08D4            654       ;output set pwm pin low if pwm counter greater than power output
08D4 C293       655       clr PWM_OUT
08D6 C2EC       656       clr LEDRA.4
08D8 8004       657       sjmp end_pwm_generator
08DA            658   
08DA            659   set_pwm_high:
08DA D293       660       setb PWM_OUT
08DC D2EC       661       setb LEDRA.4
08DE            662   
08DE            663   end_pwm_generator:
08DE 22         664       ret
08DF            665   
08DF            666   ;-------------------------------------------------------------------------------;
08DF            667   ; Temp_Compare
08DF            668   ; Checks if we have reached the user's target temperatures.
08DF            669   ; Sets 'soak_temp_reached' if current_temp >= soak_temp
08DF            670   ; Sets 'reflow_temp_reached' if current_temp >= reflow_temp
08DF            671   ;-------------------------------------------------------------------------------;
08DF            672   Temp_Compare:
08DF            673       ; Reset flags initially
08DF C203       674       clr soak_temp_reached
08E1 C204       675       clr reflow_temp_reached
08E3            676   
08E3 C0E0       677       push acc
08E5 C0D0       678       push psw
08E7 C000       679       push AR0
08E9 C001       680       push AR1
08EB C002       681       push AR2
08ED            682       
08ED            683       ; --- 1. CHECK SOAK TEMP ---
08ED            684       ; Copy current_temp to X
08ED 783F       685       mov R0, #current_temp
08EF 7932       686       mov R1, #x
08F1 120965     687       lcall Copy4_Bytes_R0_to_R1
08F4            688   
08F4            689       ; Copy soak_temp to Y
08F4 7843       690       mov R0, #soak_temp
08F6 7936       691       mov R1, #y
08F8 120965     692       lcall Copy4_Bytes_R0_to_R1
08FB            693   
08FB            694       ; Compare: Is X (Current) < Y (Target)?
08FB 12011A     695       lcall x_lt_y
08FE 200002     696       jb mf, Check_Reflow_Threshold ; If Current < Target, jump (Flag stays 0)
0901            697       
0901            698       ; If we are here, Current >= Target
0901 D203       699       setb soak_temp_reached
0903            700   
0903            701   Check_Reflow_Threshold:
0903            702       ; --- 2. CHECK REFLOW TEMP ---
0903            703       ; Copy current_temp to X (Need to reload X because math32 destroys it)
0903 783F       704       mov R0, #current_temp
0905 7932       705       mov R1, #x
0907 120965     706       lcall Copy4_Bytes_R0_to_R1
090A            707   
090A            708       ; Copy reflow_temp to Y
090A 7847       709       mov R0, #reflow_temp
090C 7936       710       mov R1, #y
090E 120965     711       lcall Copy4_Bytes_R0_to_R1
0911            712   
0911            713       ; Compare
0911 12011A     714       lcall x_lt_y
0914 200002     715       jb mf, Temp_Compare_Done
0917            716       
0917            717       ; If Current >= Target
0917 D204       718       setb reflow_temp_reached
0919            719   
0919            720   Temp_Compare_Done:
0919 D002       721       pop AR2
091B D001       722       pop AR1
091D D000       723       pop AR0
091F D0D0       724       pop psw
0921 D0E0       725       pop acc
0923 22         726       ret
0924            727   ;-------------------------------------------------------------------------------;
0924            728   ; Time_Compare
0924            729   ;
0924            730   ; PURPOSE:
0924            731   ;   Compare the elapsed time against soak and reflow
0924            732   ;   time limits.
0924            733   ;
0924            734   ; BEHAVIOR:
0924            735   ;   - If current_time >= soak_time   if soak_time_reached    = 1
0924            736   ;   - If current_time >= reflow_time if reflow_time_reached = 1
0924            737   ;
0924            738   ; NOTES:
0924            739   ;   - Time values are treated as 32-bit UNSIGNED numbers
0924            740   ;     (e.g., milliseconds or seconds).
0924            741   ;   - Uses the SAME compare logic as Temp_Compare.
0924            742   ;   - This routine ONLY SETS flags.
0924            743   ;
0924            744   ; EXPECTED VARIABLES:
0924            745   ;   current_time[4], soak_time[4], reflow_time[4]
0924            746   ;   x[4], y[4]
0924            747   ;   mf, soak_time_reached, reflow_time_reached
0924            748   ;-------------------------------------------------------------------------------;
0924            749   Time_Compare:
0924 C0E0       750       push acc
0926 C0D0       751       push psw
0928 C000       752       push AR0
092A C001       753       push AR1
092C C002       754       push AR2
092E            755   
092E            756   ; Check: current_time >= soak_time ?
092E            757       ; Copy current_time of x
092E 7850       758       mov  R0, #current_time
0930 7932       759       mov  R1, #x
0932 120965     760       lcall Copy4_Bytes_R0_to_R1
0935            761   
0935            762       ; Copy soak_time of y
0935 7854       763       mov  R0, #soak_time
0937 7936       764       mov  R1, #y
0939 120965     765       lcall Copy4_Bytes_R0_to_R1
093C            766   
093C            767       ; Compare elapsed time vs soak time
093C 12011A     768       lcall x_lt_y
093F 200002     769       jb   mf, Time_Soak_NotReached
0942 D206       770       setb soak_time_reached
0944            771   
0944            772   ; Check: current_time >= reflow_time ?
0944            773   Time_Soak_NotReached:
0944            774       ; Copy current_time of x
0944 7850       775       mov  R0, #current_time
0946 7932       776       mov  R1, #x
0948 120965     777       lcall Copy4_Bytes_R0_to_R1
094B            778   
094B            779       ; Copy reflow_time of y
094B 7858       780       mov  R0, #reflow_time
094D 7936       781       mov  R1, #y
094F 120965     782       lcall Copy4_Bytes_R0_to_R1
0952            783   
0952            784       ; Compare elapsed time vs reflow time
0952 12011A     785       lcall x_lt_y
0955 200002     786       jb   mf, Time_Reflow_NotReached
0958 D207       787       setb reflow_time_reached
095A            788   
095A            789   Time_Reflow_NotReached:
095A D002       790       pop  AR2
095C D001       791       pop  AR1
095E D000       792       pop  AR0
0960 D0D0       793       pop  psw
0962 D0E0       794       pop  acc
0964 22         795       ret
0965            796   
0965            797   ;-------------------------------------------------------------------------------;
0965            798   ; Copy4_Bytes_R0_to_R1
0965            799   ;
0965            800   ; PURPOSE:
0965            801   ;   Utility routine to copy a 32-bit value (4 bytes)
0965            802   ;   from one memory location to another.
0965            803   ;
0965            804   ; INPUTS:
0965            805   ;   R0 st source address
0965            806   ;   R1 at destination address
0965            807   ;
0965            808   ; USES:
0965            809   ;   R2 as loop counter
0965            810   ;
0965            811   ; EXAMPLE:
0965            812   ;   mov R0, #current_temp
0965            813   ;   mov R1, #x
0965            814   ;   lcall Copy4_Bytes_R0_to_R1
0965            815   ;-------------------------------------------------------------------------------;
0965            816   Copy4_Bytes_R0_to_R1:
0965 7A04       817       mov  R2, #4
0967            818   Copy4_Loop:
0967 E6         819       mov  a, @R0
0968 F7         820       mov  @R1, a
0969 08         821       inc  R0
096A 09         822       inc  R1
096B DAFA       823       djnz R2, Copy4_Loop
096D 22         824       ret
096E            825   
096E            826   ;-------------------------------------------------------------------------------;
096E            827   ; Abort condition safety check Temperature time
096E            828   ;
096E            829   ; PURPOSE:
096E            830   ;   Automatic cycle termination on error:
096E            831   ;   Abort if oven fails to reach at least 50C in first 60s.
096E            832   ;
096E            833   ; TRIP CONDITION:
096E            834   ;   if (current_time >= 60s) AND (current_temp < 50C)
096E            835   ;       -> set tc_missing_abort
096E            836   ;       -> set stop_signal
096E            837   ;
096E            838   ; ASSUMPTIONS:
096E            839   ;   - current_time is in SECONDS (32-bit, little-endian)
096E            840   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
096E            841   ;
096E            842   ;   the Load_Y constants accordingly.
096E            843   ;-------------------------------------------------------------------------------;
096E            844   Safety_Check_TC:
096E C0E0       845       push acc
0970 C0D0       846       push psw
0972 C000       847       push AR0
0974 C001       848       push AR1
0976 C002       849       push AR2
0978            850   
0978            851       ; ---------------------------------------------------------
0978            852       ; [FIX] GATEKEEPER: IGNORE UNLESS IN STATE 2 (RAMP TO SOAK)
0978            853       ; ---------------------------------------------------------
0978 E568       854       mov a, Control_FSM_state
097A B40202     855       cjne a, #2, Safety_TC_Exit_Bridge ; If State != 2, skip everything
097D 8003       856       sjmp Safety_Logic_Proceed         ; If State == 2, do the check
097F            857   
097F            858       Safety_TC_Exit_Bridge:
097F 0209CD     859           ljmp Safety_TC_Done               ; Jump to the end
0982            860   
0982            861       Safety_Logic_Proceed:
0982            862           ; If already aborted or startup window closed, do nothing
0982 200E48     863           jb   tc_missing_abort, Safety_TC_Done
0985 300F45     864           jnb  tc_startup_window, Safety_TC_Done
0988            865   
0988            866       ; Check: current_time >= 60 ?
0988 7850       867       mov  R0, #current_time
098A 7932       868       mov  R1, #x
098C 120965     869       lcall Copy4_Bytes_R0_to_R1
098F            870   
098F 75363C     871            mov y+0, #low (60 % 0x10000) 
0992 753700     871            mov y+1, #high(60 % 0x10000) 
0995 753800     871            mov y+2, #low (60 / 0x10000) 
0998 753900     871            mov y+3, #high(60 / 0x10000) 
099B 12011A     872       lcall x_lt_y
099E 2000DE     873       jb   mf, Safety_TC_Exit_Bridge        ; still < 60s  keep waiting
09A1            874   
09A1            875       ; We reached 60s: close the startup window so it won't re-check later
09A1 C20F       876       clr  tc_startup_window
09A3            877   
09A3            878       ; Now check: current_temp < 50 ?
09A3 783F       879       mov  R0, #current_temp
09A5 7932       880       mov  R1, #x
09A7 120965     881       lcall Copy4_Bytes_R0_to_R1
09AA            882   
09AA 753632     883            mov y+0, #low (50 % 0x10000) 
09AD 753700     883            mov y+1, #high(50 % 0x10000) 
09B0 753800     883            mov y+2, #low (50 / 0x10000) 
09B3 753900     883            mov y+3, #high(50 / 0x10000) 
09B6 12011A     884       lcall x_lt_y
09B9 3000C3     885       jnb  mf, Safety_TC_Exit_Bridge        ; temp >= 50  pass
09BC            886   
09BC            887       ; FAIL: at 60s, still below 50C  abort
09BC C293       888       clr  PWM_OUT
09BE D20E       889       setb tc_missing_abort
09C0 D209       890       setb stop_signal
09C2 1209E2     891            lcall Beep_Ten
09C5            892       ; 3. Force FSM to State 0 (Welcome)
09C5 756800     893       mov Control_FSM_state, #0
09C8            894       
09C8            895       ; 4. Force UI to State 0 (Home Screen)
09C8 756900     896       mov Current_State, #0
09CB            897       
09CB            898       ; 5. Trigger Screen Refresh
09CB D20C       899       setb state_change_signal ; Tell loop to redraw "Welcome"
09CD            900   
09CD            901   Safety_TC_Done:
09CD D002       902       pop  AR2
09CF D001       903       pop  AR1
09D1 D000       904       pop  AR0
09D3 D0D0       905       pop  psw
09D5 D0E0       906       pop  acc
09D7 22         907       ret
09D8            908   
09D8            909   ; ============================================================
09D8            910   ; BUZZER STARTUP FUNCTIONS
09D8            911   ; ============================================================
09D8            912   
09D8            913   Beep_Once:
09D8 756B01     914       mov beep_count, #1
09DB 800A       915       sjmp Beep_Start
09DD            916   
09DD            917   Beep_Five:
09DD 756B05     918       mov beep_count, #5
09E0 8005       919       sjmp Beep_Start
09E2            920   
09E2            921   Beep_Ten:
09E2 756B0A     922       mov beep_count, #10
09E5 8000       923       sjmp Beep_Start      ; [FIX] Added explicit jump for safety
09E7            924   
09E7            925   Beep_Start:
09E7 C28C       926       clr TR0              ; [FIX] Stop timer briefly to reset cleanly
09E9 756C01     927       mov beep_state, #1   ; Set State to ON
09EC 756D00     928       mov beep_tmr, #0     ; Reset Timer High Byte
09EF 756E00     929       mov beep_tmr+1, #0   ; Reset Timer Low Byte
09F2 D2A9       930       setb ET0             ; [FIX] Ensure Interrupt is enabled
09F4 D28C       931       setb TR0             ; START the 2kHz tone
09F6 22         932       ret
09F7            933   ;============================================================
09F7            934   
09F7            935   ;============================================================
09F7            936   ; Buzzer beep Task 
09F7            937   ; Purpose: beeps, holds, stop
09F7            938   ; Buzzer task:
09F7            939   ; Beep once when state changes
09F7            940   ; Beep five times if finished
09F7            941   ; Beep ten times if meets error
09F7            942   ;============================================================
09F7            943   
09F7            944   Beep_Task:
09F7 301335     945       jnb one_ms_beep_flag, Beep_Done
09FA C213       946       clr one_ms_beep_flag
09FC            947   
09FC E56C       948       mov a, beep_state
09FE 602F       949       jz Beep_Done
0A00            950   
0A00            951   ; ---- increment 16-bit timer ----
0A00 056D       952       inc beep_tmr
0A02 E56D       953       mov a, beep_tmr
0A04 7002       954       jnz Beep_Check
0A06 056E       955       inc beep_tmr+1
0A08            956   
0A08            957   Beep_Check:
0A08            958       ; [FIX] FUZZY TIMER CHECK
0A08            959       ; Check if High Byte is non-zero (Time >= 256ms)
0A08 E56E       960       mov a, beep_tmr+1
0A0A 6023       961       jz Beep_Done        ; If 0, keep beeping
0A0C            962   
0A0C            963       ; --- Time Limit Reached ---
0A0C 756D00     964       mov beep_tmr, #0    ; Reset timer
0A0F 756E00     965       mov beep_tmr+1, #0
0A12            966   
0A12 E56C       967       mov a, beep_state
0A14 B40106     968       cjne a, #1, Beep_Off_State
0A17            969   
0A17            970       ; State was 1 (ON) -> Turn OFF
0A17 C28C       971       clr TR0             ; Hardware Silence
0A19 756C02     972       mov beep_state, #2  ; Set State to OFF (Pause)
0A1C 22         973       ret
0A1D            974   
0A1D            975   Beep_Off_State:
0A1D            976   ; ---- OFF finished -> decrement count / next ON ----
0A1D 156B       977       dec beep_count
0A1F E56B       978       mov a, beep_count
0A21 6006       979       jz  Beep_Stop
0A23            980   
0A23 756C01     981       mov beep_state, #1
0A26 D28C       982       setb TR0
0A28 22         983       ret
0A29            984   
0A29            985   Beep_Stop:
0A29 C28C       986       clr TR0
0A2B 756C00     987       mov beep_state, #0
0A2E 22         988       ret
0A2F            989   
0A2F            990   Beep_Done:
0A2F 22         991       ret
0A30            992   ;==================================================================
0A30            993   
0A30            994   ;-------------------------------------------------------------------------------;
0A30            995   ; Main Control FSM for the entire process
0A30            996   ;-------------------------------------------------------------------------------;
0A30            997   ;-------------------------------------------------------------------------------;
0A30            998   ; FSM LOGIC (Button Logic Fixed)
0A30            999   ;-------------------------------------------------------------------------------;
0A30           1000   Control_FSM:
0A30 E568      1001       mov a, Control_FSM_state
0A32 8005      1002       sjmp Control_FSM_state0
0A34           1003   
0A34           1004   Control_FSM_state0_a:
0A34 756800    1005       mov Control_FSM_state, #0
0A37 D20C      1006       setb state_change_signal
0A39           1007            
0A39           1008   Control_FSM_state0:
0A39 B40015    1009       cjne a, #0, Control_FSM_state1
0A3C 209005    1010       jb P1.0, Control_FSM_done_bridge ; If Button High (Not Pressed), Exit
0A3F 120F6D    1011       lcall Wait_For_P1_0_Release      ; If Low (Pressed), Wait & Proceed
0A42 8001      1012       sjmp Control_FSM_state1_a  
0A44           1013       
0A44           1014   Control_FSM_done_bridge:
0A44 22        1015       ret
0A45           1016   
0A45           1017   Control_FSM_state1_a:
0A45 0568      1018       inc Control_FSM_state
0A47 756900    1019       mov Current_State, #0
0A4A 120E4B    1020       lcall Update_Screen_Full 
0A4D D20C      1021       setb state_change_signal
0A4F E568      1022       mov a, Control_FSM_state
0A51           1023       
0A51           1024   Control_FSM_state1:
0A51 B40127    1025       cjne a, #1, Control_FSM_state2
0A54 120C83    1026       lcall Check_Buttons 
0A57 120CCF    1027       lcall Check_Keypad
0A5A           1028       
0A5A           1029       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
0A5A 209008    1030       jb P1.0, Control_FSM_state1_ret
0A5D           1031       
0A5D           1032       ; If we get here, Button is LOW (Pressed)
0A5D 120F6D    1033       lcall Wait_For_P1_0_Release
0A60 120C07    1034       lcall Update_FSM_Variables
0A63 8001      1035       sjmp Control_FSM_state2_a
0A65           1036   Control_FSM_state1_ret:
0A65 22        1037       ret
0A66           1038   
0A66           1039   ; --- STATE 2: RAMP TO SOAK ---
0A66           1040   Control_FSM_state2_a:
0A66 0568      1041       inc Control_FSM_state
0A68 E568      1042       mov a, Control_FSM_state   ; [FIX] RELOAD 'A' so it matches the new state!
0A6A D20C      1043       setb state_change_signal
0A6C 1209D8    1044       lcall Beep_Once
0A6F           1045   
0A6F D20F      1046       setb tc_startup_window    ; OPEN the safety window
0A71 C20E      1047       clr tc_missing_abort      ; Clear any previous aborts
0A73 753000    1048       mov current_time_sec, #0  ; Reset Seconds to 0
0A76 753100    1049       mov current_time_minute, #0 ; Reset Minutes to 0
0A79           1050       
0A79           1051       ; [FIX] CLEAR FLAG ON ENTRY
0A79           1052       ; Force the system to wait for at least one fresh temp reading
0A79           1053       ; before deciding we are done.
0A79 C203      1054       clr soak_temp_reached      
0A7B           1055   
0A7B           1056   Control_FSM_state2:
0A7B B4021F    1057       cjne a, #2, Control_FSM_state3
0A7E 301205    1058       jnb PB2_flag, State2_Check
0A81 C212      1059       clr PB2_flag
0A83 020AEE    1060       ljmp Control_FSM_state6_a ; Pause
0A86           1061   
0A86           1062   State2_Check:
0A86 300313    1063       jnb soak_temp_reached, State2_Ret
0A89           1064       
0A89           1065       ; --- We reached Temp! Move to State 3 ---
0A89 C203      1066       clr soak_temp_reached
0A8B 0568      1067       inc Control_FSM_state
0A8D           1068       
0A8D           1069       ; [FIX] RELOAD 'A' (Good practice)
0A8D E568      1070       mov a, Control_FSM_state   
0A8F           1071       
0A8F D20C      1072       setb state_change_signal
0A91 1209D8    1073       lcall Beep_Once
0A94           1074       
0A94 753000    1075       mov current_time_sec, #0
0A97 753100    1076       mov current_time_minute, #0
0A9A           1077       
0A9A           1078       ; Ensure we start State 3 fresh
0A9A C206      1079       clr soak_time_reached 
0A9C           1080   
0A9C           1081   State2_Ret:
0A9C 22        1082       ret
0A9D           1083   
0A9D           1084   ; --- STATE 3: SOAK PHASE ---
0A9D           1085   Control_FSM_state3:
0A9D B40315    1086       cjne a, #3, Control_FSM_state4
0AA0 301205    1087       jnb PB2_flag, State3_Check
0AA3 C212      1088       clr PB2_flag
0AA5 020AEE    1089       ljmp Control_FSM_state6_a
0AA8           1090   State3_Check:
0AA8 300609    1091       jnb soak_time_reached, State3_Ret
0AAB C206      1092       clr soak_time_reached
0AAD 0568      1093       inc Control_FSM_state      
0AAF D20C      1094       setb state_change_signal 
0AB1 1209D8    1095            lcall Beep_Once
0AB4           1096   State3_Ret:
0AB4 22        1097       ret
0AB5           1098   
0AB5           1099   ; --- STATE 4: RAMP TO PEAK ---
0AB5           1100   Control_FSM_state4:
0AB5 B4041D    1101       cjne a, #4, Control_FSM_state5
0AB8 301205    1102       jnb PB2_flag, State4_Check
0ABB C212      1103       clr PB2_flag
0ABD 020AEE    1104       ljmp Control_FSM_state6_a
0AC0           1105   State4_Check:
0AC0 300411    1106       jnb reflow_temp_reached, State4_Ret
0AC3 C204      1107       clr reflow_temp_reached
0AC5 0568      1108       inc Control_FSM_state
0AC7 D20C      1109       setb state_change_signal
0AC9 1209D8    1110            lcall Beep_Once
0ACC 753000    1111       mov current_time_sec, #0
0ACF 753100    1112       mov current_time_minute, #0
0AD2           1113       ; --- ADD THIS LINE ---
0AD2 C207      1114       clr reflow_time_reached ; Kill the ghost flag
0AD4           1115       ; ---------------------
0AD4           1116   State4_Ret:
0AD4 22        1117       ret
0AD5           1118   
0AD5           1119   ; --- STATE 5: REFLOW PHASE ---
0AD5           1120   Control_FSM_state5:
0AD5 B40502    1121       cjne a, #5, Control_FSM_state6_trampoline
0AD8 8003      1122       sjmp State5_Logic
0ADA           1123   Control_FSM_state6_trampoline:
0ADA 020AF5    1124       ljmp Control_FSM_state6
0ADD           1125   
0ADD           1126   State5_Logic:
0ADD 301205    1127       jnb PB2_flag, State5_Check
0AE0 C212      1128       clr PB2_flag
0AE2 020AEE    1129       ljmp Control_FSM_state6_a
0AE5           1130   State5_Check:
0AE5 300705    1131       jnb reflow_time_reached, State5_Ret
0AE8 C207      1132       clr reflow_time_reached
0AEA 020AEE    1133       ljmp Control_FSM_state6_a
0AED           1134   State5_Ret:
0AED 22        1135       ret
0AEE           1136   
0AEE           1137   ; --- STATE 6: COOLING ---
0AEE           1138   Control_FSM_state6_a:
0AEE 0568      1139       inc Control_FSM_state
0AF0 D20C      1140       setb state_change_signal
0AF2 1209DD    1141            lcall Beep_Five
0AF5           1142   Control_FSM_state6:
0AF5 B4060A    1143       cjne a, #6, Control_FSM_state7
0AF8           1144       ; Wait for Cooling Temp Reached
0AF8 300506    1145       jnb cooling_temp_reached, State6_Ret
0AFB C205      1146       clr cooling_temp_reached
0AFD 0568      1147       inc Control_FSM_state
0AFF D20C      1148       setb state_change_signal
0B01           1149   State6_Ret:
0B01 22        1150       ret
0B02           1151   
0B02           1152   ; --- STATE 7: DONE ---
0B02           1153   Control_FSM_state7:
0B02 B40711    1154       cjne a, #7, Control_FSM_done
0B05           1155       
0B05           1156       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
0B05 201009    1157       jb PB0_flag, Control_FSM_Reset_Logic ; Wait, PB0_flag is software flag?
0B08           1158       
0B08           1159       ; Let's assume you meant the physical button P1.0 like State 0
0B08 20900B    1160       jb P1.0, Control_FSM_done
0B0B           1161       
0B0B 120F6D    1162       lcall Wait_For_P1_0_Release
0B0E 020A34    1163       ljmp Control_FSM_state0_a
0B11           1164   
0B11           1165   Control_FSM_Reset_Logic:
0B11           1166       ; If using PB0_flag from ISR, handle here
0B11 C210      1167       clr PB0_flag
0B13 020A34    1168       ljmp Control_FSM_state0_a
0B16           1169   
0B16           1170   Control_FSM_done:
0B16 22        1171       ret
0B17           1172   ;-------------------------------------------------------------------------------;
0B17           1173   ;         Main program.          
0B17           1174   ;-------------------------------------------------------------------------------;
0B17           1175   main:
0B17           1176   
0B17           1177       ; --------------------------------------------------------
0B17           1178       ; 1. SAFETY SHUTDOWN
0B17           1179       ; --------------------------------------------------------
0B17 C2AF      1180       clr EA              ; FORCE Interrupts OFF immediately
0B19 7581C0    1181       mov SP, #0xC0       ; Reset Stack Pointer to safe location
0B1C           1182       
0B1C           1183       ; --------------------------------------------------------
0B1C           1184       ; 2. THE "DIRTY DELAY" (Fixes Reset Garbage)
0B1C           1185       ; We burn ~100ms here using a raw loop. 
0B1C           1186       ; We cannot use timers yet because they aren't initialized.
0B1C           1187       ; --------------------------------------------------------
0B1C 78FA      1188       mov R0, #250
0B1E           1189   Reset_Delay_Outer:
0B1E 79FF      1190       mov R1, #255
0B20           1191   Reset_Delay_Inner:
0B20 D9FE      1192       djnz R1, Reset_Delay_Inner
0B22 D8FA      1193       djnz R0, Reset_Delay_Outer
0B24           1194       ; --------------------------------------------------------
0B24           1195   
0B24           1196       ; ... NOW continue with your normal Port Configuration ...
0B24           1197       
0B24           1198       ; --- PORT CONFIGURATION ---
0B24 759AAA    1199       mov P0MOD, #0xAA
0B27           1200   
0B27           1201       ; P1: Mixed usage 
0B27           1202       ; P1.7(LCD_RS), P1.6(Row3), P1.5(Sound), P1.4(Row2)
0B27           1203       ; P1.3(PWM), P1.2(Row1), P1.1(LCD_E) -> All Outputs
0B27           1204       ; P1.0 (Unused/RX) -> Input
0B27           1205       ; Binary: 11111110 -> Hex: 0xFE
0B27 759BFE    1206       mov P1MOD, #0xFE
0B2A           1207   
0B2A           1208       ; P2: Row4(Out), Cols(In)
0B2A           1209       ; P2.0 (Row4) is Out (1). P2.2, P2.4, P2.6 (Cols) are In (0).
0B2A           1210       ; Binary: 00000001 -> Hex: 0x01
0B2A 759C01    1211       mov P2MOD, #0x01
0B2D           1212   
0B2D           1213       ; P3: Col4(In)
0B2D           1214       ; P3.0 (Col4) is In (0).
0B2D 759D00    1215       mov P3MOD, #0x00
0B30           1216       ; Turn off all the LEDs
0B30 75E800    1217       mov LEDRA, #0 ; LEDRA is bit addressable
0B33 759500    1218       mov LEDRB, #0 ; LEDRB is NOT bit addresable
0B36           1219   
0B36           1220       ; Enable Global interrupts
0B36 D2AF      1221       setb EA  
0B38           1222   
0B38           1223       ; FSM initial states
0B38 756600    1224       mov KEY1_DEB_state, #0
0B3B 756700    1225       mov SEC_FSM_state, #0
0B3E 756800    1226       mov Control_FSM_state, #0
0B41 756900    1227       mov Current_State, #0
0B44           1228       
0B44           1229       ; FSM timers initialization
0B44 756400    1230       mov KEY1_DEB_timer, #0
0B47 756500    1231       mov SEC_FSM_timer, #0
0B4A           1232       ; time counters initialization
0B4A 753000    1233       mov current_time_sec, #0
0B4D 753100    1234       mov current_time_minute, #0
0B50           1235       ; Initialize counter to zero
0B50 756000    1236       mov pwm_counter, #0
0B53 756100    1237       mov pwm_counter+1, #0
0B56 756200    1238       mov pwm_counter+2, #0
0B59 756300    1239       mov pwm_counter+3, #0
0B5C           1240       ; Initialize power output
0B5C 755F00    1241       mov power_output+3, #0
0B5F 755E00    1242       mov power_output+2, #0
0B62 755D02    1243       mov power_output+1, #02H
0B65 755CEE    1244       mov power_output, #0EEH ; (initilize to 750 for testing)
0B68           1245   
0B68           1246       ; Clear all the flags
0B68 C20E      1247       clr  tc_missing_abort
0B6A C209      1248       clr  stop_signal
0B6C C210      1249       clr PB0_flag
0B6E C211      1250       clr PB1_flag
0B70 C212      1251       clr PB2_flag
0B72 C201      1252       clr one_second_flag
0B74 C20B      1253       clr config_finish_signal
0B76 C203      1254       clr soak_temp_reached
0B78 C206      1255       clr soak_time_reached
0B7A C204      1256       clr reflow_temp_reached
0B7C C207      1257       clr reflow_time_reached
0B7E C205      1258       clr cooling_temp_reached
0B80 C20C      1259       clr state_change_signal
0B82           1260       
0B82 D20C      1261       setb state_change_signal
0B84           1262   
0B84           1263       ; Set bit
0B84 D20F      1264       setb tc_startup_window
0B86           1265   
0B86           1266       ; --------------------------------------
0B86           1267       ; [FIX] ADD THIS BLOCK TO STOP STARTUP BEEP
0B86           1268       ; --------------------------------------
0B86 756C00    1269       mov beep_state, #0
0B89 756B00    1270       mov beep_count, #0
0B8C 756D00    1271       mov beep_tmr, #0
0B8F 756E00    1272       mov beep_tmr+1, #0
0B92 C213      1273       clr one_ms_beep_flag
0B94 C28C      1274       clr TR0              ; Force buzzer hardware OFF
0B96           1275       ; --------------------------------------
0B96           1276   
0B96           1277   
0B96 120456    1278       lcall Timer0_Init
0B99 1204BE    1279       lcall Timer2_Init
0B9C 120589    1280       lcall ELCD_4BIT
0B9F           1281       ;----- Two new lines I added to initialize the UI
0B9F 120DF8    1282       lcall Init_All_Buffers
0BA2 120E4B    1283       lcall Update_Screen_Full
0BA5           1284       ;-----
0BA5 120470    1285       lcall Initialize_Serial_Port
0BA8           1286   ;-------------------------------------------------------------------------------;
0BA8           1287   ; while(1) loop
0BA8           1288   ;-------------------------------------------------------------------------------;
0BA8           1289   loop:
0BA8           1290       ; Check the FSM for KEY1 debounce
0BA8 1207DC    1291       lcall KEY1_DEB
0BAB           1292       
0BAB           1293       ; Added to take temp readings
0BAB 120F71    1294       lcall Read_Thermocouple
0BAE           1295       
0BAE           1296       ; 1. Check if we reached temp (Observer)
0BAE 1208DF    1297       lcall Temp_Compare
0BB1           1298       
0BB1           1299       ; 2. Decide heater power based on flags (Driver)
0BB1 121003    1300       lcall Power_Control
0BB4           1301       
0BB4           1302       ; 3. [FIX] Calculate Total Seconds (Minutes * 60 + Seconds)
0BB4           1303       ; ---------------------------------------------------------
0BB4           1304       ; Load Minutes into X
0BB4 853132    1305       mov x+0, current_time_minute
0BB7 753300    1306       mov x+1, #0
0BBA 753400    1307       mov x+2, #0
0BBD 753500    1308       mov x+3, #0
0BC0           1309       
0BC0           1310       ; Multiply by 60 (Minutes -> Seconds)
0BC0 75363C    1311            mov y+0, #low (60 % 0x10000) 
0BC3 753700    1311            mov y+1, #high(60 % 0x10000) 
0BC6 753800    1311            mov y+2, #low (60 / 0x10000) 
0BC9 753900    1311            mov y+3, #high(60 / 0x10000) 
0BCC 12018C    1312       lcall mul32
0BCF           1313       
0BCF           1314       ; Load Seconds into Y
0BCF 853036    1315       mov y+0, current_time_sec
0BD2 753700    1316       mov y+1, #0
0BD5 753800    1317       mov y+2, #0
0BD8 753900    1318       mov y+3, #0
0BDB           1319       
0BDB           1320       ; Add them together (Total Seconds = X + Y)
0BDB 1200D3    1321       lcall add32
0BDE           1322       
0BDE           1323       ; Store Final Result into 'current_time'
0BDE 853250    1324       mov current_time+0, x+0
0BE1 853351    1325       mov current_time+1, x+1
0BE4 853452    1326       mov current_time+2, x+2
0BE7 853553    1327       mov current_time+3, x+3
0BEA           1328       
0BEA 120924    1329       lcall Time_Compare
0BED           1330       
0BED 12096E    1331       lcall Safety_Check_TC
0BF0           1332   
0BF0           1333   
0BF0           1334       ; Check the FSM for one second counter
0BF0 120812    1335       lcall SEC_FSM
0BF3           1336   
0BF3           1337       ; Check the FSM for the overall control flow of the reflow process
0BF3 120A30    1338       lcall Control_FSM
0BF6           1339   
0BF6           1340       ; Update the LCD display based on the current state
0BF6 120639    1341       lcall LCD_Display_Update_func
0BF9           1342   
0BF9 300202    1343       jnb one_ms_pwm_flag, Skip_Beep_Sync
0BFC D213      1344       setb one_ms_beep_flag  ; Give the buzzer its own copy of the time tick
0BFE           1345   
0BFE           1346   Skip_Beep_Sync:
0BFE           1347       ; Update the pwm output for the ssr
0BFE 120868    1348       lcall PWM_Wave 
0C01           1349            ; Update the Buzzer 
0C01 1209F7    1350            lcall Beep_Task
0C04           1351   
0C04           1352       ; After initialization the program stays in this 'forever' loop
0C04 020BA8    1353       ljmp loop
0C07           1354   ;-------------------------------------------------------------------------------;
0C07           1355   
0C07           1356   ; ================================================================
0C07           1357   ; UI & HELPER SUBROUTINES
0C07           1358   ; ================================================================
0C07           1359   
0C07           1360   ; ----------------------------------------------------------------
0C07           1361   ; MODULE: BRIDGE (Text to Integer Conversion)
0C07           1362   ; ----------------------------------------------------------------
0C07           1363   Update_FSM_Variables:
0C07           1364       ; --- 1. SOAK TEMP ---
0C07 7880      1365       mov R0, #Buf_Soak_Temp
0C09 120C46    1366       lcall Parse_Temp_String
0C0C 8F43      1367       mov soak_temp+0, R7
0C0E 754400    1368       mov soak_temp+1, #0
0C11 754500    1369       mov soak_temp+2, #0
0C14 754600    1370       mov soak_temp+3, #0
0C17           1371   
0C17           1372       ; --- 2. REFLOW TEMP ---
0C17 7889      1373       mov R0, #Buf_Refl_Temp
0C19 120C46    1374       lcall Parse_Temp_String
0C1C 8F47      1375       mov reflow_temp+0, R7
0C1E 754800    1376       mov reflow_temp+1, #0
0C21 754900    1377       mov reflow_temp+2, #0
0C24 754A00    1378       mov reflow_temp+3, #0
0C27           1379   
0C27           1380       ; --- 3. SOAK TIME ---
0C27 7884      1381       mov R0, #Buf_Soak_Time
0C29 120C5A    1382       lcall Parse_Time_String
0C2C 8F54      1383       mov soak_time+0, R7
0C2E 8E55      1384       mov soak_time+1, R6
0C30 755600    1385       mov soak_time+2, #0
0C33 755700    1386       mov soak_time+3, #0
0C36           1387   
0C36           1388       ; --- 4. REFLOW TIME ---
0C36 788D      1389       mov R0, #Buf_Refl_Time
0C38 120C5A    1390       lcall Parse_Time_String
0C3B 8F58      1391       mov reflow_time+0, R7
0C3D 8E59      1392       mov reflow_time+1, R6
0C3F 755A00    1393       mov reflow_time+2, #0
0C42 755B00    1394       mov reflow_time+3, #0
0C45 22        1395       ret
0C46           1396   
0C46           1397   ; --- Helper: Parse "123" to Integer ---
0C46           1398   Parse_Temp_String:
0C46 7F00      1399       mov R7, #0              ; Clear Result
0C48           1400   Parse_Temp_Loop:
0C48 E6        1401       mov A, @R0
0C49 600E      1402       jz Parse_Temp_Done      ; If Null, we are done
0C4B           1403       
0C4B           1404       ; Convert ASCII to Digit
0C4B C3        1405       clr C
0C4C 9430      1406       subb A, #0x30
0C4E FD        1407       mov R5, A               ; R5 = New Digit
0C4F           1408       
0C4F           1409       ; Result = (Result * 10) + New Digit
0C4F EF        1410       mov A, R7
0C50 75F00A    1411       mov B, #10
0C53 A4        1412       mul AB
0C54 2D        1413       add A, R5
0C55 FF        1414       mov R7, A
0C56           1415       
0C56 08        1416       inc R0
0C57 80EF      1417       sjmp Parse_Temp_Loop
0C59           1418   Parse_Temp_Done:
0C59 22        1419       ret
0C5A           1420   
0C5A           1421   ; --- Helper: Parse "MMSS" to Seconds ---
0C5A           1422   Parse_Time_String:
0C5A           1423       ; 1. Minutes Tens
0C5A E6        1424       mov A, @R0
0C5B 9430      1425       subb A, #0x30
0C5D 75F00A    1426       mov B, #10
0C60 A4        1427       mul AB
0C61 FD        1428       mov R5, A
0C62 08        1429       inc R0
0C63           1430       
0C63           1431       ; 2. Minutes Ones
0C63 E6        1432       mov A, @R0
0C64 9430      1433       subb A, #0x30
0C66 2D        1434       add A, R5
0C67 FD        1435       mov R5, A               ; R5 = Total Minutes
0C68 08        1436       inc R0
0C69           1437       
0C69           1438       ; 3. Seconds Tens
0C69 E6        1439       mov A, @R0
0C6A 9430      1440       subb A, #0x30
0C6C 75F00A    1441       mov B, #10
0C6F A4        1442       mul AB
0C70 FC        1443       mov R4, A
0C71 08        1444       inc R0
0C72           1445       
0C72           1446       ; 4. Seconds Ones
0C72 E6        1447       mov A, @R0
0C73 9430      1448       subb A, #0x30
0C75 2C        1449       add A, R4               ; R4 = Total Seconds
0C76           1450       
0C76           1451       ; 5. Calculate Total Seconds = (Mins * 60) + Secs
0C76 ED        1452       mov A, R5
0C77 75F03C    1453       mov B, #60
0C7A A4        1454       mul AB
0C7B 2C        1455       add A, R4
0C7C FF        1456       mov R7, A               ; Low Byte
0C7D E5F0      1457       mov A, B
0C7F 3400      1458       addc A, #0
0C81 FE        1459       mov R6, A               ; High Byte
0C82 22        1460       ret
0C83           1461   
0C83           1462   ; ----------------------------------------------------------------
0C83           1463   ; MODULE: BUTTON HANDLER (Mode Selection)
0C83           1464   ; ----------------------------------------------------------------
0C83           1465   Check_Buttons:
0C83           1466       ; --- FORCE INPUT MODE ---
0C83           1467       ; This clears any '0' the LCD library might have written to our buttons
0C83 438055    1468       orl P0, #055H   ; Sets P0.0, P0.2, P0.4, and P0.6 to '1' (Input Mode)
0C86           1469       ; ------------------------
0C86           1470   
0C86 30800A    1471       jnb BTN_SOAK_TEMP, Btn_Soak_Temp_Press
0C89 308212    1472       jnb BTN_SOAK_TIME, Btn_Soak_Time_Press
0C8C 30841A    1473       jnb BTN_REFL_TEMP, Btn_Refl_Temp_Press
0C8F 308622    1474       jnb BTN_REFL_TIME, Btn_Refl_Time_Press
0C92 22        1475       ret
0C93           1476   
0C93           1477   Btn_Soak_Temp_Press:
0C93 120F3D    1478       lcall Wait_25ms_BLOCKING
0C96 756901    1479       mov Current_State, #1
0C99 756A00    1480       mov Cursor_Idx, #0
0C9C 8021      1481       sjmp Redraw_Screen
0C9E           1482   
0C9E           1483   Btn_Soak_Time_Press:
0C9E 120F3D    1484       lcall Wait_25ms_BLOCKING
0CA1 756902    1485       mov Current_State, #2
0CA4 756A00    1486       mov Cursor_Idx, #0
0CA7 8016      1487       sjmp Redraw_Screen
0CA9           1488   
0CA9           1489   Btn_Refl_Temp_Press:
0CA9 120F3D    1490       lcall Wait_25ms_BLOCKING
0CAC 756903    1491       mov Current_State, #3
0CAF 756A00    1492       mov Cursor_Idx, #0
0CB2 800B      1493       sjmp Redraw_Screen
0CB4           1494   
0CB4           1495   Btn_Refl_Time_Press:
0CB4 120F3D    1496       lcall Wait_25ms_BLOCKING 
0CB7 756904    1497       mov Current_State, #4
0CBA 756A00    1498       mov Cursor_Idx, #0
0CBD 8000      1499       sjmp Redraw_Screen
0CBF           1500   
0CBF           1501   Redraw_Screen:
0CBF           1502       ; Wait for button release
0CBF 3080FD    1503       jnb BTN_SOAK_TEMP, $
0CC2 3082FD    1504       jnb BTN_SOAK_TIME, $
0CC5 3084FD    1505       jnb BTN_REFL_TEMP, $
0CC8 3086FD    1506       jnb BTN_REFL_TIME, $
0CCB           1507   
0CCB 120E4B    1508       lcall Update_Screen_Full
0CCE 22        1509       ret
0CCF           1510   
0CCF           1511   ; ----------------------------------------------------------------
0CCF           1512   ; MODULE: KEYPAD HANDLER (Input Logic)
0CCF           1513   ; ----------------------------------------------------------------
0CCF           1514   Check_Keypad:
0CCF           1515       ; If State is 0 (Home), ignore keypad
0CCF E569      1516       mov A, Current_State
0CD1 6050      1517       jz Keypad_Exit
0CD3           1518       
0CD3 120D24    1519       lcall Keypad_Scan
0CD6 504B      1520       jnc Keypad_Exit         ; Carry = 0 means no key pressed
0CD8           1521   
0CD8           1522       ; --- Check Special Keys ---
0CD8 EF        1523       mov A, R7
0CD9 B40E0A    1524       cjne A, #14, Check_Hash ; 14 is Star (*)
0CDC           1525       
0CDC           1526       ; Star Key Pressed: Reset Buffer
0CDC 120E28    1527       lcall Reset_Current_Buffer
0CDF 120E4B    1528       lcall Update_Screen_Full
0CE2 756A00    1529       mov Cursor_Idx, #0
0CE5 22        1530       ret
0CE6           1531   
0CE6           1532   Check_Hash:
0CE6 EF        1533       mov A, R7
0CE7 B40C01    1534       cjne A, #12, Check_Numeric ; 12 is Hash (#)
0CEA 22        1535       ret                     ; Ignore Hash key
0CEB           1536   
0CEB           1537   Check_Numeric:
0CEB           1538       ; Ensure key is 0-9
0CEB EF        1539       mov A, R7
0CEC C3        1540       clr C
0CED 940A      1541       subb A, #10
0CEF 5031      1542       jnc Symbol_Key_Ignored
0CF1           1543       
0CF1           1544       ; Convert to ASCII
0CF1 EF        1545       mov A, R7
0CF2 2430      1546       add A, #0x30
0CF4 FD        1547       mov R5, A
0CF5           1548   
0CF5           1549       ; Save to Buffer
0CF5 120F56    1550       lcall Get_Current_Buffer_Addr
0CF8 E56A      1551       mov A, Cursor_Idx
0CFA 28        1552       add A, R0
0CFB F8        1553       mov R0, A
0CFC ED        1554       mov A, R5
0CFD F6        1555       mov @R0, A
0CFE 056A      1556       inc Cursor_Idx
0D00           1557   
0D00           1558       ; --- Check Cursor Limits ---
0D00 E569      1559       mov A, Current_State
0D02 B40102    1560       cjne A, #1, Check_Limit_Time_1
0D05 8005      1561       sjmp Limit_Temp_3
0D07           1562   
0D07           1563   Check_Limit_Time_1:
0D07 B4030B    1564       cjne A, #3, Limit_Time_4
0D0A 8000      1565       sjmp Limit_Temp_3
0D0C           1566   
0D0C           1567   Limit_Temp_3:
0D0C E56A      1568       mov A, Cursor_Idx
0D0E B4030D    1569       cjne A, #3, Do_Refresh
0D11 156A      1570       dec Cursor_Idx          ; Stay at last digit
0D13 8009      1571       sjmp Do_Refresh
0D15           1572   
0D15           1573   Limit_Time_4:
0D15 E56A      1574       mov A, Cursor_Idx
0D17 B40404    1575       cjne A, #4, Do_Refresh
0D1A 156A      1576       dec Cursor_Idx          ; Stay at last digit
0D1C 8000      1577       sjmp Do_Refresh
0D1E           1578   
0D1E           1579   Do_Refresh:
0D1E 120E4B    1580       lcall Update_Screen_Full
0D21 22        1581       ret
0D22           1582   
0D22           1583   Symbol_Key_Ignored:
0D22 22        1584       ret
0D23           1585   Keypad_Exit:
0D23 22        1586       ret
0D24           1587   
0D24           1588   ; ----------------------------------------------------------------
0D24           1589   ; MODULE: HARDWARE SCANNER (Matrix Logic)
0D24           1590   ; ----------------------------------------------------------------
0D24           1591   Keypad_Scan:
0D24           1592       ; Step 1: Check if ANY key is pressed (All Rows Low)
0D24 C292      1593       clr ROW1
0D26 C294      1594       clr ROW2
0D28 C296      1595       clr ROW3
0D2A C2A0      1596       clr ROW4
0D2C A2A2      1597       mov C, COL1
0D2E 82A4      1598       anl C, COL2
0D30 82A6      1599       anl C, COL3
0D32 82B0      1600       anl C, COL4
0D34 5002      1601       jnc Keypad_Debounce
0D36 C3        1602       clr C
0D37 22        1603       ret
0D38           1604   
0D38           1605   Keypad_Debounce:
0D38 120F3D    1606       lcall Wait_25ms_BLOCKING
0D3B A2A2      1607       mov C, COL1
0D3D 82A4      1608       anl C, COL2
0D3F 82A6      1609       anl C, COL3
0D41 82B0      1610       anl C, COL4
0D43 5002      1611       jnc Keypad_Find_Row
0D45 C3        1612       clr C
0D46 22        1613       ret
0D47           1614   
0D47           1615   Keypad_Find_Row:
0D47 D292      1616       setb ROW1
0D49 D294      1617       setb ROW2
0D4B D296      1618       setb ROW3
0D4D D2A0      1619       setb ROW4
0D4F           1620   
0D4F           1621       ; Row 1
0D4F C292      1622       clr ROW1
0D51 30A23D    1623       jnb COL1, Keypad_Key_1
0D54 30A43E    1624       jnb COL2, Keypad_Key_2
0D57 30A63F    1625       jnb COL3, Keypad_Key_3
0D5A 30B040    1626       jnb COL4, Keypad_Key_A
0D5D D292      1627       setb ROW1
0D5F           1628   
0D5F           1629       ; Row 2
0D5F C294      1630       clr ROW2
0D61 30A23D    1631       jnb COL1, Keypad_Key_4
0D64 30A43E    1632       jnb COL2, Keypad_Key_5
0D67 30A63F    1633       jnb COL3, Keypad_Key_6
0D6A 30B040    1634       jnb COL4, Keypad_Key_B
0D6D D294      1635       setb ROW2
0D6F           1636   
0D6F           1637       ; Row 3
0D6F C296      1638       clr ROW3
0D71 30A23D    1639       jnb COL1, Keypad_Key_7
0D74 30A43E    1640       jnb COL2, Keypad_Key_8
0D77 30A63F    1641       jnb COL3, Keypad_Key_9
0D7A 30B040    1642       jnb COL4, Keypad_Key_C
0D7D D296      1643       setb ROW3
0D7F           1644   
0D7F           1645       ; Row 4
0D7F C2A0      1646       clr ROW4
0D81 30A23D    1647       jnb COL1, Keypad_Key_Star
0D84 30A43E    1648       jnb COL2, Keypad_Key_0
0D87 30A63F    1649       jnb COL3, Keypad_Key_Hash
0D8A 30B040    1650       jnb COL4, Keypad_Key_D
0D8D D2A0      1651       setb ROW4
0D8F C3        1652       clr C
0D90 22        1653       ret
0D91           1654   
0D91           1655   ; Key Mapping (Renamed to avoid conflicts)
0D91 7F01      1656   Keypad_Key_1: mov R7, #1
0D93 803C      1657          sjmp Wait_Release
0D95 7F02      1658   Keypad_Key_2: mov R7, #2
0D97 8038      1659          sjmp Wait_Release
0D99 7F03      1660   Keypad_Key_3: mov R7, #3
0D9B 8034      1661          sjmp Wait_Release
0D9D 7F0A      1662   Keypad_Key_A: mov R7, #10
0D9F 8030      1663          sjmp Wait_Release
0DA1 7F04      1664   Keypad_Key_4: mov R7, #4
0DA3 802C      1665          sjmp Wait_Release
0DA5 7F05      1666   Keypad_Key_5: mov R7, #5
0DA7 8028      1667          sjmp Wait_Release
0DA9 7F06      1668   Keypad_Key_6: mov R7, #6
0DAB 8024      1669          sjmp Wait_Release
0DAD 7F0B      1670   Keypad_Key_B: mov R7, #11
0DAF 8020      1671          sjmp Wait_Release
0DB1 7F07      1672   Keypad_Key_7: mov R7, #7
0DB3 801C      1673          sjmp Wait_Release
0DB5 7F08      1674   Keypad_Key_8: mov R7, #8
0DB7 8018      1675          sjmp Wait_Release
0DB9 7F09      1676   Keypad_Key_9: mov R7, #9
0DBB 8014      1677          sjmp Wait_Release
0DBD 7F0D      1678   Keypad_Key_C: mov R7, #13
0DBF 8010      1679          sjmp Wait_Release
0DC1 7F0E      1680   Keypad_Key_Star: mov R7, #14
0DC3 800C      1681          sjmp Wait_Release
0DC5 7F00      1682   Keypad_Key_0: mov R7, #0
0DC7 8008      1683          sjmp Wait_Release
0DC9 7F0C      1684   Keypad_Key_Hash: mov R7, #12
0DCB 8004      1685          sjmp Wait_Release
0DCD 7F0F      1686   Keypad_Key_D: mov R7, #15
0DCF 8000      1687          sjmp Wait_Release
0DD1           1688   
0DD1           1689   Wait_Release:
0DD1 A2A2      1690       mov C, COL1
0DD3 82A4      1691       anl C, COL2
0DD5 82A6      1692       anl C, COL3
0DD7 82B0      1693       anl C, COL4
0DD9 50F6      1694       jnc Wait_Release
0DDB D3        1695       setb C
0DDC D292      1696       setb ROW1
0DDE D294      1697       setb ROW2
0DE0 D296      1698       setb ROW3
0DE2 D2A0      1699       setb ROW4
0DE4 22        1700       ret
0DE5           1701   
0DE5           1702   Wait_25ms:
0DE5           1703       ; 1. Check if we are already waiting
0DE5 20140E    1704       jb wait25_active, Check_Timer_Status
0DE8           1705       
0DE8           1706       ; 2. Check if we just finished
0DE8 301504    1707       jnb wait25_done, Start_New_Timer
0DEB           1708       
0DEB           1709       ; 3. Timer is DONE! Reset flags and return True
0DEB C215      1710       clr wait25_done
0DED D3        1711       setb C          ; Carry = 1 means "Done"
0DEE 22        1712       ret
0DEF           1713   
0DEF           1714   Start_New_Timer:
0DEF           1715       ; 4. Start a new 25ms wait
0DEF 754F00    1716       mov wait25_count, #0
0DF2 D214      1717       setb wait25_active
0DF4 C3        1718       clr C           ; Carry = 0 means "Not Done Yet"
0DF5 22        1719       ret
0DF6           1720   
0DF6           1721   Check_Timer_Status:
0DF6           1722       ; 5. Still waiting... return False immediately
0DF6 C3        1723       clr C           ; Carry = 0 means "Not Done Yet"
0DF7 22        1724       ret
0DF8           1725   
0DF8           1726   ; ----------------------------------------------------------------
0DF8           1727   ; MODULE: BUFFER INIT (Reset Logic)
0DF8           1728   ; ----------------------------------------------------------------
0DF8           1729   Init_All_Buffers:
0DF8 7880      1730       mov R0, #Buf_Soak_Temp
0DFA 120E0D    1731       lcall Init_Temp_Template
0DFD 7889      1732       mov R0, #Buf_Refl_Temp
0DFF 120E0D    1733       lcall Init_Temp_Template
0E02 7884      1734       mov R0, #Buf_Soak_Time
0E04 120E19    1735       lcall Init_Time_Template
0E07 788D      1736       mov R0, #Buf_Refl_Time
0E09 120E19    1737       lcall Init_Time_Template
0E0C 22        1738       ret
0E0D           1739   
0E0D           1740   Init_Temp_Template:
0E0D 7630      1741       mov @R0, #'0'
0E0F 08        1742       inc R0
0E10 7630      1743       mov @R0, #'0'
0E12 08        1744       inc R0
0E13 7630      1745       mov @R0, #'0'
0E15 08        1746       inc R0
0E16 7600      1747       mov @R0, #0
0E18 22        1748       ret
0E19           1749   
0E19           1750   Init_Time_Template:
0E19 7630      1751       mov @R0, #'0'
0E1B 08        1752       inc R0
0E1C 7630      1753       mov @R0, #'0'
0E1E 08        1754       inc R0
0E1F 7630      1755       mov @R0, #'0'
0E21 08        1756       inc R0
0E22 7630      1757       mov @R0, #'0'
0E24 08        1758       inc R0
0E25 7600      1759       mov @R0, #0
0E27 22        1760       ret
0E28           1761   
0E28           1762   Reset_Current_Buffer:
0E28 E569      1763       mov A, Current_State
0E2A B40106    1764       cjne A, #1, Reset_Chk_2
0E2D 7880      1765       mov R0, #Buf_Soak_Temp
0E2F 120E0D    1766       lcall Init_Temp_Template
0E32 22        1767       ret
0E33           1768   Reset_Chk_2:
0E33 B40206    1769       cjne A, #2, Reset_Chk_3
0E36 7884      1770       mov R0, #Buf_Soak_Time
0E38 120E19    1771       lcall Init_Time_Template
0E3B 22        1772       ret
0E3C           1773   Reset_Chk_3:
0E3C B40306    1774       cjne A, #3, Reset_Chk_4
0E3F 7889      1775       mov R0, #Buf_Refl_Temp
0E41 120E0D    1776       lcall Init_Temp_Template
0E44 22        1777       ret
0E45           1778   Reset_Chk_4:
0E45 788D      1779       mov R0, #Buf_Refl_Time
0E47 120E19    1780       lcall Init_Time_Template
0E4A 22        1781       ret
0E4B           1782   
0E4B           1783   ; ----------------------------------------------------------------
0E4B           1784   ; MODULE: SCREEN UPDATE (Visual Logic)
0E4B           1785   ; ----------------------------------------------------------------
0E4B           1786   Update_Screen_Full:
0E4B 120F43    1787       lcall Clear_Screen_Func
0E4E C0E0      1788            push acc
0E50 7401      1788            mov a, #1
0E52 14        1788            dec a
0E53 1205C9    1788            lcall ?Set_Cursor_1 ; Select column and row
0E56 D0E0      1788            pop acc
0E58           1789   
0E58           1790       ; --- Draw Line 1 (Titles) ---
0E58 E569      1791       mov A, Current_State
0E5A B40013    1792       cjne A, #0, Update_State_1
0E5D C083      1793            push dph
0E5F C082      1793            push dpl
0E61 C0E0      1793            push acc
0E63 900350    1793            mov dptr, #Txt_Home
0E66 1205BC    1793            lcall ?Send_Constant_String
0E69 D0E0      1793            pop acc
0E6B D082      1793            pop dpl
0E6D D083      1793            pop dph
0E6F 22        1794       ret 
0E70           1795   Update_State_1:
0E70 B40114    1796       cjne A, #1, Update_State_2
0E73 C083      1797            push dph
0E75 C082      1797            push dpl
0E77 C0E0      1797            push acc
0E79 900361    1797            mov dptr, #Txt_SoakT
0E7C 1205BC    1797            lcall ?Send_Constant_String
0E7F D0E0      1797            pop acc
0E81 D082      1797            pop dpl
0E83 D083      1797            pop dph
0E85 8042      1798       sjmp Draw_Temp_Format
0E87           1799   Update_State_2:
0E87 B40214    1800       cjne A, #2, Update_State_3
0E8A C083      1801            push dph
0E8C C082      1801            push dpl
0E8E C0E0      1801            push acc
0E90 900372    1801            mov dptr, #Txt_SoakTime
0E93 1205BC    1801            lcall ?Send_Constant_String
0E96 D0E0      1801            pop acc
0E98 D082      1801            pop dpl
0E9A D083      1801            pop dph
0E9C 8042      1802       sjmp Draw_Time_Format
0E9E           1803   Update_State_3:
0E9E B40314    1804       cjne A, #3, Update_State_4
0EA1 C083      1805            push dph
0EA3 C082      1805            push dpl
0EA5 C0E0      1805            push acc
0EA7 900383    1805            mov dptr, #Txt_ReflT
0EAA 1205BC    1805            lcall ?Send_Constant_String
0EAD D0E0      1805            pop acc
0EAF D082      1805            pop dpl
0EB1 D083      1805            pop dph
0EB3 8014      1806       sjmp Draw_Temp_Format
0EB5           1807   Update_State_4:
0EB5 C083      1808            push dph
0EB7 C082      1808            push dpl
0EB9 C0E0      1808            push acc
0EBB 900394    1808            mov dptr, #Txt_ReflTime
0EBE 1205BC    1808            lcall ?Send_Constant_String
0EC1 D0E0      1808            pop acc
0EC3 D082      1808            pop dpl
0EC5 D083      1808            pop dph
0EC7 8017      1809       sjmp Draw_Time_Format
0EC9           1810   
0EC9           1811   ; --- Draw Line 2 (Values) ---
0EC9           1812   Draw_Temp_Format:
0EC9 C0E0      1813            push acc
0ECB 7401      1813            mov a, #1
0ECD 14        1813            dec a
0ECE 1205C7    1813            lcall ?Set_Cursor_2 ; Select column and row
0ED1 D0E0      1813            pop acc
0ED3 120F56    1814       lcall Get_Current_Buffer_Addr
0ED6 120F33    1815       lcall Print_String_RAM
0ED9 7443      1816       mov A, #'C'
0EDB 12057F    1817       lcall ?WriteData
0EDE 8027      1818       sjmp Restore_Cursor
0EE0           1819   
0EE0           1820   Draw_Time_Format:
0EE0 C0E0      1821            push acc
0EE2 7401      1821            mov a, #1
0EE4 14        1821            dec a
0EE5 1205C7    1821            lcall ?Set_Cursor_2 ; Select column and row
0EE8 D0E0      1821            pop acc
0EEA 120F56    1822       lcall Get_Current_Buffer_Addr
0EED           1823       ; MM
0EED E6        1824       mov A, @R0
0EEE 12057F    1825       lcall ?WriteData
0EF1 08        1826       inc R0
0EF2 E6        1827       mov A, @R0
0EF3 12057F    1828       lcall ?WriteData
0EF6 08        1829       inc R0
0EF7           1830       ; Colon
0EF7 743A      1831       mov A, #':'
0EF9 12057F    1832       lcall ?WriteData
0EFC           1833       ; SS
0EFC E6        1834       mov A, @R0
0EFD 12057F    1835       lcall ?WriteData
0F00 08        1836       inc R0
0F01 E6        1837       mov A, @R0
0F02 12057F    1838       lcall ?WriteData
0F05           1839       ; Unit
0F05           1840       ;got rid of the "s"
0F05           1841       ;mov A, #'s'
0F05           1842       ;lcall ?WriteData
0F05 8000      1843       sjmp Restore_Cursor
0F07           1844   
0F07           1845   ; --- Restore Cursor Position ---
0F07           1846   Restore_Cursor:
0F07 E569      1847       mov A, Current_State
0F09 B40202    1848       cjne A, #2, RC_Check_State_4  
0F0C 800D      1849       sjmp Adjust_Cursor_Time
0F0E           1850   RC_Check_State_4:             
0F0E B40402    1851       cjne A, #4, Normal_Cursor
0F11 8008      1852       sjmp Adjust_Cursor_Time
0F13           1853   
0F13           1854   Normal_Cursor:
0F13 E56A      1855       mov A, Cursor_Idx
0F15 24C0      1856       add A, #0xC0
0F17 120584    1857       lcall ?WriteCommand
0F1A 22        1858       ret
0F1B           1859   
0F1B           1860   Adjust_Cursor_Time:
0F1B           1861       ; Skip the colon index (2)
0F1B E56A      1862       mov A, Cursor_Idx
0F1D B40201    1863       cjne A, #2, No_Skip
0F20 04        1864       inc A 
0F21           1865   No_Skip:
0F21           1866       ; Add 1 if past the colon
0F21 C3        1867       clr C
0F22 9402      1868       subb A, #2
0F24 4005      1869       jc No_Add
0F26 E56A      1870       mov A, Cursor_Idx
0F28 04        1871       inc A
0F29 8002      1872       sjmp Final_Cursor_Set
0F2B           1873   No_Add:
0F2B E56A      1874       mov A, Cursor_Idx
0F2D           1875   Final_Cursor_Set:
0F2D 24C0      1876       add A, #0xC0
0F2F 120584    1877       lcall ?WriteCommand
0F32 22        1878       ret
0F33           1879   
0F33           1880   Print_String_RAM:
0F33 E6        1881       mov A, @R0
0F34 6006      1882       jz Print_String_Done
0F36 12057F    1883       lcall ?WriteData
0F39 08        1884       inc R0
0F3A 80F7      1885       sjmp Print_String_RAM
0F3C           1886   Print_String_Done:
0F3C 22        1887       ret
0F3D           1888   
0F3D           1889   ; Blocking wrapper for LCD clear (keeps old behavior just for this)
0F3D           1890   Wait_25ms_BLOCKING:
0F3D 120DE5    1891       lcall Wait_25ms
0F40 50FB      1892       jnc Wait_25ms_BLOCKING ; Keep jumping back until Done (C=1)
0F42 22        1893       ret
0F43           1894   
0F43           1895   Clear_Screen_Func:
0F43 7401      1896       mov A, #0x01
0F45 120584    1897       lcall ?WriteCommand
0F48           1898       
0F48           1899       ; --- FIX: HARDWARE DELAY LOOP (MAX STRENGTH) ---
0F48           1900       ; The LCD needs ~2ms to clear. 
0F48           1901       ; We use R0=255 to guarantee ~5ms+ delay.
0F48           1902       ; This ensures the LCD is 100% ready before we send "Ramp to Soak".
0F48 78FF      1903       mov R0, #255
0F4A           1904   Clear_Delay_Loop_Outer:
0F4A 79FF      1905       mov R1, #255
0F4C           1906   Clear_Delay_Loop_Inner:
0F4C D9FE      1907       djnz R1, Clear_Delay_Loop_Inner
0F4E D8FA      1908       djnz R0, Clear_Delay_Loop_Outer
0F50           1909       ; -----------------------------------------------
0F50           1910   
0F50 740C      1911       mov A, #0x0C  ; Display ON, Cursor OFF
0F52 120584    1912       lcall ?WriteCommand
0F55 22        1913       ret
0F56           1914   
0F56           1915   Get_Current_Buffer_Addr:
0F56 E569      1916       mov A, Current_State
0F58 B40103    1917       cjne A, #1, Get_Buf_2
0F5B 7880      1918       mov R0, #Buf_Soak_Temp
0F5D 22        1919       ret
0F5E           1920   Get_Buf_2:
0F5E B40203    1921       cjne A, #2, Get_Buf_3
0F61 7884      1922       mov R0, #Buf_Soak_Time
0F63 22        1923       ret
0F64           1924   Get_Buf_3:
0F64 B40303    1925       cjne A, #3, Get_Buf_4
0F67 7889      1926       mov R0, #Buf_Refl_Temp
0F69 22        1927       ret
0F6A           1928   Get_Buf_4:
0F6A 788D      1929       mov R0, #Buf_Refl_Time
0F6C 22        1930       ret
0F6D           1931       
0F6D           1932   ; --- Helper to prevent "Machine Gun" button presses ---
0F6D           1933   Wait_For_P1_0_Release:
0F6D 3090FD    1934       jnb P1.0, $    ; Wait here while the button is still pressed (0)
0F70 22        1935       ret
0F71           1936   
0F71           1937   ; ================================================================
0F71           1938   ; MODULE: THERMOCOUPLE ADC DRIVER (WITH NOISE SUPPRESSION & JUMP FIX)
0F71           1939   ; ================================================================
0F71           1940   Read_Thermocouple:
0F71           1941       ; 1. Check Non-Blocking Timer
0F71 120DE5    1942       lcall Wait_25ms
0F74           1943       
0F74           1944       ; [FIX] TRAMPOLINE JUMP
0F74           1945       ; "jnc" cannot jump to the end because the code is too long.
0F74           1946       ; We invert logic: If Carry=1 (Time is up), Jump NEARBY.
0F74 4001      1947       jc Proceed_Reading
0F76 22        1948       ret  ; If Carry=0, Return immediately.
0F77           1949   
0F77           1950   Proceed_Reading:
0F77           1951       ; --- 25ms Passed! Time to Read ---
0F77           1952   
0F77           1953       ; [FIX] SILENCE THE BUZZER (Noise Suppression)
0F77           1954       ; Save buzzer state and force it OFF during the sensitive read
0F77 E588      1955       mov A, TCON      
0F79 5410      1956       anl A, #0x10     ; Isolate TR0 bit
0F7B C0E0      1957       push acc         ; Save it
0F7D C28C      1958       clr TR0          ; STOP NOISE
0F7F           1959   
0F7F           1960       ; 2. Initialize / Trigger ADC
0F7F 75A180    1961       mov ADC_C, #0x80    ; Reset
0F82 00        1962       nop
0F83 00        1963       nop
0F84 75A101    1964       mov ADC_C, #0x01    ; Start Channel 0
0F87           1965       
0F87           1966       ; 3. Settle Delay
0F87 7DFA      1967       mov R5, #250
0F89           1968   ADC_Settle_Loop:
0F89 00        1969       nop
0F8A 00        1970       nop
0F8B DDFC      1971       djnz R5, ADC_Settle_Loop
0F8D           1972       
0F8D           1973       ; 4. Read Raw Data
0F8D 85A232    1974       mov x+0, ADC_L
0F90 85A333    1975       mov x+1, ADC_H
0F93 753400    1976       mov x+2, #0
0F96 753500    1977       mov x+3, #0
0F99           1978       
0F99           1979       ; 5. Mask Data
0F99 E533      1980       mov a, x+1
0F9B 540F      1981       anl a, #0x0F
0F9D F533      1982       mov x+1, a
0F9F           1983       
0F9F           1984       ; [FIX] RESTORE THE BUZZER
0F9F D0E0      1985       pop acc          ; Get previous state
0FA1 6002      1986       jz Skip_Restore  ; If it was OFF, keep it OFF
0FA3 D28C      1987       setb TR0         ; If it was ON, turn it back ON
0FA5           1988   Skip_Restore:
0FA5           1989   
0FA5           1990       ; 6. Math Conversions
0FA5 753616    1991            mov y+0, #low (4118 % 0x10000) 
0FA8 753710    1991            mov y+1, #high(4118 % 0x10000) 
0FAB 753800    1991            mov y+2, #low (4118 / 0x10000) 
0FAE 753900    1991            mov y+3, #high(4118 / 0x10000) 
0FB1 12018C    1992       lcall mul32       
0FB4           1993   
0FB4 75A104    1994       mov ADC_C, #0x04    ; Read LM4040
0FB7 85A236    1995       mov y+0, ADC_L      
0FBA 85A337    1996       mov y+1, ADC_H      
0FBD 753800    1997       mov y+2, #0
0FC0 753900    1998       mov y+3, #0
0FC3 75A100    1999       mov ADC_C, #0x00    ; Reset
0FC6           2000       
0FC6 120280    2001       lcall div32         
0FC9 753664    2002            mov y+0, #low (100 % 0x10000) 
0FCC 753700    2002            mov y+1, #high(100 % 0x10000) 
0FCF 753800    2002            mov y+2, #low (100 / 0x10000) 
0FD2 753900    2002            mov y+3, #high(100 / 0x10000) 
0FD5 12018C    2003       lcall mul32
0FD8 75362B    2004            mov y+0, #low (1323 % 0x10000) 
0FDB 753705    2004            mov y+1, #high(1323 % 0x10000) 
0FDE 753800    2004            mov y+2, #low (1323 / 0x10000) 
0FE1 753900    2004            mov y+3, #high(1323 / 0x10000)         
0FE4 120280    2005       lcall div32    
0FE7 753614    2006            mov y+0, #low (COLD_JUNCTION_TEMP % 0x10000) 
0FEA 753700    2006            mov y+1, #high(COLD_JUNCTION_TEMP % 0x10000) 
0FED 753800    2006            mov y+2, #low (COLD_JUNCTION_TEMP / 0x10000) 
0FF0 753900    2006            mov y+3, #high(COLD_JUNCTION_TEMP / 0x10000) 
0FF3 1200D3    2007       lcall add32     
0FF6           2008       
0FF6           2009       ; 8. Store Result
0FF6 85323F    2010       mov current_temp+0, x+0
0FF9 853340    2011       mov current_temp+1, x+1
0FFC 853441    2012       mov current_temp+2, x+2
0FFF 853542    2013       mov current_temp+3, x+3
1002           2014   
1002 22        2015       ret
1003           2016       
1003           2017   ; ================================================================
1003           2018   ; MODULE: POWER CONTROLLER (The Brain)
1003           2019   ; ================================================================
1003           2020   Power_Control:
1003           2021       ; Default: Turn Heat OFF (Safety)
1003 755C00    2022       mov power_output+0, #0
1006 755D00    2023       mov power_output+1, #0
1009 755E00    2024       mov power_output+2, #0
100C 755F00    2025       mov power_output+3, #0
100F           2026   
100F E568      2027       mov a, Control_FSM_state
1011           2028   
1011           2029       ; --- State 2: RAMP TO SOAK ---
1011 B40202    2030       cjne a, #2, PC_Check_Soak
1014           2031       ; Mode: Full Speed Ahead
1014 8016      2032       sjmp Set_Max_Power
1016           2033   
1016           2034   PC_Check_Soak:
1016           2035       ; --- State 3: SOAK PHASE ---
1016 B40305    2036       cjne a, #3, PC_Check_Ramp_Reflow
1019           2037       ; Mode: Maintenance (Low Power)
1019           2038       ; If Temp > Target, OFF. If Temp < Target, 20% Power.
1019 20030F    2039       jb soak_temp_reached, PC_Done ; If hot enough, stay OFF
101C 801B      2040       sjmp Set_20_Percent_Power     ; If cold, use 20%
101E           2041   
101E           2042   PC_Check_Ramp_Reflow:
101E           2043       ; --- State 4: RAMP TO REFLOW ---
101E B40402    2044       cjne a, #4, PC_Check_Reflow
1021           2045       ; Mode: Full Speed Ahead
1021 8009      2046       sjmp Set_Max_Power
1023           2047   
1023           2048   PC_Check_Reflow:
1023           2049       ; --- State 5: REFLOW PHASE ---
1023 B40505    2050       cjne a, #5, PC_Done
1026           2051       ; Mode: Maintenance (Low Power)
1026 200402    2052       jb reflow_temp_reached, PC_Done
1029 800E      2053       sjmp Set_20_Percent_Power
102B           2054   
102B           2055   PC_Done:
102B 22        2056       ret
102C           2057   
102C           2058   ; --- Power Helpers ---
102C           2059   
102C           2060   Set_Max_Power:
102C           2061       ; Load 1500 (0x05DC) = 100% Duty Cycle
102C 755CDC    2062       mov power_output+0, #0xDC
102F 755D05    2063       mov power_output+1, #0x05
1032 755E00    2064       mov power_output+2, #0
1035 755F00    2065       mov power_output+3, #0
1038 22        2066       ret
1039           2067   
1039           2068   Set_20_Percent_Power:
1039           2069       ; Load 300 (0x012C) = 20% Duty Cycle
1039 755C2C    2070       mov power_output+0, #0x2C
103C 755D01    2071       mov power_output+1, #0x01
103F 755E00    2072       mov power_output+2, #0
1042 755F00    2073       mov power_output+3, #0
1045 22        2074       ret
1046           2075   
1046           2076   EN
