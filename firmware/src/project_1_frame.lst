0000              1   ; Project 1
0000              2   ; CV-8052 microcontroller in DE10-Lite board
0000              3   ;-------------------------------------------------------------------------------
0000              4   ; Reset vector
0000              5   org 0x0000
0000 020BC1       6       ljmp main
0003              7   ; External interrupt 0 vector
0003              8   org 0x0003
0003 32           9       reti
0004             10   ; Timer/Counter 0 overflow interrupt vector
000B             11   org 0x000B
000B 02046E      12       ljmp Timer0_ISR
000E             13   ; External interrupt 1 vector
0013             14   org 0x0013
0013 32          15       reti
0014             16   ; Timer/Counter 1 overflow interrupt vector
001B             17   org 0x001B
001B 32          18       reti
001C             19   ; Serial port receive/transmit interrupt vector
0023             20   org 0x0023 
0023 32          21       reti
0024             22   ; Timer/Counter 2 overflow interrupt vector
002B             23   org 0x002B
002B 02052E      24       ljmp Timer2_ISR
002E             25   ;-------------------------------------------------------------------------------
002E             26   ; includes
                614   $LIST
                 32   $LIST
0320             34   ; ----------------------------------------------------------------------------------------------;
0320             35   ; Data Segment 0x30 -- 0x7F  (overall 79d bytes available)
0030             36   dseg at 0x30
0030             37   current_time_sec:     ds 1
0031             38   current_time_minute:  ds 1
0032             39   ; math32 buffer variables
0032             40   x:      ds  4
0036             41   y:      ds  4
003A             42   bcd:    ds  5
003F             43   
003F             44   current_temp: ds 4 ;
0043             45   soak_temp:    ds 4 ;
0047             46   reflow_temp:  ds 4 ;
004B             47   
004B             48   wait25_btn_cnt:    ds 1
004C             49   wait25_keypad_cnt: ds 1
004D             50   wait25_adc_cnt:    ds 1
004E             51   wait25_lcd_cnt:    ds 1
004F             52   wait25_count: ds 1  
0050             53   
0050             54   current_time: ds 4 ;
0054             55   soak_time:    ds 4 ;
0058             56   reflow_time:  ds 4 ;
005C             57   
005C             58   power_output:  ds 4 ;
0060             59   pwm_counter: ds 4 ; counter for pwm (0-1500)
0064             60   
0064             61   KEY1_DEB_timer: ds 1
0065             62   SEC_FSM_timer:  ds 1
0066             63   KEY1_DEB_state:    ds 1
0067             64   SEC_FSM_state:     ds 1
0068             65   Control_FSM_state: ds 1 
0069             66   
0069             67   Current_State:     ds 1
006A             68   soak_temp_diff: ds 4 ; temperature difference between target soak temp and current oven temp 
006E             69   proportional_gain_var: ds 4 ; power gain calculated from the proportional block
0072             70   ;-- UI buffers I added (ayaan)
0072             71   Cursor_Idx: ds 1
0073             72   
0073             73   ; These hold the TEXT (ASCII) safely
0073             74   ; Digits Only + Null Terminator, got rid of C,:, and s 
0073             75   
0073             76   ; Buzzer state
0073             77   beep_count:  ds 1      ; remaining beeps
0074             78   beep_state:  ds 1      ; 0=idle, 1=ON, 2=OFF
0075             79   beep_tmr:    ds 2      ; 16-bit ms timer (needs to reach 500)
0077             80   
0077             81   servo_pwm_counter: ds 1 ; counter for the servo pwm signal
0078             82   
0080             83   iseg at 0x80
0080             84   Buf_Soak_Temp: ds 4   
0084             85   Buf_Soak_Time: ds 5   
0089             86   Buf_Refl_Temp: ds 4   
008D             87   Buf_Refl_Time: ds 5
0092             88   
0092             89   
0092             90   
0092             91   ; 46d bytes used
0092             92   
0092             93   ;-------------------------------------------------------------------------------
0092             94   ; bit operation setb, clr, jb, and jnb
0000             95   bseg
0000             96   mf:     dbit 1 ; math32 sign
0001             97   one_second_flag: dbit 1
0002             98   one_ms_pwm_flag: dbit 1 ; one_millisecond_flag for pwm signal
0003             99   
0003            100   soak_temp_reached: dbit 1
0004            101   reflow_temp_reached: dbit 1
0005            102   cooling_temp_reached: dbit 1
0006            103   
0006            104   soak_time_reached: dbit 1
0007            105   reflow_time_reached: dbit 1
0008            106   
0008            107   reset_signal: dbit 1
0009            108   stop_signal: dbit 1
000A            109   start_signal: dbit 1
000B            110   config_finish_signal: dbit 1
000C            111   
000C            112   state_change_signal: dbit 1
000D            113   
000D            114   Key1_flag: dbit 1
000E            115   
000E            116   tc_missing_abort: dbit 1   ; 1 = abort because temp < 50C after 60s
000F            117   tc_startup_window: dbit 1   ; 1 = still within first 60 seconds of the run
0010            118   PB0_flag: dbit 1 ; start entire program
0011            119   PB1_flag: dbit 1 ; start soak
0012            120   PB2_flag: dbit 1 ; pause process
0013            121   
0013            122   ;buzzer beep
0013            123   one_ms_beep_flag: dbit 1
0014            124   
0014            125   ; BSEG (Bit Segment)
0014            126   wait25_active: dbit 1 ; 1 = We are currently waiting
0015            127   wait25_done:   dbit 1 ; 1 = The 25ms has finished
0016            128   wait25_btn_active:    dbit 1
0017            129   wait25_btn_done:      dbit 1
0018            130   wait25_keypad_active: dbit 1
0019            131   wait25_keypad_done:   dbit 1
001A            132   wait25_adc_active:    dbit 1
001B            133   wait25_adc_done:      dbit 1
001C            134   wait25_lcd_active:    dbit 1
001D            135   wait25_lcd_done:      dbit 1
001E            136   
001E            137   one_millisecond_flag_servo: dbit 1 ; set the one millsiecond flag for servo pwm signal generation
001F            138   servo_angle_zero: dbit 1 ; flag for indicating whether the servo angle should be at 0 or not: 1 -> 0; 0 -> 180
0020            139   soak_temp_greater: dbit 1 ; target soak_temp greater than current_temp
0021            140   ; 11 bits used
0021            141   
0021            142   ;-------------------------------------------------------------------------------
0320            143   cseg
0320            144   CLK            EQU 33333333 ; Microcontroller system crystal frequency in Hz
0320            145   BAUD           EQU 57600
0320            146   
0320            147   TIMER0_RATE    EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0320            148   TIMER0_RELOAD  EQU ((65536-(CLK/(12*TIMER0_RATE)))) ; The prescaler in the CV-8052 
0320            149   ; is always 12 unlike the N76E003 where is selectable.
0320            150   
0320            151   TIMER_1_RELOAD EQU (256-((2*CLK)/(12*32*BAUD)))
0320            152   
0320            153   TIMER2_RATE    EQU 1000     ; 1000Hz, for a timer tick of 1ms
0320            154   TIMER2_RELOAD  EQU ((65536-(CLK/(12*TIMER2_RATE))))
0320            155   
0320            156   PWM_PERIOD     EQU 1499 ; 1.5s period
0320            157   
0320            158   SOUND_OUT      EQU P1.5 ; Pin connected to the speaker
0320            159   
0320            160   PWM_OUT        EQU P1.3 ; Pin connected to the ssr for outputing pwm signal
0320            161   
0320            162   ; These 'equ' must match the wiring between the DE10Lite board and the LCD!
0320            163   ; P0 is in connector JPIO.
0320            164   
0320            165   ;Added correct I/O definitions
0320            166   ;-- LCD Pins ---
0320            167   ELCD_RS equ P1.7
0320            168   ELCD_E  equ P1.1
0320            169   ELCD_D4 equ P0.7
0320            170   ELCD_D5 equ P0.5
0320            171   ELCD_D6 equ P0.3
0320            172   ELCD_D7 equ P0.1
0320            173   
0320            174   ; -- Buttons --
0320            175   BTN_SOAK_TEMP equ P0.0
0320            176   BTN_SOAK_TIME equ P0.2
0320            177   BTN_REFL_TEMP equ P0.4
0320            178   BTN_REFL_TIME equ P0.6
0320            179   
0320            180   ; --- KEYPAD ---
0320            181   ROW1 equ P1.2
0320            182   ROW2 equ P1.4
0320            183   ROW3 equ P1.6
0320            184   ROW4 equ P2.0
0320            185   COL1 equ P2.2
0320            186   COL2 equ P2.4
0320            187   COL3 equ P2.6
0320            188   COL4 equ P3.0
0320            189   
0320            190   SERVO_OUT      EQU p3.6 ; servo pin
0320            191   
0320            192   SERVO_PERIOD   EQU 20 ; pwm signal period for the servo motor (20 ms)
0320            193   SERVO_0        EQU 1 ; pwm high time for the servo motor to stay at 0 degree
0320            194   SERVO_180      EQU 2 ; pwm high time for the servo motor to stay at 180 degrees
0320            195   
0320            196   COLD_JUNCTION_TEMP equ 20
0320            197   MAX_POWER           EQU 1500 ; max oven power
0320            198   NO_POWER            EQU 0    ; no power
0320            199   BASE_POWER     EQU (MAX_POWER/5) ; 20% base power for state 2, 4
0320            200   KP                          EQU 5 ; proportional gain
0320            201   
0320            202   ;                     1234567890123456 <-- 16 characters per line LCD
0320 696E6974   203   Initial_Message:  db 'initial message', 0
     69616C20
     6D657373
     61676500
0330 57656C63   204   String_state0_1:  db 'Welcome        ', 0
     6F6D6520
     20202020
     20202000
0340 50726573   205   String_state0_2:  db 'Press PB0      ', 0
     73205042
     30202020
     20202000
0350            206   
0350            207   ; --- UI STRINGS (REQUIRED FOR KEYPAD LOGIC), <- I can fix if duplicates
0350 53656C65   208   Txt_Home:     db 'Select Mode:    ', 0
     6374204D
     6F64653A
     20202020
     00
0361 53657420   209   Txt_SoakT:    db 'Set Soak Temp   ', 0
     536F616B
     2054656D
     70202020
     00
0372 53657420   210   Txt_SoakTime: db 'Set Soak Time   ', 0
     536F616B
     2054696D
     65202020
     00
0383 53657420   211   Txt_ReflT:    db 'Set Reflow Temp ', 0
     5265666C
     6F772054
     656D7020
     00
0394 53657420   212   Txt_ReflTime: db 'Set Reflow Time ', 0
     5265666C
     6F772054
     696D6520
     00
03A5            213   
03A5            214   ;                       1234567890123456
03A5 53657420   215   String_state1:      db 'Set Parameters ', 0
     50617261
     6D657465
     72732000
03B5 536F616B   216   String_soak_temp:   db 'Soak Temp:', 0
     2054656D
     703A00
03C0 5265666C   217   String_reflow_temp: db 'Reflow Temp:', 0
     6F772054
     656D703A
     00
03CD 536F616B   218   String_soak_time:   db 'Soak Time:', 0
     2054696D
     653A00
03D8 5265666C   219   String_reflow_time: db 'Reflow Time:', 0
     6F772054
     696D653A
     00
03E5            220   
03E5 54656D70   221   String_temp_line:  db 'Temp: ', 0
     3A2000
03EC            222   
03EC            223   ;                     1234567890123456
03EC 52616D70   224   String_state2:    db 'Ramp to Soak   ', 0
     20746F20
     536F616B
     20202000
03FC 536F616B   225   String_state3:    db 'Soak Phase     ', 0
     20506861
     73652020
     20202000
040C 52616D70   226   String_state4:    db 'Ramp to Reflow ', 0
     20746F20
     5265666C
     6F772000
041C 5265666C   227   String_state5:    db 'Reflow Phase   ', 0
     6F772050
     68617365
     20202000
042C 436F6F6C   228   String_state6:    db 'Cooling        ', 0
     696E6720
     20202020
     20202000
043C 50726F63   229   String_state7:    db 'Process Done   ', 0
     65737320
     446F6E65
     20202000
044C            230   
044C 20202020   231   String_Blank:    db '                ', 0
     20202020
     20202020
     20202020
     00
045D            232   
045D            233   ;-------------------------------------------------------------------------------
045D            234   ; Timers Setting:
045D            235   ;   Timer 0: 2kHz square wave generation at P1.5 (speaker)
045D            236   ;   Timer 1: Serial port baud rate 57600 generator
045D            237   ;   Timer 2: 1ms interrupt for BCD counter increment/decrement
045D            238   ;-------------------------------------------------------------------------------
045D            239   ; Routine to initialize the ISR for Timer 0 ;
045D            240   Timer0_Init:
045D E589       241       mov a, TMOD
045F 54F0       242       anl a, #0xf0 ; Clear the bits for timer 0
0461 4401       243       orl a, #0x01 ; Configure timer 0 as 16-timer
0463 F589       244       mov TMOD, a
0465 758CFD     245       mov TH0, #high(TIMER0_RELOAD)
0468 758A5A     246       mov TL0, #low(TIMER0_RELOAD)
046B            247       ; Enable the timer and interrupts
046B D2A9       248       setb ET0  ; Enable timer 0 interrupt
046D            249       ; setb TR0  (no need to open at first)
046D 22         250       ret
046E            251   ; ISR for timer 0.  Set to execute every 1/4096Hz 
046E            252   ; to generate a 2048 Hz square wave at pin P1.5 
046E            253   Timer0_ISR:
046E            254       ;clr TF0  ; According to the data sheet this is done for us already.
046E 758CFD     255       mov TH0, #high(TIMER0_RELOAD) ; Timer 0 doesn't have autoreload in the CV-8052
0471 758A5A     256       mov TL0, #low(TIMER0_RELOAD)
0474 B295       257       cpl SOUND_OUT ; Connect speaker to P1.5
0476 32         258       reti
0477            259   ; -----------------------------------------------------------------------------------------------;
0477            260   
0477            261   ; Routine to initialize the serial port at 57600 baud (Timer 1 in mode 2)
0477            262   Initialize_Serial_Port:
0477            263       ; Configure serial port and baud rate
0477 C28E       264       clr TR1 ; Disable timer 1
0479 53890F     265       anl TMOD, #0x0f ; Mask the bits for timer 1
047C 438920     266       orl TMOD, #0x20 ; Set timer 1 in 8-bit auto reload mode
047F 438780     267       orl PCON, #80H ; Set SMOD to 1
0482 758DFD     268       mov TH1, #low(TIMER_1_RELOAD)
0485 758BFD     269       mov TL1, #low(TIMER_1_RELOAD) 
0488 D28E       270       setb TR1 ; Enable timer 1
048A 759852     271       mov SCON, #52H
048D 22         272       ret
048E            273   
048E            274   ; uart sending functions
048E            275   putchar:
048E 109902     276       jbc TI, putchar_L1
0491 80FB       277       sjmp putchar
0493            278   putchar_L1:
0493 F599       279       mov SBUF,a
0495 22         280       ret
0496            281   
0496            282   SendString:
0496 E4         283       clr a
0497 93         284       movc a, @a+dptr
0498 6006       285       jz SendString_L1
049A 12048E     286       lcall putchar
049D A3         287       inc dptr
049E 80F6       288       sjmp SendString  
04A0            289   SendString_L1:
04A0 22         290       ret
04A1            291   
04A1            292   ;-------------------------------------------------------------------------------
04A1            293   ; serial debugging
04A1            294   ; send a four byte number via serial to laptop
04A1            295   ; need to be used with python script
04A1            296   ; content needed to be sent should be stored in the varaible x
04A1            297   ;-------------------------------------------------------------------------------
04A1            298   Send32:
04A1            299       ; data format: 0xAA, 0x55, x+3, x+2, x+1, x+0, 0xAH (big endian)
04A1 74AA       300       mov A, #0AAH
04A3 12048E     301       lcall putchar
04A6 7455       302       mov A, #055H
04A8 12048E     303       lcall putchar
04AB            304   
04AB E535       305       mov A, x+3
04AD 12048E     306       lcall putchar
04B0 E534       307       mov A, x+2
04B2 12048E     308       lcall putchar
04B5 E533       309       mov A, x+1
04B7 12048E     310       lcall putchar
04BA E532       311       mov A, x+0
04BC 12048E     312       lcall putchar
04BF            313   
04BF 740A       314       mov A, #0AH
04C1 12048E     315       lcall putchar
04C4 22         316       ret
04C5            317   ; -----------------------------------------------------------------------------------------------;
04C5            318   
04C5            319   ;-------------------------------------------------------------------------------
04C5            320   ; Serial temperature line for PuTTY/screen
04C5            321   ; Outputs: "Temp: XXXC\r\n"
04C5            322   ;-------------------------------------------------------------------------------
04C5            323   Serial_Send_Temp_Line:
04C5 9003E5     324       mov dptr, #String_temp_line
04C8 120496     325       lcall SendString
04CB            326   
04CB            327       ; Convert current_temp to BCD (same as LCD)
04CB 853F32     328       mov x, current_temp
04CE 854033     329       mov x+1, current_temp+1
04D1 854134     330       mov x+2, current_temp+2
04D4 854235     331       mov x+3, current_temp+3
04D7 12002E     332       lcall hex2bcd
04DA            333   
04DA 7F00       334       mov R7, #0          ; printed_flag = 0
04DC            335   
04DC            336       ; Print Hundreds (if non-zero)
04DC E53B       337       mov a, bcd+1
04DE 540F       338       anl a, #0x0F
04E0 6007       339       jz Serial_Skip_Hundreds
04E2 2430       340       add a, #0x30
04E4 12048E     341       lcall putchar
04E7 7F01       342       mov R7, #1
04E9            343   Serial_Skip_Hundreds:
04E9            344   
04E9            345       ; Print Tens (if non-zero or if hundreds already printed)
04E9 E53A       346       mov a, bcd+0
04EB C4         347       swap a
04EC 540F       348       anl a, #0x0F
04EE 7003       349       jnz Serial_Print_Tens
04F0 EF         350       mov a, R7
04F1 600C       351       jz Serial_Skip_Tens
04F3            352   Serial_Print_Tens:
04F3 E53A       353       mov a, bcd+0
04F5 C4         354       swap a
04F6 540F       355       anl a, #0x0F
04F8 2430       356       add a, #0x30
04FA 12048E     357       lcall putchar
04FD 7F01       358       mov R7, #1
04FF            359   Serial_Skip_Tens:
04FF            360   
04FF            361       ; Print Ones (always)
04FF E53A       362       mov a, bcd+0
0501 540F       363       anl a, #0x0F
0503 2430       364       add a, #0x30
0505 12048E     365       lcall putchar
0508            366   
0508            367       ; Print 'C' and newline
0508 7443       368       mov a, #'C'
050A 12048E     369       lcall putchar
050D 740D       370       mov a, #0DH     ; CR
050F 12048E     371       lcall putchar
0512 740A       372       mov a, #0AH     ; LF
0514 12048E     373       lcall putchar
0517 22         374       ret
0518            375   
0518            376   ;-----------------------------------------------------------------------------------------------;
                 -1   $include(..\inc\Timer2_ISR.inc) ; Timer 2 ISR for 1ms tick and pwm signal generation
0518              1   ;-------------------------------------------------------------------------------
0518              2   ; Timer2_ISR.inc
0518              3   ; Contains Initialization and ISR for the 1ms System Timer
0518              4   ;-------------------------------------------------------------------------------
0518              5   
0518              6   ;-------------------------------------------------------------------------------
0518              7   ; Routine to initialize the ISR for timer 2
0518              8   ;-------------------------------------------------------------------------------
0518              9   Timer2_Init:
0518 75C800      10       mov T2CON, #0 ; Stop timer/counter.  Autoreload mode.
051B 75CDF5      11       mov TH2, #high(TIMER2_RELOAD)
051E 75CC27      12       mov TL2, #low(TIMER2_RELOAD)
0521             13       ; Set the reload value
0521 75CBF5      14       mov RCAP2H, #high(TIMER2_RELOAD)
0524 75CA27      15       mov RCAP2L, #low(TIMER2_RELOAD)
0527             16       
0527 C2CF        17       clr TF2       ; Clear flag just in case
0529             18       ; Enable the timer and interrupts
0529 D2AD        19       setb ET2      ; Enable timer 2 interrupt
052B D2CA        20       setb TR2      ; Enable timer 2
052D 22          21       ret
052E             22   
052E             23   ;-------------------------------------------------------------------------------
052E             24   ; ISR for timer 2.  Runs every 1 ms
052E             25   ;-------------------------------------------------------------------------------
052E             26   Timer2_ISR:
052E C0E0        27       push acc
0530 C0D0        28       push psw
0532             29       
0532 C2CF        30       clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
0534             31   
0534             32       ; --- 1. Existing FSM Timers ---
0534 0564        33       inc KEY1_DEB_timer
0536 0565        34       inc SEC_FSM_timer
0538 D202        35       setb one_ms_pwm_flag 
053A D213        36       setb one_ms_beep_flag
053C D21E        37       setb one_millisecond_flag_servo
053E             38   
053E             39       ; --- 2. NEW: Non-Blocking Delay Counters ---
053E             40       
053E             41       ; A. BUTTON DELAY
053E 30160B      42       jnb wait25_btn_active, T2_Check_Keypad
0541 054B        43       inc wait25_btn_cnt
0543 E54B        44       mov a, wait25_btn_cnt
0545 B41904      45       cjne a, #25, T2_Check_Keypad
0548 D217        46       setb wait25_btn_done
054A C216        47       clr wait25_btn_active
054C             48       
054C             49       ; B. KEYPAD DELAY
054C             50   T2_Check_Keypad:
054C 30180B      51       jnb wait25_keypad_active, T2_Check_ADC
054F 054C        52       inc wait25_keypad_cnt
0551 E54C        53       mov a, wait25_keypad_cnt
0553 B41904      54       cjne a, #25, T2_Check_ADC
0556 D219        55       setb wait25_keypad_done
0558 C218        56       clr wait25_keypad_active
055A             57   
055A             58       ; C. ADC DELAY (Thermocouple)
055A             59   T2_Check_ADC:
055A 301A0B      60       jnb wait25_adc_active, T2_Check_LCD
055D 054D        61       inc wait25_adc_cnt
055F E54D        62       mov a, wait25_adc_cnt
0561 B41904      63       cjne a, #25, T2_Check_LCD
0564 D21B        64       setb wait25_adc_done
0566 C21A        65       clr wait25_adc_active
0568             66   
0568             67       ; D. LCD DELAY
0568             68   T2_Check_LCD:
0568 301C0B      69       jnb wait25_lcd_active, T2_Check_Generic
056B 054E        70       inc wait25_lcd_cnt
056D E54E        71       mov a, wait25_lcd_cnt
056F B41904      72       cjne a, #25, T2_Check_Generic
0572 D21D        73       setb wait25_lcd_done
0574 C21C        74       clr wait25_lcd_active
0576             75   
0576             76       ; E. GENERIC DELAY (Used by Wait_25ms in Main)
0576             77   T2_Check_Generic:
0576 30140B      78       jnb wait25_active, Timer2_ISR_done
0579 054F        79       inc wait25_count
057B E54F        80       mov a, wait25_count
057D B41904      81       cjne a, #25, Timer2_ISR_done
0580 D215        82       setb wait25_done      ; Tells Wait_25ms that we are finished
0582 C214        83       clr wait25_active     ; Stop counting
0584             84   
0584             85   Timer2_ISR_done:
0584 D0D0        86       pop psw
0586 D0E0        87       pop acc
0588 32          88       reti
0589             89            
                 -1   $include(..\inc\LCD_4bit_DE10Lite_no_RW.inc) ; LCD related functions and utility macros
0589              1   ;  LCD routines adapted for the DE10-Lite configured as a CV_8052 processor
0589              2   cseg
0589              3   
0589              4   ; When using a 33.333333MHz crystal clock
0589              5   ; one cycle takes 1.0/33.333333MHz = 30 ns
0589              6   
0589              7   ;---------------------------------;
0589              8   ; Wait 40 microseconds            ;
0589              9   ;---------------------------------;
0589             10   Wait40uSec:
0589 C000        11            push AR0
058B 78BE        12            mov R0, #190
058D             13   L0: 
058D 00          14            nop
058E 00          15            nop
058F 00          16            nop
0590 00          17            nop
0591 D8FA        18            djnz R0, L0 ; 1+1+1+1+3 cycles->7*30ns*190=40us
0593 D000        19            pop AR0
0595 22          20       ret
0596             21   
0596             22   ;---------------------------------;
0596             23   ; Wait 'R2' milliseconds          ;
0596             24   ;---------------------------------;
                 25   Wait_Milli_Seconds mac
                 26   	push AR2
                 27   	mov R2, %0
                 28   	lcall ?Wait_Milli_Seconds
                 29   	pop AR2
                 30   endmac
0596             31   
0596             32   ?Wait_Milli_Seconds:
0596 C000        33            push AR0
0598 C001        34            push AR1
059A 7932        35   L3: mov R1, #50
059C 78DF        36   L2: mov R0, #223
059E D8FE        37   L1: djnz R0, L1 ; 3 cycles->3*30ns*250=20.07us
05A0 D9FA        38       djnz R1, L2 ; 20.07us*50=1.004ms
05A2 DAF6        39       djnz R2, L3 ; number of millisecons to wait passed in R2
05A4 D001        40       pop AR1
05A6 D000        41       pop AR0
05A8 22          42       ret
05A9             43            
05A9             44   ;---------------------------------;
05A9             45   ; Toggles the 'E' pin in the LCD  ;
05A9             46   ;---------------------------------;
05A9             47   ELCD_pulse:
05A9 D291        48            setb ELCD_E
05AB 120589      49            lcall Wait40uSec
05AE C291        50            clr ELCD_E
05B0 120589      51       lcall Wait40uSec ; This line is needed in the DE1SoC running an 8051 because it is much faster than the AT89LP51RC2
05B3 22          52       ret
05B4             53   
05B4             54   ;---------------------------------;
05B4             55   ; Writes acc to LCD in 4-bit mode ;
05B4             56   ;---------------------------------;
05B4             57   ELCD_byte:
05B4             58            ; Write high 4 bits first
05B4 A2E7        59            mov c, ACC.7
05B6 9281        60            mov ELCD_D7, c
05B8 A2E6        61            mov c, ACC.6
05BA 9283        62            mov ELCD_D6, c
05BC A2E5        63            mov c, ACC.5
05BE 9285        64            mov ELCD_D5, c
05C0 A2E4        65            mov c, ACC.4
05C2 9287        66            mov ELCD_D4, c
05C4 1205A9      67       lcall ELCD_pulse
05C7             68            ; Write low 4 bits next
05C7 A2E3        69            mov c, ACC.3
05C9 9281        70            mov ELCD_D7, c
05CB A2E2        71            mov c, ACC.2
05CD 9283        72            mov ELCD_D6, c
05CF A2E1        73            mov c, ACC.1
05D1 9285        74            mov ELCD_D5, c
05D3 A2E0        75            mov c, ACC.0
05D5 9287        76            mov ELCD_D4, c
05D7 1205A9      77       lcall ELCD_pulse
05DA 22          78            ret
05DB             79   
05DB             80   ;---------------------------------;
05DB             81   ; Write data to LCD               ;
05DB             82   ;---------------------------------;
                 83   WriteData mac
                 84   	mov a, %0
                 85   	lcall ?WriteData
                 86   endmac
05DB             87            
05DB             88   ?WriteData:
05DB D297        89            setb ELCD_RS
05DD 0205B4      90            ljmp ELCD_byte
05E0             91   
05E0             92   ;---------------------------------;
05E0             93   ; Write command to LCD            ;
05E0             94   ;---------------------------------;
                 95   WriteCommand mac
                 96   	mov a, %0
                 97   	lcall ?WriteCommand
                 98   endmac
05E0             99   
05E0            100   ?WriteCommand:
05E0 C297       101            clr ELCD_RS
05E2 0205B4     102            ljmp ELCD_byte
05E5            103   
05E5            104   ;---------------------------------;
05E5            105   ; Configure LCD in 4-bit mode     ;
05E5            106   ;---------------------------------;
05E5            107   ELCD_4BIT:
05E5 C291       108            clr ELCD_E   ; Resting state of LCD's enable pin is zero
05E7            109            ;clr ELCD_RW  ; RW forced to zero
05E7            110            
05E7            111            ; After power on, let the LCD start up before initializing
05E7 C002       112            push AR2
05E9 7A28       112            mov R2, #40
05EB 120596     112            lcall ?Wait_Milli_Seconds
05EE D002       112            pop AR2
05F0            113            
05F0            114            ; First make sure the LCD is in 8-bit mode and then change to 4-bit mode
05F0 7433       115            mov a, #0x33
05F2 1205E0     115            lcall ?WriteCommand
05F5 7433       116            mov a, #0x33
05F7 1205E0     116            lcall ?WriteCommand
05FA 7432       117            mov a, #0x32
05FC 1205E0     117            lcall ?WriteCommand ; change to 4-bit mode
05FF            118   
05FF            119            ; Configure the LCD
05FF 7428       120            mov a, #0x28
0601 1205E0     120            lcall ?WriteCommand
0604 740C       121            mov a, #0x0c
0606 1205E0     121            lcall ?WriteCommand
0609 7401       122            mov a, #0x01
060B 1205E0     122            lcall ?WriteCommand ;  Clear screen command (takes some time)
060E            123   
060E            124       ;Wait for the clear screen command to finish.
060E C002       125            push AR2
0610 7A02       125            mov R2, #2
0612 120596     125            lcall ?Wait_Milli_Seconds
0615 D002       125            pop AR2
0617 22         126       ret
0618            127   
0618            128   ;---------------------------------;
0618            129   ; Send a constant string to LCD   ;
0618            130   ;---------------------------------;
                131   Send_Constant_String mac
                132   	push dph
                133   	push dpl
                134   	push acc
                135   	mov dptr, %0
                136   	lcall ?Send_Constant_String
                137   	pop acc
                138   	pop dpl
                139   	pop dph
                140   endmac
0618            141   
0618            142   ?Send_Constant_String:
0618 E4         143       clr a
0619 93         144       movc a, @a+dptr
061A 6006       145       jz ?Send_Constant_String_Done
061C 1205DB     146       lcall ?WriteData
061F A3         147       inc dptr
0620 80F6       148       sjmp ?Send_Constant_String
0622            149   ?Send_Constant_String_Done:
0622 22         150       ret  
0623            151   
0623            152   ;---------------------------------;
0623            153   ; Set LCD cursor at row, column   ;
0623            154   ;---------------------------------;
                155   Set_Cursor mac
                156   	push acc
                157   	mov a, #%1
                158   	dec a
                159   	lcall ?Set_Cursor_%0 ; Select column and row
                160   	pop acc
                161   endmac
0623            162   
0623            163   ?Set_Cursor_2:
0623 4440       164            orl a, #01000000B
0625            165   ?Set_Cursor_1:
0625 4480       166            orl a, #10000000B
0627 0205E0     167            ljmp ?WriteCommand ; Select column and row
062A            168   
062A            169   ;---------------------------------;
062A            170   ; Display a BCD number in the LCD ;
062A            171   ;---------------------------------;
                172   Display_BCD mac
                173   	push ar0
                174   	mov r0, %0
                175   	lcall ?Display_BCD
                176   	pop ar0
                177   endmac
062A            178   
062A            179   ?Display_BCD:
062A C0E0       180            push acc
062C            181            ; Write most significant digit
062C E8         182            mov a, r0
062D C4         183            swap a
062E 540F       184            anl a, #0fh
0630 4430       185            orl a, #30h
0632 1205DB     186            lcall ?WriteData
0635            187            ; write least significant digit
0635 E8         188            mov a, r0
0636 540F       189            anl a, #0fh
0638 4430       190            orl a, #30h
063A 1205DB     191            lcall ?WriteData
063D D0E0       192            pop acc
063F 22         193            ret
0640            194   
0640            195   ;------------------------------------;
0640            196   ; Display a char in the LCD          ;
0640            197   ;------------------------------------;
                198   Display_char mac
                199   	push acc
                200   	mov a, %0
                201   	lcall ?WriteData
                202   	pop acc
                203   endmac
0640            204   
0640            379            ;-----------------------------------------------------------------------------------------------;
0640            380   
0640            381   ;-------------------------------------------------------------------------------
0640            382   ; Display Function for 7-segment displays       
0640            383   ;-------------------------------------------------------------------------------
0640            384   ; Look-up table for the 7-seg displays. (Segments are turn on with zero) 
0640            385   T_7seg:
0640 C0F9A4B0   386       DB 0xC0, 0xF9, 0xA4, 0xB0, 0x99        ; 0 TO 4
     99
0645 9282F880   387       DB 0x92, 0x82, 0xF8, 0x80, 0x90        ; 4 TO 9
     90
064A 8883C6A1   388       DB 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E  ; A to F
     868E
0650            389   
0650            390   ; Displays a BCD number pased in R0 in HEX5-HEX0
0650            391   Display_BCD_7_Seg_HEX10:
0650 900640     392       mov dptr, #T_7seg
0653 E8         393       mov a, R0
0654 C4         394       swap a
0655 540F       395       anl a, #0FH
0657 93         396       movc a, @a+dptr
0658 F592       397       mov HEX1, a
065A E8         398       mov a, R0
065B 540F       399       anl a, #0FH
065D 93         400       movc a, @a+dptr
065E F591       401       mov HEX0, a
0660 22         402       ret
0661            403   
0661            404   Display_BCD_7_Seg_HEX32:
0661 900640     405       mov dptr, #T_7seg
0664 E8         406       mov a, R0
0665 C4         407       swap a
0666 540F       408       anl a, #0FH
0668 93         409       movc a, @a+dptr
0669 F594       410       mov HEX3, a
066B E8         411       mov a, R0
066C 540F       412       anl a, #0FH
066E 93         413       movc a, @a+dptr
066F F593       414       mov HEX2, a
0671 22         415       ret
0672            416   
0672            417   Display_BCD_7_Seg_HEX54:
0672 900640     418       mov dptr, #T_7seg
0675 E8         419       mov a, R0
0676 C4         420       swap a
0677 540F       421       anl a, #0FH
0679 93         422       movc a, @a+dptr
067A F58F       423       mov HEX5, a
067C E8         424       mov a, R0
067D 540F       425       anl a, #0FH
067F 93         426       movc a, @a+dptr
0680 F58E       427       mov HEX4, a
0682 22         428       ret
0683            429   
0683            430   ; The 8-bit hex number passed in the accumulator is converted to
0683            431   ; BCD and stored in [R1, R0]
0683            432   Hex_to_bcd_8bit:
0683 75F064     433       mov b, #100
0686 84         434       div ab
0687 F9         435       mov R1, a   ; After dividing, a has the 100s
0688 E5F0       436       mov a, b    ; Remainder is in register b
068A 75F00A     437       mov b, #10
068D 84         438       div ab ; The tens are stored in a, the units are stored in b 
068E C4         439       swap a
068F 54F0       440       anl a, #0xf0
0691 45F0       441       orl a, b
0693 F8         442       mov R0, a
0694 22         443       ret
0695            444   ;-------------------------------------------------------------------------------
0695            445   ; Display Function for LCD                      
0695            446   ;-------------------------------------------------------------------------------
0695            447   LCD_Print_2Digits:
0695 120683     448       lcall Hex_to_bcd_8bit
0698 E8         449       mov a, R0
0699 C4         450       swap a
069A 540F       451       anl a, #0x0F
069C 2430       452       add a, #0x30
069E 1205DB     453       lcall ?WriteData
06A1 E8         454       mov a, R0
06A2 540F       455       anl a, #0x0F
06A4 2430       456       add a, #0x30
06A6 1205DB     457       lcall ?WriteData
06A9 22         458       ret
06AA            459   
06AA            460   LCD_Display_Update_func:
06AA C0E0       461       push acc
06AC            462       
06AC            463       ; ==========================================
06AC            464       ; PART 1: STATIC TEXT (Title)
06AC            465       ; Runs ONLY when the state changes
06AC            466       ; ==========================================
06AC            467       
06AC            468       ; [FIX] "Trampoline" logic for long distance jump
06AC            469       ; If signal is SET (1), we stay here and update.
06AC            470       ; If signal is CLEAR (0), we Long Jump to the Live Update section.
06AC 200C03     471       jb state_change_signal, Do_Static_Update
06AF 0207E8     472       ljmp Check_Live_Update
06B2            473   
06B2            474   Do_Static_Update:
06B2 C20C       475       clr state_change_signal
06B4            476       
06B4            477       ; State Changed: Clear Screen and Write Title
06B4 120FFA     478       lcall Clear_Screen_Func
06B7 E568       479       mov a, Control_FSM_state
06B9            480       
06B9            481       ; State 0: Welcome
06B9 B4003B     482       cjne a, #0, LCD_Check_1
06BC C0E0       483            push acc
06BE 7401       483            mov a, #1
06C0 14         483            dec a
06C1 120625     483            lcall ?Set_Cursor_1 ; Select column and row
06C4 D0E0       483            pop acc
06C6 C083       484            push dph
06C8 C082       484            push dpl
06CA C0E0       484            push acc
06CC 900330     484            mov dptr, #String_state0_1
06CF 120618     484            lcall ?Send_Constant_String
06D2 D0E0       484            pop acc
06D4 D082       484            pop dpl
06D6 D083       484            pop dph
06D8 C0E0       485            push acc
06DA 7401       485            mov a, #1
06DC 14         485            dec a
06DD 120623     485            lcall ?Set_Cursor_2 ; Select column and row
06E0 D0E0       485            pop acc
06E2 C083       486            push dph
06E4 C082       486            push dpl
06E6 C0E0       486            push acc
06E8 900340     486            mov dptr, #String_state0_2
06EB 120618     486            lcall ?Send_Constant_String
06EE D0E0       486            pop acc
06F0 D082       486            pop dpl
06F2 D083       486            pop dph
06F4 0207E5     487       ljmp LCD_Done_Bridge ; Exit
06F7            488   
06F7            489   LCD_Check_1: ; Setup
06F7 B4011F     490       cjne a, #1, LCD_Check_2
06FA C0E0       491            push acc
06FC 7401       491            mov a, #1
06FE 14         491            dec a
06FF 120625     491            lcall ?Set_Cursor_1 ; Select column and row
0702 D0E0       491            pop acc
0704 C083       492            push dph
0706 C082       492            push dpl
0708 C0E0       492            push acc
070A 9003A5     492            mov dptr, #String_state1
070D 120618     492            lcall ?Send_Constant_String
0710 D0E0       492            pop acc
0712 D082       492            pop dpl
0714 D083       492            pop dph
0716 0207E5     493       ljmp LCD_Done_Bridge
0719            494   
0719            495   LCD_Check_2: ; Ramp to Soak
0719 B4021F     496       cjne a, #2, LCD_Check_3
071C C0E0       497            push acc
071E 7401       497            mov a, #1
0720 14         497            dec a
0721 120625     497            lcall ?Set_Cursor_1 ; Select column and row
0724 D0E0       497            pop acc
0726 C083       498            push dph
0728 C082       498            push dpl
072A C0E0       498            push acc
072C 9003EC     498            mov dptr, #String_state2
072F 120618     498            lcall ?Send_Constant_String
0732 D0E0       498            pop acc
0734 D082       498            pop dpl
0736 D083       498            pop dph
0738 020808     499       ljmp LCD_Update_Temp_Value ; Draw Temp immediately!
073B            500   
073B            501   LCD_Check_3: ; Soak
073B B4031F     502       cjne a, #3, LCD_Check_4
073E C0E0       503            push acc
0740 7401       503            mov a, #1
0742 14         503            dec a
0743 120625     503            lcall ?Set_Cursor_1 ; Select column and row
0746 D0E0       503            pop acc
0748 C083       504            push dph
074A C082       504            push dpl
074C C0E0       504            push acc
074E 9003FC     504            mov dptr, #String_state3
0751 120618     504            lcall ?Send_Constant_String
0754 D0E0       504            pop acc
0756 D082       504            pop dpl
0758 D083       504            pop dph
075A 020808     505       ljmp LCD_Update_Temp_Value
075D            506   
075D            507   LCD_Check_4: ; Ramp to Peak
075D B4041F     508       cjne a, #4, LCD_Check_5
0760 C0E0       509            push acc
0762 7401       509            mov a, #1
0764 14         509            dec a
0765 120625     509            lcall ?Set_Cursor_1 ; Select column and row
0768 D0E0       509            pop acc
076A C083       510            push dph
076C C082       510            push dpl
076E C0E0       510            push acc
0770 90040C     510            mov dptr, #String_state4
0773 120618     510            lcall ?Send_Constant_String
0776 D0E0       510            pop acc
0778 D082       510            pop dpl
077A D083       510            pop dph
077C 020808     511       ljmp LCD_Update_Temp_Value
077F            512   
077F            513   LCD_Check_5: ; Reflow
077F B4051F     514       cjne a, #5, LCD_Check_6
0782 C0E0       515            push acc
0784 7401       515            mov a, #1
0786 14         515            dec a
0787 120625     515            lcall ?Set_Cursor_1 ; Select column and row
078A D0E0       515            pop acc
078C C083       516            push dph
078E C082       516            push dpl
0790 C0E0       516            push acc
0792 90041C     516            mov dptr, #String_state5
0795 120618     516            lcall ?Send_Constant_String
0798 D0E0       516            pop acc
079A D082       516            pop dpl
079C D083       516            pop dph
079E 020808     517       ljmp LCD_Update_Temp_Value
07A1            518   
07A1            519   LCD_Check_6: ; Cooling
07A1 B4061F     520       cjne a, #6, LCD_Check_7
07A4 C0E0       521            push acc
07A6 7401       521            mov a, #1
07A8 14         521            dec a
07A9 120625     521            lcall ?Set_Cursor_1 ; Select column and row
07AC D0E0       521            pop acc
07AE C083       522            push dph
07B0 C082       522            push dpl
07B2 C0E0       522            push acc
07B4 90042C     522            mov dptr, #String_state6
07B7 120618     522            lcall ?Send_Constant_String
07BA D0E0       522            pop acc
07BC D082       522            pop dpl
07BE D083       522            pop dph
07C0 020808     523       ljmp LCD_Update_Temp_Value
07C3            524   
07C3            525   LCD_Check_7: ; Done
07C3            526       ; [FIX] Check distance safe logic for State 7
07C3 B4071F     527       cjne a, #7, LCD_Done_Bridge ; If not 7, we are done
07C6 C0E0       528            push acc
07C8 7401       528            mov a, #1
07CA 14         528            dec a
07CB 120625     528            lcall ?Set_Cursor_1 ; Select column and row
07CE D0E0       528            pop acc
07D0 C083       529            push dph
07D2 C082       529            push dpl
07D4 C0E0       529            push acc
07D6 90043C     529            mov dptr, #String_state7
07D9 120618     529            lcall ?Send_Constant_String
07DC D0E0       529            pop acc
07DE D082       529            pop dpl
07E0 D083       529            pop dph
07E2 0207E5     530       ljmp LCD_Done_Bridge
07E5            531   
07E5            532   ; Local bridge to reach the far-away LCD_Done
07E5            533   LCD_Done_Bridge:
07E5 020869     534       ljmp LCD_Done
07E8            535   
07E8            536   ; ==========================================
07E8            537   ; PART 2: DYNAMIC VALUES (Temperature)
07E8            538   ; Runs every time 'one_second_flag' is set
07E8            539   ; ==========================================
07E8            540   Check_Live_Update:
07E8 3001FA     541       jnb one_second_flag, LCD_Done_Bridge
07EB C201       542       clr one_second_flag
07ED            543       
07ED            544       ; Only update temp for States 2, 3, 4, 5, 6
07ED E568       545       mov a, Control_FSM_state
07EF B40202     546       cjne a, #2, Check_St3
07F2 8014       547       sjmp LCD_Update_Temp_Value
07F4            548   Check_St3:
07F4 B40302     549       cjne a, #3, Check_St4
07F7 800F       550       sjmp LCD_Update_Temp_Value
07F9            551   Check_St4:
07F9 B40402     552       cjne a, #4, Check_St5
07FC 800A       553       sjmp LCD_Update_Temp_Value
07FE            554   Check_St5:
07FE B40502     555       cjne a, #5, Check_St6
0801 8005       556       sjmp LCD_Update_Temp_Value
0803            557   Check_St6:
0803 B40663     558       cjne a, #6, LCD_Done
0806 8000       559       sjmp LCD_Update_Temp_Value
0808            560   
0808            561   ; --- HELPER: Prints "XXX C" on Line 2 ---
0808            562   LCD_Update_Temp_Value:
0808 C0E0       563            push acc
080A 7401       563            mov a, #1
080C 14         563            dec a
080D 120623     563            lcall ?Set_Cursor_2 ; Select column and row
0810 D0E0       563            pop acc
0812            564       
0812            565       ; Convert current_temp to BCD
0812 853F32     566       mov x, current_temp
0815 854033     567       mov x+1, current_temp+1
0818 854134     568       mov x+2, current_temp+2
081B 854235     569       mov x+3, current_temp+3
081E 12002E     570       lcall hex2bcd
0821            571   
0821            572       ; Update HEX2-HEX0 with temperature
0821 12086C     573       lcall Update_HEX_Temp
0824            574       
0824            575       ; Print Hundreds
0824 E53B       576       mov a, bcd+1
0826 540F       577       anl a, #0x0F
0828 2430       578       add a, #0x30
082A 1205DB     579       lcall ?WriteData
082D            580       
082D            581       ; Print Tens
082D E53A       582       mov a, bcd+0
082F C4         583       swap a
0830 540F       584       anl a, #0x0F
0832 2430       585       add a, #0x30
0834 1205DB     586       lcall ?WriteData
0837            587       
0837            588       ; Print Ones
0837 E53A       589       mov a, bcd+0
0839 540F       590       anl a, #0x0F
083B 2430       591       add a, #0x30
083D 1205DB     592       lcall ?WriteData
0840            593       
0840            594       ; Print 'C'
0840 7443       595       mov a, #'C'
0842 1205DB     596       lcall ?WriteData
0845            597       
0845            598       ; Clear remaining line space (prevents garbage)
0845 7420       599       mov a, #' '
0847 1205DB     600       lcall ?WriteData
084A 1205DB     601       lcall ?WriteData
084D            602   
084D            603       ; Print time MM:SS at bottom right
084D C0E0       604            push acc
084F 740C       604            mov a, #12
0851 14         604            dec a
0852 120623     604            lcall ?Set_Cursor_2 ; Select column and row
0855 D0E0       604            pop acc
0857 E531       605       mov a, current_time_minute
0859 120695     606       lcall LCD_Print_2Digits
085C 743A       607       mov a, #':'
085E 1205DB     608       lcall ?WriteData
0861 E530       609       mov a, current_time_sec
0863 120695     610       lcall LCD_Print_2Digits
0866            611   
0866            612       ; Mirror temp to serial (PuTTY/screen)
0866 1204C5     613       lcall Serial_Send_Temp_Line
0869            614   
0869            615   LCD_Done:
0869 D0E0       616       pop acc
086B 22         617       ret
086C            618   ;---------------------------------------------------------
086C            619   
086C            620   ;-------------------------------------------------------------------------------
086C            621   ; Update HEX2-HEX0 with temperature (3 digits)
086C            622   ;-------------------------------------------------------------------------------
086C            623   Update_HEX_Temp:
086C 900640     624       mov dptr, #T_7seg
086F            625       ; Hundreds -> HEX2
086F E53B       626       mov a, bcd+1
0871 540F       627       anl a, #0x0F
0873 93         628       movc a, @a+dptr
0874 F593       629       mov HEX2, a
0876            630       ; Tens -> HEX1
0876 E53A       631       mov a, bcd+0
0878 C4         632       swap a
0879 540F       633       anl a, #0x0F
087B 93         634       movc a, @a+dptr
087C F592       635       mov HEX1, a
087E            636       ; Ones -> HEX0
087E E53A       637       mov a, bcd+0
0880 540F       638       anl a, #0x0F
0882 93         639       movc a, @a+dptr
0883 F591       640       mov HEX0, a
0885 22         641       ret
0886            642   
0886            643   KEY1_DEB:
0886            644   ;non-blocking state machine for KEY1 debounce
0886 E566       645       mov a, KEY1_DEB_state
0888            646   KEY1_DEB_state0:
0888 B4000A     647       cjne a, #0, KEY1_DEB_state1
088B 20F92D     648       jb KEY.1, KEY1_DEB_done
088E 756400     649       mov KEY1_DEB_timer, #0
0891 0566       650       inc KEY1_DEB_state
0893 8026       651       sjmp KEY1_DEB_done
0895            652   KEY1_DEB_state1:
0895 B40109     653       cjne a, #1, KEY1_DEB_state2
0898            654       ; this is the debounce state
0898 E564       655       mov a, KEY1_DEB_timer
089A B4321E     656       cjne a, #50, KEY1_DEB_done ; 50 ms passed?
089D 0566       657       inc KEY1_DEB_state
089F 801A       658       sjmp KEY1_DEB_done  
08A1            659   KEY1_DEB_state2:
08A1 B4020C     660       cjne a, #2, KEY1_DEB_state3
08A4 20F904     661       jb KEY.1, KEY1_DEB_state2b
08A7 0566       662       inc KEY1_DEB_state
08A9 8010       663       sjmp KEY1_DEB_done  
08AB            664   KEY1_DEB_state2b:
08AB 756600     665       mov KEY1_DEB_state, #0
08AE 800B       666       sjmp KEY1_DEB_done
08B0            667   KEY1_DEB_state3:
08B0 B40308     668       cjne a, #3, KEY1_DEB_done
08B3 30F905     669       jnb KEY.1, KEY1_DEB_done
08B6 D20D       670       setb Key1_flag ; Suscesfully detected a valid KEY1 press/release
08B8 756600     671       mov KEY1_DEB_state, #0  
08BB            672   KEY1_DEB_done:
08BB 22         673       ret
08BC            674   ; ------------------------------------------------------------------------------
08BC            675   ; Non-blocking FSM for the one second counter
08BC            676   ;-------------------------------------------------------------------------------
08BC            677   SEC_FSM:
08BC E567       678       mov a, SEC_FSM_state
08BE            679   SEC_FSM_state0:
08BE B4000C     680       cjne a, #0, SEC_FSM_state1
08C1 E565       681       mov a, SEC_FSM_timer
08C3 B4FA4B     682       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08C6 756500     683       mov SEC_FSM_timer, #0
08C9 0567       684       inc SEC_FSM_state
08CB 8044       685       sjmp SEC_FSM_done
08CD            686   SEC_FSM_state1: 
08CD B4010E     687       cjne a, #1, SEC_FSM_state2
08D0 D2E9       688       setb LEDRA.1
08D2 E565       689       mov a, SEC_FSM_timer
08D4 B4FA3A     690       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08D7 756500     691       mov SEC_FSM_timer, #0
08DA 0567       692       inc SEC_FSM_state
08DC 8033       693       sjmp SEC_FSM_done
08DE            694   SEC_FSM_state2: 
08DE B4020E     695       cjne a, #2, SEC_FSM_state3
08E1 D2EA       696       setb LEDRA.2
08E3 E565       697       mov a, SEC_FSM_timer
08E5 B4FA29     698       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08E8 756500     699       mov SEC_FSM_timer, #0
08EB 0567       700       inc SEC_FSM_state
08ED 8022       701       sjmp SEC_FSM_done
08EF            702   SEC_FSM_state3: 
08EF B4031F     703       cjne a, #3, SEC_FSM_done
08F2 D2EB       704       setb LEDRA.3
08F4 E565       705       mov a, SEC_FSM_timer
08F6 B4FA18     706       cjne a, #250, SEC_FSM_done ; 250 ms passed?
08F9 756500     707       mov SEC_FSM_timer, #0
08FC 756700     708       mov SEC_FSM_state, #0
08FF            709       
08FF            710       ; --- 1 Second has passed! ---
08FF D201       711       setb one_second_flag
0901            712       
0901 E530       713       mov a, current_time_sec
0903 B43B07     714       cjne a, #59, IncCurrentTimeSec 
0906            715       
0906            716       ; --- FIX: 59s -> 0s AND Increment Minute ---
0906 753000     717       mov current_time_sec, #0
0909 0531       718       inc current_time_minute    ; <--- YOU WERE MISSING THIS!
090B            719       ; -------------------------------------------
090B            720       
090B 8004       721       sjmp SEC_FSM_done
090D            722   
090D            723   IncCurrentTimeSec:
090D 0530       724       inc current_time_sec
090F B2E8       725       cpl LEDRA.0 
0911            726   SEC_FSM_done:
0911 22         727       ret
0912            728   ;-------------------------------------------------------------------------------
0912            729   ; PWM
0912            730   ; generate pwm signal for the ssr ; 1.5s period for the pwm signal; with 1 watt 
0912            731   ; clarity for the pwm signal; input parameter: power_output; used buffers: x, y
0912            732   ; ------------------------------------------------------------------------------
0912            733   PWM_Wave: ; call pwm generator when 1 ms flag is triggered
0912 100202     734       jbc one_ms_pwm_flag, pwm_wave_generator
0915 8071       735       sjmp end_pwm_generator
0917            736   
0917            737   pwm_wave_generator:
0917 C200       738       clr mf
0919            739       ; move pwm counter value into x for comparison purpose
0919 856032     740       mov x, pwm_counter
091C 856133     741       mov x+1, pwm_counter+1
091F 856234     742       mov x+2, pwm_counter+2
0922 856335     743       mov x+3, pwm_counter+3
0925            744   
0925 7536DB     745            mov y+0, #low (PWM_PERIOD % 0x10000) 
0928 753705     745            mov y+1, #high(PWM_PERIOD % 0x10000) 
092B 753800     745            mov y+2, #low (PWM_PERIOD / 0x10000) 
092E 753900     745            mov y+3, #high(PWM_PERIOD / 0x10000) 
0931            746   
0931            747       ; compare x(pwm_counter) and y(1499) if x=y, wrap x back to 0; else 
0931            748       ; increase x by 1
0931 120152     749       lcall x_eq_y 
0934 20001D     750       jb mf, wrap_pwm_counter
0937            751       ; x not equal 1499, increment by 1
0937 753601     752            mov y+0, #low (1 % 0x10000) 
093A 753700     752            mov y+1, #high(1 % 0x10000) 
093D 753800     752            mov y+2, #low (1 / 0x10000) 
0940 753900     752            mov y+3, #high(1 / 0x10000) 
0943 1200D3     753       lcall add32
0946            754       ; update pwm_counter
0946 853260     755       mov pwm_counter, x
0949 853361     756       mov pwm_counter+1, x+1
094C 853462     757       mov pwm_counter+2, x+2
094F 853563     758       mov pwm_counter+3, x+3
0952 8018       759       sjmp set_pwm
0954            760   
0954            761   wrap_pwm_counter:
0954            762       ; x equal 1499, wrap to 0
0954 753200     763            mov x+0, #low (0 % 0x10000) 
0957 753300     763            mov x+1, #high(0 % 0x10000) 
095A 753400     763            mov x+2, #low (0 / 0x10000) 
095D 753500     763            mov x+3, #high(0 / 0x10000) 
0960 853260     764       mov pwm_counter, x
0963 853361     765       mov pwm_counter+1, x+1
0966 853462     766       mov pwm_counter+2, x+2
0969 853563     767       mov pwm_counter+3, x+3
096C            768   
096C            769   set_pwm:
096C            770       ; compare with power_output, if pwm counter smaller than power_output, 
096C            771       ; set pwm pin high; else set pwm pin low load y with power output value
096C 855C36     772       mov y, power_output
096F 855D37     773       mov y+1, power_output+1
0972 855E38     774       mov y+2, power_output+2
0975 855F39     775       mov y+3, power_output+3
0978            776   
0978            777       ; compare x(pwm counter) with y(power output)
0978 12011A     778       lcall x_lt_y
097B 200006     779       jb mf, set_pwm_high ; set pwm pin high if pwm counter smaller than power 
097E            780       ;output set pwm pin low if pwm counter greater than power output
097E C293       781       clr PWM_OUT
0980 C2EC       782       clr LEDRA.4
0982 8004       783       sjmp end_pwm_generator
0984            784   
0984            785   set_pwm_high:
0984 D293       786       setb PWM_OUT
0986 D2EC       787       setb LEDRA.4
0988            788   
0988            789   end_pwm_generator:
0988 22         790       ret
0989            791   
0989            792   ;-------------------------------------------------------------------------------;
0989            793   ; Temp_Compare
0989            794   ; Checks if we have reached the user's target temperatures.
0989            795   ; Sets 'soak_temp_reached' if current_temp >= soak_temp
0989            796   ; Sets 'reflow_temp_reached' if current_temp >= reflow_temp
0989            797   ;-------------------------------------------------------------------------------;
0989            798   Temp_Compare:
0989            799       ; Reset flags initially
0989 C203       800       clr soak_temp_reached
098B C204       801       clr reflow_temp_reached
098D            802   
098D C0E0       803       push acc
098F C0D0       804       push psw
0991 C000       805       push AR0
0993 C001       806       push AR1
0995 C002       807       push AR2
0997            808       
0997            809       ; --- 1. CHECK SOAK TEMP ---
0997            810       ; Copy current_temp to X
0997 783F       811       mov R0, #current_temp
0999 7932       812       mov R1, #x
099B 120A0F     813       lcall Copy4_Bytes_R0_to_R1
099E            814   
099E            815       ; Copy soak_temp to Y
099E 7843       816       mov R0, #soak_temp
09A0 7936       817       mov R1, #y
09A2 120A0F     818       lcall Copy4_Bytes_R0_to_R1
09A5            819   
09A5            820       ; Compare: Is X (Current) < Y (Target)?
09A5 12011A     821       lcall x_lt_y
09A8 200002     822       jb mf, Check_Reflow_Threshold ; If Current < Target, jump (Flag stays 0)
09AB            823       
09AB            824       ; If we are here, Current >= Target
09AB D203       825       setb soak_temp_reached
09AD            826   
09AD            827   Check_Reflow_Threshold:
09AD            828       ; --- 2. CHECK REFLOW TEMP ---
09AD            829       ; Copy current_temp to X (Need to reload X because math32 destroys it)
09AD 783F       830       mov R0, #current_temp
09AF 7932       831       mov R1, #x
09B1 120A0F     832       lcall Copy4_Bytes_R0_to_R1
09B4            833   
09B4            834       ; Copy reflow_temp to Y
09B4 7847       835       mov R0, #reflow_temp
09B6 7936       836       mov R1, #y
09B8 120A0F     837       lcall Copy4_Bytes_R0_to_R1
09BB            838   
09BB            839       ; Compare
09BB 12011A     840       lcall x_lt_y
09BE 200002     841       jb mf, Temp_Compare_Done
09C1            842       
09C1            843       ; If Current >= Target
09C1 D204       844       setb reflow_temp_reached
09C3            845   
09C3            846   Temp_Compare_Done:
09C3 D002       847       pop AR2
09C5 D001       848       pop AR1
09C7 D000       849       pop AR0
09C9 D0D0       850       pop psw
09CB D0E0       851       pop acc
09CD 22         852       ret
09CE            853   ;-------------------------------------------------------------------------------;
09CE            854   ; Time_Compare
09CE            855   ;
09CE            856   ; PURPOSE:
09CE            857   ;   Compare the elapsed time against soak and reflow
09CE            858   ;   time limits.
09CE            859   ;
09CE            860   ; BEHAVIOR:
09CE            861   ;   - If current_time >= soak_time   if soak_time_reached    = 1
09CE            862   ;   - If current_time >= reflow_time if reflow_time_reached = 1
09CE            863   ;
09CE            864   ; NOTES:
09CE            865   ;   - Time values are treated as 32-bit UNSIGNED numbers
09CE            866   ;     (e.g., milliseconds or seconds).
09CE            867   ;   - Uses the SAME compare logic as Temp_Compare.
09CE            868   ;   - This routine ONLY SETS flags.
09CE            869   ;
09CE            870   ; EXPECTED VARIABLES:
09CE            871   ;   current_time[4], soak_time[4], reflow_time[4]
09CE            872   ;   x[4], y[4]
09CE            873   ;   mf, soak_time_reached, reflow_time_reached
09CE            874   ;-------------------------------------------------------------------------------;
09CE            875   Time_Compare:
09CE C0E0       876       push acc
09D0 C0D0       877       push psw
09D2 C000       878       push AR0
09D4 C001       879       push AR1
09D6 C002       880       push AR2
09D8            881   
09D8            882   ; Check: current_time >= soak_time ?
09D8            883       ; Copy current_time of x
09D8 7850       884       mov  R0, #current_time
09DA 7932       885       mov  R1, #x
09DC 120A0F     886       lcall Copy4_Bytes_R0_to_R1
09DF            887   
09DF            888       ; Copy soak_time of y
09DF 7854       889       mov  R0, #soak_time
09E1 7936       890       mov  R1, #y
09E3 120A0F     891       lcall Copy4_Bytes_R0_to_R1
09E6            892   
09E6            893       ; Compare elapsed time vs soak time
09E6 12011A     894       lcall x_lt_y
09E9 200002     895       jb   mf, Time_Soak_NotReached
09EC D206       896       setb soak_time_reached
09EE            897   
09EE            898   ; Check: current_time >= reflow_time ?
09EE            899   Time_Soak_NotReached:
09EE            900       ; Copy current_time of x
09EE 7850       901       mov  R0, #current_time
09F0 7932       902       mov  R1, #x
09F2 120A0F     903       lcall Copy4_Bytes_R0_to_R1
09F5            904   
09F5            905       ; Copy reflow_time of y
09F5 7858       906       mov  R0, #reflow_time
09F7 7936       907       mov  R1, #y
09F9 120A0F     908       lcall Copy4_Bytes_R0_to_R1
09FC            909   
09FC            910       ; Compare elapsed time vs reflow time
09FC 12011A     911       lcall x_lt_y
09FF 200002     912       jb   mf, Time_Reflow_NotReached
0A02 D207       913       setb reflow_time_reached
0A04            914   
0A04            915   Time_Reflow_NotReached:
0A04 D002       916       pop  AR2
0A06 D001       917       pop  AR1
0A08 D000       918       pop  AR0
0A0A D0D0       919       pop  psw
0A0C D0E0       920       pop  acc
0A0E 22         921       ret
0A0F            922   
0A0F            923   ;-------------------------------------------------------------------------------;
0A0F            924   ; Copy4_Bytes_R0_to_R1
0A0F            925   ;
0A0F            926   ; PURPOSE:
0A0F            927   ;   Utility routine to copy a 32-bit value (4 bytes)
0A0F            928   ;   from one memory location to another.
0A0F            929   ;
0A0F            930   ; INPUTS:
0A0F            931   ;   R0 st source address
0A0F            932   ;   R1 at destination address
0A0F            933   ;
0A0F            934   ; USES:
0A0F            935   ;   R2 as loop counter
0A0F            936   ;
0A0F            937   ; EXAMPLE:
0A0F            938   ;   mov R0, #current_temp
0A0F            939   ;   mov R1, #x
0A0F            940   ;   lcall Copy4_Bytes_R0_to_R1
0A0F            941   ;-------------------------------------------------------------------------------;
0A0F            942   Copy4_Bytes_R0_to_R1:
0A0F 7A04       943       mov  R2, #4
0A11            944   Copy4_Loop:
0A11 E6         945       mov  a, @R0
0A12 F7         946       mov  @R1, a
0A13 08         947       inc  R0
0A14 09         948       inc  R1
0A15 DAFA       949       djnz R2, Copy4_Loop
0A17 22         950       ret
0A18            951   
0A18            952   ;-------------------------------------------------------------------------------;
0A18            953   ; Abort condition safety check Temperature time
0A18            954   ;
0A18            955   ; PURPOSE:
0A18            956   ;   Automatic cycle termination on error:
0A18            957   ;   Abort if oven fails to reach at least 50C in first 60s.
0A18            958   ;
0A18            959   ; TRIP CONDITION:
0A18            960   ;   if (current_time >= 60s) AND (current_temp < 50C)
0A18            961   ;       -> set tc_missing_abort
0A18            962   ;       -> set stop_signal
0A18            963   ;
0A18            964   ; ASSUMPTIONS:
0A18            965   ;   - current_time is in SECONDS (32-bit, little-endian)
0A18            966   ;   - current_temp is in DEGREES C (integer, 32-bit, little-endian)
0A18            967   ;
0A18            968   ;   the Load_Y constants accordingly.
0A18            969   ;-------------------------------------------------------------------------------;
0A18            970   Safety_Check_TC:
0A18 C0E0       971       push acc
0A1A C0D0       972       push psw
0A1C C000       973       push AR0
0A1E C001       974       push AR1
0A20 C002       975       push AR2
0A22            976   
0A22            977       ; ---------------------------------------------------------
0A22            978       ; [FIX] GATEKEEPER: IGNORE UNLESS IN STATE 2 (RAMP TO SOAK)
0A22            979       ; ---------------------------------------------------------
0A22 E568       980       mov a, Control_FSM_state
0A24 B40202     981       cjne a, #2, Safety_TC_Exit_Bridge ; If State != 2, skip everything
0A27 8003       982       sjmp Safety_Logic_Proceed         ; If State == 2, do the check
0A29            983   
0A29            984       Safety_TC_Exit_Bridge:
0A29 020A77     985           ljmp Safety_TC_Done               ; Jump to the end
0A2C            986   
0A2C            987       Safety_Logic_Proceed:
0A2C            988           ; If already aborted or startup window closed, do nothing
0A2C 200E48     989           jb   tc_missing_abort, Safety_TC_Done
0A2F 300F45     990           jnb  tc_startup_window, Safety_TC_Done
0A32            991   
0A32            992       ; Check: current_time >= 60 ?
0A32 7850       993       mov  R0, #current_time
0A34 7932       994       mov  R1, #x
0A36 120A0F     995       lcall Copy4_Bytes_R0_to_R1
0A39            996   
0A39 75363C     997            mov y+0, #low (60 % 0x10000) 
0A3C 753700     997            mov y+1, #high(60 % 0x10000) 
0A3F 753800     997            mov y+2, #low (60 / 0x10000) 
0A42 753900     997            mov y+3, #high(60 / 0x10000) 
0A45 12011A     998       lcall x_lt_y
0A48 2000DE     999       jb   mf, Safety_TC_Exit_Bridge        ; still < 60s  keep waiting
0A4B           1000   
0A4B           1001       ; We reached 60s: close the startup window so it won't re-check later
0A4B C20F      1002       clr  tc_startup_window
0A4D           1003   
0A4D           1004       ; Now check: current_temp < 50 ?
0A4D 783F      1005       mov  R0, #current_temp
0A4F 7932      1006       mov  R1, #x
0A51 120A0F    1007       lcall Copy4_Bytes_R0_to_R1
0A54           1008   
0A54 753632    1009            mov y+0, #low (50 % 0x10000) 
0A57 753700    1009            mov y+1, #high(50 % 0x10000) 
0A5A 753800    1009            mov y+2, #low (50 / 0x10000) 
0A5D 753900    1009            mov y+3, #high(50 / 0x10000) 
0A60 12011A    1010       lcall x_lt_y
0A63 3000C3    1011       jnb  mf, Safety_TC_Exit_Bridge        ; temp >= 50  pass
0A66           1012   
0A66           1013       ; FAIL: at 60s, still below 50C  abort
0A66 C293      1014       clr  PWM_OUT
0A68 D20E      1015       setb tc_missing_abort
0A6A D209      1016       setb stop_signal
0A6C 120A8C    1017            lcall Beep_Ten
0A6F           1018       ; 3. Force FSM to State 0 (Welcome)
0A6F 756800    1019       mov Control_FSM_state, #0
0A72           1020       
0A72           1021       ; 4. Force UI to State 0 (Home Screen)
0A72 756900    1022       mov Current_State, #0
0A75           1023       
0A75           1024       ; 5. Trigger Screen Refresh
0A75 D20C      1025       setb state_change_signal ; Tell loop to redraw "Welcome"
0A77           1026   
0A77           1027   Safety_TC_Done:
0A77 D002      1028       pop  AR2
0A79 D001      1029       pop  AR1
0A7B D000      1030       pop  AR0
0A7D D0D0      1031       pop  psw
0A7F D0E0      1032       pop  acc
0A81 22        1033       ret
0A82           1034   
0A82           1035   ; ============================================================
0A82           1036   ; BUZZER STARTUP FUNCTIONS
0A82           1037   ; ============================================================
0A82           1038   
0A82           1039   Beep_Once:
0A82 757301    1040       mov beep_count, #1
0A85 800A      1041       sjmp Beep_Start
0A87           1042   
0A87           1043   Beep_Five:
0A87 757305    1044       mov beep_count, #5
0A8A 8005      1045       sjmp Beep_Start
0A8C           1046   
0A8C           1047   Beep_Ten:
0A8C 75730A    1048       mov beep_count, #10
0A8F 8000      1049       sjmp Beep_Start      ; [FIX] Added explicit jump for safety
0A91           1050   
0A91           1051   Beep_Start:
0A91 C28C      1052       clr TR0              ; [FIX] Stop timer briefly to reset cleanly
0A93 757401    1053       mov beep_state, #1   ; Set State to ON
0A96 757500    1054       mov beep_tmr, #0     ; Reset Timer High Byte
0A99 757600    1055       mov beep_tmr+1, #0   ; Reset Timer Low Byte
0A9C D2A9      1056       setb ET0             ; [FIX] Ensure Interrupt is enabled
0A9E D28C      1057       setb TR0             ; START the 2kHz tone
0AA0 22        1058       ret
0AA1           1059   ;============================================================
0AA1           1060   
0AA1           1061   ;============================================================
0AA1           1062   ; Buzzer beep Task 
0AA1           1063   ; Purpose: beeps, holds, stop
0AA1           1064   ; Buzzer task:
0AA1           1065   ; Beep once when state changes
0AA1           1066   ; Beep five times if finished
0AA1           1067   ; Beep ten times if meets error
0AA1           1068   ;============================================================
0AA1           1069   
0AA1           1070   Beep_Task:
0AA1 301335    1071       jnb one_ms_beep_flag, Beep_Done
0AA4 C213      1072       clr one_ms_beep_flag
0AA6           1073   
0AA6 E574      1074       mov a, beep_state
0AA8 602F      1075       jz Beep_Done
0AAA           1076   
0AAA           1077   ; ---- increment 16-bit timer ----
0AAA 0575      1078       inc beep_tmr
0AAC E575      1079       mov a, beep_tmr
0AAE 7002      1080       jnz Beep_Check
0AB0 0576      1081       inc beep_tmr+1
0AB2           1082   
0AB2           1083   Beep_Check:
0AB2           1084       ; [FIX] FUZZY TIMER CHECK
0AB2           1085       ; Check if High Byte is non-zero (Time >= 256ms)
0AB2 E576      1086       mov a, beep_tmr+1
0AB4 6023      1087       jz Beep_Done        ; If 0, keep beeping
0AB6           1088   
0AB6           1089       ; --- Time Limit Reached ---
0AB6 757500    1090       mov beep_tmr, #0    ; Reset timer
0AB9 757600    1091       mov beep_tmr+1, #0
0ABC           1092   
0ABC E574      1093       mov a, beep_state
0ABE B40106    1094       cjne a, #1, Beep_Off_State
0AC1           1095   
0AC1           1096       ; State was 1 (ON) -> Turn OFF
0AC1 C28C      1097       clr TR0             ; Hardware Silence
0AC3 757402    1098       mov beep_state, #2  ; Set State to OFF (Pause)
0AC6 22        1099       ret
0AC7           1100   
0AC7           1101   Beep_Off_State:
0AC7           1102   ; ---- OFF finished -> decrement count / next ON ----
0AC7 1573      1103       dec beep_count
0AC9 E573      1104       mov a, beep_count
0ACB 6006      1105       jz  Beep_Stop
0ACD           1106   
0ACD 757401    1107       mov beep_state, #1
0AD0 D28C      1108       setb TR0
0AD2 22        1109       ret
0AD3           1110   
0AD3           1111   Beep_Stop:
0AD3 C28C      1112       clr TR0
0AD5 757400    1113       mov beep_state, #0
0AD8 22        1114       ret
0AD9           1115   
0AD9           1116   Beep_Done:
0AD9 22        1117       ret
0ADA           1118   ;==================================================================
0ADA           1119   
0ADA           1120   ;-------------------------------------------------------------------------------;
0ADA           1121   ; Main Control FSM for the entire process
0ADA           1122   ;-------------------------------------------------------------------------------;
0ADA           1123   ;-------------------------------------------------------------------------------;
0ADA           1124   ; FSM LOGIC (Button Logic Fixed)
0ADA           1125   ;-------------------------------------------------------------------------------;
0ADA           1126   Control_FSM:
0ADA E568      1127       mov a, Control_FSM_state
0ADC 8005      1128       sjmp Control_FSM_state0
0ADE           1129   
0ADE           1130   Control_FSM_state0_a:
0ADE 756800    1131       mov Control_FSM_state, #0
0AE1 D20C      1132       setb state_change_signal
0AE3           1133            
0AE3           1134   Control_FSM_state0:
0AE3 B40015    1135       cjne a, #0, Control_FSM_state1
0AE6 209005    1136       jb P1.0, Control_FSM_done_bridge ; If Button High (Not Pressed), Exit
0AE9 121024    1137       lcall Wait_For_P1_0_Release      ; If Low (Pressed), Wait & Proceed
0AEC 8001      1138       sjmp Control_FSM_state1_a  
0AEE           1139       
0AEE           1140   Control_FSM_done_bridge:
0AEE 22        1141       ret
0AEF           1142   
0AEF           1143   Control_FSM_state1_a:
0AEF 0568      1144       inc Control_FSM_state
0AF1 756900    1145       mov Current_State, #0
0AF4 120F02    1146       lcall Update_Screen_Full 
0AF7 D20C      1147       setb state_change_signal
0AF9 E568      1148       mov a, Control_FSM_state
0AFB           1149       
0AFB           1150   Control_FSM_state1:
0AFB B40127    1151       cjne a, #1, Control_FSM_state2
0AFE 120D3A    1152       lcall Check_Buttons 
0B01 120D86    1153       lcall Check_Keypad
0B04           1154       
0B04           1155       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
0B04 209008    1156       jb P1.0, Control_FSM_state1_ret
0B07           1157       
0B07           1158       ; If we get here, Button is LOW (Pressed)
0B07 121024    1159       lcall Wait_For_P1_0_Release
0B0A 120CBE    1160       lcall Update_FSM_Variables
0B0D 8001      1161       sjmp Control_FSM_state2_a
0B0F           1162   Control_FSM_state1_ret:
0B0F 22        1163       ret
0B10           1164   
0B10           1165   ; --- STATE 2: RAMP TO SOAK ---
0B10           1166   Control_FSM_state2_a:
0B10 0568      1167       inc Control_FSM_state
0B12 E568      1168       mov a, Control_FSM_state   ; [FIX] RELOAD 'A' so it matches the new state!
0B14 D20C      1169       setb state_change_signal
0B16 120A82    1170       lcall Beep_Once
0B19           1171   
0B19 D20F      1172       setb tc_startup_window    ; OPEN the safety window
0B1B C20E      1173       clr tc_missing_abort      ; Clear any previous aborts
0B1D 753000    1174       mov current_time_sec, #0  ; Reset Seconds to 0
0B20 753100    1175       mov current_time_minute, #0 ; Reset Minutes to 0
0B23           1176       
0B23           1177       ; [FIX] CLEAR FLAG ON ENTRY
0B23           1178       ; Force the system to wait for at least one fresh temp reading
0B23           1179       ; before deciding we are done.
0B23 C203      1180       clr soak_temp_reached      
0B25           1181   
0B25           1182   Control_FSM_state2:
0B25 B4021F    1183       cjne a, #2, Control_FSM_state3
0B28 301205    1184       jnb PB2_flag, State2_Check
0B2B C212      1185       clr PB2_flag
0B2D 020B98    1186       ljmp Control_FSM_state6_a ; Pause
0B30           1187   
0B30           1188   State2_Check:
0B30 300313    1189       jnb soak_temp_reached, State2_Ret
0B33           1190       
0B33           1191       ; --- We reached Temp! Move to State 3 ---
0B33 C203      1192       clr soak_temp_reached
0B35 0568      1193       inc Control_FSM_state
0B37           1194       
0B37           1195       ; [FIX] RELOAD 'A' (Good practice)
0B37 E568      1196       mov a, Control_FSM_state   
0B39           1197       
0B39 D20C      1198       setb state_change_signal
0B3B 120A82    1199       lcall Beep_Once
0B3E           1200       
0B3E 753000    1201       mov current_time_sec, #0
0B41 753100    1202       mov current_time_minute, #0
0B44           1203       
0B44           1204       ; Ensure we start State 3 fresh
0B44 C206      1205       clr soak_time_reached 
0B46           1206   
0B46           1207   State2_Ret:
0B46 22        1208       ret
0B47           1209   
0B47           1210   ; --- STATE 3: SOAK PHASE ---
0B47           1211   Control_FSM_state3:
0B47 B40315    1212       cjne a, #3, Control_FSM_state4
0B4A 301205    1213       jnb PB2_flag, State3_Check
0B4D C212      1214       clr PB2_flag
0B4F 020B98    1215       ljmp Control_FSM_state6_a
0B52           1216   State3_Check:
0B52 300609    1217       jnb soak_time_reached, State3_Ret
0B55 C206      1218       clr soak_time_reached
0B57 0568      1219       inc Control_FSM_state      
0B59 D20C      1220       setb state_change_signal 
0B5B 120A82    1221            lcall Beep_Once
0B5E           1222   State3_Ret:
0B5E 22        1223       ret
0B5F           1224   
0B5F           1225   ; --- STATE 4: RAMP TO PEAK ---
0B5F           1226   Control_FSM_state4:
0B5F B4041D    1227       cjne a, #4, Control_FSM_state5
0B62 301205    1228       jnb PB2_flag, State4_Check
0B65 C212      1229       clr PB2_flag
0B67 020B98    1230       ljmp Control_FSM_state6_a
0B6A           1231   State4_Check:
0B6A 300411    1232       jnb reflow_temp_reached, State4_Ret
0B6D C204      1233       clr reflow_temp_reached
0B6F 0568      1234       inc Control_FSM_state
0B71 D20C      1235       setb state_change_signal
0B73 120A82    1236            lcall Beep_Once
0B76 753000    1237       mov current_time_sec, #0
0B79 753100    1238       mov current_time_minute, #0
0B7C           1239       ; --- ADD THIS LINE ---
0B7C C207      1240       clr reflow_time_reached ; Kill the ghost flag
0B7E           1241       ; ---------------------
0B7E           1242   State4_Ret:
0B7E 22        1243       ret
0B7F           1244   
0B7F           1245   ; --- STATE 5: REFLOW PHASE ---
0B7F           1246   Control_FSM_state5:
0B7F B40502    1247       cjne a, #5, Control_FSM_state6_trampoline
0B82 8003      1248       sjmp State5_Logic
0B84           1249   Control_FSM_state6_trampoline:
0B84 020B9F    1250       ljmp Control_FSM_state6
0B87           1251   
0B87           1252   State5_Logic:
0B87 301205    1253       jnb PB2_flag, State5_Check
0B8A C212      1254       clr PB2_flag
0B8C 020B98    1255       ljmp Control_FSM_state6_a
0B8F           1256   State5_Check:
0B8F 300705    1257       jnb reflow_time_reached, State5_Ret
0B92 C207      1258       clr reflow_time_reached
0B94 020B98    1259       ljmp Control_FSM_state6_a
0B97           1260   State5_Ret:
0B97 22        1261       ret
0B98           1262   
0B98           1263   ; --- STATE 6: COOLING ---
0B98           1264   Control_FSM_state6_a:
0B98 0568      1265       inc Control_FSM_state
0B9A D20C      1266       setb state_change_signal
0B9C 120A87    1267            lcall Beep_Five
0B9F           1268   Control_FSM_state6:
0B9F B4060A    1269       cjne a, #6, Control_FSM_state7
0BA2           1270       ; Wait for Cooling Temp Reached
0BA2 300506    1271       jnb cooling_temp_reached, State6_Ret
0BA5 C205      1272       clr cooling_temp_reached
0BA7 0568      1273       inc Control_FSM_state
0BA9 D20C      1274       setb state_change_signal
0BAB           1275   State6_Ret:
0BAB 22        1276       ret
0BAC           1277   
0BAC           1278   ; --- STATE 7: DONE ---
0BAC           1279   Control_FSM_state7:
0BAC B40711    1280       cjne a, #7, Control_FSM_done
0BAF           1281       
0BAF           1282       ; FIX: Check if Button is HIGH (Not Pressed). If so, exit.
0BAF 201009    1283       jb PB0_flag, Control_FSM_Reset_Logic ; Wait, PB0_flag is software flag?
0BB2           1284       
0BB2           1285       ; Let's assume you meant the physical button P1.0 like State 0
0BB2 20900B    1286       jb P1.0, Control_FSM_done
0BB5           1287       
0BB5 121024    1288       lcall Wait_For_P1_0_Release
0BB8 020ADE    1289       ljmp Control_FSM_state0_a
0BBB           1290   
0BBB           1291   Control_FSM_Reset_Logic:
0BBB           1292       ; If using PB0_flag from ISR, handle here
0BBB C210      1293       clr PB0_flag
0BBD 020ADE    1294       ljmp Control_FSM_state0_a
0BC0           1295   
0BC0           1296   Control_FSM_done:
0BC0 22        1297       ret
0BC1           1298   ;-------------------------------------------------------------------------------;
0BC1           1299   ;         Main program.          
0BC1           1300   ;-------------------------------------------------------------------------------;
0BC1           1301   main:
0BC1           1302   
0BC1           1303       ; --------------------------------------------------------
0BC1           1304       ; 1. SAFETY SHUTDOWN
0BC1           1305       ; --------------------------------------------------------
0BC1 C2AF      1306       clr EA              ; FORCE Interrupts OFF immediately
0BC3 7581C0    1307       mov SP, #0xC0       ; Reset Stack Pointer to safe location
0BC6           1308       
0BC6           1309       ; --------------------------------------------------------
0BC6           1310       ; 2. THE "DIRTY DELAY" (Fixes Reset Garbage)
0BC6           1311       ; We burn ~100ms here using a raw loop. 
0BC6           1312       ; We cannot use timers yet because they aren't initialized.
0BC6           1313       ; --------------------------------------------------------
0BC6 78FA      1314       mov R0, #250
0BC8           1315   Reset_Delay_Outer:
0BC8 79FF      1316       mov R1, #255
0BCA           1317   Reset_Delay_Inner:
0BCA D9FE      1318       djnz R1, Reset_Delay_Inner
0BCC D8FA      1319       djnz R0, Reset_Delay_Outer
0BCE           1320       ; --------------------------------------------------------
0BCE           1321   
0BCE           1322       ; ... NOW continue with your normal Port Configuration ...
0BCE           1323       
0BCE           1324       ; --- PORT CONFIGURATION ---
0BCE 759AAA    1325       mov P0MOD, #0xAA
0BD1           1326   
0BD1           1327       ; P1: Mixed usage 
0BD1           1328       ; P1.7(LCD_RS), P1.6(Row3), P1.5(Sound), P1.4(Row2)
0BD1           1329       ; P1.3(PWM), P1.2(Row1), P1.1(LCD_E) -> All Outputs
0BD1           1330       ; P1.0 (Unused/RX) -> Input
0BD1           1331       ; Binary: 11111110 -> Hex: 0xFE
0BD1 759BFE    1332       mov P1MOD, #0xFE
0BD4           1333   
0BD4           1334       ; P2: Row4(Out), Cols(In)
0BD4           1335       ; P2.0 (Row4) is Out (1). P2.2, P2.4, P2.6 (Cols) are In (0).
0BD4           1336       ; Binary: 00000001 -> Hex: 0x01
0BD4 759C01    1337       mov P2MOD, #0x01
0BD7           1338   
0BD7           1339       ; P3: Col4(In)
0BD7           1340       ; P3.0 (Col4) is In (0).
0BD7 759D40    1341       mov P3MOD, #01000000B
0BDA           1342       ; Turn off all the LEDs
0BDA 75E800    1343       mov LEDRA, #0 ; LEDRA is bit addressable
0BDD 759500    1344       mov LEDRB, #0 ; LEDRB is NOT bit addresable
0BE0           1345   
0BE0           1346       ; Enable Global interrupts
0BE0 D2AF      1347       setb EA  
0BE2           1348   
0BE2           1349       ; FSM initial states
0BE2 756600    1350       mov KEY1_DEB_state, #0
0BE5 756700    1351       mov SEC_FSM_state, #0
0BE8 756800    1352       mov Control_FSM_state, #0
0BEB 756900    1353       mov Current_State, #0
0BEE           1354       
0BEE           1355       ; FSM timers initialization
0BEE 756400    1356       mov KEY1_DEB_timer, #0
0BF1 756500    1357       mov SEC_FSM_timer, #0
0BF4           1358       ; time counters initialization
0BF4 753000    1359       mov current_time_sec, #0
0BF7 753100    1360       mov current_time_minute, #0
0BFA           1361       ; Initialize counter to zero
0BFA 756000    1362       mov pwm_counter, #0
0BFD 756100    1363       mov pwm_counter+1, #0
0C00 756200    1364       mov pwm_counter+2, #0
0C03 756300    1365       mov pwm_counter+3, #0
0C06           1366       ; Initialize power output
0C06 755F00    1367       mov power_output+3, #0
0C09 755E00    1368       mov power_output+2, #0
0C0C 755D02    1369       mov power_output+1, #02H
0C0F 755CEE    1370       mov power_output, #0EEH ; (initilize to 750 for testing)
0C12           1371   
0C12           1372       ; Clear all the flags
0C12 C20E      1373       clr  tc_missing_abort
0C14 C209      1374       clr  stop_signal
0C16 C210      1375       clr PB0_flag
0C18 C211      1376       clr PB1_flag
0C1A C212      1377       clr PB2_flag
0C1C C201      1378       clr one_second_flag
0C1E C20B      1379       clr config_finish_signal
0C20 C203      1380       clr soak_temp_reached
0C22 C206      1381       clr soak_time_reached
0C24 C204      1382       clr reflow_temp_reached
0C26 C207      1383       clr reflow_time_reached
0C28 C205      1384       clr cooling_temp_reached
0C2A C20C      1385       clr state_change_signal
0C2C C21E      1386       clr one_millisecond_flag_servo
0C2E           1387       
0C2E D20C      1388       setb state_change_signal
0C30           1389   
0C30           1390       ; Set bit
0C30 D20F      1391       setb tc_startup_window
0C32           1392   
0C32           1393       ; --------------------------------------
0C32           1394       ; [FIX] ADD THIS BLOCK TO STOP STARTUP BEEP
0C32           1395       ; --------------------------------------
0C32 757400    1396       mov beep_state, #0
0C35 757300    1397       mov beep_count, #0
0C38 757500    1398       mov beep_tmr, #0
0C3B 757600    1399       mov beep_tmr+1, #0
0C3E C213      1400       clr one_ms_beep_flag
0C40 C28C      1401       clr TR0              ; Force buzzer hardware OFF
0C42           1402       ; --------------------------------------
0C42           1403   
0C42           1404   
0C42 12045D    1405       lcall Timer0_Init
0C45 120518    1406       lcall Timer2_Init
0C48 1205E5    1407       lcall ELCD_4BIT
0C4B           1408       ;----- Two new lines I added to initialize the UI
0C4B 120EAF    1409       lcall Init_All_Buffers
0C4E 120F02    1410       lcall Update_Screen_Full
0C51           1411       ;-----
0C51 120477    1412       lcall Initialize_Serial_Port
0C54           1413   ;-------------------------------------------------------------------------------;
0C54           1414   ; while(1) loop
0C54           1415   ;-------------------------------------------------------------------------------;
0C54           1416   loop:
0C54           1417       ; Full reset button on P3.7 (active-low to GND)
0C54 30B702    1418        jnb P3_7, Full_Reset_Trig
0C57 8003      1419       sjmp Full_Reset_Check_Done
0C59           1420   
0C59           1421   Full_Reset_Trig:
0C59 02102C    1422       ljmp Full_Reset
0C5C           1423   
0C5C           1424   Full_Reset_Check_Done:
0C5C           1425       ; Check the FSM for KEY1 debounce
0C5C 120886    1426       lcall KEY1_DEB
0C5F           1427       
0C5F           1428       ; Added to take temp readings
0C5F 121032    1429       lcall Read_Thermocouple
0C62           1430       
0C62           1431       ; 1. Check if we reached temp (Observer)
0C62 120989    1432       lcall Temp_Compare
0C65           1433       
0C65           1434       ; 2. Decide heater power based on flags (Driver)
0C65           1435       ;lcall Power_Control
0C65 121174    1436       lcall proportaional_power_control
0C68           1437   
0C68           1438       ; 3. [FIX] Calculate Total Seconds (Minutes * 60 + Seconds)
0C68           1439       ; ---------------------------------------------------------
0C68           1440       ; Load Minutes into X
0C68 853132    1441       mov x+0, current_time_minute
0C6B 753300    1442       mov x+1, #0
0C6E 753400    1443       mov x+2, #0
0C71 753500    1444       mov x+3, #0
0C74           1445       
0C74           1446       ; Multiply by 60 (Minutes -> Seconds)
0C74 75363C    1447            mov y+0, #low (60 % 0x10000) 
0C77 753700    1447            mov y+1, #high(60 % 0x10000) 
0C7A 753800    1447            mov y+2, #low (60 / 0x10000) 
0C7D 753900    1447            mov y+3, #high(60 / 0x10000) 
0C80 12018C    1448       lcall mul32
0C83           1449       
0C83           1450       ; Load Seconds into Y
0C83 853036    1451       mov y+0, current_time_sec
0C86 753700    1452       mov y+1, #0
0C89 753800    1453       mov y+2, #0
0C8C 753900    1454       mov y+3, #0
0C8F           1455       
0C8F           1456       ; Add them together (Total Seconds = X + Y)
0C8F 1200D3    1457       lcall add32
0C92           1458       
0C92           1459       ; Store Final Result into 'current_time'
0C92 853250    1460       mov current_time+0, x+0
0C95 853351    1461       mov current_time+1, x+1
0C98 853452    1462       mov current_time+2, x+2
0C9B 853553    1463       mov current_time+3, x+3
0C9E           1464       
0C9E 1209CE    1465       lcall Time_Compare
0CA1           1466       
0CA1 120A18    1467       lcall Safety_Check_TC
0CA4           1468   
0CA4           1469   
0CA4           1470       ; Check the FSM for one second counter
0CA4 1208BC    1471       lcall SEC_FSM
0CA7           1472   
0CA7           1473       ; Check the FSM for the overall control flow of the reflow process
0CA7 120ADA    1474       lcall Control_FSM
0CAA           1475   
0CAA           1476       ; Update the LCD display based on the current state
0CAA 1206AA    1477       lcall LCD_Display_Update_func
0CAD           1478   
0CAD 300202    1479       jnb one_ms_pwm_flag, Skip_Beep_Sync
0CB0 D213      1480       setb one_ms_beep_flag  ; Give the buzzer its own copy of the time tick
0CB2           1481   
0CB2           1482   Skip_Beep_Sync:
0CB2           1483       ; Update the pwm output for the ssr
0CB2 120912    1484       lcall PWM_Wave 
0CB5           1485            ; Update the Buzzer 
0CB5 120AA1    1486            lcall Beep_Task
0CB8           1487       ; Update the pwm output for the servo
0CB8 121107    1488       lcall call_servo_control
0CBB           1489       ; After initialization the program stays in this 'forever' loop
0CBB 020C54    1490       ljmp loop
0CBE           1491   ;-------------------------------------------------------------------------------;
0CBE           1492   
0CBE           1493   ; ================================================================
0CBE           1494   ; UI & HELPER SUBROUTINES
0CBE           1495   ; ================================================================
0CBE           1496   
0CBE           1497   ; ----------------------------------------------------------------
0CBE           1498   ; MODULE: BRIDGE (Text to Integer Conversion)
0CBE           1499   ; ----------------------------------------------------------------
0CBE           1500   Update_FSM_Variables:
0CBE           1501       ; --- 1. SOAK TEMP ---
0CBE 7880      1502       mov R0, #Buf_Soak_Temp
0CC0 120CFD    1503       lcall Parse_Temp_String
0CC3 8F43      1504       mov soak_temp+0, R7
0CC5 754400    1505       mov soak_temp+1, #0
0CC8 754500    1506       mov soak_temp+2, #0
0CCB 754600    1507       mov soak_temp+3, #0
0CCE           1508   
0CCE           1509       ; --- 2. REFLOW TEMP ---
0CCE 7889      1510       mov R0, #Buf_Refl_Temp
0CD0 120CFD    1511       lcall Parse_Temp_String
0CD3 8F47      1512       mov reflow_temp+0, R7
0CD5 754800    1513       mov reflow_temp+1, #0
0CD8 754900    1514       mov reflow_temp+2, #0
0CDB 754A00    1515       mov reflow_temp+3, #0
0CDE           1516   
0CDE           1517       ; --- 3. SOAK TIME ---
0CDE 7884      1518       mov R0, #Buf_Soak_Time
0CE0 120D11    1519       lcall Parse_Time_String
0CE3 8F54      1520       mov soak_time+0, R7
0CE5 8E55      1521       mov soak_time+1, R6
0CE7 755600    1522       mov soak_time+2, #0
0CEA 755700    1523       mov soak_time+3, #0
0CED           1524   
0CED           1525       ; --- 4. REFLOW TIME ---
0CED 788D      1526       mov R0, #Buf_Refl_Time
0CEF 120D11    1527       lcall Parse_Time_String
0CF2 8F58      1528       mov reflow_time+0, R7
0CF4 8E59      1529       mov reflow_time+1, R6
0CF6 755A00    1530       mov reflow_time+2, #0
0CF9 755B00    1531       mov reflow_time+3, #0
0CFC 22        1532       ret
0CFD           1533   
0CFD           1534   ; --- Helper: Parse "123" to Integer ---
0CFD           1535   Parse_Temp_String:
0CFD 7F00      1536       mov R7, #0              ; Clear Result
0CFF           1537   Parse_Temp_Loop:
0CFF E6        1538       mov A, @R0
0D00 600E      1539       jz Parse_Temp_Done      ; If Null, we are done
0D02           1540       
0D02           1541       ; Convert ASCII to Digit
0D02 C3        1542       clr C
0D03 9430      1543       subb A, #0x30
0D05 FD        1544       mov R5, A               ; R5 = New Digit
0D06           1545       
0D06           1546       ; Result = (Result * 10) + New Digit
0D06 EF        1547       mov A, R7
0D07 75F00A    1548       mov B, #10
0D0A A4        1549       mul AB
0D0B 2D        1550       add A, R5
0D0C FF        1551       mov R7, A
0D0D           1552       
0D0D 08        1553       inc R0
0D0E 80EF      1554       sjmp Parse_Temp_Loop
0D10           1555   Parse_Temp_Done:
0D10 22        1556       ret
0D11           1557   
0D11           1558   ; --- Helper: Parse "MMSS" to Seconds ---
0D11           1559   Parse_Time_String:
0D11           1560       ; 1. Minutes Tens
0D11 E6        1561       mov A, @R0
0D12 9430      1562       subb A, #0x30
0D14 75F00A    1563       mov B, #10
0D17 A4        1564       mul AB
0D18 FD        1565       mov R5, A
0D19 08        1566       inc R0
0D1A           1567       
0D1A           1568       ; 2. Minutes Ones
0D1A E6        1569       mov A, @R0
0D1B 9430      1570       subb A, #0x30
0D1D 2D        1571       add A, R5
0D1E FD        1572       mov R5, A               ; R5 = Total Minutes
0D1F 08        1573       inc R0
0D20           1574       
0D20           1575       ; 3. Seconds Tens
0D20 E6        1576       mov A, @R0
0D21 9430      1577       subb A, #0x30
0D23 75F00A    1578       mov B, #10
0D26 A4        1579       mul AB
0D27 FC        1580       mov R4, A
0D28 08        1581       inc R0
0D29           1582       
0D29           1583       ; 4. Seconds Ones
0D29 E6        1584       mov A, @R0
0D2A 9430      1585       subb A, #0x30
0D2C 2C        1586       add A, R4               ; R4 = Total Seconds
0D2D           1587       
0D2D           1588       ; 5. Calculate Total Seconds = (Mins * 60) + Secs
0D2D ED        1589       mov A, R5
0D2E 75F03C    1590       mov B, #60
0D31 A4        1591       mul AB
0D32 2C        1592       add A, R4
0D33 FF        1593       mov R7, A               ; Low Byte
0D34 E5F0      1594       mov A, B
0D36 3400      1595       addc A, #0
0D38 FE        1596       mov R6, A               ; High Byte
0D39 22        1597       ret
0D3A           1598   
0D3A           1599   ; ----------------------------------------------------------------
0D3A           1600   ; MODULE: BUTTON HANDLER (Mode Selection)
0D3A           1601   ; ----------------------------------------------------------------
0D3A           1602   Check_Buttons:
0D3A           1603       ; --- FORCE INPUT MODE ---
0D3A           1604       ; This clears any '0' the LCD library might have written to our buttons
0D3A 438055    1605       orl P0, #055H   ; Sets P0.0, P0.2, P0.4, and P0.6 to '1' (Input Mode)
0D3D           1606       ; ------------------------
0D3D           1607   
0D3D 30800A    1608       jnb BTN_SOAK_TEMP, Btn_Soak_Temp_Press
0D40 308212    1609       jnb BTN_SOAK_TIME, Btn_Soak_Time_Press
0D43 30841A    1610       jnb BTN_REFL_TEMP, Btn_Refl_Temp_Press
0D46 308622    1611       jnb BTN_REFL_TIME, Btn_Refl_Time_Press
0D49 22        1612       ret
0D4A           1613   
0D4A           1614   Btn_Soak_Temp_Press:
0D4A 120FF4    1615       lcall Wait_25ms_BLOCKING
0D4D 756901    1616       mov Current_State, #1
0D50 757200    1617       mov Cursor_Idx, #0
0D53 8021      1618       sjmp Redraw_Screen
0D55           1619   
0D55           1620   Btn_Soak_Time_Press:
0D55 120FF4    1621       lcall Wait_25ms_BLOCKING
0D58 756902    1622       mov Current_State, #2
0D5B 757200    1623       mov Cursor_Idx, #0
0D5E 8016      1624       sjmp Redraw_Screen
0D60           1625   
0D60           1626   Btn_Refl_Temp_Press:
0D60 120FF4    1627       lcall Wait_25ms_BLOCKING
0D63 756903    1628       mov Current_State, #3
0D66 757200    1629       mov Cursor_Idx, #0
0D69 800B      1630       sjmp Redraw_Screen
0D6B           1631   
0D6B           1632   Btn_Refl_Time_Press:
0D6B 120FF4    1633       lcall Wait_25ms_BLOCKING 
0D6E 756904    1634       mov Current_State, #4
0D71 757200    1635       mov Cursor_Idx, #0
0D74 8000      1636       sjmp Redraw_Screen
0D76           1637   
0D76           1638   Redraw_Screen:
0D76           1639       ; Wait for button release
0D76 3080FD    1640       jnb BTN_SOAK_TEMP, $
0D79 3082FD    1641       jnb BTN_SOAK_TIME, $
0D7C 3084FD    1642       jnb BTN_REFL_TEMP, $
0D7F 3086FD    1643       jnb BTN_REFL_TIME, $
0D82           1644   
0D82 120F02    1645       lcall Update_Screen_Full
0D85 22        1646       ret
0D86           1647   
0D86           1648   ; ----------------------------------------------------------------
0D86           1649   ; MODULE: KEYPAD HANDLER (Input Logic)
0D86           1650   ; ----------------------------------------------------------------
0D86           1651   Check_Keypad:
0D86           1652       ; If State is 0 (Home), ignore keypad
0D86 E569      1653       mov A, Current_State
0D88 6050      1654       jz Keypad_Exit
0D8A           1655       
0D8A 120DDB    1656       lcall Keypad_Scan
0D8D 504B      1657       jnc Keypad_Exit         ; Carry = 0 means no key pressed
0D8F           1658   
0D8F           1659       ; --- Check Special Keys ---
0D8F EF        1660       mov A, R7
0D90 B40E0A    1661       cjne A, #14, Check_Hash ; 14 is Star (*)
0D93           1662       
0D93           1663       ; Star Key Pressed: Reset Buffer
0D93 120EDF    1664       lcall Reset_Current_Buffer
0D96 120F02    1665       lcall Update_Screen_Full
0D99 757200    1666       mov Cursor_Idx, #0
0D9C 22        1667       ret
0D9D           1668   
0D9D           1669   Check_Hash:
0D9D EF        1670       mov A, R7
0D9E B40C01    1671       cjne A, #12, Check_Numeric ; 12 is Hash (#)
0DA1 22        1672       ret                     ; Ignore Hash key
0DA2           1673   
0DA2           1674   Check_Numeric:
0DA2           1675       ; Ensure key is 0-9
0DA2 EF        1676       mov A, R7
0DA3 C3        1677       clr C
0DA4 940A      1678       subb A, #10
0DA6 5031      1679       jnc Symbol_Key_Ignored
0DA8           1680       
0DA8           1681       ; Convert to ASCII
0DA8 EF        1682       mov A, R7
0DA9 2430      1683       add A, #0x30
0DAB FD        1684       mov R5, A
0DAC           1685   
0DAC           1686       ; Save to Buffer
0DAC 12100D    1687       lcall Get_Current_Buffer_Addr
0DAF E572      1688       mov A, Cursor_Idx
0DB1 28        1689       add A, R0
0DB2 F8        1690       mov R0, A
0DB3 ED        1691       mov A, R5
0DB4 F6        1692       mov @R0, A
0DB5 0572      1693       inc Cursor_Idx
0DB7           1694   
0DB7           1695       ; --- Check Cursor Limits ---
0DB7 E569      1696       mov A, Current_State
0DB9 B40102    1697       cjne A, #1, Check_Limit_Time_1
0DBC 8005      1698       sjmp Limit_Temp_3
0DBE           1699   
0DBE           1700   Check_Limit_Time_1:
0DBE B4030B    1701       cjne A, #3, Limit_Time_4
0DC1 8000      1702       sjmp Limit_Temp_3
0DC3           1703   
0DC3           1704   Limit_Temp_3:
0DC3 E572      1705       mov A, Cursor_Idx
0DC5 B4030D    1706       cjne A, #3, Do_Refresh
0DC8 1572      1707       dec Cursor_Idx          ; Stay at last digit
0DCA 8009      1708       sjmp Do_Refresh
0DCC           1709   
0DCC           1710   Limit_Time_4:
0DCC E572      1711       mov A, Cursor_Idx
0DCE B40404    1712       cjne A, #4, Do_Refresh
0DD1 1572      1713       dec Cursor_Idx          ; Stay at last digit
0DD3 8000      1714       sjmp Do_Refresh
0DD5           1715   
0DD5           1716   Do_Refresh:
0DD5 120F02    1717       lcall Update_Screen_Full
0DD8 22        1718       ret
0DD9           1719   
0DD9           1720   Symbol_Key_Ignored:
0DD9 22        1721       ret
0DDA           1722   Keypad_Exit:
0DDA 22        1723       ret
0DDB           1724   
0DDB           1725   ; ----------------------------------------------------------------
0DDB           1726   ; MODULE: HARDWARE SCANNER (Matrix Logic)
0DDB           1727   ; ----------------------------------------------------------------
0DDB           1728   Keypad_Scan:
0DDB           1729       ; Step 1: Check if ANY key is pressed (All Rows Low)
0DDB C292      1730       clr ROW1
0DDD C294      1731       clr ROW2
0DDF C296      1732       clr ROW3
0DE1 C2A0      1733       clr ROW4
0DE3 A2A2      1734       mov C, COL1
0DE5 82A4      1735       anl C, COL2
0DE7 82A6      1736       anl C, COL3
0DE9 82B0      1737       anl C, COL4
0DEB 5002      1738       jnc Keypad_Debounce
0DED C3        1739       clr C
0DEE 22        1740       ret
0DEF           1741   
0DEF           1742   Keypad_Debounce:
0DEF 120FF4    1743       lcall Wait_25ms_BLOCKING
0DF2 A2A2      1744       mov C, COL1
0DF4 82A4      1745       anl C, COL2
0DF6 82A6      1746       anl C, COL3
0DF8 82B0      1747       anl C, COL4
0DFA 5002      1748       jnc Keypad_Find_Row
0DFC C3        1749       clr C
0DFD 22        1750       ret
0DFE           1751   
0DFE           1752   Keypad_Find_Row:
0DFE D292      1753       setb ROW1
0E00 D294      1754       setb ROW2
0E02 D296      1755       setb ROW3
0E04 D2A0      1756       setb ROW4
0E06           1757   
0E06           1758       ; Row 1
0E06 C292      1759       clr ROW1
0E08 30A23D    1760       jnb COL1, Keypad_Key_1
0E0B 30A43E    1761       jnb COL2, Keypad_Key_2
0E0E 30A63F    1762       jnb COL3, Keypad_Key_3
0E11 30B040    1763       jnb COL4, Keypad_Key_A
0E14 D292      1764       setb ROW1
0E16           1765   
0E16           1766       ; Row 2
0E16 C294      1767       clr ROW2
0E18 30A23D    1768       jnb COL1, Keypad_Key_4
0E1B 30A43E    1769       jnb COL2, Keypad_Key_5
0E1E 30A63F    1770       jnb COL3, Keypad_Key_6
0E21 30B040    1771       jnb COL4, Keypad_Key_B
0E24 D294      1772       setb ROW2
0E26           1773   
0E26           1774       ; Row 3
0E26 C296      1775       clr ROW3
0E28 30A23D    1776       jnb COL1, Keypad_Key_7
0E2B 30A43E    1777       jnb COL2, Keypad_Key_8
0E2E 30A63F    1778       jnb COL3, Keypad_Key_9
0E31 30B040    1779       jnb COL4, Keypad_Key_C
0E34 D296      1780       setb ROW3
0E36           1781   
0E36           1782       ; Row 4
0E36 C2A0      1783       clr ROW4
0E38 30A23D    1784       jnb COL1, Keypad_Key_Star
0E3B 30A43E    1785       jnb COL2, Keypad_Key_0
0E3E 30A63F    1786       jnb COL3, Keypad_Key_Hash
0E41 30B040    1787       jnb COL4, Keypad_Key_D
0E44 D2A0      1788       setb ROW4
0E46 C3        1789       clr C
0E47 22        1790       ret
0E48           1791   
0E48           1792   ; Key Mapping (Renamed to avoid conflicts)
0E48 7F01      1793   Keypad_Key_1: mov R7, #1
0E4A 803C      1794          sjmp Wait_Release
0E4C 7F02      1795   Keypad_Key_2: mov R7, #2
0E4E 8038      1796          sjmp Wait_Release
0E50 7F03      1797   Keypad_Key_3: mov R7, #3
0E52 8034      1798          sjmp Wait_Release
0E54 7F0A      1799   Keypad_Key_A: mov R7, #10
0E56 8030      1800          sjmp Wait_Release
0E58 7F04      1801   Keypad_Key_4: mov R7, #4
0E5A 802C      1802          sjmp Wait_Release
0E5C 7F05      1803   Keypad_Key_5: mov R7, #5
0E5E 8028      1804          sjmp Wait_Release
0E60 7F06      1805   Keypad_Key_6: mov R7, #6
0E62 8024      1806          sjmp Wait_Release
0E64 7F0B      1807   Keypad_Key_B: mov R7, #11
0E66 8020      1808          sjmp Wait_Release
0E68 7F07      1809   Keypad_Key_7: mov R7, #7
0E6A 801C      1810          sjmp Wait_Release
0E6C 7F08      1811   Keypad_Key_8: mov R7, #8
0E6E 8018      1812          sjmp Wait_Release
0E70 7F09      1813   Keypad_Key_9: mov R7, #9
0E72 8014      1814          sjmp Wait_Release
0E74 7F0D      1815   Keypad_Key_C: mov R7, #13
0E76 8010      1816          sjmp Wait_Release
0E78 7F0E      1817   Keypad_Key_Star: mov R7, #14
0E7A 800C      1818          sjmp Wait_Release
0E7C 7F00      1819   Keypad_Key_0: mov R7, #0
0E7E 8008      1820          sjmp Wait_Release
0E80 7F0C      1821   Keypad_Key_Hash: mov R7, #12
0E82 8004      1822          sjmp Wait_Release
0E84 7F0F      1823   Keypad_Key_D: mov R7, #15
0E86 8000      1824          sjmp Wait_Release
0E88           1825   
0E88           1826   Wait_Release:
0E88 A2A2      1827       mov C, COL1
0E8A 82A4      1828       anl C, COL2
0E8C 82A6      1829       anl C, COL3
0E8E 82B0      1830       anl C, COL4
0E90 50F6      1831       jnc Wait_Release
0E92 D3        1832       setb C
0E93 D292      1833       setb ROW1
0E95 D294      1834       setb ROW2
0E97 D296      1835       setb ROW3
0E99 D2A0      1836       setb ROW4
0E9B 22        1837       ret
0E9C           1838   
0E9C           1839   Wait_25ms:
0E9C           1840       ; 1. Check if we are already waiting
0E9C 20140E    1841       jb wait25_active, Check_Timer_Status
0E9F           1842       
0E9F           1843       ; 2. Check if we just finished
0E9F 301504    1844       jnb wait25_done, Start_New_Timer
0EA2           1845       
0EA2           1846       ; 3. Timer is DONE! Reset flags and return True
0EA2 C215      1847       clr wait25_done
0EA4 D3        1848       setb C          ; Carry = 1 means "Done"
0EA5 22        1849       ret
0EA6           1850   
0EA6           1851   Start_New_Timer:
0EA6           1852       ; 4. Start a new 25ms wait
0EA6 754F00    1853       mov wait25_count, #0
0EA9 D214      1854       setb wait25_active
0EAB C3        1855       clr C           ; Carry = 0 means "Not Done Yet"
0EAC 22        1856       ret
0EAD           1857   
0EAD           1858   Check_Timer_Status:
0EAD           1859       ; 5. Still waiting... return False immediately
0EAD C3        1860       clr C           ; Carry = 0 means "Not Done Yet"
0EAE 22        1861       ret
0EAF           1862   
0EAF           1863   ; ----------------------------------------------------------------
0EAF           1864   ; MODULE: BUFFER INIT (Reset Logic)
0EAF           1865   ; ----------------------------------------------------------------
0EAF           1866   Init_All_Buffers:
0EAF 7880      1867       mov R0, #Buf_Soak_Temp
0EB1 120EC4    1868       lcall Init_Temp_Template
0EB4 7889      1869       mov R0, #Buf_Refl_Temp
0EB6 120EC4    1870       lcall Init_Temp_Template
0EB9 7884      1871       mov R0, #Buf_Soak_Time
0EBB 120ED0    1872       lcall Init_Time_Template
0EBE 788D      1873       mov R0, #Buf_Refl_Time
0EC0 120ED0    1874       lcall Init_Time_Template
0EC3 22        1875       ret
0EC4           1876   
0EC4           1877   Init_Temp_Template:
0EC4 7630      1878       mov @R0, #'0'
0EC6 08        1879       inc R0
0EC7 7630      1880       mov @R0, #'0'
0EC9 08        1881       inc R0
0ECA 7630      1882       mov @R0, #'0'
0ECC 08        1883       inc R0
0ECD 7600      1884       mov @R0, #0
0ECF 22        1885       ret
0ED0           1886   
0ED0           1887   Init_Time_Template:
0ED0 7630      1888       mov @R0, #'0'
0ED2 08        1889       inc R0
0ED3 7630      1890       mov @R0, #'0'
0ED5 08        1891       inc R0
0ED6 7630      1892       mov @R0, #'0'
0ED8 08        1893       inc R0
0ED9 7630      1894       mov @R0, #'0'
0EDB 08        1895       inc R0
0EDC 7600      1896       mov @R0, #0
0EDE 22        1897       ret
0EDF           1898   
0EDF           1899   Reset_Current_Buffer:
0EDF E569      1900       mov A, Current_State
0EE1 B40106    1901       cjne A, #1, Reset_Chk_2
0EE4 7880      1902       mov R0, #Buf_Soak_Temp
0EE6 120EC4    1903       lcall Init_Temp_Template
0EE9 22        1904       ret
0EEA           1905   Reset_Chk_2:
0EEA B40206    1906       cjne A, #2, Reset_Chk_3
0EED 7884      1907       mov R0, #Buf_Soak_Time
0EEF 120ED0    1908       lcall Init_Time_Template
0EF2 22        1909       ret
0EF3           1910   Reset_Chk_3:
0EF3 B40306    1911       cjne A, #3, Reset_Chk_4
0EF6 7889      1912       mov R0, #Buf_Refl_Temp
0EF8 120EC4    1913       lcall Init_Temp_Template
0EFB 22        1914       ret
0EFC           1915   Reset_Chk_4:
0EFC 788D      1916       mov R0, #Buf_Refl_Time
0EFE 120ED0    1917       lcall Init_Time_Template
0F01 22        1918       ret
0F02           1919   
0F02           1920   ; ----------------------------------------------------------------
0F02           1921   ; MODULE: SCREEN UPDATE (Visual Logic)
0F02           1922   ; ----------------------------------------------------------------
0F02           1923   Update_Screen_Full:
0F02 120FFA    1924       lcall Clear_Screen_Func
0F05 C0E0      1925            push acc
0F07 7401      1925            mov a, #1
0F09 14        1925            dec a
0F0A 120625    1925            lcall ?Set_Cursor_1 ; Select column and row
0F0D D0E0      1925            pop acc
0F0F           1926   
0F0F           1927       ; --- Draw Line 1 (Titles) ---
0F0F E569      1928       mov A, Current_State
0F11 B40013    1929       cjne A, #0, Update_State_1
0F14 C083      1930            push dph
0F16 C082      1930            push dpl
0F18 C0E0      1930            push acc
0F1A 900350    1930            mov dptr, #Txt_Home
0F1D 120618    1930            lcall ?Send_Constant_String
0F20 D0E0      1930            pop acc
0F22 D082      1930            pop dpl
0F24 D083      1930            pop dph
0F26 22        1931       ret 
0F27           1932   Update_State_1:
0F27 B40114    1933       cjne A, #1, Update_State_2
0F2A C083      1934            push dph
0F2C C082      1934            push dpl
0F2E C0E0      1934            push acc
0F30 900361    1934            mov dptr, #Txt_SoakT
0F33 120618    1934            lcall ?Send_Constant_String
0F36 D0E0      1934            pop acc
0F38 D082      1934            pop dpl
0F3A D083      1934            pop dph
0F3C 8042      1935       sjmp Draw_Temp_Format
0F3E           1936   Update_State_2:
0F3E B40214    1937       cjne A, #2, Update_State_3
0F41 C083      1938            push dph
0F43 C082      1938            push dpl
0F45 C0E0      1938            push acc
0F47 900372    1938            mov dptr, #Txt_SoakTime
0F4A 120618    1938            lcall ?Send_Constant_String
0F4D D0E0      1938            pop acc
0F4F D082      1938            pop dpl
0F51 D083      1938            pop dph
0F53 8042      1939       sjmp Draw_Time_Format
0F55           1940   Update_State_3:
0F55 B40314    1941       cjne A, #3, Update_State_4
0F58 C083      1942            push dph
0F5A C082      1942            push dpl
0F5C C0E0      1942            push acc
0F5E 900383    1942            mov dptr, #Txt_ReflT
0F61 120618    1942            lcall ?Send_Constant_String
0F64 D0E0      1942            pop acc
0F66 D082      1942            pop dpl
0F68 D083      1942            pop dph
0F6A 8014      1943       sjmp Draw_Temp_Format
0F6C           1944   Update_State_4:
0F6C C083      1945            push dph
0F6E C082      1945            push dpl
0F70 C0E0      1945            push acc
0F72 900394    1945            mov dptr, #Txt_ReflTime
0F75 120618    1945            lcall ?Send_Constant_String
0F78 D0E0      1945            pop acc
0F7A D082      1945            pop dpl
0F7C D083      1945            pop dph
0F7E 8017      1946       sjmp Draw_Time_Format
0F80           1947   
0F80           1948   ; --- Draw Line 2 (Values) ---
0F80           1949   Draw_Temp_Format:
0F80 C0E0      1950            push acc
0F82 7401      1950            mov a, #1
0F84 14        1950            dec a
0F85 120623    1950            lcall ?Set_Cursor_2 ; Select column and row
0F88 D0E0      1950            pop acc
0F8A 12100D    1951       lcall Get_Current_Buffer_Addr
0F8D 120FEA    1952       lcall Print_String_RAM
0F90 7443      1953       mov A, #'C'
0F92 1205DB    1954       lcall ?WriteData
0F95 8027      1955       sjmp Restore_Cursor
0F97           1956   
0F97           1957   Draw_Time_Format:
0F97 C0E0      1958            push acc
0F99 7401      1958            mov a, #1
0F9B 14        1958            dec a
0F9C 120623    1958            lcall ?Set_Cursor_2 ; Select column and row
0F9F D0E0      1958            pop acc
0FA1 12100D    1959       lcall Get_Current_Buffer_Addr
0FA4           1960       ; MM
0FA4 E6        1961       mov A, @R0
0FA5 1205DB    1962       lcall ?WriteData
0FA8 08        1963       inc R0
0FA9 E6        1964       mov A, @R0
0FAA 1205DB    1965       lcall ?WriteData
0FAD 08        1966       inc R0
0FAE           1967       ; Colon
0FAE 743A      1968       mov A, #':'
0FB0 1205DB    1969       lcall ?WriteData
0FB3           1970       ; SS
0FB3 E6        1971       mov A, @R0
0FB4 1205DB    1972       lcall ?WriteData
0FB7 08        1973       inc R0
0FB8 E6        1974       mov A, @R0
0FB9 1205DB    1975       lcall ?WriteData
0FBC           1976       ; Unit
0FBC           1977       ;got rid of the "s"
0FBC           1978       ;mov A, #'s'
0FBC           1979       ;lcall ?WriteData
0FBC 8000      1980       sjmp Restore_Cursor
0FBE           1981   
0FBE           1982   ; --- Restore Cursor Position ---
0FBE           1983   Restore_Cursor:
0FBE E569      1984       mov A, Current_State
0FC0 B40202    1985       cjne A, #2, RC_Check_State_4  
0FC3 800D      1986       sjmp Adjust_Cursor_Time
0FC5           1987   RC_Check_State_4:             
0FC5 B40402    1988       cjne A, #4, Normal_Cursor
0FC8 8008      1989       sjmp Adjust_Cursor_Time
0FCA           1990   
0FCA           1991   Normal_Cursor:
0FCA E572      1992       mov A, Cursor_Idx
0FCC 24C0      1993       add A, #0xC0
0FCE 1205E0    1994       lcall ?WriteCommand
0FD1 22        1995       ret
0FD2           1996   
0FD2           1997   Adjust_Cursor_Time:
0FD2           1998       ; Skip the colon index (2)
0FD2 E572      1999       mov A, Cursor_Idx
0FD4 B40201    2000       cjne A, #2, No_Skip
0FD7 04        2001       inc A 
0FD8           2002   No_Skip:
0FD8           2003       ; Add 1 if past the colon
0FD8 C3        2004       clr C
0FD9 9402      2005       subb A, #2
0FDB 4005      2006       jc No_Add
0FDD E572      2007       mov A, Cursor_Idx
0FDF 04        2008       inc A
0FE0 8002      2009       sjmp Final_Cursor_Set
0FE2           2010   No_Add:
0FE2 E572      2011       mov A, Cursor_Idx
0FE4           2012   Final_Cursor_Set:
0FE4 24C0      2013       add A, #0xC0
0FE6 1205E0    2014       lcall ?WriteCommand
0FE9 22        2015       ret
0FEA           2016   
0FEA           2017   Print_String_RAM:
0FEA E6        2018       mov A, @R0
0FEB 6006      2019       jz Print_String_Done
0FED 1205DB    2020       lcall ?WriteData
0FF0 08        2021       inc R0
0FF1 80F7      2022       sjmp Print_String_RAM
0FF3           2023   Print_String_Done:
0FF3 22        2024       ret
0FF4           2025   
0FF4           2026   ; Blocking wrapper for LCD clear (keeps old behavior just for this)
0FF4           2027   Wait_25ms_BLOCKING:
0FF4 120E9C    2028       lcall Wait_25ms
0FF7 50FB      2029       jnc Wait_25ms_BLOCKING ; Keep jumping back until Done (C=1)
0FF9 22        2030       ret
0FFA           2031   
0FFA           2032   Clear_Screen_Func:
0FFA 7401      2033       mov A, #0x01
0FFC 1205E0    2034       lcall ?WriteCommand
0FFF           2035       
0FFF           2036       ; --- FIX: HARDWARE DELAY LOOP (MAX STRENGTH) ---
0FFF           2037       ; The LCD needs ~2ms to clear. 
0FFF           2038       ; We use R0=255 to guarantee ~5ms+ delay.
0FFF           2039       ; This ensures the LCD is 100% ready before we send "Ramp to Soak".
0FFF 78FF      2040       mov R0, #255
1001           2041   Clear_Delay_Loop_Outer:
1001 79FF      2042       mov R1, #255
1003           2043   Clear_Delay_Loop_Inner:
1003 D9FE      2044       djnz R1, Clear_Delay_Loop_Inner
1005 D8FA      2045       djnz R0, Clear_Delay_Loop_Outer
1007           2046       ; -----------------------------------------------
1007           2047   
1007 740C      2048       mov A, #0x0C  ; Display ON, Cursor OFF
1009 1205E0    2049       lcall ?WriteCommand
100C 22        2050       ret
100D           2051   
100D           2052   Get_Current_Buffer_Addr:
100D E569      2053       mov A, Current_State
100F B40103    2054       cjne A, #1, Get_Buf_2
1012 7880      2055       mov R0, #Buf_Soak_Temp
1014 22        2056       ret
1015           2057   Get_Buf_2:
1015 B40203    2058       cjne A, #2, Get_Buf_3
1018 7884      2059       mov R0, #Buf_Soak_Time
101A 22        2060       ret
101B           2061   Get_Buf_3:
101B B40303    2062       cjne A, #3, Get_Buf_4
101E 7889      2063       mov R0, #Buf_Refl_Temp
1020 22        2064       ret
1021           2065   Get_Buf_4:
1021 788D      2066       mov R0, #Buf_Refl_Time
1023 22        2067       ret
1024           2068       
1024           2069   ; --- Helper to prevent "Machine Gun" button presses ---
1024           2070   Wait_For_P1_0_Release:
1024 3090FD    2071       jnb P1.0, $    ; Wait here while the button is still pressed (0)
1027 22        2072       ret
1028           2073   
1028           2074   ; --- Full reset helper for P3.7 (active-low) ---
1028           2075   Wait_For_P3_7_Release:
1028 30B7FD    2076       jnb P3_7, $    ; Wait here while the button is still pressed (0)
102B 22        2077       ret
102C           2078   
102C           2079   Full_Reset:
102C 121028    2080       lcall Wait_For_P3_7_Release
102F 020BC1    2081       ljmp main
1032           2082   
1032           2083   ; ================================================================
1032           2084   ; MODULE: THERMOCOUPLE ADC DRIVER (WITH NOISE SUPPRESSION & JUMP FIX)
1032           2085   ; ================================================================
1032           2086   Read_Thermocouple:
1032           2087       ; 1. Check Non-Blocking Timer
1032 120E9C    2088       lcall Wait_25ms
1035           2089       
1035           2090       ; [FIX] TRAMPOLINE JUMP
1035           2091       ; "jnc" cannot jump to the end because the code is too long.
1035           2092       ; We invert logic: If Carry=1 (Time is up), Jump NEARBY.
1035 4001      2093       jc Proceed_Reading
1037 22        2094       ret  ; If Carry=0, Return immediately.
1038           2095   
1038           2096   Proceed_Reading:
1038           2097       ; --- 25ms Passed! Time to Read ---
1038           2098   
1038           2099       ; [FIX] SILENCE THE BUZZER (Noise Suppression)
1038           2100       ; Save buzzer state and force it OFF during the sensitive read
1038 E588      2101       mov A, TCON      
103A 5410      2102       anl A, #0x10     ; Isolate TR0 bit
103C C0E0      2103       push acc         ; Save it
103E C28C      2104       clr TR0          ; STOP NOISE
1040           2105   
1040           2106       ; 2. Initialize / Trigger ADC
1040 75A180    2107       mov ADC_C, #0x80    ; Reset
1043 00        2108       nop
1044 00        2109       nop
1045 75A101    2110       mov ADC_C, #0x01    ; Start Channel 0
1048           2111       
1048           2112       ; 3. Settle Delay
1048 7DFA      2113       mov R5, #250
104A           2114   ADC_Settle_Loop:
104A 00        2115       nop
104B 00        2116       nop
104C DDFC      2117       djnz R5, ADC_Settle_Loop
104E           2118       
104E           2119       ; 4. Read Raw Data
104E 85A232    2120       mov x+0, ADC_L
1051 85A333    2121       mov x+1, ADC_H
1054 753400    2122       mov x+2, #0
1057 753500    2123       mov x+3, #0
105A           2124       
105A           2125       ; 5. Mask Data
105A E533      2126       mov a, x+1
105C 540F      2127       anl a, #0x0F
105E F533      2128       mov x+1, a
1060           2129       
1060           2130       ; [FIX] RESTORE THE BUZZER
1060 D0E0      2131       pop acc          ; Get previous state
1062 6002      2132       jz Skip_Restore  ; If it was OFF, keep it OFF
1064 D28C      2133       setb TR0         ; If it was ON, turn it back ON
1066           2134   Skip_Restore:
1066           2135   
1066           2136       ; 6. Math Conversions
1066 753616    2137            mov y+0, #low (4118 % 0x10000) 
1069 753710    2137            mov y+1, #high(4118 % 0x10000) 
106C 753800    2137            mov y+2, #low (4118 / 0x10000) 
106F 753900    2137            mov y+3, #high(4118 / 0x10000) 
1072 12018C    2138       lcall mul32       
1075           2139   
1075 75A104    2140       mov ADC_C, #0x04    ; Read LM4040
1078 85A236    2141       mov y+0, ADC_L      
107B 85A337    2142       mov y+1, ADC_H      
107E 753800    2143       mov y+2, #0
1081 753900    2144       mov y+3, #0
1084 75A100    2145       mov ADC_C, #0x00    ; Reset
1087           2146       
1087 120280    2147       lcall div32         
108A 753664    2148            mov y+0, #low (100 % 0x10000) 
108D 753700    2148            mov y+1, #high(100 % 0x10000) 
1090 753800    2148            mov y+2, #low (100 / 0x10000) 
1093 753900    2148            mov y+3, #high(100 / 0x10000) 
1096 12018C    2149       lcall mul32
1099 75362B    2150            mov y+0, #low (1323 % 0x10000) 
109C 753705    2150            mov y+1, #high(1323 % 0x10000) 
109F 753800    2150            mov y+2, #low (1323 / 0x10000) 
10A2 753900    2150            mov y+3, #high(1323 / 0x10000)         
10A5 120280    2151       lcall div32    
10A8 753614    2152            mov y+0, #low (COLD_JUNCTION_TEMP % 0x10000) 
10AB 753700    2152            mov y+1, #high(COLD_JUNCTION_TEMP % 0x10000) 
10AE 753800    2152            mov y+2, #low (COLD_JUNCTION_TEMP / 0x10000) 
10B1 753900    2152            mov y+3, #high(COLD_JUNCTION_TEMP / 0x10000) 
10B4 1200D3    2153       lcall add32     
10B7           2154       
10B7           2155       ; 8. Store Result
10B7 85323F    2156       mov current_temp+0, x+0
10BA 853340    2157       mov current_temp+1, x+1
10BD 853441    2158       mov current_temp+2, x+2
10C0 853542    2159       mov current_temp+3, x+3
10C3           2160   
10C3 22        2161       ret
10C4           2162       
10C4           2163   ; ================================================================
10C4           2164   ; MODULE: POWER CONTROLLER (The Brain)
10C4           2165   ; ================================================================
10C4           2166   Power_Control:
10C4           2167       ; Default: Turn Heat OFF (Safety)
10C4 755C00    2168       mov power_output+0, #0
10C7 755D00    2169       mov power_output+1, #0
10CA 755E00    2170       mov power_output+2, #0
10CD 755F00    2171       mov power_output+3, #0
10D0           2172   
10D0 E568      2173       mov a, Control_FSM_state
10D2           2174   
10D2           2175       ; --- State 2: RAMP TO SOAK ---
10D2 B40202    2176       cjne a, #2, PC_Check_Soak
10D5           2177       ; Mode: Full Speed Ahead
10D5 8016      2178       sjmp Set_Max_Power
10D7           2179   
10D7           2180   PC_Check_Soak:
10D7           2181       ; --- State 3: SOAK PHASE ---
10D7 B40305    2182       cjne a, #3, PC_Check_Ramp_Reflow
10DA           2183       ; Mode: Maintenance (Low Power)
10DA           2184       ; If Temp > Target, OFF. If Temp < Target, 20% Power.
10DA 20030F    2185       jb soak_temp_reached, PC_Done ; If hot enough, stay OFF
10DD 801B      2186       sjmp Set_20_Percent_Power     ; If cold, use 20%
10DF           2187   
10DF           2188   PC_Check_Ramp_Reflow:
10DF           2189       ; --- State 4: RAMP TO REFLOW ---
10DF B40402    2190       cjne a, #4, PC_Check_Reflow
10E2           2191       ; Mode: Full Speed Ahead
10E2 8009      2192       sjmp Set_Max_Power
10E4           2193   
10E4           2194   PC_Check_Reflow:
10E4           2195       ; --- State 5: REFLOW PHASE ---
10E4 B40505    2196       cjne a, #5, PC_Done
10E7           2197       ; Mode: Maintenance (Low Power)
10E7 200402    2198       jb reflow_temp_reached, PC_Done
10EA 800E      2199       sjmp Set_20_Percent_Power
10EC           2200   
10EC           2201   PC_Done:
10EC 22        2202       ret
10ED           2203   
10ED           2204   ; --- Power Helpers ---
10ED           2205   
10ED           2206   Set_Max_Power:
10ED           2207       ; Load 1500 (0x05DC) = 100% Duty Cycle
10ED 755CDC    2208       mov power_output+0, #0xDC
10F0 755D05    2209       mov power_output+1, #0x05
10F3 755E00    2210       mov power_output+2, #0
10F6 755F00    2211       mov power_output+3, #0
10F9 22        2212       ret
10FA           2213   
10FA           2214   Set_20_Percent_Power:
10FA           2215       ; Load 300 (0x012C) = 20% Duty Cycle
10FA 755C2C    2216       mov power_output+0, #0x2C
10FD 755D01    2217       mov power_output+1, #0x01
1100 755E00    2218       mov power_output+2, #0
1103 755F00    2219       mov power_output+3, #0
1106 22        2220       ret
1107           2221   
1107           2222   
1107           2223   ;--------------------------------------------------------------
1107           2224   ; set servo angle according to the state
1107           2225   ; call servo control function every 1ms
1107           2226   ;--------------------------------------------------------------
1107           2227   call_servo_control:
1107           2228            ; check current state and change servo angle
1107 E568      2229            mov a, Control_FSM_state
1109           2230            
1109           2231            ; handle state 0
1109 B40004    2232            cjne a, #0, servo_state1
110C C21F      2233            clr servo_angle_zero ; close door at state 0
110E 802C      2234            sjmp check_servo_flag
1110           2235   
1110           2236            ; handle state 1
1110           2237            servo_state1:
1110 B40104    2238            cjne a, #1, servo_state2
1113 D21F      2239            setb servo_angle_zero ; open door at state 1
1115 8025      2240            sjmp check_servo_flag
1117           2241   
1117           2242            ; handle state 2
1117           2243            servo_state2:
1117 B40204    2244            cjne a, #2, servo_state3
111A C21F      2245            clr servo_angle_zero ; close door at state 2
111C 801E      2246            sjmp check_servo_flag
111E           2247   
111E           2248            ; handle state 3
111E           2249            servo_state3:
111E B40304    2250            cjne a, #3, servo_state4
1121 C21F      2251            clr servo_angle_zero ; close door at state 3
1123 8017      2252            sjmp check_servo_flag
1125           2253   
1125           2254            ; handle state 4
1125           2255            servo_state4:
1125 B40404    2256            cjne a, #4, servo_state5
1128 C21F      2257            clr servo_angle_zero ; close door at state 4
112A 8010      2258            sjmp check_servo_flag
112C           2259   
112C           2260            ; handle state 5
112C           2261            servo_state5:
112C B40504    2262            cjne a, #5, servo_state6
112F C21F      2263            clr servo_angle_zero ; close door at state 5
1131 8009      2264            sjmp check_servo_flag
1133           2265   
1133           2266            ; handle state 6
1133           2267            servo_state6:
1133 B40604    2268            cjne a, #6, servo_state7
1136 C21F      2269            clr servo_angle_zero ; close door at state 6
1138 8002      2270            sjmp check_servo_flag
113A           2271   
113A           2272            ; handle state 7
113A           2273            servo_state7:
113A D21F      2274            setb servo_angle_zero ; open door at state 7
113C           2275   
113C           2276   check_servo_flag:
113C           2277            ; check 1 ms flag
113C 101E01    2278            jbc one_millisecond_flag_servo, run_servo_control
113F 22        2279            ret
1140           2280   
1140           2281   run_servo_control:
1140 121144    2282            lcall servo_control
1143 22        2283            ret
1144           2284   
1144           2285   
1144           2286   ;---------------------------------------------------------------
1144           2287   ; servo control
1144           2288   ; generate a 20 ms period pwm signal to control the servo motor
1144           2289   ; able to make the servo motor stay at 0 degree and 180 degree
1144           2290   ;---------------------------------------------------------------
1144           2291   servo_control:
1144 D2ED      2292       setb LEDRA.5
1146 C0E0      2293            push acc
1148 C0D0      2294            push psw
114A E577      2295            mov a, servo_pwm_counter ; move servo counter to accumulator
114C 04        2296            inc A ; a += 1
114D B41402    2297            cjne a, #SERVO_PERIOD, servo_pwm_angle_compare ; jump if wrapup not needed
1150 7400      2298            mov a, #0
1152           2299   
1152           2300   servo_pwm_angle_compare: ; read target angle
1152 F577      2301            mov servo_pwm_counter, A
1154 201F09    2302            jb servo_angle_zero, set_zero_degree ; set servo motor to 0 degree
1157           2303            ; set servo motor to 180 degrees
1157 E577      2304            mov a, servo_pwm_counter
1159 C3        2305            clr c
115A 9402      2306            subb a, #SERVO_180
115C 400B      2307            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 180 degrees duty cycle
115E 800D      2308            sjmp servo_pwm_set_low ; set low if greater
1160           2309   
1160           2310   set_zero_degree:
1160           2311            ; set servo motor to 0 degree
1160 E577      2312            mov a, servo_pwm_counter
1162 C3        2313            clr c
1163 9401      2314            subb a, #SERVO_0
1165 4002      2315            jc servo_pwm_set_high ; set high if servo pwm counter smaller than 0 degrees duty cycle
1167 8004      2316            sjmp servo_pwm_set_low ; set low if greater
1169           2317   
1169           2318   servo_pwm_set_high:
1169           2319            ; set pwm pin high
1169 D2B6      2320            setb SERVO_OUT
116B 8002      2321            sjmp servo_control_done
116D           2322   
116D           2323   servo_pwm_set_low:
116D           2324            ; set pwm pin low
116D C2B6      2325            clr SERVO_OUT
116F           2326   
116F           2327   servo_control_done:
116F D0D0      2328            pop psw
1171 D0E0      2329            pop acc
1173 22        2330            ret
1174           2331   
1174           2332   ;-------------------------------------------------------------------------------
1174           2333   ; power_control
1174           2334   ;-------------------------------------------------------------------------------
1174           2335   ; Determine the power output based on current state and current temperature 
1174           2336   ; input parameter: Control_FSM_state
1174           2337   ;-------------------------------------------------------------------------------
1174           2338   
1174           2339   proportaional_power_control:
1174 E568      2340            mov a, Control_FSM_state
1176           2341   
1176           2342   state0_power_control:
1176           2343            ; idle
1176           2344            ; 0% power
1176 B4000F    2345            cjne a, #0, state1_power_control
1179 755C00    2346            mov power_output, #low(NO_POWER)
117C 755D00    2347            mov power_output+1, #low(NO_POWER)
117F 755E00    2348            mov power_output+2, #0
1182 755F00    2349            mov power_output+3, #0
1185 021320    2350            ljmp power_control_done
1188           2351   
1188           2352   state1_power_control:
1188           2353            ; idle
1188           2354            ; 0% power
1188 B4010F    2355            cjne a, #1, state2_power_control
118B 755C00    2356            mov power_output, #low(NO_POWER)
118E 755D00    2357            mov power_output+1, #low(NO_POWER)
1191 755E00    2358            mov power_output+2, #0
1194 755F00    2359            mov power_output+3, #0
1197 021320    2360            ljmp power_control_done
119A           2361            
119A           2362   state2_power_control:
119A           2363            ; ramp to soak, ramp to ~150C
119A           2364            ; 100% power
119A B4020F    2365            cjne a, #2, state3_power_control
119D 755CDC    2366            mov power_output, #low(MAX_POWER)
11A0 755D05    2367            mov power_output+1, #high(MAX_POWER)
11A3 755E00    2368            mov power_output+2, #0
11A6 755F00    2369            mov power_output+3, #0
11A9 021320    2370            ljmp power_control_done
11AC           2371   
11AC           2372   state3_power_control:
11AC           2373            ; soak period, hold at 150C
11AC           2374            ; 20% base power + proportional calculated power
11AC B40302    2375            cjne a, #3, jump_state4_power_control
11AF 8003      2376            sjmp state3_power_control_calculation
11B1           2377   
11B1           2378   jump_state4_power_control:
11B1 0212DE    2379            ljmp state4_power_control
11B4           2380   
11B4           2381   state3_power_control_calculation:
11B4           2382            ; move soak_temp to x
11B4 854332    2383            mov x, soak_temp
11B7 854433    2384            mov x+1, soak_temp+1
11BA 854534    2385            mov x+2, soak_temp+2
11BD 854635    2386            mov x+3, soak_temp+3
11C0           2387            ; move current_temp to y
11C0 853F36    2388            mov y, current_temp
11C3 854037    2389            mov y+1, current_temp+1
11C6 854138    2390            mov y+2, current_temp+2
11C9 854239    2391            mov y+3, current_temp+3
11CC           2392   
11CC           2393            ; compare between soak_temp and current_temp
11CC C200      2394            clr mf
11CE 120178    2395            lcall x_gteq_y
11D1 10002B    2396            jbc mf, st_sub_ct
11D4           2397            ; current_temp - soak_temp if st < ct
11D4 C220      2398            clr soak_temp_greater
11D6           2399            ; move current_temp to y
11D6 854336    2400            mov y, soak_temp
11D9 854437    2401            mov y+1, soak_temp+1
11DC 854538    2402            mov y+2, soak_temp+2
11DF 854639    2403            mov y+3, soak_temp+3
11E2           2404            ; move current_temp to x
11E2 853F32    2405            mov x, current_temp
11E5 854033    2406            mov x+1, current_temp+1
11E8 854134    2407            mov x+2, current_temp+2
11EB 854235    2408            mov x+3, current_temp+3
11EE 1200F6    2409            lcall sub32
11F1 85326A    2410            mov soak_temp_diff, x
11F4 85336B    2411            mov soak_temp_diff+1, x+1
11F7 85346C    2412            mov soak_temp_diff+2, x+2
11FA 85356D    2413            mov soak_temp_diff+3, x+3
11FD 8011      2414            sjmp proportional_input_soak
11FF           2415   
11FF           2416   st_sub_ct:
11FF           2417            ; soak_temp - current_temp
11FF D220      2418            setb soak_temp_greater
1201 1200F6    2419            lcall sub32
1204 85326A    2420            mov soak_temp_diff, x
1207 85336B    2421            mov soak_temp_diff+1, x+1
120A 85346C    2422            mov soak_temp_diff+2, x+2
120D 85356D    2423            mov soak_temp_diff+3, x+3
1210           2424   
1210           2425   proportional_input_soak:
1210           2426            ; proportaional block calculation       
1210           2427            ; move soak_temp_diff to x
1210 856A32    2428            mov x, soak_temp_diff
1213 856B33    2429            mov x+1, soak_temp_diff+1
1216 856C34    2430            mov x+2, soak_temp_diff+2
1219 856D35    2431            mov x+3, soak_temp_diff+3
121C           2432            ; move proportional gain to y
121C 753605    2433            mov y+0, #low (KP % 0x10000) 
121F 753700    2433            mov y+1, #high(KP % 0x10000) 
1222 753800    2433            mov y+2, #low (KP / 0x10000) 
1225 753900    2433            mov y+3, #high(KP / 0x10000) 
1228 12018C    2434            lcall mul32 ; proportional_output = proportional_gain * difference
122B           2435            
122B 85326E    2436            mov proportional_gain_var, x
122E 85336F    2437            mov proportional_gain_var+1, x+1
1231 853470    2438            mov proportional_gain_var+2, x+2
1234 853571    2439            mov proportional_gain_var+3, x+3
1237           2440   
1237           2441            ; base_power + soak_power when soak_temp > current_temp
1237 302029    2442            jnb soak_temp_greater, sub_proportional_soak
123A 856E32    2443            mov x, proportional_gain_var
123D 856F33    2444            mov x+1, proportional_gain_var+1
1240 857034    2445            mov x+2, proportional_gain_var+2
1243 857135    2446            mov x+3, proportional_gain_var+3
1246 75362C    2447            mov y+0, #low (BASE_POWER % 0x10000) 
1249 753701    2447            mov y+1, #high(BASE_POWER % 0x10000) 
124C 753800    2447            mov y+2, #low (BASE_POWER / 0x10000) 
124F 753900    2447            mov y+3, #high(BASE_POWER / 0x10000) 
1252 1200D3    2448            lcall add32
1255           2449            ; x now holds the power output before the saturator
1255 85326E    2450            mov proportional_gain_var, x
1258 85336F    2451            mov proportional_gain_var+1, x+1
125B 853470    2452            mov proportional_gain_var+2, x+2
125E 853571    2453            mov proportional_gain_var+3, x+3
1261 803D      2454            sjmp saturator_soak
1263           2455   
1263           2456   sub_proportional_soak:
1263           2457            ; base_power - soak_power when soak_temp <= current_temp
1263 75322C    2458            mov x+0, #low (BASE_POWER % 0x10000) 
1266 753301    2458            mov x+1, #high(BASE_POWER % 0x10000) 
1269 753400    2458            mov x+2, #low (BASE_POWER / 0x10000) 
126C 753500    2458            mov x+3, #high(BASE_POWER / 0x10000) 
126F 856E36    2459            mov y, proportional_gain_var
1272 856F37    2460            mov y+1, proportional_gain_var+1
1275 857038    2461            mov y+2, proportional_gain_var+2
1278 857139    2462            mov y+3, proportional_gain_var+3
127B           2463   
127B           2464            ; compare whether base_power < proportional_gain_var
127B C200      2465            clr mf
127D 12011A    2466            lcall x_lt_y ; set mf to 1 if base_power < proportional_gain_var, clamp output to 0
1280 30000E    2467            jnb mf, bp_gteq_pgv
1283 756E00    2468            mov proportional_gain_var, #low(NO_POWER)
1286 756F00    2469            mov proportional_gain_var+1, #high(NO_POWER)
1289 757000    2470            mov proportional_gain_var+2, #0
128C 757100    2471            mov proportional_gain_var+3, #0
128F 800F      2472            sjmp saturator_soak
1291           2473   
1291           2474   bp_gteq_pgv:
1291           2475            ; calculate subtracted gain
1291 1200F6    2476            lcall sub32
1294           2477            ; x now holds the power output before the saturator
1294 85326E    2478            mov proportional_gain_var, x
1297 85336F    2479            mov proportional_gain_var+1, x+1
129A 853470    2480            mov proportional_gain_var+2, x+2
129D 853571    2481            mov proportional_gain_var+3, x+3
12A0           2482   
12A0           2483   saturator_soak:
12A0           2484            ; proportional_gain_var now holds the power output before the saturator
12A0           2485            ; saturate power output to max power
12A0 856E32    2486            mov x, proportional_gain_var
12A3 856F33    2487            mov x+1, proportional_gain_var+1
12A6 857034    2488            mov x+2, proportional_gain_var+2
12A9 857135    2489            mov x+3, proportional_gain_var+3
12AC           2490   
12AC 7536DC    2491            mov y+0, #low (MAX_POWER % 0x10000) 
12AF 753705    2491            mov y+1, #high(MAX_POWER % 0x10000) 
12B2 753800    2491            mov y+2, #low (MAX_POWER / 0x10000) 
12B5 753900    2491            mov y+3, #high(MAX_POWER / 0x10000) 
12B8           2492   
12B8 C200      2493            clr mf
12BA 120136    2494            lcall x_gt_y ; set mf to 1 if calculated power output greater than max power
12BD 20000F    2495            jb mf, saturated_soak
12C0           2496            ; set power_output to calculated power if not saturated
12C0 856E5C    2497            mov power_output, proportional_gain_var
12C3 856F5D    2498            mov power_output+1, proportional_gain_var+1
12C6 85705E    2499            mov power_output+2, proportional_gain_var+2
12C9 85715F    2500            mov power_output+3, proportional_gain_var+3
12CC 021320    2501            ljmp power_control_done
12CF           2502   
12CF           2503   saturated_soak:
12CF 755CDC    2504            mov power_output, #low(MAX_POWER)
12D2 755D05    2505            mov power_output+1, #high(MAX_POWER)
12D5 755E00    2506            mov power_output+2, #0
12D8 755F00    2507            mov power_output+3, #0
12DB 021320    2508            ljmp power_control_done
12DE           2509   
12DE           2510   
12DE           2511   state4_power_control:
12DE           2512            ; ramp to reflow, max power
12DE B4040F    2513            cjne a, #4, state5_power_control
12E1 755CDC    2514            mov power_output, #low(MAX_POWER)
12E4 755D05    2515            mov power_output+1, #high(MAX_POWER)
12E7 755E00    2516            mov power_output+2, #0
12EA 755F00    2517            mov power_output+3, #0
12ED 021320    2518            ljmp power_control_done
12F0           2519   
12F0           2520   state5_power_control:
12F0           2521            ; reflow 20% base power
12F0 B4050F    2522            cjne a, #5, state6_power_control
12F3 755C2C    2523            mov power_output, #low(BASE_POWER)  
12F6 755D01    2524            mov power_output+1, #high(BASE_POWER)
12F9 755E00    2525            mov power_output+2, #0
12FC 755F00    2526            mov power_output+3, #0
12FF 021320    2527            ljmp power_control_done
1302           2528   
1302           2529   state6_power_control:
1302           2530            ; cooling 0% power
1302 B4060F    2531            cjne a, #6, state_7_power_control
1305 755C00    2532            mov power_output, #low(NO_POWER)
1308 755D00    2533            mov power_output+1, #high(NO_POWER)
130B 755E00    2534            mov power_output+2, #0
130E 755F00    2535            mov power_output+3, #0
1311 021320    2536            ljmp power_control_done
1314           2537   
1314           2538   state_7_power_control:
1314           2539            ; idle 0% power
1314 755C00    2540            mov power_output, #low(NO_POWER)
1317 755D00    2541            mov power_output+1, #high(NO_POWER)
131A 755E00    2542            mov power_output+2, #0
131D 755F00    2543            mov power_output+3, #0
1320           2544   
1320           2545   power_control_done:
1320 22        2546            ret
1321           2547   
1321           2548   END
